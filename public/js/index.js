/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 5);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.4.0
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2019-04-10T19:48Z
 */
(function (global, factory) {

    "use strict";

    if (typeof module === "object" && typeof module.exports === "object") {

        // For CommonJS and CommonJS-like environments where a proper `window`
        // is present, execute the factory and get jQuery.
        // For environments that do not have a `window` with a `document`
        // (such as Node.js), expose a factory as module.exports.
        // This accentuates the need for the creation of a real `window`.
        // e.g. var jQuery = require("jquery")(window);
        // See ticket #14549 for more info.
        module.exports = global.document ?
            factory(global, true) :
            function (w) {
                if (!w.document) {
                    throw new Error("jQuery requires a window with a document");
                }
                return factory(w);
            };
    } else {
        factory(global);
    }

    // Pass this if window is not defined yet
})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {

    // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
    // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
    // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
    // enough that all such attempts are guarded in a try block.
    "use strict";

    var arr = [];

    var document = window.document;

    var getProto = Object.getPrototypeOf;

    var slice = arr.slice;

    var concat = arr.concat;

    var push = arr.push;

    var indexOf = arr.indexOf;

    var class2type = {};

    var toString = class2type.toString;

    var hasOwn = class2type.hasOwnProperty;

    var fnToString = hasOwn.toString;

    var ObjectFunctionString = fnToString.call(Object);

    var support = {};

    var isFunction = function isFunction(obj) {

        // Support: Chrome <=57, Firefox <=52
        // In some browsers, typeof returns "function" for HTML <object> elements
        // (i.e., `typeof document.createElement( "object" ) === "function"`).
        // We don't want to classify *any* DOM node as a function.
        return typeof obj === "function" && typeof obj.nodeType !== "number";
    };


    var isWindow = function isWindow(obj) {
        return obj != null && obj === obj.window;
    };


    var preservedScriptAttributes = {
        type: true,
        src: true,
        nonce: true,
        noModule: true
    };

    function DOMEval(code, node, doc) {
        doc = doc || document;

        var i, val,
            script = doc.createElement("script");

        script.text = code;
        if (node) {
            for (i in preservedScriptAttributes) {

                // Support: Firefox 64+, Edge 18+
                // Some browsers don't support the "nonce" property on scripts.
                // On the other hand, just using `getAttribute` is not enough as
                // the `nonce` attribute is reset to an empty string whenever it
                // becomes browsing-context connected.
                // See https://github.com/whatwg/html/issues/2369
                // See https://html.spec.whatwg.org/#nonce-attributes
                // The `node.getAttribute` check was added for the sake of
                // `jQuery.globalEval` so that it can fake a nonce-containing node
                // via an object.
                val = node[i] || node.getAttribute && node.getAttribute(i);
                if (val) {
                    script.setAttribute(i, val);
                }
            }
        }
        doc.head.appendChild(script).parentNode.removeChild(script);
    }


    function toType(obj) {
        if (obj == null) {
            return obj + "";
        }

        // Support: Android <=2.3 only (functionish RegExp)
        return typeof obj === "object" || typeof obj === "function" ?
            class2type[toString.call(obj)] || "object" :
            typeof obj;
    }

    /* global Symbol */
    // Defining this global in .eslintrc.json would create a danger of using the global
    // unguarded in another place, it seems safer to define global only for this module


    var
        version = "3.4.0",

        // Define a local copy of jQuery
        jQuery = function (selector, context) {

            // The jQuery object is actually just the init constructor 'enhanced'
            // Need init if jQuery is called (just allow error to be thrown if not included)
            return new jQuery.fn.init(selector, context);
        },

        // Support: Android <=4.0 only
        // Make sure we trim BOM and NBSP
        rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

    jQuery.fn = jQuery.prototype = {

        // The current version of jQuery being used
        jquery: version,

        constructor: jQuery,

        // The default length of a jQuery object is 0
        length: 0,

        toArray: function () {
            return slice.call(this);
        },

        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function (num) {

            // Return all the elements in a clean array
            if (num == null) {
                return slice.call(this);
            }

            // Return just the one element from the set
            return num < 0 ? this[num + this.length] : this[num];
        },

        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function (elems) {

            // Build a new jQuery matched element set
            var ret = jQuery.merge(this.constructor(), elems);

            // Add the old object onto the stack (as a reference)
            ret.prevObject = this;

            // Return the newly-formed element set
            return ret;
        },

        // Execute a callback for every element in the matched set.
        each: function (callback) {
            return jQuery.each(this, callback);
        },

        map: function (callback) {
            return this.pushStack(jQuery.map(this, function (elem, i) {
                return callback.call(elem, i, elem);
            }));
        },

        slice: function () {
            return this.pushStack(slice.apply(this, arguments));
        },

        first: function () {
            return this.eq(0);
        },

        last: function () {
            return this.eq(-1);
        },

        eq: function (i) {
            var len = this.length,
                j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },

        end: function () {
            return this.prevObject || this.constructor();
        },

        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };

    jQuery.extend = jQuery.fn.extend = function () {
        var options, name, src, copy, copyIsArray, clone,
            target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;

        // Handle a deep copy situation
        if (typeof target === "boolean") {
            deep = target;

            // Skip the boolean and the target
            target = arguments[i] || {};
            i++;
        }

        // Handle case when target is a string or something (possible in deep copy)
        if (typeof target !== "object" && !isFunction(target)) {
            target = {};
        }

        // Extend jQuery itself if only one argument is passed
        if (i === length) {
            target = this;
            i--;
        }

        for (; i < length; i++) {

            // Only deal with non-null/undefined values
            if ((options = arguments[i]) != null) {

                // Extend the base object
                for (name in options) {
                    copy = options[name];

                    // Prevent Object.prototype pollution
                    // Prevent never-ending loop
                    if (name === "__proto__" || target === copy) {
                        continue;
                    }

                    // Recurse if we're merging plain objects or arrays
                    if (deep && copy && (jQuery.isPlainObject(copy) ||
                        (copyIsArray = Array.isArray(copy)))) {
                        src = target[name];

                        // Ensure proper type for the source value
                        if (copyIsArray && !Array.isArray(src)) {
                            clone = [];
                        } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
                            clone = {};
                        } else {
                            clone = src;
                        }
                        copyIsArray = false;

                        // Never move original objects, clone them
                        target[name] = jQuery.extend(deep, clone, copy);

                        // Don't bring in undefined values
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }

        // Return the modified object
        return target;
    };

    jQuery.extend({

        // Unique for each copy of jQuery on the page
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

        // Assume jQuery is ready without the ready module
        isReady: true,

        error: function (msg) {
            throw new Error(msg);
        },

        noop: function () {
        },

        isPlainObject: function (obj) {
            var proto, Ctor;

            // Detect obvious negatives
            // Use toString instead of jQuery.type to catch host objects
            if (!obj || toString.call(obj) !== "[object Object]") {
                return false;
            }

            proto = getProto(obj);

            // Objects with no prototype (e.g., `Object.create( null )`) are plain
            if (!proto) {
                return true;
            }

            // Objects with prototype are plain iff they were constructed by a global Object function
            Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
            return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
        },

        isEmptyObject: function (obj) {
            var name;

            for (name in obj) {
                return false;
            }
            return true;
        },

        // Evaluates a script in a global context
        globalEval: function (code, options) {
            DOMEval(code, {nonce: options && options.nonce});
        },

        each: function (obj, callback) {
            var length, i = 0;

            if (isArrayLike(obj)) {
                length = obj.length;
                for (; i < length; i++) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            } else {
                for (i in obj) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            }

            return obj;
        },

        // Support: Android <=4.0 only
        trim: function (text) {
            return text == null ?
                "" :
                (text + "").replace(rtrim, "");
        },

        // results is for internal usage only
        makeArray: function (arr, results) {
            var ret = results || [];

            if (arr != null) {
                if (isArrayLike(Object(arr))) {
                    jQuery.merge(ret,
                        typeof arr === "string" ?
                            [arr] : arr
                    );
                } else {
                    push.call(ret, arr);
                }
            }

            return ret;
        },

        inArray: function (elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i);
        },

        // Support: Android <=4.0 only, PhantomJS 1 only
        // push.apply(_, arraylike) throws on ancient WebKit
        merge: function (first, second) {
            var len = +second.length,
                j = 0,
                i = first.length;

            for (; j < len; j++) {
                first[i++] = second[j];
            }

            first.length = i;

            return first;
        },

        grep: function (elems, callback, invert) {
            var callbackInverse,
                matches = [],
                i = 0,
                length = elems.length,
                callbackExpect = !invert;

            // Go through the array, only saving the items
            // that pass the validator function
            for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }

            return matches;
        },

        // arg is for internal usage only
        map: function (elems, callback, arg) {
            var length, value,
                i = 0,
                ret = [];

            // Go through the array, translating each of the items to their new values
            if (isArrayLike(elems)) {
                length = elems.length;
                for (; i < length; i++) {
                    value = callback(elems[i], i, arg);

                    if (value != null) {
                        ret.push(value);
                    }
                }

                // Go through every key on the object,
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);

                    if (value != null) {
                        ret.push(value);
                    }
                }
            }

            // Flatten any nested arrays
            return concat.apply([], ret);
        },

        // A global GUID counter for objects
        guid: 1,

        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support: support
    });

    if (typeof Symbol === "function") {
        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    }

    // Populate the class2type map
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
        function (i, name) {
            class2type["[object " + name + "]"] = name.toLowerCase();
        });

    function isArrayLike(obj) {

        // Support: real iOS 8.2 only (not reproducible in simulator)
        // `in` check used to prevent JIT error (gh-2145)
        // hasOwn isn't used here due to false negatives
        // regarding Nodelist length in IE
        var length = !!obj && "length" in obj && obj.length,
            type = toType(obj);

        if (isFunction(obj) || isWindow(obj)) {
            return false;
        }

        return type === "array" || length === 0 ||
            typeof length === "number" && length > 0 && (length - 1) in obj;
    }

    var Sizzle =
    /*!
    * Sizzle CSS Selector Engine v2.3.4
    * https://sizzlejs.com/
    *
    * Copyright JS Foundation and other contributors
    * Released under the MIT license
    * https://js.foundation/
    *
    * Date: 2019-04-08
    */
        (function (window) {

            var i,
                support,
                Expr,
                getText,
                isXML,
                tokenize,
                compile,
                select,
                outermostContext,
                sortInput,
                hasDuplicate,

                // Local document vars
                setDocument,
                document,
                docElem,
                documentIsHTML,
                rbuggyQSA,
                rbuggyMatches,
                matches,
                contains,

                // Instance-specific data
                expando = "sizzle" + 1 * new Date(),
                preferredDoc = window.document,
                dirruns = 0,
                done = 0,
                classCache = createCache(),
                tokenCache = createCache(),
                compilerCache = createCache(),
                nonnativeSelectorCache = createCache(),
                sortOrder = function (a, b) {
                    if (a === b) {
                        hasDuplicate = true;
                    }
                    return 0;
                },

                // Instance methods
                hasOwn = ({}).hasOwnProperty,
                arr = [],
                pop = arr.pop,
                push_native = arr.push,
                push = arr.push,
                slice = arr.slice,
                // Use a stripped-down indexOf as it's faster than native
                // https://jsperf.com/thor-indexof-vs-for/5
                indexOf = function (list, elem) {
                    var i = 0,
                        len = list.length;
                    for (; i < len; i++) {
                        if (list[i] === elem) {
                            return i;
                        }
                    }
                    return -1;
                },

                booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

                // Regular expressions

                // http://www.w3.org/TR/css3-selectors/#whitespace
                whitespace = "[\\x20\\t\\r\\n\\f]",

                // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
                identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

                // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
                attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
                    // Operator (capture 2)
                    "*([*^$|!~]?=)" + whitespace +
                    // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
                    "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
                    "*\\]",

                pseudos = ":(" + identifier + ")(?:\\((" +
                    // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
                    // 1. quoted (capture 3; capture 4 or capture 5)
                    "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
                    // 2. simple (capture 6)
                    "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
                    // 3. anything else (capture 2)
                    ".*" +
                    ")\\)|)",

                // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                rwhitespace = new RegExp(whitespace + "+", "g"),
                rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),

                rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
                rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
                rdescend = new RegExp(whitespace + "|>"),

                rpseudo = new RegExp(pseudos),
                ridentifier = new RegExp("^" + identifier + "$"),

                matchExpr = {
                    "ID": new RegExp("^#(" + identifier + ")"),
                    "CLASS": new RegExp("^\\.(" + identifier + ")"),
                    "TAG": new RegExp("^(" + identifier + "|[*])"),
                    "ATTR": new RegExp("^" + attributes),
                    "PSEUDO": new RegExp("^" + pseudos),
                    "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
                        "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
                        "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
                    "bool": new RegExp("^(?:" + booleans + ")$", "i"),
                    // For use in libraries implementing .is()
                    // We use this for POS matching in `select`
                    "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
                        whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
                },

                rhtml = /HTML$/i,
                rinputs = /^(?:input|select|textarea|button)$/i,
                rheader = /^h\d$/i,

                rnative = /^[^{]+\{\s*\[native \w/,

                // Easily-parseable/retrievable ID or TAG or CLASS selectors
                rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

                rsibling = /[+~]/,

                // CSS escapes
                // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
                funescape = function (_, escaped, escapedWhitespace) {
                    var high = "0x" + escaped - 0x10000;
                    // NaN means non-codepoint
                    // Support: Firefox<24
                    // Workaround erroneous numeric interpretation of +"0x"
                    return high !== high || escapedWhitespace ?
                        escaped :
                        high < 0 ?
                            // BMP codepoint
                            String.fromCharCode(high + 0x10000) :
                            // Supplemental Plane codepoint (surrogate pair)
                            String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
                },

                // CSS string/identifier serialization
                // https://drafts.csswg.org/cssom/#common-serializing-idioms
                rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
                fcssescape = function (ch, asCodePoint) {
                    if (asCodePoint) {

                        // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
                        if (ch === "\0") {
                            return "\uFFFD";
                        }

                        // Control characters and (dependent upon position) numbers get escaped as code points
                        return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
                    }

                    // Other potentially-special ASCII characters get backslash-escaped
                    return "\\" + ch;
                },

                // Used for iframes
                // See setDocument()
                // Removing the function wrapper causes a "Permission Denied"
                // error in IE
                unloadHandler = function () {
                    setDocument();
                },

                inDisabledFieldset = addCombinator(
                    function (elem) {
                        return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
                    },
                    {dir: "parentNode", next: "legend"}
                );

                // Optimize for push.apply( _, NodeList )
            try {
                push.apply(
                    (arr = slice.call(preferredDoc.childNodes)),
                    preferredDoc.childNodes
                );
                // Support: Android<4.0
                // Detect silently failing push.apply
                arr[preferredDoc.childNodes.length].nodeType;
            } catch (e) {
                push = {
                    apply: arr.length ?

                        // Leverage slice if possible
                        function (target, els) {
                            push_native.apply(target, slice.call(els));
                        } :

                        // Support: IE<9
                        // Otherwise append directly
                        function (target, els) {
                            var j = target.length,
                                i = 0;
                            // Can't trust NodeList.length
                            while ((target[j++] = els[i++])) {
                            }
                            target.length = j - 1;
                        }
                };
            }

            function Sizzle(selector, context, results, seed) {
                var m, i, elem, nid, match, groups, newSelector,
                    newContext = context && context.ownerDocument,

                    // nodeType defaults to 9, since context defaults to document
                    nodeType = context ? context.nodeType : 9;

                results = results || [];

                // Return early from calls with invalid selector or context
                if (typeof selector !== "string" || !selector ||
                    nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {

                    return results;
                }

                // Try to shortcut find operations (as opposed to filters) in HTML documents
                if (!seed) {

                    if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                        setDocument(context);
                    }
                    context = context || document;

                    if (documentIsHTML) {

                        // If the selector is sufficiently simple, try using a "get*By*" DOM method
                        // (excepting DocumentFragment context, where the methods don't exist)
                        if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {

                            // ID selector
                            if ((m = match[1])) {

                                // Document context
                                if (nodeType === 9) {
                                    if ((elem = context.getElementById(m))) {

                                        // Support: IE, Opera, Webkit
                                        // TODO: identify versions
                                        // getElementById can match elements by name instead of ID
                                        if (elem.id === m) {
                                            results.push(elem);
                                            return results;
                                        }
                                    } else {
                                        return results;
                                    }

                                    // Element context
                                } else {

                                    // Support: IE, Opera, Webkit
                                    // TODO: identify versions
                                    // getElementById can match elements by name instead of ID
                                    if (newContext && (elem = newContext.getElementById(m)) &&
                                        contains(context, elem) &&
                                        elem.id === m) {

                                        results.push(elem);
                                        return results;
                                    }
                                }

                                // Type selector
                            } else if (match[2]) {
                                push.apply(results, context.getElementsByTagName(selector));
                                return results;

                                // Class selector
                            } else if ((m = match[3]) && support.getElementsByClassName &&
                                context.getElementsByClassName) {

                                push.apply(results, context.getElementsByClassName(m));
                                return results;
                            }
                        }

                        // Take advantage of querySelectorAll
                        if (support.qsa &&
                            !nonnativeSelectorCache[selector + " "] &&
                            (!rbuggyQSA || !rbuggyQSA.test(selector)) &&

                            // Support: IE 8 only
                            // Exclude object elements
                            (nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {

                            newSelector = selector;
                            newContext = context;

                            // qSA considers elements outside a scoping root when evaluating child or
                            // descendant combinators, which is not what we want.
                            // In such cases, we work around the behavior by prefixing every selector in the
                            // list with an ID selector referencing the scope context.
                            // Thanks to Andrew Dupont for this technique.
                            if (nodeType === 1 && rdescend.test(selector)) {

                                // Capture the context ID, setting it first if necessary
                                if ((nid = context.getAttribute("id"))) {
                                    nid = nid.replace(rcssescape, fcssescape);
                                } else {
                                    context.setAttribute("id", (nid = expando));
                                }

                                // Prefix every selector in the list
                                groups = tokenize(selector);
                                i = groups.length;
                                while (i--) {
                                    groups[i] = "#" + nid + " " + toSelector(groups[i]);
                                }
                                newSelector = groups.join(",");

                                // Expand context for sibling selectors
                                newContext = rsibling.test(selector) && testContext(context.parentNode) ||
                                    context;
                            }

                            try {
                                push.apply(results,
                                    newContext.querySelectorAll(newSelector)
                                );
                                return results;
                            } catch (qsaError) {
                                nonnativeSelectorCache(selector, true);
                            } finally {
                                if (nid === expando) {
                                    context.removeAttribute("id");
                                }
                            }
                        }
                    }
                }

                // All others
                return select(selector.replace(rtrim, "$1"), context, results, seed);
            }

            /**
             * Create key-value caches of limited size
             * @returns {function(string, object)} Returns the Object data after storing it on itself with
             *    property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
             *    deleting the oldest entry
             */
            function createCache() {
                var keys = [];

                function cache(key, value) {
                    // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                    if (keys.push(key + " ") > Expr.cacheLength) {
                        // Only keep the most recent entries
                        delete cache[keys.shift()];
                    }
                    return (cache[key + " "] = value);
                }

                return cache;
            }

            /**
             * Mark a function for special use by Sizzle
             * @param {Function} fn The function to mark
             */
            function markFunction(fn) {
                fn[expando] = true;
                return fn;
            }

            /**
             * Support testing using an element
             * @param {Function} fn Passed the created element and returns a boolean result
             */
            function assert(fn) {
                var el = document.createElement("fieldset");

                try {
                    return !!fn(el);
                } catch (e) {
                    return false;
                } finally {
                    // Remove from its parent by default
                    if (el.parentNode) {
                        el.parentNode.removeChild(el);
                    }
                    // release memory in IE
                    el = null;
                }
            }

            /**
             * Adds the same handler for all of the specified attrs
             * @param {String} attrs Pipe-separated list of attributes
             * @param {Function} handler The method that will be applied
             */
            function addHandle(attrs, handler) {
                var arr = attrs.split("|"),
                    i = arr.length;

                while (i--) {
                    Expr.attrHandle[arr[i]] = handler;
                }
            }

            /**
             * Checks document order of two siblings
             * @param {Element} a
             * @param {Element} b
             * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
             */
            function siblingCheck(a, b) {
                var cur = b && a,
                    diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
                        a.sourceIndex - b.sourceIndex;

                // Use IE sourceIndex if available on both nodes
                if (diff) {
                    return diff;
                }

                // Check if b follows a
                if (cur) {
                    while ((cur = cur.nextSibling)) {
                        if (cur === b) {
                            return -1;
                        }
                    }
                }

                return a ? 1 : -1;
            }

            /**
             * Returns a function to use in pseudos for input types
             * @param {String} type
             */
            function createInputPseudo(type) {
                return function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === type;
                };
            }

            /**
             * Returns a function to use in pseudos for buttons
             * @param {String} type
             */
            function createButtonPseudo(type) {
                return function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return (name === "input" || name === "button") && elem.type === type;
                };
            }

            /**
             * Returns a function to use in pseudos for :enabled/:disabled
             * @param {Boolean} disabled true for :disabled; false for :enabled
             */
            function createDisabledPseudo(disabled) {

                // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
                return function (elem) {

                    // Only certain elements can match :enabled or :disabled
                    // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
                    // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
                    if ("form" in elem) {

                        // Check for inherited disabledness on relevant non-disabled elements:
                        // * listed form-associated elements in a disabled fieldset
                        //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
                        //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
                        // * option elements in a disabled optgroup
                        //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
                        // All such elements have a "form" property.
                        if (elem.parentNode && elem.disabled === false) {

                            // Option elements defer to a parent optgroup if present
                            if ("label" in elem) {
                                if ("label" in elem.parentNode) {
                                    return elem.parentNode.disabled === disabled;
                                } else {
                                    return elem.disabled === disabled;
                                }
                            }

                            // Support: IE 6 - 11
                            // Use the isDisabled shortcut property to check for disabled fieldset ancestors
                            return elem.isDisabled === disabled ||

                                // Where there is no isDisabled, check manually
                                /* jshint -W018 */
                                elem.isDisabled !== !disabled &&
                                inDisabledFieldset(elem) === disabled;
                        }

                        return elem.disabled === disabled;

                        // Try to winnow out elements that can't be disabled before trusting the disabled property.
                        // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
                        // even exist on them, let alone have a boolean value.
                    } else if ("label" in elem) {
                        return elem.disabled === disabled;
                    }

                    // Remaining elements are neither :enabled nor :disabled
                    return false;
                };
            }

            /**
             * Returns a function to use in pseudos for positionals
             * @param {Function} fn
             */
            function createPositionalPseudo(fn) {
                return markFunction(function (argument) {
                    argument = +argument;
                    return markFunction(function (seed, matches) {
                        var j,
                            matchIndexes = fn([], seed.length, argument),
                            i = matchIndexes.length;

                        // Match elements found at the specified indexes
                        while (i--) {
                            if (seed[(j = matchIndexes[i])]) {
                                seed[j] = !(matches[j] = seed[j]);
                            }
                        }
                    });
                });
            }

            /**
             * Checks a node for validity as a Sizzle context
             * @param {Element|Object=} context
             * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
             */
            function testContext(context) {
                return context && typeof context.getElementsByTagName !== "undefined" && context;
            }

    // Expose support vars for convenience
            support = Sizzle.support = {};

            /**
             * Detects XML nodes
             * @param {Element|Object} elem An element or a document
             * @returns {Boolean} True iff elem is a non-HTML XML node
             */
            isXML = Sizzle.isXML = function (elem) {
                var namespace = elem.namespaceURI,
                    docElem = (elem.ownerDocument || elem).documentElement;

                // Support: IE <=8
                // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
                // https://bugs.jquery.com/ticket/4833
                return !rhtml.test(namespace || docElem && docElem.nodeName || "HTML");
            };

            /**
             * Sets document-related variables once based on the current document
             * @param {Element|Object} [doc] An element or document object to use to set the document
             * @returns {Object} Returns the current document
             */
            setDocument = Sizzle.setDocument = function (node) {
                var hasCompare, subWindow,
                    doc = node ? node.ownerDocument || node : preferredDoc;

                // Return early if doc is invalid or already selected
                if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                    return document;
                }

                // Update global variables
                document = doc;
                docElem = document.documentElement;
                documentIsHTML = !isXML(document);

                // Support: IE 9-11, Edge
                // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
                if (preferredDoc !== document &&
                    (subWindow = document.defaultView) && subWindow.top !== subWindow) {

                    // Support: IE 11, Edge
                    if (subWindow.addEventListener) {
                        subWindow.addEventListener("unload", unloadHandler, false);

                        // Support: IE 9 - 10 only
                    } else if (subWindow.attachEvent) {
                        subWindow.attachEvent("onunload", unloadHandler);
                    }
                }

                /* Attributes
	---------------------------------------------------------------------- */

                // Support: IE<8
                // Verify that getAttribute really returns attributes and not properties
                // (excepting IE8 booleans)
                support.attributes = assert(function (el) {
                    el.className = "i";
                    return !el.getAttribute("className");
                });

                /* getElement(s)By*
	---------------------------------------------------------------------- */

                // Check if getElementsByTagName("*") returns only elements
                support.getElementsByTagName = assert(function (el) {
                    el.appendChild(document.createComment(""));
                    return !el.getElementsByTagName("*").length;
                });

                // Support: IE<9
                support.getElementsByClassName = rnative.test(document.getElementsByClassName);

                // Support: IE<10
                // Check if getElementById returns elements by name
                // The broken getElementById methods don't pick up programmatically-set names,
                // so use a roundabout getElementsByName test
                support.getById = assert(function (el) {
                    docElem.appendChild(el).id = expando;
                    return !document.getElementsByName || !document.getElementsByName(expando).length;
                });

                // ID filter and find
                if (support.getById) {
                    Expr.filter["ID"] = function (id) {
                        var attrId = id.replace(runescape, funescape);
                        return function (elem) {
                            return elem.getAttribute("id") === attrId;
                        };
                    };
                    Expr.find["ID"] = function (id, context) {
                        if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                            var elem = context.getElementById(id);
                            return elem ? [elem] : [];
                        }
                    };
                } else {
                    Expr.filter["ID"] = function (id) {
                        var attrId = id.replace(runescape, funescape);
                        return function (elem) {
                            var node = typeof elem.getAttributeNode !== "undefined" &&
                                elem.getAttributeNode("id");
                            return node && node.value === attrId;
                        };
                    };

                    // Support: IE 6 - 7 only
                    // getElementById is not reliable as a find shortcut
                    Expr.find["ID"] = function (id, context) {
                        if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                            var node, i, elems,
                                elem = context.getElementById(id);

                            if (elem) {

                                // Verify the id attribute
                                node = elem.getAttributeNode("id");
                                if (node && node.value === id) {
                                    return [elem];
                                }

                                // Fall back on getElementsByName
                                elems = context.getElementsByName(id);
                                i = 0;
                                while ((elem = elems[i++])) {
                                    node = elem.getAttributeNode("id");
                                    if (node && node.value === id) {
                                        return [elem];
                                    }
                                }
                            }

                            return [];
                        }
                    };
                }

                // Tag
                Expr.find["TAG"] = support.getElementsByTagName ?
                    function (tag, context) {
                        if (typeof context.getElementsByTagName !== "undefined") {
                            return context.getElementsByTagName(tag);

                            // DocumentFragment nodes don't have gEBTN
                        } else if (support.qsa) {
                            return context.querySelectorAll(tag);
                        }
                    } :

                    function (tag, context) {
                        var elem,
                            tmp = [],
                            i = 0,
                            // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                            results = context.getElementsByTagName(tag);

                        // Filter out possible comments
                        if (tag === "*") {
                            while ((elem = results[i++])) {
                                if (elem.nodeType === 1) {
                                    tmp.push(elem);
                                }
                            }

                            return tmp;
                        }
                        return results;
                    };

                // Class
                Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
                    if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
                        return context.getElementsByClassName(className);
                    }
                };

                /* QSA/matchesSelector
	---------------------------------------------------------------------- */

                // QSA and matchesSelector support

                // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                rbuggyMatches = [];

                // qSa(:focus) reports false when true (Chrome 21)
                // We allow this because of a bug in IE8/9 that throws an error
                // whenever `document.activeElement` is accessed on an iframe
                // So, we allow :focus to pass through QSA all the time to avoid the IE error
                // See https://bugs.jquery.com/ticket/13378
                rbuggyQSA = [];

                if ((support.qsa = rnative.test(document.querySelectorAll))) {
                    // Build QSA regex
                    // Regex strategy adopted from Diego Perini
                    assert(function (el) {
                        // Select is set to empty string on purpose
                        // This is to test IE's treatment of not explicitly
                        // setting a boolean content attribute,
                        // since its presence should be enough
                        // https://bugs.jquery.com/ticket/12359
                        docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" +
                            "<select id='" + expando + "-\r\\' msallowcapture=''>" +
                            "<option selected=''></option></select>";

                        // Support: IE8, Opera 11-12.16
                        // Nothing should be selected when empty strings follow ^= or $= or *=
                        // The test attribute must be unknown in Opera but "safe" for WinRT
                        // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                        if (el.querySelectorAll("[msallowcapture^='']").length) {
                            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                        }

                        // Support: IE8
                        // Boolean attributes and "value" are not treated correctly
                        if (!el.querySelectorAll("[selected]").length) {
                            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                        }

                        // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
                        if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
                            rbuggyQSA.push("~=");
                        }

                        // Webkit/Opera - :checked should return selected option elements
                        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                        // IE8 throws error here and will not see later tests
                        if (!el.querySelectorAll(":checked").length) {
                            rbuggyQSA.push(":checked");
                        }

                        // Support: Safari 8+, iOS 8+
                        // https://bugs.webkit.org/show_bug.cgi?id=136851
                        // In-page `selector#id sibling-combinator selector` fails
                        if (!el.querySelectorAll("a#" + expando + "+*").length) {
                            rbuggyQSA.push(".#.+[+~]");
                        }
                    });

                    assert(function (el) {
                        el.innerHTML = "<a href='' disabled='disabled'></a>" +
                            "<select disabled='disabled'><option/></select>";

                        // Support: Windows 8 Native Apps
                        // The type and name attributes are restricted during .innerHTML assignment
                        var input = document.createElement("input");
                        input.setAttribute("type", "hidden");
                        el.appendChild(input).setAttribute("name", "D");

                        // Support: IE8
                        // Enforce case-sensitivity of name attribute
                        if (el.querySelectorAll("[name=d]").length) {
                            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                        }

                        // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                        // IE8 throws error here and will not see later tests
                        if (el.querySelectorAll(":enabled").length !== 2) {
                            rbuggyQSA.push(":enabled", ":disabled");
                        }

                        // Support: IE9-11+
                        // IE's :disabled selector does not pick up the children of disabled fieldsets
                        docElem.appendChild(el).disabled = true;
                        if (el.querySelectorAll(":disabled").length !== 2) {
                            rbuggyQSA.push(":enabled", ":disabled");
                        }

                        // Opera 10-11 does not throw on post-comma invalid pseudos
                        el.querySelectorAll("*,:x");
                        rbuggyQSA.push(",.*:");
                    });
                }

                if ((support.matchesSelector = rnative.test((matches = docElem.matches ||
                    docElem.webkitMatchesSelector ||
                    docElem.mozMatchesSelector ||
                    docElem.oMatchesSelector ||
                    docElem.msMatchesSelector)))) {

                    assert(function (el) {
                        // Check to see if it's possible to do matchesSelector
                        // on a disconnected node (IE 9)
                        support.disconnectedMatch = matches.call(el, "*");

                        // This should fail with an exception
                        // Gecko does not error, returns false instead
                        matches.call(el, "[s!='']:x");
                        rbuggyMatches.push("!=", pseudos);
                    });
                }

                rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
                rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

                /* Contains
	---------------------------------------------------------------------- */
                hasCompare = rnative.test(docElem.compareDocumentPosition);

                // Element contains another
                // Purposefully self-exclusive
                // As in, an element does not contain itself
                contains = hasCompare || rnative.test(docElem.contains) ?
                    function (a, b) {
                        var adown = a.nodeType === 9 ? a.documentElement : a,
                            bup = b && b.parentNode;
                        return a === bup || !!(bup && bup.nodeType === 1 && (
                            adown.contains ?
                                adown.contains(bup) :
                                a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
                        ));
                    } :
                    function (a, b) {
                        if (b) {
                            while ((b = b.parentNode)) {
                                if (b === a) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    };

                /* Sorting
	---------------------------------------------------------------------- */

                // Document order sorting
                sortOrder = hasCompare ?
                    function (a, b) {

                        // Flag for duplicate removal
                        if (a === b) {
                            hasDuplicate = true;
                            return 0;
                        }

                        // Sort on method existence if only one input has compareDocumentPosition
                        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                        if (compare) {
                            return compare;
                        }

                        // Calculate position if both inputs belong to the same document
                        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ?
                            a.compareDocumentPosition(b) :

                            // Otherwise we know they are disconnected
                            1;

                        // Disconnected nodes
                        if (compare & 1 ||
                            (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {

                            // Choose the first element that is related to our preferred document
                            if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                                return -1;
                            }
                            if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                                return 1;
                            }

                            // Maintain original order
                            return sortInput ?
                                (indexOf(sortInput, a) - indexOf(sortInput, b)) :
                                0;
                        }

                        return compare & 4 ? -1 : 1;
                    } :
                    function (a, b) {
                        // Exit early if the nodes are identical
                        if (a === b) {
                            hasDuplicate = true;
                            return 0;
                        }

                        var cur,
                            i = 0,
                            aup = a.parentNode,
                            bup = b.parentNode,
                            ap = [a],
                            bp = [b];

                        // Parentless nodes are either documents or disconnected
                        if (!aup || !bup) {
                            return a === document ? -1 :
                                b === document ? 1 :
                                    aup ? -1 :
                                        bup ? 1 :
                                            sortInput ?
                                                (indexOf(sortInput, a) - indexOf(sortInput, b)) :
                                                0;

                            // If the nodes are siblings, we can do a quick check
                        } else if (aup === bup) {
                            return siblingCheck(a, b);
                        }

                        // Otherwise we need full lists of their ancestors for comparison
                        cur = a;
                        while ((cur = cur.parentNode)) {
                            ap.unshift(cur);
                        }
                        cur = b;
                        while ((cur = cur.parentNode)) {
                            bp.unshift(cur);
                        }

                        // Walk down the tree looking for a discrepancy
                        while (ap[i] === bp[i]) {
                            i++;
                        }

                        return i ?
                            // Do a sibling check if the nodes have a common ancestor
                            siblingCheck(ap[i], bp[i]) :

                            // Otherwise nodes in our document sort first
                            ap[i] === preferredDoc ? -1 :
                                bp[i] === preferredDoc ? 1 :
                                    0;
                    };

                return document;
            };

            Sizzle.matches = function (expr, elements) {
                return Sizzle(expr, null, null, elements);
            };

            Sizzle.matchesSelector = function (elem, expr) {
                // Set document vars if needed
                if ((elem.ownerDocument || elem) !== document) {
                    setDocument(elem);
                }

                if (support.matchesSelector && documentIsHTML &&
                    !nonnativeSelectorCache[expr + " "] &&
                    (!rbuggyMatches || !rbuggyMatches.test(expr)) &&
                    (!rbuggyQSA || !rbuggyQSA.test(expr))) {

                    try {
                        var ret = matches.call(elem, expr);

                        // IE 9's matchesSelector returns false on disconnected nodes
                        if (ret || support.disconnectedMatch ||
                            // As well, disconnected nodes are said to be in a document
                            // fragment in IE 9
                            elem.document && elem.document.nodeType !== 11) {
                            return ret;
                        }
                    } catch (e) {
                        nonnativeSelectorCache(expr, true);
                    }
                }

                return Sizzle(expr, document, null, [elem]).length > 0;
            };

            Sizzle.contains = function (context, elem) {
                // Set document vars if needed
                if ((context.ownerDocument || context) !== document) {
                    setDocument(context);
                }
                return contains(context, elem);
            };

            Sizzle.attr = function (elem, name) {
                // Set document vars if needed
                if ((elem.ownerDocument || elem) !== document) {
                    setDocument(elem);
                }

                var fn = Expr.attrHandle[name.toLowerCase()],
                    // Don't get fooled by Object.prototype properties (jQuery #13807)
                    val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?
                        fn(elem, name, !documentIsHTML) :
                        undefined;

                return val !== undefined ?
                    val :
                    support.attributes || !documentIsHTML ?
                        elem.getAttribute(name) :
                        (val = elem.getAttributeNode(name)) && val.specified ?
                            val.value :
                            null;
            };

            Sizzle.escape = function (sel) {
                return (sel + "").replace(rcssescape, fcssescape);
            };

            Sizzle.error = function (msg) {
                throw new Error("Syntax error, unrecognized expression: " + msg);
            };

            /**
             * Document sorting and removing duplicates
             * @param {ArrayLike} results
             */
            Sizzle.uniqueSort = function (results) {
                var elem,
                    duplicates = [],
                    j = 0,
                    i = 0;

                // Unless we *know* we can detect duplicates, assume their presence
                hasDuplicate = !support.detectDuplicates;
                sortInput = !support.sortStable && results.slice(0);
                results.sort(sortOrder);

                if (hasDuplicate) {
                    while ((elem = results[i++])) {
                        if (elem === results[i]) {
                            j = duplicates.push(i);
                        }
                    }
                    while (j--) {
                        results.splice(duplicates[j], 1);
                    }
                }

                // Clear input after sorting to release objects
                // See https://github.com/jquery/sizzle/pull/225
                sortInput = null;

                return results;
            };

            /**
             * Utility function for retrieving the text value of an array of DOM nodes
             * @param {Array|Element} elem
             */
            getText = Sizzle.getText = function (elem) {
                var node,
                    ret = "",
                    i = 0,
                    nodeType = elem.nodeType;

                if (!nodeType) {
                    // If no nodeType, this is expected to be an array
                    while ((node = elem[i++])) {
                        // Do not traverse comment nodes
                        ret += getText(node);
                    }
                } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                    // Use textContent for elements
                    // innerText usage removed for consistency of new lines (jQuery #11153)
                    if (typeof elem.textContent === "string") {
                        return elem.textContent;
                    } else {
                        // Traverse its children
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                            ret += getText(elem);
                        }
                    }
                } else if (nodeType === 3 || nodeType === 4) {
                    return elem.nodeValue;
                }
                // Do not include comment or processing instruction nodes

                return ret;
            };

            Expr = Sizzle.selectors = {

                // Can be adjusted by the user
                cacheLength: 50,

                createPseudo: markFunction,

                match: matchExpr,

                attrHandle: {},

                find: {},

                relative: {
                    ">": {dir: "parentNode", first: true},
                    " ": {dir: "parentNode"},
                    "+": {dir: "previousSibling", first: true},
                    "~": {dir: "previousSibling"}
                },

                preFilter: {
                    "ATTR": function (match) {
                        match[1] = match[1].replace(runescape, funescape);

                        // Move the given value to match[3] whether quoted or unquoted
                        match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

                        if (match[2] === "~=") {
                            match[3] = " " + match[3] + " ";
                        }

                        return match.slice(0, 4);
                    },

                    "CHILD": function (match) {
                        /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
                        match[1] = match[1].toLowerCase();

                        if (match[1].slice(0, 3) === "nth") {
                            // nth-* requires argument
                            if (!match[3]) {
                                Sizzle.error(match[0]);
                            }

                            // numeric x and y parameters for Expr.filter.CHILD
                            // remember that false/true cast respectively to 0/1
                            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                            match[5] = +((match[7] + match[8]) || match[3] === "odd");

                            // other types prohibit arguments
                        } else if (match[3]) {
                            Sizzle.error(match[0]);
                        }

                        return match;
                    },

                    "PSEUDO": function (match) {
                        var excess,
                            unquoted = !match[6] && match[2];

                        if (matchExpr["CHILD"].test(match[0])) {
                            return null;
                        }

                        // Accept quoted arguments as-is
                        if (match[3]) {
                            match[2] = match[4] || match[5] || "";

                            // Strip excess characters from unquoted arguments
                        } else if (unquoted && rpseudo.test(unquoted) &&
                            // Get excess from tokenize (recursively)
                            (excess = tokenize(unquoted, true)) &&
                            // advance to the next closing parenthesis
                            (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

                            // excess is a negative index
                            match[0] = match[0].slice(0, excess);
                            match[2] = unquoted.slice(0, excess);
                        }

                        // Return only captures needed by the pseudo filter method (type and argument)
                        return match.slice(0, 3);
                    }
                },

                filter: {

                    "TAG": function (nodeNameSelector) {
                        var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                        return nodeNameSelector === "*" ?
                            function () {
                                return true;
                            } :
                            function (elem) {
                                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                            };
                    },

                    "CLASS": function (className) {
                        var pattern = classCache[className + " "];

                        return pattern ||
                            (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) &&
                            classCache(className, function (elem) {
                                return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
                            });
                    },

                    "ATTR": function (name, operator, check) {
                        return function (elem) {
                            var result = Sizzle.attr(elem, name);

                            if (result == null) {
                                return operator === "!=";
                            }
                            if (!operator) {
                                return true;
                            }

                            result += "";

                            return operator === "=" ? result === check :
                                operator === "!=" ? result !== check :
                                    operator === "^=" ? check && result.indexOf(check) === 0 :
                                        operator === "*=" ? check && result.indexOf(check) > -1 :
                                            operator === "$=" ? check && result.slice(-check.length) === check :
                                                operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 :
                                                    operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" :
                                                        false;
                        };
                    },

                    "CHILD": function (type, what, argument, first, last) {
                        var simple = type.slice(0, 3) !== "nth",
                            forward = type.slice(-4) !== "last",
                            ofType = what === "of-type";

                        return first === 1 && last === 0 ?

                            // Shortcut for :nth-*(n)
                            function (elem) {
                                return !!elem.parentNode;
                            } :

                            function (elem, context, xml) {
                                var cache, uniqueCache, outerCache, node, nodeIndex, start,
                                    dir = simple !== forward ? "nextSibling" : "previousSibling",
                                    parent = elem.parentNode,
                                    name = ofType && elem.nodeName.toLowerCase(),
                                    useCache = !xml && !ofType,
                                    diff = false;

                                if (parent) {

                                    // :(first|last|only)-(child|of-type)
                                    if (simple) {
                                        while (dir) {
                                            node = elem;
                                            while ((node = node[dir])) {
                                                if (ofType ?
                                                    node.nodeName.toLowerCase() === name :
                                                    node.nodeType === 1) {

                                                    return false;
                                                }
                                            }
                                            // Reverse direction for :only-* (if we haven't yet done so)
                                            start = dir = type === "only" && !start && "nextSibling";
                                        }
                                        return true;
                                    }

                                    start = [forward ? parent.firstChild : parent.lastChild];

                                    // non-xml :nth-child(...) stores cache data on `parent`
                                    if (forward && useCache) {

                                        // Seek `elem` from a previously-cached index

                                        // ...in a gzip-friendly way
                                        node = parent;
                                        outerCache = node[expando] || (node[expando] = {});

                                        // Support: IE <9 only
                                        // Defend against cloned attroperties (jQuery gh-1709)
                                        uniqueCache = outerCache[node.uniqueID] ||
                                            (outerCache[node.uniqueID] = {});

                                        cache = uniqueCache[type] || [];
                                        nodeIndex = cache[0] === dirruns && cache[1];
                                        diff = nodeIndex && cache[2];
                                        node = nodeIndex && parent.childNodes[nodeIndex];

                                        while ((node = ++nodeIndex && node && node[dir] ||

                                            // Fallback to seeking `elem` from the start
                                            (diff = nodeIndex = 0) || start.pop())) {

                                            // When found, cache indexes on `parent` and break
                                            if (node.nodeType === 1 && ++diff && node === elem) {
                                                uniqueCache[type] = [dirruns, nodeIndex, diff];
                                                break;
                                            }
                                        }

                                    } else {
                                        // Use previously-cached element index if available
                                        if (useCache) {
                                            // ...in a gzip-friendly way
                                            node = elem;
                                            outerCache = node[expando] || (node[expando] = {});

                                            // Support: IE <9 only
                                            // Defend against cloned attroperties (jQuery gh-1709)
                                            uniqueCache = outerCache[node.uniqueID] ||
                                                (outerCache[node.uniqueID] = {});

                                            cache = uniqueCache[type] || [];
                                            nodeIndex = cache[0] === dirruns && cache[1];
                                            diff = nodeIndex;
                                        }

                                        // xml :nth-child(...)
                                        // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                        if (diff === false) {
                                            // Use the same loop as above to seek `elem` from the start
                                            while ((node = ++nodeIndex && node && node[dir] ||
                                                (diff = nodeIndex = 0) || start.pop())) {

                                                if ((ofType ?
                                                    node.nodeName.toLowerCase() === name :
                                                    node.nodeType === 1) &&
                                                    ++diff) {

                                                    // Cache the index of each encountered element
                                                    if (useCache) {
                                                        outerCache = node[expando] || (node[expando] = {});

                                                        // Support: IE <9 only
                                                        // Defend against cloned attroperties (jQuery gh-1709)
                                                        uniqueCache = outerCache[node.uniqueID] ||
                                                            (outerCache[node.uniqueID] = {});

                                                        uniqueCache[type] = [dirruns, diff];
                                                    }

                                                    if (node === elem) {
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    // Incorporate the offset, then check against cycle size
                                    diff -= last;
                                    return diff === first || (diff % first === 0 && diff / first >= 0);
                                }
                            };
                    },

                    "PSEUDO": function (pseudo, argument) {
                        // pseudo-class names are case-insensitive
                        // http://www.w3.org/TR/selectors/#pseudo-classes
                        // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                        // Remember that setFilters inherits from pseudos
                        var args,
                            fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||
                                Sizzle.error("unsupported pseudo: " + pseudo);

                        // The user may use createPseudo to indicate that
                        // arguments are needed to create the filter function
                        // just as Sizzle does
                        if (fn[expando]) {
                            return fn(argument);
                        }

                        // But maintain support for old signatures
                        if (fn.length > 1) {
                            args = [pseudo, pseudo, "", argument];
                            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
                                markFunction(function (seed, matches) {
                                    var idx,
                                        matched = fn(seed, argument),
                                        i = matched.length;
                                    while (i--) {
                                        idx = indexOf(seed, matched[i]);
                                        seed[idx] = !(matches[idx] = matched[i]);
                                    }
                                }) :
                                function (elem) {
                                    return fn(elem, 0, args);
                                };
                        }

                        return fn;
                    }
                },

                pseudos: {
                    // Potentially complex pseudos
                    "not": markFunction(function (selector) {
                        // Trim the selector passed to compile
                        // to avoid treating leading and trailing
                        // spaces as combinators
                        var input = [],
                            results = [],
                            matcher = compile(selector.replace(rtrim, "$1"));

                        return matcher[expando] ?
                            markFunction(function (seed, matches, context, xml) {
                                var elem,
                                    unmatched = matcher(seed, null, xml, []),
                                    i = seed.length;

                                // Match elements unmatched by `matcher`
                                while (i--) {
                                    if ((elem = unmatched[i])) {
                                        seed[i] = !(matches[i] = elem);
                                    }
                                }
                            }) :
                            function (elem, context, xml) {
                                input[0] = elem;
                                matcher(input, null, xml, results);
                                // Don't keep the element (issue #299)
                                input[0] = null;
                                return !results.pop();
                            };
                    }),

                    "has": markFunction(function (selector) {
                        return function (elem) {
                            return Sizzle(selector, elem).length > 0;
                        };
                    }),

                    "contains": markFunction(function (text) {
                        text = text.replace(runescape, funescape);
                        return function (elem) {
                            return (elem.textContent || getText(elem)).indexOf(text) > -1;
                        };
                    }),

                    // "Whether an element is represented by a :lang() selector
                    // is based solely on the element's language value
                    // being equal to the identifier C,
                    // or beginning with the identifier C immediately followed by "-".
                    // The matching of C against the element's language value is performed case-insensitively.
                    // The identifier C does not have to be a valid language name."
                    // http://www.w3.org/TR/selectors/#lang-pseudo
                    "lang": markFunction(function (lang) {
                        // lang value must be a valid identifier
                        if (!ridentifier.test(lang || "")) {
                            Sizzle.error("unsupported lang: " + lang);
                        }
                        lang = lang.replace(runescape, funescape).toLowerCase();
                        return function (elem) {
                            var elemLang;
                            do {
                                if ((elemLang = documentIsHTML ?
                                    elem.lang :
                                    elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {

                                    elemLang = elemLang.toLowerCase();
                                    return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                                }
                            } while ((elem = elem.parentNode) && elem.nodeType === 1);
                            return false;
                        };
                    }),

                    // Miscellaneous
                    "target": function (elem) {
                        var hash = window.location && window.location.hash;
                        return hash && hash.slice(1) === elem.id;
                    },

                    "root": function (elem) {
                        return elem === docElem;
                    },

                    "focus": function (elem) {
                        return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                    },

                    // Boolean properties
                    "enabled": createDisabledPseudo(false),
                    "disabled": createDisabledPseudo(true),

                    "checked": function (elem) {
                        // In CSS3, :checked should return both checked and selected elements
                        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                        var nodeName = elem.nodeName.toLowerCase();
                        return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
                    },

                    "selected": function (elem) {
                        // Accessing this property makes selected-by-default
                        // options in Safari work properly
                        if (elem.parentNode) {
                            elem.parentNode.selectedIndex;
                        }

                        return elem.selected === true;
                    },

                    // Contents
                    "empty": function (elem) {
                        // http://www.w3.org/TR/selectors/#empty-pseudo
                        // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                        //   but not by others (comment: 8; processing instruction: 7; etc.)
                        // nodeType < 6 works because attributes (2) do not appear as children
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                            if (elem.nodeType < 6) {
                                return false;
                            }
                        }
                        return true;
                    },

                    "parent": function (elem) {
                        return !Expr.pseudos["empty"](elem);
                    },

                    // Element/input types
                    "header": function (elem) {
                        return rheader.test(elem.nodeName);
                    },

                    "input": function (elem) {
                        return rinputs.test(elem.nodeName);
                    },

                    "button": function (elem) {
                        var name = elem.nodeName.toLowerCase();
                        return name === "input" && elem.type === "button" || name === "button";
                    },

                    "text": function (elem) {
                        var attr;
                        return elem.nodeName.toLowerCase() === "input" &&
                            elem.type === "text" &&

                            // Support: IE<8
                            // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                            ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                    },

                    // Position-in-collection
                    "first": createPositionalPseudo(function () {
                        return [0];
                    }),

                    "last": createPositionalPseudo(function (matchIndexes, length) {
                        return [length - 1];
                    }),

                    "eq": createPositionalPseudo(function (matchIndexes, length, argument) {
                        return [argument < 0 ? argument + length : argument];
                    }),

                    "even": createPositionalPseudo(function (matchIndexes, length) {
                        var i = 0;
                        for (; i < length; i += 2) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),

                    "odd": createPositionalPseudo(function (matchIndexes, length) {
                        var i = 1;
                        for (; i < length; i += 2) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),

                    "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
                        var i = argument < 0 ?
                            argument + length :
                            argument > length ?
                                length :
                                argument;
                        for (; --i >= 0;) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),

                    "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
                        var i = argument < 0 ? argument + length : argument;
                        for (; ++i < length;) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    })
                }
            };

            Expr.pseudos["nth"] = Expr.pseudos["eq"];

    // Add button/input type pseudos
            for (i in {radio: true, checkbox: true, file: true, password: true, image: true}) {
                Expr.pseudos[i] = createInputPseudo(i);
            }
            for (i in {submit: true, reset: true}) {
                Expr.pseudos[i] = createButtonPseudo(i);
            }

    // Easy API for creating new setFilters
            function setFilters() {
            }

            setFilters.prototype = Expr.filters = Expr.pseudos;
            Expr.setFilters = new setFilters();

            tokenize = Sizzle.tokenize = function (selector, parseOnly) {
                var matched, match, tokens, type,
                    soFar, groups, preFilters,
                    cached = tokenCache[selector + " "];

                if (cached) {
                    return parseOnly ? 0 : cached.slice(0);
                }

                soFar = selector;
                groups = [];
                preFilters = Expr.preFilter;

                while (soFar) {

                    // Comma and first run
                    if (!matched || (match = rcomma.exec(soFar))) {
                        if (match) {
                            // Don't consume trailing commas as valid
                            soFar = soFar.slice(match[0].length) || soFar;
                        }
                        groups.push((tokens = []));
                    }

                    matched = false;

                    // Combinators
                    if ((match = rcombinators.exec(soFar))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            // Cast descendant combinators to space
                            type: match[0].replace(rtrim, " ")
                        });
                        soFar = soFar.slice(matched.length);
                    }

                    // Filters
                    for (type in Expr.filter) {
                        if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||
                            (match = preFilters[type](match)))) {
                            matched = match.shift();
                            tokens.push({
                                value: matched,
                                type: type,
                                matches: match
                            });
                            soFar = soFar.slice(matched.length);
                        }
                    }

                    if (!matched) {
                        break;
                    }
                }

                // Return the length of the invalid excess
                // if we're just parsing
                // Otherwise, throw an error or return tokens
                return parseOnly ?
                    soFar.length :
                    soFar ?
                        Sizzle.error(selector) :
                        // Cache the tokens
                        tokenCache(selector, groups).slice(0);
            };

            function toSelector(tokens) {
                var i = 0,
                    len = tokens.length,
                    selector = "";
                for (; i < len; i++) {
                    selector += tokens[i].value;
                }
                return selector;
            }

            function addCombinator(matcher, combinator, base) {
                var dir = combinator.dir,
                    skip = combinator.next,
                    key = skip || dir,
                    checkNonElements = base && key === "parentNode",
                    doneName = done++;

                return combinator.first ?
                    // Check against closest ancestor/preceding element
                    function (elem, context, xml) {
                        while ((elem = elem[dir])) {
                            if (elem.nodeType === 1 || checkNonElements) {
                                return matcher(elem, context, xml);
                            }
                        }
                        return false;
                    } :

                    // Check against all ancestor/preceding elements
                    function (elem, context, xml) {
                        var oldCache, uniqueCache, outerCache,
                            newCache = [dirruns, doneName];

                        // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
                        if (xml) {
                            while ((elem = elem[dir])) {
                                if (elem.nodeType === 1 || checkNonElements) {
                                    if (matcher(elem, context, xml)) {
                                        return true;
                                    }
                                }
                            }
                        } else {
                            while ((elem = elem[dir])) {
                                if (elem.nodeType === 1 || checkNonElements) {
                                    outerCache = elem[expando] || (elem[expando] = {});

                                    // Support: IE <9 only
                                    // Defend against cloned attroperties (jQuery gh-1709)
                                    uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

                                    if (skip && skip === elem.nodeName.toLowerCase()) {
                                        elem = elem[dir] || elem;
                                    } else if ((oldCache = uniqueCache[key]) &&
                                        oldCache[0] === dirruns && oldCache[1] === doneName) {

                                        // Assign to newCache so results back-propagate to previous elements
                                        return (newCache[2] = oldCache[2]);
                                    } else {
                                        // Reuse newcache so results back-propagate to previous elements
                                        uniqueCache[key] = newCache;

                                        // A match means we're done; a fail means we have to keep checking
                                        if ((newCache[2] = matcher(elem, context, xml))) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                        return false;
                    };
            }

            function elementMatcher(matchers) {
                return matchers.length > 1 ?
                    function (elem, context, xml) {
                        var i = matchers.length;
                        while (i--) {
                            if (!matchers[i](elem, context, xml)) {
                                return false;
                            }
                        }
                        return true;
                    } :
                    matchers[0];
            }

            function multipleContexts(selector, contexts, results) {
                var i = 0,
                    len = contexts.length;
                for (; i < len; i++) {
                    Sizzle(selector, contexts[i], results);
                }
                return results;
            }

            function condense(unmatched, map, filter, context, xml) {
                var elem,
                    newUnmatched = [],
                    i = 0,
                    len = unmatched.length,
                    mapped = map != null;

                for (; i < len; i++) {
                    if ((elem = unmatched[i])) {
                        if (!filter || filter(elem, context, xml)) {
                            newUnmatched.push(elem);
                            if (mapped) {
                                map.push(i);
                            }
                        }
                    }
                }

                return newUnmatched;
            }

            function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                if (postFilter && !postFilter[expando]) {
                    postFilter = setMatcher(postFilter);
                }
                if (postFinder && !postFinder[expando]) {
                    postFinder = setMatcher(postFinder, postSelector);
                }
                return markFunction(function (seed, results, context, xml) {
                    var temp, i, elem,
                        preMap = [],
                        postMap = [],
                        preexisting = results.length,

                        // Get initial elements from seed or context
                        elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),

                        // Prefilter to get matcher input, preserving a map for seed-results synchronization
                        matcherIn = preFilter && (seed || !selector) ?
                            condense(elems, preMap, preFilter, context, xml) :
                            elems,

                        matcherOut = matcher ?
                            // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                            postFinder || (seed ? preFilter : preexisting || postFilter) ?

                                // ...intermediate processing is necessary
                                [] :

                                // ...otherwise use results directly
                                results :
                            matcherIn;

                    // Find primary matches
                    if (matcher) {
                        matcher(matcherIn, matcherOut, context, xml);
                    }

                    // Apply postFilter
                    if (postFilter) {
                        temp = condense(matcherOut, postMap);
                        postFilter(temp, [], context, xml);

                        // Un-match failing elements by moving them back to matcherIn
                        i = temp.length;
                        while (i--) {
                            if ((elem = temp[i])) {
                                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                            }
                        }
                    }

                    if (seed) {
                        if (postFinder || preFilter) {
                            if (postFinder) {
                                // Get the final matcherOut by condensing this intermediate into postFinder contexts
                                temp = [];
                                i = matcherOut.length;
                                while (i--) {
                                    if ((elem = matcherOut[i])) {
                                        // Restore matcherIn since elem is not yet a final match
                                        temp.push((matcherIn[i] = elem));
                                    }
                                }
                                postFinder(null, (matcherOut = []), temp, xml);
                            }

                            // Move matched elements from seed to results to keep them synchronized
                            i = matcherOut.length;
                            while (i--) {
                                if ((elem = matcherOut[i]) &&
                                    (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {

                                    seed[temp] = !(results[temp] = elem);
                                }
                            }
                        }

                        // Add elements to results, through postFinder if defined
                    } else {
                        matcherOut = condense(
                            matcherOut === results ?
                                matcherOut.splice(preexisting, matcherOut.length) :
                                matcherOut
                        );
                        if (postFinder) {
                            postFinder(null, results, matcherOut, xml);
                        } else {
                            push.apply(results, matcherOut);
                        }
                    }
                });
            }

            function matcherFromTokens(tokens) {
                var checkContext, matcher, j,
                    len = tokens.length,
                    leadingRelative = Expr.relative[tokens[0].type],
                    implicitRelative = leadingRelative || Expr.relative[" "],
                    i = leadingRelative ? 1 : 0,

                    // The foundational matcher ensures that elements are reachable from top-level context(s)
                    matchContext = addCombinator(function (elem) {
                        return elem === checkContext;
                    }, implicitRelative, true),
                    matchAnyContext = addCombinator(function (elem) {
                        return indexOf(checkContext, elem) > -1;
                    }, implicitRelative, true),
                    matchers = [function (elem, context, xml) {
                        var ret = (!leadingRelative && (xml || context !== outermostContext)) || (
                            (checkContext = context).nodeType ?
                                matchContext(elem, context, xml) :
                                matchAnyContext(elem, context, xml));
                        // Avoid hanging onto element (issue #299)
                        checkContext = null;
                        return ret;
                    }];

                for (; i < len; i++) {
                    if ((matcher = Expr.relative[tokens[i].type])) {
                        matchers = [addCombinator(elementMatcher(matchers), matcher)];
                    } else {
                        matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

                        // Return special upon seeing a positional matcher
                        if (matcher[expando]) {
                            // Find the next relative operator (if any) for proper handling
                            j = ++i;
                            for (; j < len; j++) {
                                if (Expr.relative[tokens[j].type]) {
                                    break;
                                }
                            }
                            return setMatcher(
                                i > 1 && elementMatcher(matchers),
                                i > 1 && toSelector(
                                // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                                tokens.slice(0, i - 1).concat({value: tokens[i - 2].type === " " ? "*" : ""})
                                ).replace(rtrim, "$1"),
                                matcher,
                                i < j && matcherFromTokens(tokens.slice(i, j)),
                                j < len && matcherFromTokens((tokens = tokens.slice(j))),
                                j < len && toSelector(tokens)
                            );
                        }
                        matchers.push(matcher);
                    }
                }

                return elementMatcher(matchers);
            }

            function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                var bySet = setMatchers.length > 0,
                    byElement = elementMatchers.length > 0,
                    superMatcher = function (seed, context, xml, results, outermost) {
                        var elem, j, matcher,
                            matchedCount = 0,
                            i = "0",
                            unmatched = seed && [],
                            setMatched = [],
                            contextBackup = outermostContext,
                            // We must always have either seed elements or outermost context
                            elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                            // Use integer dirruns iff this is the outermost matcher
                            dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                            len = elems.length;

                        if (outermost) {
                            outermostContext = context === document || context || outermost;
                        }

                        // Add elements passing elementMatchers directly to results
                        // Support: IE<9, Safari
                        // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                        for (; i !== len && (elem = elems[i]) != null; i++) {
                            if (byElement && elem) {
                                j = 0;
                                if (!context && elem.ownerDocument !== document) {
                                    setDocument(elem);
                                    xml = !documentIsHTML;
                                }
                                while ((matcher = elementMatchers[j++])) {
                                    if (matcher(elem, context || document, xml)) {
                                        results.push(elem);
                                        break;
                                    }
                                }
                                if (outermost) {
                                    dirruns = dirrunsUnique;
                                }
                            }

                            // Track unmatched elements for set filters
                            if (bySet) {
                                // They will have gone through all possible matchers
                                if ((elem = !matcher && elem)) {
                                    matchedCount--;
                                }

                                // Lengthen the array for every element, matched or not
                                if (seed) {
                                    unmatched.push(elem);
                                }
                            }
                        }

                        // `i` is now the count of elements visited above, and adding it to `matchedCount`
                        // makes the latter nonnegative.
                        matchedCount += i;

                        // Apply set filters to unmatched elements
                        // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
                        // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
                        // no element matchers and no seed.
                        // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
                        // case, which will result in a "00" `matchedCount` that differs from `i` but is also
                        // numerically zero.
                        if (bySet && i !== matchedCount) {
                            j = 0;
                            while ((matcher = setMatchers[j++])) {
                                matcher(unmatched, setMatched, context, xml);
                            }

                            if (seed) {
                                // Reintegrate element matches to eliminate the need for sorting
                                if (matchedCount > 0) {
                                    while (i--) {
                                        if (!(unmatched[i] || setMatched[i])) {
                                            setMatched[i] = pop.call(results);
                                        }
                                    }
                                }

                                // Discard index placeholder values to get only actual matches
                                setMatched = condense(setMatched);
                            }

                            // Add matches to results
                            push.apply(results, setMatched);

                            // Seedless set matches succeeding multiple successful matchers stipulate sorting
                            if (outermost && !seed && setMatched.length > 0 &&
                                (matchedCount + setMatchers.length) > 1) {

                                Sizzle.uniqueSort(results);
                            }
                        }

                        // Override manipulation of globals by nested matchers
                        if (outermost) {
                            dirruns = dirrunsUnique;
                            outermostContext = contextBackup;
                        }

                        return unmatched;
                    };

                return bySet ?
                    markFunction(superMatcher) :
                    superMatcher;
            }

            compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {
                var i,
                    setMatchers = [],
                    elementMatchers = [],
                    cached = compilerCache[selector + " "];

                if (!cached) {
                    // Generate a function of recursive functions that can be used to check each element
                    if (!match) {
                        match = tokenize(selector);
                    }
                    i = match.length;
                    while (i--) {
                        cached = matcherFromTokens(match[i]);
                        if (cached[expando]) {
                            setMatchers.push(cached);
                        } else {
                            elementMatchers.push(cached);
                        }
                    }

                    // Cache the compiled function
                    cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

                    // Save selector and tokenization
                    cached.selector = selector;
                }
                return cached;
            };

            /**
             * A low-level selection function that works with Sizzle's compiled
             *  selector functions
             * @param {String|Function} selector A selector or a pre-compiled
             *  selector function built with Sizzle.compile
             * @param {Element} context
             * @param {Array} [results]
             * @param {Array} [seed] A set of elements to match against
             */
            select = Sizzle.select = function (selector, context, results, seed) {
                var i, tokens, token, type, find,
                    compiled = typeof selector === "function" && selector,
                    match = !seed && tokenize((selector = compiled.selector || selector));

                results = results || [];

                // Try to minimize operations if there is only one selector in the list and no seed
                // (the latter of which guarantees us context)
                if (match.length === 1) {

                    // Reduce context if the leading compound selector is an ID
                    tokens = match[0] = match[0].slice(0);
                    if (tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                        context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {

                        context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                        if (!context) {
                            return results;

                            // Precompiled matchers will still verify ancestry, so step up a level
                        } else if (compiled) {
                            context = context.parentNode;
                        }

                        selector = selector.slice(tokens.shift().value.length);
                    }

                    // Fetch a seed set for right-to-left matching
                    i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                    while (i--) {
                        token = tokens[i];

                        // Abort if we hit a combinator
                        if (Expr.relative[(type = token.type)]) {
                            break;
                        }
                        if ((find = Expr.find[type])) {
                            // Search, expanding context for leading sibling combinators
                            if ((seed = find(
                                token.matches[0].replace(runescape, funescape),
                                rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                            ))) {

                                // If seed is empty or no tokens remain, we can return early
                                tokens.splice(i, 1);
                                selector = seed.length && toSelector(tokens);
                                if (!selector) {
                                    push.apply(results, seed);
                                    return results;
                                }

                                break;
                            }
                        }
                    }
                }

                // Compile and execute a filtering function if one is not provided
                // Provide `match` to avoid retokenization if we modified the selector above
                (compiled || compile(selector, match))(
                    seed,
                    context,
                    !documentIsHTML,
                    results,
                    !context || rsibling.test(selector) && testContext(context.parentNode) || context
                );
                return results;
            };

    // One-time assignments

    // Sort stability
            support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

    // Support: Chrome 14-35+
    // Always assume duplicates if they aren't passed to the comparison function
            support.detectDuplicates = !!hasDuplicate;

    // Initialize against the default document
            setDocument();

    // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
    // Detached nodes confoundingly follow *each other*
            support.sortDetached = assert(function (el) {
                // Should return 1, but returns 4 (following)
                return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
            });

    // Support: IE<8
    // Prevent attribute/property "interpolation"
    // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
            if (!assert(function (el) {
                el.innerHTML = "<a href='#'></a>";
                return el.firstChild.getAttribute("href") === "#";
            })) {
                addHandle("type|href|height|width", function (elem, name, isXML) {
                    if (!isXML) {
                        return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
                    }
                });
            }

    // Support: IE<9
    // Use defaultValue in place of getAttribute("value")
            if (!support.attributes || !assert(function (el) {
                el.innerHTML = "<input/>";
                el.firstChild.setAttribute("value", "");
                return el.firstChild.getAttribute("value") === "";
      })) {
                addHandle("value", function (elem, name, isXML) {
                    if (!isXML && elem.nodeName.toLowerCase() === "input") {
                        return elem.defaultValue;
                    }
                });
            }

    // Support: IE<9
    // Use getAttributeNode to fetch booleans when getAttribute lies
            if (!assert(function (el) {
                return el.getAttribute("disabled") == null;
            })) {
                addHandle(booleans, function (elem, name, isXML) {
                    var val;
                    if (!isXML) {
                        return elem[name] === true ? name.toLowerCase() :
                            (val = elem.getAttributeNode(name)) && val.specified ?
                                val.value :
                                null;
                    }
                });
            }

            return Sizzle;

        })(window);


    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;

    // Deprecated
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    jQuery.escapeSelector = Sizzle.escape;


    var dir = function (elem, dir, until) {
        var matched = [],
            truncate = until !== undefined;

        while ((elem = elem[dir]) && elem.nodeType !== 9) {
            if (elem.nodeType === 1) {
                if (truncate && jQuery(elem).is(until)) {
                    break;
                }
                matched.push(elem);
            }
        }
        return matched;
    };


    var siblings = function (n, elem) {
        var matched = [];

        for (; n; n = n.nextSibling) {
            if (n.nodeType === 1 && n !== elem) {
                matched.push(n);
            }
        }

        return matched;
    };


    var rneedsContext = jQuery.expr.match.needsContext;


    function nodeName(elem, name) {

        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

    };
    var rsingleTag = (/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i);


    // Implement the identical functionality for filter and not
    function winnow(elements, qualifier, not) {
        if (isFunction(qualifier)) {
            return jQuery.grep(elements, function (elem, i) {
                return !!qualifier.call(elem, i, elem) !== not;
            });
        }

        // Single element
        if (qualifier.nodeType) {
            return jQuery.grep(elements, function (elem) {
                return (elem === qualifier) !== not;
            });
        }

        // Arraylike of elements (jQuery, arguments, Array)
        if (typeof qualifier !== "string") {
            return jQuery.grep(elements, function (elem) {
                return (indexOf.call(qualifier, elem) > -1) !== not;
            });
        }

        // Filtered directly for both simple and complex selectors
        return jQuery.filter(qualifier, elements, not);
    }

    jQuery.filter = function (expr, elems, not) {
        var elem = elems[0];

        if (not) {
            expr = ":not(" + expr + ")";
        }

        if (elems.length === 1 && elem.nodeType === 1) {
            return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
        }

        return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
            return elem.nodeType === 1;
        }));
    };

    jQuery.fn.extend({
        find: function (selector) {
            var i, ret,
                len = this.length,
                self = this;

            if (typeof selector !== "string") {
                return this.pushStack(jQuery(selector).filter(function () {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                }));
            }

            ret = this.pushStack([]);

            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }

            return len > 1 ? jQuery.uniqueSort(ret) : ret;
        },
        filter: function (selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function (selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function (selector) {
            return !!winnow(
                this,

                // If this is a positional/relative selector, check membership in the returned set
                // so $("p:first").is("p:last") won't return true for a doc with two "p".
                typeof selector === "string" && rneedsContext.test(selector) ?
                    jQuery(selector) :
                    selector || [],
                false
            ).length;
        }
    });


    // Initialize a jQuery object


    // A central reference to the root jQuery(document)
    var rootjQuery,

        // A simple way to check for HTML strings
        // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
        // Strict HTML recognition (#11290: must start with <)
        // Shortcut simple #id case for speed
        rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

        init = jQuery.fn.init = function (selector, context, root) {
            var match, elem;

            // HANDLE: $(""), $(null), $(undefined), $(false)
            if (!selector) {
                return this;
            }

            // Method init() accepts an alternate rootjQuery
            // so migrate can support jQuery.sub (gh-2101)
            root = root || rootjQuery;

            // Handle HTML strings
            if (typeof selector === "string") {
                if (selector[0] === "<" &&
                    selector[selector.length - 1] === ">" &&
                    selector.length >= 3) {

                    // Assume that strings that start and end with <> are HTML and skip the regex check
                    match = [null, selector, null];

                } else {
                    match = rquickExpr.exec(selector);
                }

                // Match html or make sure no context is specified for #id
                if (match && (match[1] || !context)) {

                    // HANDLE: $(html) -> $(array)
                    if (match[1]) {
                        context = context instanceof jQuery ? context[0] : context;

                        // Option to run scripts is true for back-compat
                        // Intentionally let the error be thrown if parseHTML is not present
                        jQuery.merge(this, jQuery.parseHTML(
                            match[1],
                            context && context.nodeType ? context.ownerDocument || context : document,
                            true
                        ));

                        // HANDLE: $(html, props)
                        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                            for (match in context) {

                                // Properties of context are called as methods if possible
                                if (isFunction(this[match])) {
                                    this[match](context[match]);

                                    // ...and otherwise set as attributes
                                } else {
                                    this.attr(match, context[match]);
                                }
                            }
                        }

                        return this;

                        // HANDLE: $(#id)
                    } else {
                        elem = document.getElementById(match[2]);

                        if (elem) {

                            // Inject the element directly into the jQuery object
                            this[0] = elem;
                            this.length = 1;
                        }
                        return this;
                    }

                    // HANDLE: $(expr, $(...))
                } else if (!context || context.jquery) {
                    return (context || root).find(selector);

                    // HANDLE: $(expr, context)
                    // (which is just equivalent to: $(context).find(expr)
                } else {
                    return this.constructor(context).find(selector);
                }

                // HANDLE: $(DOMElement)
            } else if (selector.nodeType) {
                this[0] = selector;
                this.length = 1;
                return this;

                // HANDLE: $(function)
                // Shortcut for document ready
            } else if (isFunction(selector)) {
                return root.ready !== undefined ?
                    root.ready(selector) :

                    // Execute immediately if ready is not present
                    selector(jQuery);
            }

            return jQuery.makeArray(selector, this);
        };

    // Give the init function the jQuery prototype for later instantiation
    init.prototype = jQuery.fn;

    // Initialize central reference
    rootjQuery = jQuery(document);


    var rparentsprev = /^(?:parents|prev(?:Until|All))/,

        // Methods guaranteed to produce a unique set when starting from a unique set
        guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };

    jQuery.fn.extend({
        has: function (target) {
            var targets = jQuery(target, this),
                l = targets.length;

            return this.filter(function () {
                var i = 0;
                for (; i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },

        closest: function (selectors, context) {
            var cur,
                i = 0,
                l = this.length,
                matched = [],
                targets = typeof selectors !== "string" && jQuery(selectors);

            // Positional selectors never match, since there's no _selection_ context
            if (!rneedsContext.test(selectors)) {
                for (; i < l; i++) {
                    for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {

                        // Always skip document fragments
                        if (cur.nodeType < 11 && (targets ?
                            targets.index(cur) > -1 :

                            // Don't pass non-elements to Sizzle
                            cur.nodeType === 1 &&
                            jQuery.find.matchesSelector(cur, selectors))) {

                            matched.push(cur);
                            break;
                        }
                    }
                }
            }

            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },

        // Determine the position of an element within the set
        index: function (elem) {

            // No argument, return index in parent
            if (!elem) {
                return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
            }

            // Index in selector
            if (typeof elem === "string") {
                return indexOf.call(jQuery(elem), this[0]);
            }

            // Locate the position of the desired element
            return indexOf.call(this,

                // If it receives a jQuery object, the first element is used
                elem.jquery ? elem[0] : elem
            );
        },

        add: function (selector, context) {
            return this.pushStack(
                jQuery.uniqueSort(
                    jQuery.merge(this.get(), jQuery(selector, context))
                )
            );
        },

        addBack: function (selector) {
            return this.add(selector == null ?
                this.prevObject : this.prevObject.filter(selector)
            );
        }
    });

    function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) {
        }
        return cur;
    }

    jQuery.each({
        parent: function (elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function (elem) {
            return dir(elem, "parentNode");
        },
        parentsUntil: function (elem, i, until) {
            return dir(elem, "parentNode", until);
        },
        next: function (elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function (elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function (elem) {
            return dir(elem, "nextSibling");
        },
        prevAll: function (elem) {
            return dir(elem, "previousSibling");
        },
        nextUntil: function (elem, i, until) {
            return dir(elem, "nextSibling", until);
        },
        prevUntil: function (elem, i, until) {
            return dir(elem, "previousSibling", until);
        },
        siblings: function (elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function (elem) {
            return siblings(elem.firstChild);
        },
        contents: function (elem) {
            if (typeof elem.contentDocument !== "undefined") {
                return elem.contentDocument;
            }

            // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
            // Treat the template element as a regular one in browsers that
            // don't support it.
            if (nodeName(elem, "template")) {
                elem = elem.content || elem;
            }

            return jQuery.merge([], elem.childNodes);
        }
    }, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
            var matched = jQuery.map(this, fn, until);

            if (name.slice(-5) !== "Until") {
                selector = until;
            }

            if (selector && typeof selector === "string") {
                matched = jQuery.filter(selector, matched);
            }

            if (this.length > 1) {

                // Remove duplicates
                if (!guaranteedUnique[name]) {
                    jQuery.uniqueSort(matched);
                }

                // Reverse order for parents* and prev-derivatives
                if (rparentsprev.test(name)) {
                    matched.reverse();
                }
            }

            return this.pushStack(matched);
        };
    });
    var rnothtmlwhite = (/[^\x20\t\r\n\f]+/g);


    // Convert String-formatted options into Object-formatted ones
    function createOptions(options) {
        var object = {};
        jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
            object[flag] = true;
        });
        return object;
    }

    /*
    * Create a callback list using the following parameters:
    *
     *	options: an optional list of space-separated options that will change how
     *			the callback list behaves or a more traditional option object
     *
     * By default a callback list will act like an event callback list and can be
     * "fired" multiple times.
     *
     * Possible options:
     *
     *	once:			will ensure the callback list can only be fired once (like a Deferred)
     *
     *	memory:			will keep track of previous values and will call any callback added
     *					after the list has been fired right away with the latest "memorized"
     *					values (like a Deferred)
     *
     *	unique:			will ensure a callback can only be added once (no duplicate in the list)
     *
     *	stopOnFalse:	interrupt callings when a callback returns false
     *
     */
    jQuery.Callbacks = function (options) {

        // Convert options from String-formatted to Object-formatted if needed
        // (we check in cache first)
        options = typeof options === "string" ?
            createOptions(options) :
            jQuery.extend({}, options);

        var // Flag to know if list is currently firing
            firing,

            // Last fire value for non-forgettable lists
            memory,

            // Flag to know if list was already fired
            fired,

            // Flag to prevent firing
            locked,

            // Actual callback list
            list = [],

            // Queue of execution data for repeatable lists
            queue = [],

            // Index of currently firing callback (modified by add/remove as needed)
            firingIndex = -1,

            // Fire callbacks
            fire = function () {

                // Enforce single-firing
                locked = locked || options.once;

                // Execute callbacks for all pending executions,
                // respecting firingIndex overrides and runtime changes
                fired = firing = true;
                for (; queue.length; firingIndex = -1) {
                    memory = queue.shift();
                    while (++firingIndex < list.length) {

                        // Run callback and check for early termination
                        if (list[firingIndex].apply(memory[0], memory[1]) === false &&
                            options.stopOnFalse) {

                            // Jump to end and forget the data so .add doesn't re-fire
                            firingIndex = list.length;
                            memory = false;
                        }
                    }
                }

                // Forget the data if we're done with it
                if (!options.memory) {
                    memory = false;
                }

                firing = false;

                // Clean up if we're done firing for good
                if (locked) {

                    // Keep an empty list if we have data for future add calls
                    if (memory) {
                        list = [];

                        // Otherwise, this object is spent
                    } else {
                        list = "";
                    }
                }
            },

            // Actual Callbacks object
            self = {

                // Add a callback or a collection of callbacks to the list
                add: function () {
                    if (list) {

                        // If we have memory from a past run, we should fire after adding
                        if (memory && !firing) {
                            firingIndex = list.length - 1;
                            queue.push(memory);
                        }

                        (function add(args) {
                            jQuery.each(args, function (_, arg) {
                                if (isFunction(arg)) {
                                    if (!options.unique || !self.has(arg)) {
                                        list.push(arg);
                                    }
                                } else if (arg && arg.length && toType(arg) !== "string") {

                                    // Inspect recursively
                                    add(arg);
                                }
                            });
                        })(arguments);

                        if (memory && !firing) {
                            fire();
                        }
                    }
                    return this;
                },

                // Remove a callback from the list
                remove: function () {
                    jQuery.each(arguments, function (_, arg) {
                        var index;
                        while ((index = jQuery.inArray(arg, list, index)) > -1) {
                            list.splice(index, 1);

                            // Handle firing indexes
                            if (index <= firingIndex) {
                                firingIndex--;
                            }
                        }
                    });
                    return this;
                },

                // Check if a given callback is in the list.
                // If no argument is given, return whether or not list has callbacks attached.
                has: function (fn) {
                    return fn ?
                        jQuery.inArray(fn, list) > -1 :
                        list.length > 0;
                },

                // Remove all callbacks from the list
                empty: function () {
                    if (list) {
                        list = [];
                    }
                    return this;
                },

                // Disable .fire and .add
                // Abort any current/pending executions
                // Clear all callbacks and values
                disable: function () {
                    locked = queue = [];
                    list = memory = "";
                    return this;
                },
                disabled: function () {
                    return !list;
                },

                // Disable .fire
                // Also disable .add unless we have memory (since it would have no effect)
                // Abort any pending executions
                lock: function () {
                    locked = queue = [];
                    if (!memory && !firing) {
                        list = memory = "";
                    }
                    return this;
                },
                locked: function () {
                    return !!locked;
                },

                // Call all callbacks with the given context and arguments
                fireWith: function (context, args) {
                    if (!locked) {
                        args = args || [];
                        args = [context, args.slice ? args.slice() : args];
                        queue.push(args);
                        if (!firing) {
                            fire();
                        }
                    }
                    return this;
                },

                // Call all the callbacks with the given arguments
                fire: function () {
                    self.fireWith(this, arguments);
                    return this;
                },

                // To know if the callbacks have already been called at least once
                fired: function () {
                    return !!fired;
                }
            };

        return self;
    };


    function Identity(v) {
        return v;
    }

    function Thrower(ex) {
        throw ex;
    }

    function adoptValue(value, resolve, reject, noValue) {
        var method;

        try {

            // Check for promise aspect first to privilege synchronous behavior
            if (value && isFunction((method = value.promise))) {
                method.call(value).done(resolve).fail(reject);

                // Other thenables
            } else if (value && isFunction((method = value.then))) {
                method.call(value, resolve, reject);

                // Other non-thenables
            } else {

                // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
                // * false: [ value ].slice( 0 ) => resolve( value )
                // * true: [ value ].slice( 1 ) => resolve()
                resolve.apply(undefined, [value].slice(noValue));
            }

            // For Promises/A+, convert exceptions into rejections
            // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
            // Deferred#then to conditionally suppress rejection.
        } catch (value) {

            // Support: Android 4.0 only
            // Strict mode functions invoked without .call/.apply get global-object context
            reject.apply(undefined, [value]);
        }
    }

    jQuery.extend({

        Deferred: function (func) {
            var tuples = [

                    // action, add listener, callbacks,
                    // ... .then handlers, argument index, [final state]
                    ["notify", "progress", jQuery.Callbacks("memory"),
                        jQuery.Callbacks("memory"), 2],
                    ["resolve", "done", jQuery.Callbacks("once memory"),
                        jQuery.Callbacks("once memory"), 0, "resolved"],
                    ["reject", "fail", jQuery.Callbacks("once memory"),
                        jQuery.Callbacks("once memory"), 1, "rejected"]
                ],
                state = "pending",
                promise = {
                    state: function () {
                        return state;
                    },
                    always: function () {
                        deferred.done(arguments).fail(arguments);
                        return this;
                    },
                    "catch": function (fn) {
                        return promise.then(null, fn);
                    },

                    // Keep pipe for back-compat
                    pipe: function (/* fnDone, fnFail, fnProgress */) {
                        var fns = arguments;

                        return jQuery.Deferred(function (newDefer) {
                            jQuery.each(tuples, function (i, tuple) {

                                // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                                var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];

                                // deferred.progress(function() { bind to newDefer or newDefer.notify })
                                // deferred.done(function() { bind to newDefer or newDefer.resolve })
                                // deferred.fail(function() { bind to newDefer or newDefer.reject })
                                deferred[tuple[1]](function () {
                                    var returned = fn && fn.apply(this, arguments);
                                    if (returned && isFunction(returned.promise)) {
                                        returned.promise()
                                            .progress(newDefer.notify)
                                            .done(newDefer.resolve)
                                            .fail(newDefer.reject);
                                    } else {
                                        newDefer[tuple[0] + "With"](
                                            this,
                                            fn ? [returned] : arguments
                                        );
                                    }
                                });
                            });
                            fns = null;
                        }).promise();
                    },
                    then: function (onFulfilled, onRejected, onProgress) {
                        var maxDepth = 0;

                        function resolve(depth, deferred, handler, special) {
                            return function () {
                                var that = this,
                                    args = arguments,
                                    mightThrow = function () {
                                        var returned, then;

                                        // Support: Promises/A+ section 2.3.3.3.3
                                        // https://promisesaplus.com/#point-59
                                        // Ignore double-resolution attempts
                                        if (depth < maxDepth) {
                                            return;
                                        }

                                        returned = handler.apply(that, args);

                                        // Support: Promises/A+ section 2.3.1
                                        // https://promisesaplus.com/#point-48
                                        if (returned === deferred.promise()) {
                                            throw new TypeError("Thenable self-resolution");
                                        }

                                        // Support: Promises/A+ sections 2.3.3.1, 3.5
                                        // https://promisesaplus.com/#point-54
                                        // https://promisesaplus.com/#point-75
                                        // Retrieve `then` only once
                                        then = returned &&

                                            // Support: Promises/A+ section 2.3.4
                                            // https://promisesaplus.com/#point-64
                                            // Only check objects and functions for thenability
                                            (typeof returned === "object" ||
                                                typeof returned === "function") &&
                                            returned.then;

                                        // Handle a returned thenable
                                        if (isFunction(then)) {

                                            // Special processors (notify) just wait for resolution
                                            if (special) {
                                                then.call(
                                                    returned,
                                                    resolve(maxDepth, deferred, Identity, special),
                                                    resolve(maxDepth, deferred, Thrower, special)
                                                );

                                                // Normal processors (resolve) also hook into progress
                                            } else {

                                                // ...and disregard older resolution values
                                                maxDepth++;

                                                then.call(
                                                    returned,
                                                    resolve(maxDepth, deferred, Identity, special),
                                                    resolve(maxDepth, deferred, Thrower, special),
                                                    resolve(maxDepth, deferred, Identity,
                                                        deferred.notifyWith)
                                                );
                                            }

                                            // Handle all other returned values
                                        } else {

                                            // Only substitute handlers pass on context
                                            // and multiple values (non-spec behavior)
                                            if (handler !== Identity) {
                                                that = undefined;
                                                args = [returned];
                                            }

                                            // Process the value(s)
                                            // Default process is resolve
                                            (special || deferred.resolveWith)(that, args);
                                        }
                                    },

                                    // Only normal processors (resolve) catch and reject exceptions
                                    process = special ?
                                        mightThrow :
                                        function () {
                                            try {
                                                mightThrow();
                                            } catch (e) {

                                                if (jQuery.Deferred.exceptionHook) {
                                                    jQuery.Deferred.exceptionHook(e,
                                                        process.stackTrace);
                                                }

                                                // Support: Promises/A+ section 2.3.3.3.4.1
                                                // https://promisesaplus.com/#point-61
                                                // Ignore post-resolution exceptions
                                                if (depth + 1 >= maxDepth) {

                                                    // Only substitute handlers pass on context
                                                    // and multiple values (non-spec behavior)
                                                    if (handler !== Thrower) {
                                                        that = undefined;
                                                        args = [e];
                                                    }

                                                    deferred.rejectWith(that, args);
                                                }
                                            }
                                        };

                                // Support: Promises/A+ section 2.3.3.3.1
                                // https://promisesaplus.com/#point-57
                                // Re-resolve promises immediately to dodge false rejection from
                                // subsequent errors
                                if (depth) {
                                    process();
                                } else {

                                    // Call an optional hook to record the stack, in case of exception
                                    // since it's otherwise lost when execution goes async
                                    if (jQuery.Deferred.getStackHook) {
                                        process.stackTrace = jQuery.Deferred.getStackHook();
                                    }
                                    window.setTimeout(process);
                                }
                            };
                        }

                        return jQuery.Deferred(function (newDefer) {

                            // progress_handlers.add( ... )
                            tuples[0][3].add(
                                resolve(
                                    0,
                                    newDefer,
                                    isFunction(onProgress) ?
                                        onProgress :
                                        Identity,
                                    newDefer.notifyWith
                                )
                            );

                            // fulfilled_handlers.add( ... )
                            tuples[1][3].add(
                                resolve(
                                    0,
                                    newDefer,
                                    isFunction(onFulfilled) ?
                                        onFulfilled :
                                        Identity
                                )
                            );

                            // rejected_handlers.add( ... )
                            tuples[2][3].add(
                                resolve(
                                    0,
                                    newDefer,
                                    isFunction(onRejected) ?
                                        onRejected :
                                        Thrower
                                )
                            );
                        }).promise();
                    },

                    // Get a promise for this deferred
                    // If obj is provided, the promise aspect is added to the object
                    promise: function (obj) {
                        return obj != null ? jQuery.extend(obj, promise) : promise;
                    }
                },
                deferred = {};

            // Add list-specific methods
            jQuery.each(tuples, function (i, tuple) {
                var list = tuple[2],
                    stateString = tuple[5];

                // promise.progress = list.add
                // promise.done = list.add
                // promise.fail = list.add
                promise[tuple[1]] = list.add;

                // Handle state
                if (stateString) {
                    list.add(
                        function () {

                            // state = "resolved" (i.e., fulfilled)
                            // state = "rejected"
                            state = stateString;
                        },

                        // rejected_callbacks.disable
                        // fulfilled_callbacks.disable
                        tuples[3 - i][2].disable,

                        // rejected_handlers.disable
                        // fulfilled_handlers.disable
                        tuples[3 - i][3].disable,

                        // progress_callbacks.lock
                        tuples[0][2].lock,

                        // progress_handlers.lock
                        tuples[0][3].lock
                    );
                }

                // progress_handlers.fire
                // fulfilled_handlers.fire
                // rejected_handlers.fire
                list.add(tuple[3].fire);

                // deferred.notify = function() { deferred.notifyWith(...) }
                // deferred.resolve = function() { deferred.resolveWith(...) }
                // deferred.reject = function() { deferred.rejectWith(...) }
                deferred[tuple[0]] = function () {
                    deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
                    return this;
                };

                // deferred.notifyWith = list.fireWith
                // deferred.resolveWith = list.fireWith
                // deferred.rejectWith = list.fireWith
                deferred[tuple[0] + "With"] = list.fireWith;
            });

            // Make the deferred a promise
            promise.promise(deferred);

            // Call given func if any
            if (func) {
                func.call(deferred, deferred);
            }

            // All done!
            return deferred;
        },

        // Deferred helper
        when: function (singleValue) {
            var

                // count of uncompleted subordinates
                remaining = arguments.length,

                // count of unprocessed arguments
                i = remaining,

                // subordinate fulfillment data
                resolveContexts = Array(i),
                resolveValues = slice.call(arguments),

                // the master Deferred
                master = jQuery.Deferred(),

                // subordinate callback factory
                updateFunc = function (i) {
                    return function (value) {
                        resolveContexts[i] = this;
                        resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
                        if (!(--remaining)) {
                            master.resolveWith(resolveContexts, resolveValues);
                        }
                    };
                };

            // Single- and empty arguments are adopted like Promise.resolve
            if (remaining <= 1) {
                adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject,
                    !remaining);

                // Use .then() to unwrap secondary thenables (cf. gh-3000)
                if (master.state() === "pending" ||
                    isFunction(resolveValues[i] && resolveValues[i].then)) {

                    return master.then();
                }
            }

            // Multiple arguments are aggregated like Promise.all array elements
            while (i--) {
                adoptValue(resolveValues[i], updateFunc(i), master.reject);
            }

            return master.promise();
        }
    });


    // These usually indicate a programmer mistake during development,
    // warn about them ASAP rather than swallowing them by default.
    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

    jQuery.Deferred.exceptionHook = function (error, stack) {

        // Support: IE 8 - 9 only
        // Console exists when dev tools are open, which can happen at any time
        if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
            window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
        }
    };


    jQuery.readyException = function (error) {
        window.setTimeout(function () {
            throw error;
        });
    };


    // The deferred used on DOM ready
    var readyList = jQuery.Deferred();

    jQuery.fn.ready = function (fn) {

        readyList
            .then(fn)

            // Wrap jQuery.readyException in a function so that the lookup
            // happens at the time of error handling instead of callback
            // registration.
            .catch(function (error) {
                jQuery.readyException(error);
            });

        return this;
    };

    jQuery.extend({

        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,

        // A counter to track how many items to wait for before
        // the ready event fires. See #6781
        readyWait: 1,

        // Handle when the DOM is ready
        ready: function (wait) {

            // Abort if there are pending holds or we're already ready
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }

            // Remember that the DOM is ready
            jQuery.isReady = true;

            // If a normal DOM Ready event fired, decrement, and wait if need be
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }

            // If there are functions bound, to execute
            readyList.resolveWith(document, [jQuery]);
        }
    });

    jQuery.ready.then = readyList.then;

    // The ready event handler and self cleanup method
    function completed() {
        document.removeEventListener("DOMContentLoaded", completed);
        window.removeEventListener("load", completed);
        jQuery.ready();
    }

    // Catch cases where $(document).ready() is called
    // after the browser event has already occurred.
    // Support: IE <=9 - 10 only
    // Older IE sometimes signals "interactive" too soon
    if (document.readyState === "complete" ||
        (document.readyState !== "loading" && !document.documentElement.doScroll)) {

        // Handle it asynchronously to allow scripts the opportunity to delay ready
        window.setTimeout(jQuery.ready);

    } else {

        // Use the handy event callback
        document.addEventListener("DOMContentLoaded", completed);

        // A fallback to window.onload, that will always work
        window.addEventListener("load", completed);
    }


    // Multifunctional method to get and set values of a collection
    // The value/s can optionally be executed if it's a function
    var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0,
            len = elems.length,
            bulk = key == null;

        // Sets many values
        if (toType(key) === "object") {
            chainable = true;
            for (i in key) {
                access(elems, fn, i, key[i], true, emptyGet, raw);
            }

            // Sets one value
        } else if (value !== undefined) {
            chainable = true;

            if (!isFunction(value)) {
                raw = true;
            }

            if (bulk) {

                // Bulk operations run against the entire set
                if (raw) {
                    fn.call(elems, value);
                    fn = null;

                    // ...except when executing function values
                } else {
                    bulk = fn;
                    fn = function (elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }

            if (fn) {
                for (; i < len; i++) {
                    fn(
                        elems[i], key, raw ?
                            value :
                            value.call(elems[i], i, fn(elems[i], key))
                    );
                }
            }
        }

        if (chainable) {
            return elems;
        }

        // Gets
        if (bulk) {
            return fn.call(elems);
        }

        return len ? fn(elems[0], key) : emptyGet;
    };


    // Matches dashed string for camelizing
    var rmsPrefix = /^-ms-/,
        rdashAlpha = /-([a-z])/g;

    // Used by camelCase as callback to replace()
    function fcamelCase(all, letter) {
        return letter.toUpperCase();
    }

    // Convert dashed to camelCase; used by the css and data modules
    // Support: IE <=9 - 11, Edge 12 - 15
    // Microsoft forgot to hump their vendor prefix (#9572)
    function camelCase(string) {
        return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    }

    var acceptData = function (owner) {

        // Accepts only:
        //  - Node
        //    - Node.ELEMENT_NODE
        //    - Node.DOCUMENT_NODE
        //  - Object
        //    - Any
        return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
    };


    function Data() {
        this.expando = jQuery.expando + Data.uid++;
    }

    Data.uid = 1;

    Data.prototype = {

        cache: function (owner) {

            // Check if the owner object already has a cache
            var value = owner[this.expando];

            // If not, create one
            if (!value) {
                value = {};

                // We can accept data for non-element nodes in modern browsers,
                // but we should not, see #8335.
                // Always return an empty object.
                if (acceptData(owner)) {

                    // If it is a node unlikely to be stringify-ed or looped over
                    // use plain assignment
                    if (owner.nodeType) {
                        owner[this.expando] = value;

                        // Otherwise secure it in a non-enumerable property
                        // configurable must be true to allow the property to be
                        // deleted when data is removed
                    } else {
                        Object.defineProperty(owner, this.expando, {
                            value: value,
                            configurable: true
                        });
                    }
                }
            }

            return value;
        },
        set: function (owner, data, value) {
            var prop,
                cache = this.cache(owner);

            // Handle: [ owner, key, value ] args
            // Always use camelCase key (gh-2257)
            if (typeof data === "string") {
                cache[camelCase(data)] = value;

                // Handle: [ owner, { properties } ] args
            } else {

                // Copy the properties one-by-one to the cache object
                for (prop in data) {
                    cache[camelCase(prop)] = data[prop];
                }
            }
            return cache;
        },
        get: function (owner, key) {
            return key === undefined ?
                this.cache(owner) :

                // Always use camelCase key (gh-2257)
                owner[this.expando] && owner[this.expando][camelCase(key)];
        },
        access: function (owner, key, value) {

            // In cases where either:
            //
            //   1. No key was specified
            //   2. A string key was specified, but no value provided
            //
            // Take the "read" path and allow the get method to determine
            // which value to return, respectively either:
            //
            //   1. The entire cache object
            //   2. The data stored at the key
            //
            if (key === undefined ||
                ((key && typeof key === "string") && value === undefined)) {

                return this.get(owner, key);
            }

            // When the key is not a string, or both a key and value
            // are specified, set or extend (existing objects) with either:
            //
            //   1. An object of properties
            //   2. A key and value
            //
            this.set(owner, key, value);

            // Since the "set" path can have two possible entry points
            // return the expected data based on which path was taken[*]
            return value !== undefined ? value : key;
        },
        remove: function (owner, key) {
            var i,
                cache = owner[this.expando];

            if (cache === undefined) {
                return;
            }

            if (key !== undefined) {

                // Support array or space separated string of keys
                if (Array.isArray(key)) {

                    // If key is an array of keys...
                    // We always set camelCase keys, so remove that.
                    key = key.map(camelCase);
                } else {
                    key = camelCase(key);

                    // If a key with the spaces exists, use it.
                    // Otherwise, create an array by matching non-whitespace
                    key = key in cache ?
                        [key] :
                        (key.match(rnothtmlwhite) || []);
                }

                i = key.length;

                while (i--) {
                    delete cache[key[i]];
                }
            }

            // Remove the expando if there's no more data
            if (key === undefined || jQuery.isEmptyObject(cache)) {

                // Support: Chrome <=35 - 45
                // Webkit & Blink performance suffers when deleting properties
                // from DOM nodes, so set to undefined instead
                // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
                if (owner.nodeType) {
                    owner[this.expando] = undefined;
                } else {
                    delete owner[this.expando];
                }
            }
        },
        hasData: function (owner) {
            var cache = owner[this.expando];
            return cache !== undefined && !jQuery.isEmptyObject(cache);
        }
    };
    var dataPriv = new Data();

    var dataUser = new Data();


    //	Implementation Summary
    //
    //	1. Enforce API surface and semantic compatibility with 1.9.x branch
    //	2. Improve the module's maintainability by reducing the storage
    //		paths to a single mechanism.
    //	3. Use the same single mechanism to support "private" and "user" data.
    //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
    //	5. Avoid exposing implementation details on user objects (eg. expando properties)
    //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        rmultiDash = /[A-Z]/g;

    function getData(data) {
        if (data === "true") {
            return true;
        }

        if (data === "false") {
            return false;
        }

        if (data === "null") {
            return null;
        }

        // Only convert to a number if it doesn't change the string
        if (data === +data + "") {
            return +data;
        }

        if (rbrace.test(data)) {
            return JSON.parse(data);
        }

        return data;
    }

    function dataAttr(elem, key, data) {
        var name;

        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if (data === undefined && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
            data = elem.getAttribute(name);

            if (typeof data === "string") {
                try {
                    data = getData(data);
                } catch (e) {
                }

                // Make sure we set the data so it isn't changed later
                dataUser.set(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }

    jQuery.extend({
        hasData: function (elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },

        data: function (elem, name, data) {
            return dataUser.access(elem, name, data);
        },

        removeData: function (elem, name) {
            dataUser.remove(elem, name);
        },

        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to dataPriv methods, these can be deprecated.
        _data: function (elem, name, data) {
            return dataPriv.access(elem, name, data);
        },

        _removeData: function (elem, name) {
            dataPriv.remove(elem, name);
        }
    });

    jQuery.fn.extend({
        data: function (key, value) {
            var i, name, data,
                elem = this[0],
                attrs = elem && elem.attributes;

            // Gets all values
            if (key === undefined) {
                if (this.length) {
                    data = dataUser.get(elem);

                    if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                        i = attrs.length;
                        while (i--) {

                            // Support: IE 11 only
                            // The attrs elements can be null (#14894)
                            if (attrs[i]) {
                                name = attrs[i].name;
                                if (name.indexOf("data-") === 0) {
                                    name = camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name]);
                                }
                            }
                        }
                        dataPriv.set(elem, "hasDataAttrs", true);
                    }
                }

                return data;
            }

            // Sets multiple values
            if (typeof key === "object") {
                return this.each(function () {
                    dataUser.set(this, key);
                });
            }

            return access(this, function (value) {
                var data;

                // The calling jQuery object (element matches) is not empty
                // (and therefore has an element appears at this[ 0 ]) and the
                // `value` parameter was not undefined. An empty jQuery object
                // will result in `undefined` for elem = this[ 0 ] which will
                // throw an exception if an attempt to read a data cache is made.
                if (elem && value === undefined) {

                    // Attempt to get data from the cache
                    // The key will always be camelCased in Data
                    data = dataUser.get(elem, key);
                    if (data !== undefined) {
                        return data;
                    }

                    // Attempt to "discover" the data in
                    // HTML5 custom data-* attrs
                    data = dataAttr(elem, key);
                    if (data !== undefined) {
                        return data;
                    }

                    // We tried really hard, but the data doesn't exist.
                    return;
                }

                // Set the data...
                this.each(function () {

                    // We always store the camelCased key
                    dataUser.set(this, key, value);
                });
            }, null, value, arguments.length > 1, null, true);
        },

        removeData: function (key) {
            return this.each(function () {
                dataUser.remove(this, key);
            });
        }
    });


    jQuery.extend({
        queue: function (elem, type, data) {
            var queue;

            if (elem) {
                type = (type || "fx") + "queue";
                queue = dataPriv.get(elem, type);

                // Speed up dequeue by getting out quickly if this is just a lookup
                if (data) {
                    if (!queue || Array.isArray(data)) {
                        queue = dataPriv.access(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },

        dequeue: function (elem, type) {
            type = type || "fx";

            var queue = jQuery.queue(elem, type),
                startLength = queue.length,
                fn = queue.shift(),
                hooks = jQuery._queueHooks(elem, type),
                next = function () {
                    jQuery.dequeue(elem, type);
                };

            // If the fx queue is dequeued, always remove the progress sentinel
            if (fn === "inprogress") {
                fn = queue.shift();
                startLength--;
            }

            if (fn) {

                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if (type === "fx") {
                    queue.unshift("inprogress");
                }

                // Clear up the last queue stop function
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }

            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },

        // Not public - generate a queueHooks object, or return the current one
        _queueHooks: function (elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function () {
                    dataPriv.remove(elem, [type + "queue", key]);
                })
            });
        }
    });

    jQuery.fn.extend({
        queue: function (type, data) {
            var setter = 2;

            if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--;
            }

            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }

            return data === undefined ?
                this :
                this.each(function () {
                    var queue = jQuery.queue(this, type, data);

                    // Ensure a hooks for this queue
                    jQuery._queueHooks(this, type);

                    if (type === "fx" && queue[0] !== "inprogress") {
                        jQuery.dequeue(this, type);
                    }
                });
        },
        dequeue: function (type) {
            return this.each(function () {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function (type) {
            return this.queue(type || "fx", []);
        },

        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function (type, obj) {
            var tmp,
                count = 1,
                defer = jQuery.Deferred(),
                elements = this,
                i = this.length,
                resolve = function () {
                    if (!(--count)) {
                        defer.resolveWith(elements, [elements]);
                    }
                };

            if (typeof type !== "string") {
                obj = type;
                type = undefined;
            }
            type = type || "fx";

            while (i--) {
                tmp = dataPriv.get(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

    var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");


    var cssExpand = ["Top", "Right", "Bottom", "Left"];

    var documentElement = document.documentElement;


    var isAttached = function (elem) {
            return jQuery.contains(elem.ownerDocument, elem);
        },
        composed = {composed: true};

    // Check attachment across shadow DOM boundaries when possible (gh-3504)
    if (documentElement.attachShadow) {
        isAttached = function (elem) {
            return jQuery.contains(elem.ownerDocument, elem) ||
                elem.getRootNode(composed) === elem.ownerDocument;
        };
    }
    var isHiddenWithinTree = function (elem, el) {

        // isHiddenWithinTree might be called from jQuery#filter function;
        // in that case, element will be second argument
        elem = el || elem;

        // Inline style trumps all
        return elem.style.display === "none" ||
            elem.style.display === "" &&

            // Otherwise, check computed style
            // Support: Firefox <=43 - 45
            // Disconnected elements can have computed display: none, so first confirm that elem is
            // in the document.
            isAttached(elem) &&

            jQuery.css(elem, "display") === "none";
    };

    var swap = function (elem, options, callback, args) {
        var ret, name,
            old = {};

        // Remember the old values, and insert the new ones
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }

        ret = callback.apply(elem, args || []);

        // Revert the old values
        for (name in options) {
            elem.style[name] = old[name];
        }

        return ret;
    };


    function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale,
            maxIterations = 20,
            currentValue = tween ?
                function () {
                    return tween.cur();
                } :
                function () {
                    return jQuery.css(elem, prop, "");
                },
            initial = currentValue(),
            unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),

            // Starting value computation is required for potential unit mismatches
            initialInUnit = elem.nodeType &&
                (jQuery.cssNumber[prop] || unit !== "px" && +initial) &&
                rcssNum.exec(jQuery.css(elem, prop));

        if (initialInUnit && initialInUnit[3] !== unit) {

            // Support: Firefox <=54
            // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
            initial = initial / 2;

            // Trust units reported by jQuery.css
            unit = unit || initialInUnit[3];

            // Iteratively approximate from a nonzero starting point
            initialInUnit = +initial || 1;

            while (maxIterations--) {

                // Evaluate and update our best guess (doubling guesses that zero out).
                // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
                jQuery.style(elem, prop, initialInUnit + unit);
                if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
                    maxIterations = 0;
                }
                initialInUnit = initialInUnit / scale;

            }

            initialInUnit = initialInUnit * 2;
            jQuery.style(elem, prop, initialInUnit + unit);

            // Make sure we update the tween properties later on
            valueParts = valueParts || [];
        }

        if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;

            // Apply relative offset (+=/-=) if specified
            adjusted = valueParts[1] ?
                initialInUnit + (valueParts[1] + 1) * valueParts[2] :
                +valueParts[2];
            if (tween) {
                tween.unit = unit;
                tween.start = initialInUnit;
                tween.end = adjusted;
            }
        }
        return adjusted;
    }


    var defaultDisplayMap = {};

    function getDefaultDisplay(elem) {
        var temp,
            doc = elem.ownerDocument,
            nodeName = elem.nodeName,
            display = defaultDisplayMap[nodeName];

        if (display) {
            return display;
        }

        temp = doc.body.appendChild(doc.createElement(nodeName));
        display = jQuery.css(temp, "display");

        temp.parentNode.removeChild(temp);

        if (display === "none") {
            display = "block";
        }
        defaultDisplayMap[nodeName] = display;

        return display;
    }

    function showHide(elements, show) {
        var display, elem,
            values = [],
            index = 0,
            length = elements.length;

        // Determine new display value for elements that need to change
        for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }

            display = elem.style.display;
            if (show) {

                // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
                // check is required in this first loop unless we have a nonempty display value (either
                // inline or about-to-be-restored)
                if (display === "none") {
                    values[index] = dataPriv.get(elem, "display") || null;
                    if (!values[index]) {
                        elem.style.display = "";
                    }
                }
                if (elem.style.display === "" && isHiddenWithinTree(elem)) {
                    values[index] = getDefaultDisplay(elem);
                }
            } else {
                if (display !== "none") {
                    values[index] = "none";

                    // Remember what we're overwriting
                    dataPriv.set(elem, "display", display);
                }
            }
        }

        // Set the display of the elements in a second loop to avoid constant reflow
        for (index = 0; index < length; index++) {
            if (values[index] != null) {
                elements[index].style.display = values[index];
            }
        }

        return elements;
    }

    jQuery.fn.extend({
        show: function () {
            return showHide(this, true);
        },
        hide: function () {
            return showHide(this);
        },
        toggle: function (state) {
            if (typeof state === "boolean") {
                return state ? this.show() : this.hide();
            }

            return this.each(function () {
                if (isHiddenWithinTree(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });
    var rcheckableType = (/^(?:checkbox|radio)$/i);

    var rtagName = (/<([a-z][^\/\0>\x20\t\r\n\f]*)/i);

    var rscriptType = (/^$|^module$|\/(?:java|ecma)script/i);


    // We have to close these tags to support XHTML (#13200)
    var wrapMap = {

        // Support: IE <=9 only
        option: [1, "<select multiple='multiple'>", "</select>"],

        // XHTML parsers do not magically insert elements in the
        // same way that tag soup parsers do. So we cannot shorten
        // this by omitting <tbody> or other required elements.
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

        _default: [0, "", ""]
    };

    // Support: IE <=9 only
    wrapMap.optgroup = wrapMap.option;

    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;


    function getAll(context, tag) {

        // Support: IE <=9 - 11 only
        // Use typeof to avoid zero-argument method invocation on host objects (#15151)
        var ret;

        if (typeof context.getElementsByTagName !== "undefined") {
            ret = context.getElementsByTagName(tag || "*");

        } else if (typeof context.querySelectorAll !== "undefined") {
            ret = context.querySelectorAll(tag || "*");

        } else {
            ret = [];
        }

        if (tag === undefined || tag && nodeName(context, tag)) {
            return jQuery.merge([context], ret);
        }

        return ret;
    }


    // Mark scripts as having already been evaluated
    function setGlobalEval(elems, refElements) {
        var i = 0,
            l = elems.length;

        for (; i < l; i++) {
            dataPriv.set(
                elems[i],
                "globalEval",
                !refElements || dataPriv.get(refElements[i], "globalEval")
            );
        }
    }


    var rhtml = /<|&#?\w+;/;

    function buildFragment(elems, context, scripts, selection, ignored) {
        var elem, tmp, tag, wrap, attached, j,
            fragment = context.createDocumentFragment(),
            nodes = [],
            i = 0,
            l = elems.length;

        for (; i < l; i++) {
            elem = elems[i];

            if (elem || elem === 0) {

                // Add nodes directly
                if (toType(elem) === "object") {

                    // Support: Android <=4.0 only, PhantomJS 1 only
                    // push.apply(_, arraylike) throws on ancient WebKit
                    jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

                    // Convert non-html into a text node
                } else if (!rhtml.test(elem)) {
                    nodes.push(context.createTextNode(elem));

                    // Convert html into DOM nodes
                } else {
                    tmp = tmp || fragment.appendChild(context.createElement("div"));

                    // Deserialize a standard representation
                    tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                    wrap = wrapMap[tag] || wrapMap._default;
                    tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];

                    // Descend through wrappers to the right content
                    j = wrap[0];
                    while (j--) {
                        tmp = tmp.lastChild;
                    }

                    // Support: Android <=4.0 only, PhantomJS 1 only
                    // push.apply(_, arraylike) throws on ancient WebKit
                    jQuery.merge(nodes, tmp.childNodes);

                    // Remember the top-level container
                    tmp = fragment.firstChild;

                    // Ensure the created nodes are orphaned (#12392)
                    tmp.textContent = "";
                }
            }
        }

        // Remove wrapper from fragment
        fragment.textContent = "";

        i = 0;
        while ((elem = nodes[i++])) {

            // Skip elements already in the context collection (trac-4087)
            if (selection && jQuery.inArray(elem, selection) > -1) {
                if (ignored) {
                    ignored.push(elem);
                }
                continue;
            }

            attached = isAttached(elem);

            // Append to fragment
            tmp = getAll(fragment.appendChild(elem), "script");

            // Preserve script evaluation history
            if (attached) {
                setGlobalEval(tmp);
            }

            // Capture executables
            if (scripts) {
                j = 0;
                while ((elem = tmp[j++])) {
                    if (rscriptType.test(elem.type || "")) {
                        scripts.push(elem);
                    }
                }
            }
        }

        return fragment;
    }


    (function () {
        var fragment = document.createDocumentFragment(),
            div = fragment.appendChild(document.createElement("div")),
            input = document.createElement("input");

        // Support: Android 4.0 - 4.3 only
        // Check state lost if the name is set (#11217)
        // Support: Windows Web Apps (WWA)
        // `name` and `type` must use .setAttribute for WWA (#14901)
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");

        div.appendChild(input);

        // Support: Android <=4.1 only
        // Older WebKit doesn't clone checked state correctly in fragments
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

        // Support: IE <=11 only
        // Make sure textarea (and checkbox) defaultValue is properly cloned
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
    })();


    var
        rkeyEvent = /^key/,
        rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
        rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

    function returnTrue() {
        return true;
    }

    function returnFalse() {
        return false;
    }

    // Support: IE <=9 - 11+
    // focus() and blur() are asynchronous, except when they are no-op.
    // So expect focus to be synchronous when the element is already active,
    // and blur to be synchronous when the element is not already active.
    // (focus and blur are always synchronous in other supported browsers,
    // this just defines when we can count on it).
    function expectSync(elem, type) {
        return (elem === safeActiveElement()) === (type === "focus");
    }

    // Support: IE <=9 only
    // Accessing document.activeElement can throw unexpectedly
    // https://bugs.jquery.com/ticket/13393
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {
        }
    }

    function on(elem, types, selector, data, fn, one) {
        var origFn, type;

        // Types can be a map of types/handlers
        if (typeof types === "object") {

            // ( types-Object, selector, data )
            if (typeof selector !== "string") {

                // ( types-Object, data )
                data = data || selector;
                selector = undefined;
            }
            for (type in types) {
                on(elem, type, selector, data, types[type], one);
            }
            return elem;
        }

        if (data == null && fn == null) {

            // ( types, fn )
            fn = selector;
            data = selector = undefined;
        } else if (fn == null) {
            if (typeof selector === "string") {

                // ( types, selector, fn )
                fn = data;
                data = undefined;
            } else {

                // ( types, data, fn )
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if (fn === false) {
            fn = returnFalse;
        } else if (!fn) {
            return elem;
        }

        if (one === 1) {
            origFn = fn;
            fn = function (event) {

                // Can use an empty set, since event contains the info
                jQuery().off(event);
                return origFn.apply(this, arguments);
            };

            // Use same guid so caller can remove using origFn
            fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
        }
        return elem.each(function () {
            jQuery.event.add(this, types, fn, data, selector);
        });
    }

    /*
    * Helper functions for managing events -- not part of the public interface.
    * Props to Dean Edwards' addEvent library for many of the ideas.
    */
    jQuery.event = {

        global: {},

        add: function (elem, types, handler, data, selector) {

            var handleObjIn, eventHandle, tmp,
                events, t, handleObj,
                special, handlers, type, namespaces, origType,
                elemData = dataPriv.get(elem);

            // Don't attach events to noData or text/comment nodes (but allow plain objects)
            if (!elemData) {
                return;
            }

            // Caller can pass in an object of custom data in lieu of the handler
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }

            // Ensure that invalid selectors throw exceptions at attach time
            // Evaluate against documentElement in case elem is a non-element node (e.g., document)
            if (selector) {
                jQuery.find.matchesSelector(documentElement, selector);
            }

            // Make sure that the handler has a unique ID, used to find/remove it later
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }

            // Init the element's event structure and main handler, if this is the first
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function (e) {

                    // Discard the second event of a jQuery.event.trigger() and
                    // when an event is called after a page has unloaded
                    return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
                        jQuery.event.dispatch.apply(elem, arguments) : undefined;
                };
            }

            // Handle multiple events separated by a space
            types = (types || "").match(rnothtmlwhite) || [""];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();

                // There *must* be a type, no attaching namespace-only handlers
                if (!type) {
                    continue;
                }

                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[type] || {};

                // If selector defined, determine special event api type, otherwise given type
                type = (selector ? special.delegateType : special.bindType) || type;

                // Update special based on newly reset type
                special = jQuery.event.special[type] || {};

                // handleObj is passed to all event handlers
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn);

                // Init the event handler queue if we're the first
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;

                    // Only use addEventListener if the special events handler returns false
                    if (!special.setup ||
                        special.setup.call(elem, data, namespaces, eventHandle) === false) {

                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle);
                        }
                    }
                }

                if (special.add) {
                    special.add.call(elem, handleObj);

                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }

                // Add to the element's handler list, delegates in front
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }

                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[type] = true;
            }

        },

        // Detach an event or set of events from an element
        remove: function (elem, types, handler, selector, mappedTypes) {

            var j, origCount, tmp,
                events, t, handleObj,
                special, handlers, type, namespaces, origType,
                elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

            if (!elemData || !(events = elemData.events)) {
                return;
            }

            // Once for each type.namespace in types; type may be omitted
            types = (types || "").match(rnothtmlwhite) || [""];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();

                // Unbind all events (on this namespace, if provided) for the element
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }

                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] &&
                    new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

                // Remove matching events
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];

                    if ((mappedTypes || origType === handleObj.origType) &&
                        (!handler || handler.guid === handleObj.guid) &&
                        (!tmp || tmp.test(handleObj.namespace)) &&
                        (!selector || selector === handleObj.selector ||
                            selector === "**" && handleObj.selector)) {
                        handlers.splice(j, 1);

                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }

                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if (origCount && !handlers.length) {
                    if (!special.teardown ||
                        special.teardown.call(elem, namespaces, elemData.handle) === false) {

                        jQuery.removeEvent(elem, type, elemData.handle);
                    }

                    delete events[type];
                }
            }

            // Remove data and the expando if it's no longer used
            if (jQuery.isEmptyObject(events)) {
                dataPriv.remove(elem, "handle events");
            }
        },

        dispatch: function (nativeEvent) {

            // Make a writable jQuery.Event from the native event object
            var event = jQuery.event.fix(nativeEvent);

            var i, j, ret, matched, handleObj, handlerQueue,
                args = new Array(arguments.length),
                handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
                special = jQuery.event.special[event.type] || {};

            // Use the fix-ed jQuery.Event rather than the (read-only) native event
            args[0] = event;

            for (i = 1; i < arguments.length; i++) {
                args[i] = arguments[i];
            }

            event.delegateTarget = this;

            // Call the preDispatch hook for the mapped type, and let it bail if desired
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }

            // Determine handlers
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);

            // Run delegates first; they may want to stop propagation beneath us
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;

                j = 0;
                while ((handleObj = matched.handlers[j++]) &&
                !event.isImmediatePropagationStopped()) {

                    // If the event is namespaced, then each handler is only invoked if it is
                    // specially universal or its namespaces are a superset of the event's.
                    if (!event.rnamespace || handleObj.namespace === false ||
                        event.rnamespace.test(handleObj.namespace)) {

                        event.handleObj = handleObj;
                        event.data = handleObj.data;

                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle ||
                            handleObj.handler).apply(matched.elem, args);

                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }

            // Call the postDispatch hook for the mapped type
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }

            return event.result;
        },

        handlers: function (event, handlers) {
            var i, handleObj, sel, matchedHandlers, matchedSelectors,
                handlerQueue = [],
                delegateCount = handlers.delegateCount,
                cur = event.target;

            // Find delegate handlers
            if (delegateCount &&

                // Support: IE <=9
                // Black-hole SVG <use> instance trees (trac-13180)
                cur.nodeType &&

                // Support: Firefox <=42
                // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
                // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
                // Support: IE 11 only
                // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
                !(event.type === "click" && event.button >= 1)) {

                for (; cur !== this; cur = cur.parentNode || this) {

                    // Don't check non-elements (#13208)
                    // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                    if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                        matchedHandlers = [];
                        matchedSelectors = {};
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];

                            // Don't conflict with Object.prototype properties (#13203)
                            sel = handleObj.selector + " ";

                            if (matchedSelectors[sel] === undefined) {
                                matchedSelectors[sel] = handleObj.needsContext ?
                                    jQuery(sel, this).index(cur) > -1 :
                                    jQuery.find(sel, this, null, [cur]).length;
                            }
                            if (matchedSelectors[sel]) {
                                matchedHandlers.push(handleObj);
                            }
                        }
                        if (matchedHandlers.length) {
                            handlerQueue.push({elem: cur, handlers: matchedHandlers});
                        }
                    }
                }
            }

            // Add the remaining (directly-bound) handlers
            cur = this;
            if (delegateCount < handlers.length) {
                handlerQueue.push({elem: cur, handlers: handlers.slice(delegateCount)});
            }

            return handlerQueue;
        },

        addProp: function (name, hook) {
            Object.defineProperty(jQuery.Event.prototype, name, {
                enumerable: true,
                configurable: true,

                get: isFunction(hook) ?
                    function () {
                        if (this.originalEvent) {
                            return hook(this.originalEvent);
                        }
                    } :
                    function () {
                        if (this.originalEvent) {
                            return this.originalEvent[name];
                        }
                    },

                set: function (value) {
                    Object.defineProperty(this, name, {
                        enumerable: true,
                        configurable: true,
                        writable: true,
                        value: value
                    });
                }
            });
        },

        fix: function (originalEvent) {
            return originalEvent[jQuery.expando] ?
                originalEvent :
                new jQuery.Event(originalEvent);
        },

        special: {
            load: {

                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
            },
            click: {

                // Utilize native event to ensure correct state for checkable inputs
                setup: function (data) {

                    // For mutual compressibility with _default, replace `this` access with a local var.
                    // `|| data` is dead code meant only to preserve the variable through minification.
                    var el = this || data;

                    // Claim the first handler
                    if (rcheckableType.test(el.type) &&
                        el.click && nodeName(el, "input") &&
                        dataPriv.get(el, "click") === undefined) {

                        // dataPriv.set( el, "click", ... )
                        leverageNative(el, "click", returnTrue);
                    }

                    // Return false to allow normal processing in the caller
                    return false;
                },
                trigger: function (data) {

                    // For mutual compressibility with _default, replace `this` access with a local var.
                    // `|| data` is dead code meant only to preserve the variable through minification.
                    var el = this || data;

                    // Force setup before triggering a click
                    if (rcheckableType.test(el.type) &&
                        el.click && nodeName(el, "input") &&
                        dataPriv.get(el, "click") === undefined) {

                        leverageNative(el, "click");
                    }

                    // Return non-false to allow normal event-path propagation
                    return true;
                },

                // For cross-browser consistency, suppress native .click() on links
                // Also prevent it if we're currently inside a leveraged native-event stack
                _default: function (event) {
                    var target = event.target;
                    return rcheckableType.test(target.type) &&
                        target.click && nodeName(target, "input") &&
                        dataPriv.get(target, "click") ||
                        nodeName(target, "a");
                }
            },

            beforeunload: {
                postDispatch: function (event) {

                    // Support: Firefox 20+
                    // Firefox doesn't alert if the returnValue field is not set.
                    if (event.result !== undefined && event.originalEvent) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        }
    };

    // Ensure the presence of an event listener that handles manually-triggered
    // synthetic events by interrupting progress until reinvoked in response to
    // *native* events that it fires directly, ensuring that state changes have
    // already occurred before other listeners are invoked.
    function leverageNative(el, type, expectSync) {

        // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
        if (!expectSync) {
            jQuery.event.add(el, type, returnTrue);
            return;
        }

        // Register the controller as a special universal handler for all event namespaces
        dataPriv.set(el, type, false);
        jQuery.event.add(el, type, {
            namespace: false,
            handler: function (event) {
                var notAsync, result,
                    saved = dataPriv.get(this, type);

                if ((event.isTrigger & 1) && this[type]) {

                    // Interrupt processing of the outer synthetic .trigger()ed event
                    if (!saved) {

                        // Store arguments for use when handling the inner native event
                        saved = slice.call(arguments);
                        dataPriv.set(this, type, saved);

                        // Trigger the native event and capture its result
                        // Support: IE <=9 - 11+
                        // focus() and blur() are asynchronous
                        notAsync = expectSync(this, type);
                        this[type]();
                        result = dataPriv.get(this, type);
                        if (saved !== result || notAsync) {
                            dataPriv.set(this, type, false);
                        } else {
                            result = undefined;
                        }
                        if (saved !== result) {

                            // Cancel the outer synthetic event
                            event.stopImmediatePropagation();
                            event.preventDefault();
                            return result;
                        }

                        // If this is an inner synthetic event for an event with a bubbling surrogate
                        // (focus or blur), assume that the surrogate already propagated from triggering the
                        // native event and prevent that from happening again here.
                        // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
                        // bubbling surrogate propagates *after* the non-bubbling base), but that seems
                        // less bad than duplication.
                    } else if ((jQuery.event.special[type] || {}).delegateType) {
                        event.stopPropagation();
                    }

                    // If this is a native event triggered above, everything is now in order
                    // Fire an inner synthetic event with the original arguments
                } else if (saved) {

                    // ...and capture the result
                    dataPriv.set(this, type, jQuery.event.trigger(
                        // Support: IE <=9 - 11+
                        // Extend with the prototype to reset the above stopImmediatePropagation()
                        jQuery.extend(saved.shift(), jQuery.Event.prototype),
                        saved,
                        this
                    ));

                    // Abort handling of the native event
                    event.stopImmediatePropagation();
                }
            }
        });
    }

    jQuery.removeEvent = function (elem, type, handle) {

        // This "if" is needed for plain objects
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle);
        }
    };

    jQuery.Event = function (src, props) {

        // Allow instantiation without the 'new' keyword
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }

        // Event object
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;

            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = src.defaultPrevented ||
            src.defaultPrevented === undefined &&

            // Support: Android <=2.3 only
            src.returnValue === false ?
                returnTrue :
                returnFalse;

            // Create target properties
            // Support: Safari <=6 - 7 only
            // Target should not be a text node (#504, #13143)
            this.target = (src.target && src.target.nodeType === 3) ?
                src.target.parentNode :
                src.target;

            this.currentTarget = src.currentTarget;
            this.relatedTarget = src.relatedTarget;

            // Event type
        } else {
            this.type = src;
        }

        // Put explicitly provided properties onto the event object
        if (props) {
            jQuery.extend(this, props);
        }

        // Create a timestamp if incoming event doesn't have one
        this.timeStamp = src && src.timeStamp || Date.now();

        // Mark it as fixed
        this[jQuery.expando] = true;
    };

    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,

        preventDefault: function () {
            var e = this.originalEvent;

            this.isDefaultPrevented = returnTrue;

            if (e && !this.isSimulated) {
                e.preventDefault();
            }
        },
        stopPropagation: function () {
            var e = this.originalEvent;

            this.isPropagationStopped = returnTrue;

            if (e && !this.isSimulated) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function () {
            var e = this.originalEvent;

            this.isImmediatePropagationStopped = returnTrue;

            if (e && !this.isSimulated) {
                e.stopImmediatePropagation();
            }

            this.stopPropagation();
        }
    };

    // Includes all common event props including KeyEvent and MouseEvent specific props
    jQuery.each({
        altKey: true,
        bubbles: true,
        cancelable: true,
        changedTouches: true,
        ctrlKey: true,
        detail: true,
        eventPhase: true,
        metaKey: true,
        pageX: true,
        pageY: true,
        shiftKey: true,
        view: true,
        "char": true,
        code: true,
        charCode: true,
        key: true,
        keyCode: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pointerId: true,
        pointerType: true,
        screenX: true,
        screenY: true,
        targetTouches: true,
        toElement: true,
        touches: true,

        which: function (event) {
            var button = event.button;

            // Add which for key events
            if (event.which == null && rkeyEvent.test(event.type)) {
                return event.charCode != null ? event.charCode : event.keyCode;
            }

            // Add which for click: 1 === left; 2 === middle; 3 === right
            if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
                if (button & 1) {
                    return 1;
                }

                if (button & 2) {
                    return 3;
                }

                if (button & 4) {
                    return 2;
                }

                return 0;
            }

            return event.which;
        }
    }, jQuery.event.addProp);

    jQuery.each({focus: "focusin", blur: "focusout"}, function (type, delegateType) {
        jQuery.event.special[type] = {

            // Utilize native event if possible so blur/focus sequence is correct
            setup: function () {

                // Claim the first handler
                // dataPriv.set( this, "focus", ... )
                // dataPriv.set( this, "blur", ... )
                leverageNative(this, type, expectSync);

                // Return false to allow normal processing in the caller
                return false;
            },
            trigger: function () {

                // Force setup before trigger
                leverageNative(this, type);

                // Return non-false to allow normal event-path propagation
                return true;
            },

            delegateType: delegateType
        };
    });

    // Create mouseenter/leave events using mouseover/out and event-time checks
    // so that event delegation works in jQuery.
    // Do the same for pointerenter/pointerleave and pointerover/pointerout
    //
    // Support: Safari 7 only
    // Safari sends mouseenter too often; see:
    // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
    // for the description of the bug (it existed in older Chrome versions as well).
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function (orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,

            handle: function (event) {
                var ret,
                    target = this,
                    related = event.relatedTarget,
                    handleObj = event.handleObj;

                // For mouseenter/leave call the handler if related is outside the target.
                // NB: No relatedTarget if the mouse left/entered the browser window
                if (!related || (related !== target && !jQuery.contains(target, related))) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });

    jQuery.fn.extend({

        on: function (types, selector, data, fn) {
            return on(this, types, selector, data, fn);
        },
        one: function (types, selector, data, fn) {
            return on(this, types, selector, data, fn, 1);
        },
        off: function (types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {

                // ( event )  dispatched jQuery.Event
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(
                    handleObj.namespace ?
                        handleObj.origType + "." + handleObj.namespace :
                        handleObj.origType,
                    handleObj.selector,
                    handleObj.handler
                );
                return this;
            }
            if (typeof types === "object") {

                // ( types-object [, selector] )
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === "function") {

                // ( types [, fn] )
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function () {
                jQuery.event.remove(this, types, fn, selector);
            });
        }
    });


    var

        /* eslint-disable max-len */

        // See https://github.com/eslint/eslint/issues/3229
        rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

        /* eslint-enable */

        // Support: IE <=10 - 11, Edge 12 - 13 only
        // In IE/Edge using regex groups here causes severe slowdowns.
        // See https://connect.microsoft.com/IE/feedback/details/1736512/
        rnoInnerhtml = /<script|<style|<link/i,

        // checked="checked" or checked
        rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

    // Prefer a tbody over its parent table for containing new rows
    function manipulationTarget(elem, content) {
        if (nodeName(elem, "table") &&
            nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {

            return jQuery(elem).children("tbody")[0] || elem;
        }

        return elem;
    }

    // Replace/restore the type attribute of script elements for safe DOM manipulation
    function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
    }

    function restoreScript(elem) {
        if ((elem.type || "").slice(0, 5) === "true/") {
            elem.type = elem.type.slice(5);
        } else {
            elem.removeAttribute("type");
        }

        return elem;
    }

    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

        if (dest.nodeType !== 1) {
            return;
        }

        // 1. Copy private data: events, handlers, etc.
        if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.access(src);
            pdataCur = dataPriv.set(dest, pdataOld);
            events = pdataOld.events;

            if (events) {
                delete pdataCur.handle;
                pdataCur.events = {};

                for (type in events) {
                    for (i = 0, l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type, events[type][i]);
                    }
                }
            }
        }

        // 2. Copy user data
        if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery.extend({}, udataOld);

            dataUser.set(dest, udataCur);
        }
    }

    // Fix IE bugs, see support tests
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();

        // Fails to persist the checked state of a cloned checkbox or radio button.
        if (nodeName === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;

            // Fails to return the selected option to the default selected state when cloning options
        } else if (nodeName === "input" || nodeName === "textarea") {
            dest.defaultValue = src.defaultValue;
        }
    }

    function domManip(collection, args, callback, ignored) {

        // Flatten any nested arrays
        args = concat.apply([], args);

        var fragment, first, scripts, hasScripts, node, doc,
            i = 0,
            l = collection.length,
            iNoClone = l - 1,
            value = args[0],
            valueIsFunction = isFunction(value);

        // We can't cloneNode fragments that contain checked, in WebKit
        if (valueIsFunction ||
            (l > 1 && typeof value === "string" &&
                !support.checkClone && rchecked.test(value))) {
            return collection.each(function (index) {
                var self = collection.eq(index);
                if (valueIsFunction) {
                    args[0] = value.call(this, index, self.html());
                }
                domManip(self, args, callback, ignored);
            });
        }

        if (l) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;

            if (fragment.childNodes.length === 1) {
                fragment = first;
            }

            // Require either new content or an interest in ignored elements to invoke the callback
            if (first || ignored) {
                scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                hasScripts = scripts.length;

                // Use the original fragment for the last item
                // instead of the first because it can end up
                // being emptied incorrectly in certain situations (#8070).
                for (; i < l; i++) {
                    node = fragment;

                    if (i !== iNoClone) {
                        node = jQuery.clone(node, true, true);

                        // Keep references to cloned scripts for later restoration
                        if (hasScripts) {

                            // Support: Android <=4.0 only, PhantomJS 1 only
                            // push.apply(_, arraylike) throws on ancient WebKit
                            jQuery.merge(scripts, getAll(node, "script"));
                        }
                    }

                    callback.call(collection[i], node, i);
                }

                if (hasScripts) {
                    doc = scripts[scripts.length - 1].ownerDocument;

                    // Reenable scripts
                    jQuery.map(scripts, restoreScript);

                    // Evaluate executable scripts on first document insertion
                    for (i = 0; i < hasScripts; i++) {
                        node = scripts[i];
                        if (rscriptType.test(node.type || "") &&
                            !dataPriv.access(node, "globalEval") &&
                            jQuery.contains(doc, node)) {

                            if (node.src && (node.type || "").toLowerCase() !== "module") {

                                // Optional AJAX dependency, but won't run scripts if not present
                                if (jQuery._evalUrl && !node.noModule) {
                                    jQuery._evalUrl(node.src, {
                                        nonce: node.nonce || node.getAttribute("nonce")
                                    });
                                }
                            } else {
                                DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                            }
                        }
                    }
                }
            }
        }

        return collection;
    }

    function remove(elem, selector, keepData) {
        var node,
            nodes = selector ? jQuery.filter(selector, elem) : elem,
            i = 0;

        for (; (node = nodes[i]) != null; i++) {
            if (!keepData && node.nodeType === 1) {
                jQuery.cleanData(getAll(node));
            }

            if (node.parentNode) {
                if (keepData && isAttached(node)) {
                    setGlobalEval(getAll(node, "script"));
                }
                node.parentNode.removeChild(node);
            }
        }

        return elem;
    }

    jQuery.extend({
        htmlPrefilter: function (html) {
            return html.replace(rxhtmlTag, "<$1></$2>");
        },

        clone: function (elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements,
                clone = elem.cloneNode(true),
                inPage = isAttached(elem);

            // Fix IE cloning issues
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) &&
                !jQuery.isXMLDoc(elem)) {

                // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
                destElements = getAll(clone);
                srcElements = getAll(elem);

                for (i = 0, l = srcElements.length; i < l; i++) {
                    fixInput(srcElements[i], destElements[i]);
                }
            }

            // Copy the events from the original to the clone
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);

                    for (i = 0, l = srcElements.length; i < l; i++) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }

            // Preserve script evaluation history
            destElements = getAll(clone, "script");
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }

            // Return the cloned set
            return clone;
        },

        cleanData: function (elems) {
            var data, elem, type,
                special = jQuery.event.special,
                i = 0;

            for (; (elem = elems[i]) !== undefined; i++) {
                if (acceptData(elem)) {
                    if ((data = elem[dataPriv.expando])) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);

                                    // This is a shortcut to avoid jQuery.event.remove's overhead
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }

                        // Support: Chrome <=35 - 45+
                        // Assign undefined instead of using delete, see Data#remove
                        elem[dataPriv.expando] = undefined;
                    }
                    if (elem[dataUser.expando]) {

                        // Support: Chrome <=35 - 45+
                        // Assign undefined instead of using delete, see Data#remove
                        elem[dataUser.expando] = undefined;
                    }
                }
            }
        }
    });

    jQuery.fn.extend({
        detach: function (selector) {
            return remove(this, selector, true);
        },

        remove: function (selector) {
            return remove(this, selector);
        },

        text: function (value) {
            return access(this, function (value) {
                return value === undefined ?
                    jQuery.text(this) :
                    this.empty().each(function () {
                        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                            this.textContent = value;
                        }
                    });
            }, null, value, arguments.length);
        },

        append: function () {
            return domManip(this, arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },

        prepend: function () {
            return domManip(this, arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },

        before: function () {
            return domManip(this, arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },

        after: function () {
            return domManip(this, arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },

        empty: function () {
            var elem,
                i = 0;

            for (; (elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {

                    // Prevent memory leaks
                    jQuery.cleanData(getAll(elem, false));

                    // Remove any remaining nodes
                    elem.textContent = "";
                }
            }

            return this;
        },

        clone: function (dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

            return this.map(function () {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },

        html: function (value) {
            return access(this, function (value) {
                var elem = this[0] || {},
                    i = 0,
                    l = this.length;

                if (value === undefined && elem.nodeType === 1) {
                    return elem.innerHTML;
                }

                // See if we can take a shortcut and just use innerHTML
                if (typeof value === "string" && !rnoInnerhtml.test(value) &&
                    !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

                    value = jQuery.htmlPrefilter(value);

                    try {
                        for (; i < l; i++) {
                            elem = this[i] || {};

                            // Remove element nodes and prevent memory leaks
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }

                        elem = 0;

                        // If using innerHTML throws an exception, use the fallback method
                    } catch (e) {
                    }
                }

                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },

        replaceWith: function () {
            var ignored = [];

            // Make the changes, replacing each non-ignored context element with the new content
            return domManip(this, arguments, function (elem) {
                var parent = this.parentNode;

                if (jQuery.inArray(this, ignored) < 0) {
                    jQuery.cleanData(getAll(this));
                    if (parent) {
                        parent.replaceChild(elem, this);
                    }
                }

                // Force callback invocation
            }, ignored);
        }
    });

    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function (name, original) {
        jQuery.fn[name] = function (selector) {
            var elems,
                ret = [],
                insert = jQuery(selector),
                last = insert.length - 1,
                i = 0;

            for (; i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);

                // Support: Android <=4.0 only, PhantomJS 1 only
                // .get() because push.apply(_, arraylike) throws on ancient WebKit
                push.apply(ret, elems.get());
            }

            return this.pushStack(ret);
        };
    });
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

    var getStyles = function (elem) {

        // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
        // IE throws on elements created in popups
        // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
        var view = elem.ownerDocument.defaultView;

        if (!view || !view.opener) {
            view = window;
        }

        return view.getComputedStyle(elem);
    };

    var rboxStyle = new RegExp(cssExpand.join("|"), "i");


    (function () {

        // Executing both pixelPosition & boxSizingReliable tests require only one layout
        // so they're executed at the same time to save the second computation.
        function computeStyleTests() {

            // This is a singleton, we need to execute it only once
            if (!div) {
                return;
            }

            container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
                "margin-top:1px;padding:0;border:0";
            div.style.cssText =
                "position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
                "margin:auto;border:1px;padding:1px;" +
                "width:60%;top:1%";
            documentElement.appendChild(container).appendChild(div);

            var divStyle = window.getComputedStyle(div);
            pixelPositionVal = divStyle.top !== "1%";

            // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
            reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;

            // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
            // Some styles come back with percentage values, even though they shouldn't
            div.style.right = "60%";
            pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;

            // Support: IE 9 - 11 only
            // Detect misreporting of content dimensions for box-sizing:border-box elements
            boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;

            // Support: IE 9 only
            // Detect overflow:scroll screwiness (gh-3699)
            // Support: Chrome <=64
            // Don't get tricked when zoom affects offsetWidth (gh-4029)
            div.style.position = "absolute";
            scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;

            documentElement.removeChild(container);

            // Nullify the div so it wouldn't be stored in the memory and
            // it will also be a sign that checks already performed
            div = null;
        }

        function roundPixelMeasures(measure) {
            return Math.round(parseFloat(measure));
        }

        var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
            reliableMarginLeftVal,
            container = document.createElement("div"),
            div = document.createElement("div");

        // Finish early in limited (non-browser) environments
        if (!div.style) {
            return;
        }

        // Support: IE <=9 - 11 only
        // Style of cloned element affects source element cloned (#8908)
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";

        jQuery.extend(support, {
            boxSizingReliable: function () {
                computeStyleTests();
                return boxSizingReliableVal;
            },
            pixelBoxStyles: function () {
                computeStyleTests();
                return pixelBoxStylesVal;
            },
            pixelPosition: function () {
                computeStyleTests();
                return pixelPositionVal;
            },
            reliableMarginLeft: function () {
                computeStyleTests();
                return reliableMarginLeftVal;
            },
            scrollboxSize: function () {
                computeStyleTests();
                return scrollboxSizeVal;
            }
        });
    })();


    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret,

            // Support: Firefox 51+
            // Retrieving style before computed somehow
            // fixes an issue with getting wrong values
            // on detached elements
            style = elem.style;

        computed = computed || getStyles(elem);

        // getPropertyValue is needed for:
        //   .css('filter') (IE 9 only, #12537)
        //   .css('--customProperty) (#3144)
        if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];

            if (ret === "" && !isAttached(elem)) {
                ret = jQuery.style(elem, name);
            }

            // A tribute to the "awesome hack by Dean Edwards"
            // Android Browser returns percentage for some values,
            // but width seems to be reliably pixels.
            // This is against the CSSOM draft spec:
            // https://drafts.csswg.org/cssom/#resolved-values
            if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {

                // Remember the original values
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;

                // Put in the new values to get a computed value out
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;

                // Revert the changed values
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }

        return ret !== undefined ?

            // Support: IE <=9 - 11 only
            // IE returns zIndex value as an integer.
            ret + "" :
            ret;
    }


    function addGetHookIf(conditionFn, hookFn) {

        // Define the hook, we'll check on the first run if it's really needed.
        return {
            get: function () {
                if (conditionFn()) {

                    // Hook not needed (or it's not possible to use it due
                    // to missing dependency), remove it.
                    delete this.get;
                    return;
                }

                // Hook needed; redefine it so that the support test is not executed again.
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }


    var cssPrefixes = ["Webkit", "Moz", "ms"],
        emptyStyle = document.createElement("div").style,
        vendorProps = {};

    // Return a vendor-prefixed property or undefined
    function vendorPropName(name) {

        // Check for vendor prefixed names
        var capName = name[0].toUpperCase() + name.slice(1),
            i = cssPrefixes.length;

        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in emptyStyle) {
                return name;
            }
        }
    }

    // Return a potentially-mapped jQuery.cssProps or vendor prefixed property
    function finalPropName(name) {
        var final = jQuery.cssProps[name] || vendorProps[name];

        if (final) {
            return final;
        }
        if (name in emptyStyle) {
            return name;
        }
        return vendorProps[name] = vendorPropName(name) || name;
    }


    var

        // Swappable if display is none or starts with table
        // except "table", "table-cell", or "table-caption"
        // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
        rdisplayswap = /^(none|table(?!-c[ea]).+)/,
        rcustomProp = /^--/,
        cssShow = {position: "absolute", visibility: "hidden", display: "block"},
        cssNormalTransform = {
            letterSpacing: "0",
            fontWeight: "400"
        };

    function setPositiveNumber(elem, value, subtract) {

        // Any relative (+/-) values have already been
        // normalized at this point
        var matches = rcssNum.exec(value);
        return matches ?

            // Guard against undefined "subtract", e.g., when used as in cssHooks
            Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") :
            value;
    }

    function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
        var i = dimension === "width" ? 1 : 0,
            extra = 0,
            delta = 0;

        // Adjustment may not be necessary
        if (box === (isBorderBox ? "border" : "content")) {
            return 0;
        }

        for (; i < 4; i += 2) {

            // Both box models exclude margin
            if (box === "margin") {
                delta += jQuery.css(elem, box + cssExpand[i], true, styles);
            }

            // If we get here with a content-box, we're seeking "padding" or "border" or "margin"
            if (!isBorderBox) {

                // Add padding
                delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

                // For "border" or "margin", add border
                if (box !== "padding") {
                    delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);

                    // But still keep track of it otherwise
                } else {
                    extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }

                // If we get here with a border-box (content + padding + border), we're seeking "content" or
                // "padding" or "margin"
            } else {

                // For "content", subtract padding
                if (box === "content") {
                    delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                }

                // For "content" or "padding", subtract border
                if (box !== "margin") {
                    delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            }
        }

        // Account for positive content-box scroll gutter when requested by providing computedVal
        if (!isBorderBox && computedVal >= 0) {

            // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
            // Assuming integer scroll gutter, subtract the rest and round down
            delta += Math.max(0, Math.ceil(
                elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] -
                computedVal -
                delta -
                extra -
                0.5

                // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
                // Use an explicit zero to avoid NaN (gh-3964)
            )) || 0;
        }

        return delta;
    }

    function getWidthOrHeight(elem, dimension, extra) {

        // Start with computed style
        var styles = getStyles(elem),

            // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
            // Fake content-box until we know it's needed to know the true value.
            boxSizingNeeded = !support.boxSizingReliable() || extra,
            isBorderBox = boxSizingNeeded &&
                jQuery.css(elem, "boxSizing", false, styles) === "border-box",
            valueIsBorderBox = isBorderBox,

            val = curCSS(elem, dimension, styles),
            offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);

        // Support: Firefox <=54
        // Return a confounding non-pixel value or feign ignorance, as appropriate.
        if (rnumnonpx.test(val)) {
            if (!extra) {
                return val;
            }
            val = "auto";
        }


        // Fall back to offsetWidth/offsetHeight when value is "auto"
        // This happens for inline elements with no explicit setting (gh-3571)
        // Support: Android <=4.1 - 4.3 only
        // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
        // Support: IE 9-11 only
        // Also use offsetWidth/offsetHeight for when box sizing is unreliable
        // We use getClientRects() to check for hidden/disconnected.
        // In those cases, the computed value can be trusted to be border-box
        if ((!support.boxSizingReliable() && isBorderBox ||
            val === "auto" ||
            !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") &&
            elem.getClientRects().length) {

            isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";

            // Where available, offsetWidth/offsetHeight approximate border box dimensions.
            // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
            // retrieved value as a content box dimension.
            valueIsBorderBox = offsetProp in elem;
            if (valueIsBorderBox) {
                val = elem[offsetProp];
            }
        }

        // Normalize "" and auto
        val = parseFloat(val) || 0;

        // Adjust for the element's box model
        return (val +
            boxModelAdjustment(
                elem,
                dimension,
                extra || (isBorderBox ? "border" : "content"),
                valueIsBorderBox,
                styles,

                // Provide the current computed size to request scroll gutter calculation (gh-3589)
                val
            )
        ) + "px";
    }

    jQuery.extend({

        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function (elem, computed) {
                    if (computed) {

                        // We should always get a number back from opacity
                        var ret = curCSS(elem, "opacity");
                        return ret === "" ? "1" : ret;
                    }
                }
            }
        },

        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
            "animationIterationCount": true,
            "columnCount": true,
            "fillOpacity": true,
            "flexGrow": true,
            "flexShrink": true,
            "fontWeight": true,
            "gridArea": true,
            "gridColumn": true,
            "gridColumnEnd": true,
            "gridColumnStart": true,
            "gridRow": true,
            "gridRowEnd": true,
            "gridRowStart": true,
            "lineHeight": true,
            "opacity": true,
            "order": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },

        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {},

        // Get and set the style property on a DOM Node
        style: function (elem, name, value, extra) {

            // Don't set styles on text and comment nodes
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }

            // Make sure that we're working with the right name
            var ret, type, hooks,
                origName = camelCase(name),
                isCustomProp = rcustomProp.test(name),
                style = elem.style;

            // Make sure that we're working with the right name. We don't
            // want to query the value if it is a CSS custom property
            // since they are user-defined.
            if (!isCustomProp) {
                name = finalPropName(origName);
            }

            // Gets hook for the prefixed version, then unprefixed version
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

            // Check if we're setting a value
            if (value !== undefined) {
                type = typeof value;

                // Convert "+=" or "-=" to relative numbers (#7345)
                if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                    value = adjustCSS(elem, name, ret);

                    // Fixes bug #9237
                    type = "number";
                }

                // Make sure that null and NaN values aren't set (#7116)
                if (value == null || value !== value) {
                    return;
                }

                // If a number was passed in, add the unit (except for certain CSS properties)
                // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
                // "px" to a few hardcoded values.
                if (type === "number" && !isCustomProp) {
                    value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
                }

                // background-* props affect original clone's values
                if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                    style[name] = "inherit";
                }

                // If a hook was provided, use that value, otherwise just set the specified value
                if (!hooks || !("set" in hooks) ||
                    (value = hooks.set(elem, value, extra)) !== undefined) {

                    if (isCustomProp) {
                        style.setProperty(name, value);
                    } else {
                        style[name] = value;
                    }
                }

            } else {

                // If a hook was provided get the non-computed value from there
                if (hooks && "get" in hooks &&
                    (ret = hooks.get(elem, false, extra)) !== undefined) {

                    return ret;
                }

                // Otherwise just get the value from the style object
                return style[name];
            }
        },

        css: function (elem, name, extra, styles) {
            var val, num, hooks,
                origName = camelCase(name),
                isCustomProp = rcustomProp.test(name);

            // Make sure that we're working with the right name. We don't
            // want to modify the value if it is a CSS custom property
            // since they are user-defined.
            if (!isCustomProp) {
                name = finalPropName(origName);
            }

            // Try prefixed name followed by the unprefixed name
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

            // If a hook was provided get the computed value from there
            if (hooks && "get" in hooks) {
                val = hooks.get(elem, true, extra);
            }

            // Otherwise, if a way to get the computed value exists, use that
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }

            // Convert "normal" to computed value
            if (val === "normal" && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }

            // Make numeric if forced or a qualifier was provided and val looks numeric
            if (extra === "" || extra) {
                num = parseFloat(val);
                return extra === true || isFinite(num) ? num || 0 : val;
            }

            return val;
        }
    });

    jQuery.each(["height", "width"], function (i, dimension) {
        jQuery.cssHooks[dimension] = {
            get: function (elem, computed, extra) {
                if (computed) {

                    // Certain elements can have dimension info if we invisibly show them
                    // but it must have a current display style that would benefit
                    return rdisplayswap.test(jQuery.css(elem, "display")) &&

                    // Support: Safari 8+
                    // Table columns in Safari have non-zero offsetWidth & zero
                    // getBoundingClientRect().width unless display is changed.
                    // Support: IE <=11 only
                    // Running getBoundingClientRect on a disconnected node
                    // in IE throws an error.
                    (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ?
                        swap(elem, cssShow, function () {
                            return getWidthOrHeight(elem, dimension, extra);
                        }) :
                        getWidthOrHeight(elem, dimension, extra);
                }
            },

            set: function (elem, value, extra) {
                var matches,
                    styles = getStyles(elem),

                    // Only read styles.position if the test has a chance to fail
                    // to avoid forcing a reflow.
                    scrollboxSizeBuggy = !support.scrollboxSize() &&
                        styles.position === "absolute",

                    // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
                    boxSizingNeeded = scrollboxSizeBuggy || extra,
                    isBorderBox = boxSizingNeeded &&
                        jQuery.css(elem, "boxSizing", false, styles) === "border-box",
                    subtract = extra ?
                        boxModelAdjustment(
                            elem,
                            dimension,
                            extra,
                            isBorderBox,
                            styles
                        ) :
                        0;

                // Account for unreliable border-box dimensions by comparing offset* to computed and
                // faking a content-box to get border and padding (gh-3699)
                if (isBorderBox && scrollboxSizeBuggy) {
                    subtract -= Math.ceil(
                        elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] -
                        parseFloat(styles[dimension]) -
                        boxModelAdjustment(elem, dimension, "border", false, styles) -
                        0.5
                    );
                }

                // Convert to pixels if value adjustment is needed
                if (subtract && (matches = rcssNum.exec(value)) &&
                    (matches[3] || "px") !== "px") {

                    elem.style[dimension] = value;
                    value = jQuery.css(elem, dimension);
                }

                return setPositiveNumber(elem, value, subtract);
            }
        };
    });

    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft,
        function (elem, computed) {
            if (computed) {
                return (parseFloat(curCSS(elem, "marginLeft")) ||
                    elem.getBoundingClientRect().left -
                    swap(elem, {marginLeft: 0}, function () {
                        return elem.getBoundingClientRect().left;
                    })
                ) + "px";
            }
        }
    );

    // These hooks are used by animate to expand properties
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function (prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function (value) {
                var i = 0,
                    expanded = {},

                    // Assumes a single number if not a string
                    parts = typeof value === "string" ? value.split(" ") : [value];

                for (; i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] =
                        parts[i] || parts[i - 2] || parts[0];
                }

                return expanded;
            }
        };

        if (prefix !== "margin") {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });

    jQuery.fn.extend({
        css: function (name, value) {
            return access(this, function (elem, name, value) {
                var styles, len,
                    map = {},
                    i = 0;

                if (Array.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;

                    for (; i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    }

                    return map;
                }

                return value !== undefined ?
                    jQuery.style(elem, name, value) :
                    jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        }
    });


    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }

    jQuery.Tween = Tween;

    Tween.prototype = {
        constructor: Tween,
        init: function (elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function () {
            var hooks = Tween.propHooks[this.prop];

            return hooks && hooks.get ?
                hooks.get(this) :
                Tween.propHooks._default.get(this);
        },
        run: function (percent) {
            var eased,
                hooks = Tween.propHooks[this.prop];

            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](
                    percent, this.options.duration * percent, 0, 1, this.options.duration
                );
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;

            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }

            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };

    Tween.prototype.init.prototype = Tween.prototype;

    Tween.propHooks = {
        _default: {
            get: function (tween) {
                var result;

                // Use a property on the element directly when it is not a DOM element,
                // or when there is no matching style property that exists.
                if (tween.elem.nodeType !== 1 ||
                    tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                    return tween.elem[tween.prop];
                }

                // Passing an empty string as a 3rd parameter to .css will automatically
                // attempt a parseFloat and fallback to a string if the parse fails.
                // Simple values such as "10px" are parsed to Float;
                // complex values such as "rotate(1rad)" are returned as-is.
                result = jQuery.css(tween.elem, tween.prop, "");

                // Empty strings, null, undefined and "auto" are converted to 0.
                return !result || result === "auto" ? 0 : result;
            },
            set: function (tween) {

                // Use step hook for back compat.
                // Use cssHook if its there.
                // Use .style if available and use plain properties where available.
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.nodeType === 1 && (
                    jQuery.cssHooks[tween.prop] ||
                    tween.elem.style[finalPropName(tween.prop)] != null)) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };

    // Support: IE <=9 only
    // Panic based approach to setting things on disconnected nodes
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function (tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };

    jQuery.easing = {
        linear: function (p) {
            return p;
        },
        swing: function (p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        },
        _default: "swing"
    };

    jQuery.fx = Tween.prototype.init;

    // Back compat <1.8 extension point
    jQuery.fx.step = {};


    var
        fxNow, inProgress,
        rfxtypes = /^(?:toggle|show|hide)$/,
        rrun = /queueHooks$/;

    function schedule() {
        if (inProgress) {
            if (document.hidden === false && window.requestAnimationFrame) {
                window.requestAnimationFrame(schedule);
            } else {
                window.setTimeout(schedule, jQuery.fx.interval);
            }

            jQuery.fx.tick();
        }
    }

    // Animations created synchronously will run synchronously
    function createFxNow() {
        window.setTimeout(function () {
            fxNow = undefined;
        });
        return (fxNow = Date.now());
    }

    // Generate parameters to create a standard animation
    function genFx(type, includeWidth) {
        var which,
            i = 0,
            attrs = {height: type};

        // If we include width, step value is 1 to do all cssExpand values,
        // otherwise step value is 2 to skip over Left and Right
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
        }

        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }

        return attrs;
    }

    function createTween(value, prop, animation) {
        var tween,
            collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
            index = 0,
            length = collection.length;
        for (; index < length; index++) {
            if ((tween = collection[index].call(animation, prop, value))) {

                // We're done with this property
                return tween;
            }
        }
    }

    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
            isBox = "width" in props || "height" in props,
            anim = this,
            orig = {},
            style = elem.style,
            hidden = elem.nodeType && isHiddenWithinTree(elem),
            dataShow = dataPriv.get(elem, "fxshow");

        // Queue-skipping animations hijack the fx hooks
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function () {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;

            anim.always(function () {

                // Ensure the complete handler is called before this completes
                anim.always(function () {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, "fx").length) {
                        hooks.empty.fire();
                    }
                });
            });
        }

        // Detect show/hide animations
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.test(value)) {
                delete props[prop];
                toggle = toggle || value === "toggle";
                if (value === (hidden ? "hide" : "show")) {

                    // Pretend to be hidden if this is a "show" and
                    // there is still data from a stopped show/hide
                    if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;

                        // Ignore all other no-op show/hide data
                    } else {
                        continue;
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            }
        }

        // Bail out if this is a no-op like .hide().hide()
        propTween = !jQuery.isEmptyObject(props);
        if (!propTween && jQuery.isEmptyObject(orig)) {
            return;
        }

        // Restrict "overflow" and "display" styles during box animations
        if (isBox && elem.nodeType === 1) {

            // Support: IE <=9 - 11, Edge 12 - 15
            // Record all 3 overflow attributes because IE does not infer the shorthand
            // from identically-valued overflowX and overflowY and Edge just mirrors
            // the overflowX value there.
            opts.overflow = [style.overflow, style.overflowX, style.overflowY];

            // Identify a display type, preferring old show/hide data over the CSS cascade
            restoreDisplay = dataShow && dataShow.display;
            if (restoreDisplay == null) {
                restoreDisplay = dataPriv.get(elem, "display");
            }
            display = jQuery.css(elem, "display");
            if (display === "none") {
                if (restoreDisplay) {
                    display = restoreDisplay;
                } else {

                    // Get nonempty value(s) by temporarily forcing visibility
                    showHide([elem], true);
                    restoreDisplay = elem.style.display || restoreDisplay;
                    display = jQuery.css(elem, "display");
                    showHide([elem]);
                }
            }

            // Animate inline elements as inline-block
            if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
                if (jQuery.css(elem, "float") === "none") {

                    // Restore the original display value at the end of pure show/hide animations
                    if (!propTween) {
                        anim.done(function () {
                            style.display = restoreDisplay;
                        });
                        if (restoreDisplay == null) {
                            display = style.display;
                            restoreDisplay = display === "none" ? "" : display;
                        }
                    }
                    style.display = "inline-block";
                }
            }
        }

        if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function () {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
            });
        }

        // Implement show/hide animations
        propTween = false;
        for (prop in orig) {

            // General show/hide setup for this element animation
            if (!propTween) {
                if (dataShow) {
                    if ("hidden" in dataShow) {
                        hidden = dataShow.hidden;
                    }
                } else {
                    dataShow = dataPriv.access(elem, "fxshow", {display: restoreDisplay});
                }

                // Store hidden/visible for toggle so `.stop().toggle()` "reverses"
                if (toggle) {
                    dataShow.hidden = !hidden;
                }

                // Show elements before animating them
                if (hidden) {
                    showHide([elem], true);
                }

                /* eslint-disable no-loop-func */

                anim.done(function () {

                    /* eslint-enable no-loop-func */

                    // The final step of a "hide" animation is actually hiding the element
                    if (!hidden) {
                        showHide([elem]);
                    }
                    dataPriv.remove(elem, "fxshow");
                    for (prop in orig) {
                        jQuery.style(elem, prop, orig[prop]);
                    }
                });
            }

            // Per-property setup
            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
            if (!(prop in dataShow)) {
                dataShow[prop] = propTween.start;
                if (hidden) {
                    propTween.end = propTween.start;
                    propTween.start = 0;
                }
            }
        }
    }

    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;

        // camelCase, specialEasing and expand cssHook pass
        for (index in props) {
            name = camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (Array.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }

            if (index !== name) {
                props[name] = value;
                delete props[index];
            }

            hooks = jQuery.cssHooks[name];
            if (hooks && "expand" in hooks) {
                value = hooks.expand(value);
                delete props[name];

                // Not quite $.extend, this won't overwrite existing keys.
                // Reusing 'index' because we have the correct "name"
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }

    function Animation(elem, properties, options) {
        var result,
            stopped,
            index = 0,
            length = Animation.prefilters.length,
            deferred = jQuery.Deferred().always(function () {

                // Don't match elem in the :animated selector
                delete tick.elem;
            }),
            tick = function () {
                if (stopped) {
                    return false;
                }
                var currentTime = fxNow || createFxNow(),
                    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),

                    // Support: Android 2.3 only
                    // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
                    temp = remaining / animation.duration || 0,
                    percent = 1 - temp,
                    index = 0,
                    length = animation.tweens.length;

                for (; index < length; index++) {
                    animation.tweens[index].run(percent);
                }

                deferred.notifyWith(elem, [animation, percent, remaining]);

                // If there's more to do, yield
                if (percent < 1 && length) {
                    return remaining;
                }

                // If this was an empty animation, synthesize a final progress notification
                if (!length) {
                    deferred.notifyWith(elem, [animation, 1, 0]);
                }

                // Resolve the animation and report its conclusion
                deferred.resolveWith(elem, [animation]);
                return false;
            },
            animation = deferred.promise({
                elem: elem,
                props: jQuery.extend({}, properties),
                opts: jQuery.extend(true, {
                    specialEasing: {},
                    easing: jQuery.easing._default
                }, options),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function (prop, end) {
                    var tween = jQuery.Tween(elem, animation.opts, prop, end,
                        animation.opts.specialEasing[prop] || animation.opts.easing);
                    animation.tweens.push(tween);
                    return tween;
                },
                stop: function (gotoEnd) {
                    var index = 0,

                        // If we are going to the end, we want to run all the tweens
                        // otherwise we skip this part
                        length = gotoEnd ? animation.tweens.length : 0;
                    if (stopped) {
                        return this;
                    }
                    stopped = true;
                    for (; index < length; index++) {
                        animation.tweens[index].run(1);
                    }

                    // Resolve when we played the last frame; otherwise, reject
                    if (gotoEnd) {
                        deferred.notifyWith(elem, [animation, 1, 0]);
                        deferred.resolveWith(elem, [animation, gotoEnd]);
                    } else {
                        deferred.rejectWith(elem, [animation, gotoEnd]);
                    }
                    return this;
                }
            }),
            props = animation.props;

        propFilter(props, animation.opts.specialEasing);

        for (; index < length; index++) {
            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                if (isFunction(result.stop)) {
                    jQuery._queueHooks(animation.elem, animation.opts.queue).stop =
                        result.stop.bind(result);
                }
                return result;
            }
        }

        jQuery.map(props, createTween, animation);

        if (isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }

        // Attach callbacks from options
        animation
            .progress(animation.opts.progress)
            .done(animation.opts.done, animation.opts.complete)
            .fail(animation.opts.fail)
            .always(animation.opts.always);

        jQuery.fx.timer(
            jQuery.extend(tick, {
                elem: elem,
                anim: animation,
                queue: animation.opts.queue
            })
        );

        return animation;
    }

    jQuery.Animation = jQuery.extend(Animation, {

        tweeners: {
            "*": [function (prop, value) {
                var tween = this.createTween(prop, value);
                adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
                return tween;
            }]
        },

        tweener: function (props, callback) {
            if (isFunction(props)) {
                callback = props;
                props = ["*"];
            } else {
                props = props.match(rnothtmlwhite);
            }

            var prop,
                index = 0,
                length = props.length;

            for (; index < length; index++) {
                prop = props[index];
                Animation.tweeners[prop] = Animation.tweeners[prop] || [];
                Animation.tweeners[prop].unshift(callback);
            }
        },

        prefilters: [defaultPrefilter],

        prefilter: function (callback, prepend) {
            if (prepend) {
                Animation.prefilters.unshift(callback);
            } else {
                Animation.prefilters.push(callback);
            }
        }
    });

    jQuery.speed = function (speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing ||
                isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !isFunction(easing) && easing
        };

        // Go to the end state if fx are off
        if (jQuery.fx.off) {
            opt.duration = 0;

        } else {
            if (typeof opt.duration !== "number") {
                if (opt.duration in jQuery.fx.speeds) {
                    opt.duration = jQuery.fx.speeds[opt.duration];

                } else {
                    opt.duration = jQuery.fx.speeds._default;
                }
            }
        }

        // Normalize opt.queue - true/undefined/null -> "fx"
        if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
        }

        // Queueing
        opt.old = opt.complete;

        opt.complete = function () {
            if (isFunction(opt.old)) {
                opt.old.call(this);
            }

            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };

        return opt;
    };

    jQuery.fn.extend({
        fadeTo: function (speed, to, easing, callback) {

            // Show any hidden elements after setting opacity to 0
            return this.filter(isHiddenWithinTree).css("opacity", 0).show()

            // Animate to the value specified
                .end().animate({opacity: to}, speed, easing, callback);
        },
        animate: function (prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop),
                optall = jQuery.speed(speed, easing, callback),
                doAnimation = function () {

                    // Operate on a copy of prop so per-property easing won't be lost
                    var anim = Animation(this, jQuery.extend({}, prop), optall);

                    // Empty animations, or finishing resolves immediately
                    if (empty || dataPriv.get(this, "finish")) {
                        anim.stop(true);
                    }
                };
            doAnimation.finish = doAnimation;

            return empty || optall.queue === false ?
                this.each(doAnimation) :
                this.queue(optall.queue, doAnimation);
        },
        stop: function (type, clearQueue, gotoEnd) {
            var stopQueue = function (hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };

            if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || "fx", []);
            }

            return this.each(function () {
                var dequeue = true,
                    index = type != null && type + "queueHooks",
                    timers = jQuery.timers,
                    data = dataPriv.get(this);

                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }

                for (index = timers.length; index--;) {
                    if (timers[index].elem === this &&
                        (type == null || timers[index].queue === type)) {

                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }

                // Start the next in the queue if the last step wasn't forced.
                // Timers currently will call their complete callbacks, which
                // will dequeue but only if they were gotoEnd.
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function (type) {
            if (type !== false) {
                type = type || "fx";
            }
            return this.each(function () {
                var index,
                    data = dataPriv.get(this),
                    queue = data[type + "queue"],
                    hooks = data[type + "queueHooks"],
                    timers = jQuery.timers,
                    length = queue ? queue.length : 0;

                // Enable finishing flag on private data
                data.finish = true;

                // Empty the queue first
                jQuery.queue(this, type, []);

                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }

                // Look for any active animations, and finish them
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }

                // Look for any animations in the old queue and finish them
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }

                // Turn off finishing flag
                delete data.finish;
            });
        }
    });

    jQuery.each(["toggle", "show", "hide"], function (i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function (speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ?
                cssFn.apply(this, arguments) :
                this.animate(genFx(name, true), speed, easing, callback);
        };
    });

    // Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {opacity: "show"},
        fadeOut: {opacity: "hide"},
        fadeToggle: {opacity: "toggle"}
    }, function (name, props) {
        jQuery.fn[name] = function (speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });

    jQuery.timers = [];
    jQuery.fx.tick = function () {
        var timer,
            i = 0,
            timers = jQuery.timers;

        fxNow = Date.now();

        for (; i < timers.length; i++) {
            timer = timers[i];

            // Run the timer and safely remove it when done (allowing for external removal)
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }

        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };

    jQuery.fx.timer = function (timer) {
        jQuery.timers.push(timer);
        jQuery.fx.start();
    };

    jQuery.fx.interval = 13;
    jQuery.fx.start = function () {
        if (inProgress) {
            return;
        }

        inProgress = true;
        schedule();
    };

    jQuery.fx.stop = function () {
        inProgress = null;
    };

    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,

        // Default speed
        _default: 400
    };


    // Based off of the plugin by Clint Helfers, with permission.
    // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
    jQuery.fn.delay = function (time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";

        return this.queue(type, function (next, hooks) {
            var timeout = window.setTimeout(next, time);
            hooks.stop = function () {
                window.clearTimeout(timeout);
            };
        });
    };


    (function () {
        var input = document.createElement("input"),
            select = document.createElement("select"),
            opt = select.appendChild(document.createElement("option"));

        input.type = "checkbox";

        // Support: Android <=4.3 only
        // Default value for a checkbox should be "on"
        support.checkOn = input.value !== "";

        // Support: IE <=11 only
        // Must access selectedIndex to make default options select
        support.optSelected = opt.selected;

        // Support: IE <=11 only
        // An input loses its value after becoming a radio
        input = document.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
    })();


    var boolHook,
        attrHandle = jQuery.expr.attrHandle;

    jQuery.fn.extend({
        attr: function (name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },

        removeAttr: function (name) {
            return this.each(function () {
                jQuery.removeAttr(this, name);
            });
        }
    });

    jQuery.extend({
        attr: function (elem, name, value) {
            var ret, hooks,
                nType = elem.nodeType;

            // Don't get/set attributes on text, comment and attribute nodes
            if (nType === 3 || nType === 8 || nType === 2) {
                return;
            }

            // Fallback to prop when attributes are not supported
            if (typeof elem.getAttribute === "undefined") {
                return jQuery.prop(elem, name, value);
            }

            // Attribute hooks are determined by the lowercase version
            // Grab necessary hook if one is defined
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                hooks = jQuery.attrHooks[name.toLowerCase()] ||
                    (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
            }

            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                    return;
                }

                if (hooks && "set" in hooks &&
                    (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                }

                elem.setAttribute(name, value + "");
                return value;
            }

            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            }

            ret = jQuery.find.attr(elem, name);

            // Non-existent attributes return null, we normalize to undefined
            return ret == null ? undefined : ret;
        },

        attrHooks: {
            type: {
                set: function (elem, value) {
                    if (!support.radioValue && value === "radio" &&
                        nodeName(elem, "input")) {
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        },

        removeAttr: function (elem, value) {
            var name,
                i = 0,

                // Attribute names can contain non-HTML whitespace characters
                // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
                attrNames = value && value.match(rnothtmlwhite);

            if (attrNames && elem.nodeType === 1) {
                while ((name = attrNames[i++])) {
                    elem.removeAttribute(name);
                }
            }
        }
    });

    // Hooks for boolean attributes
    boolHook = {
        set: function (elem, value, name) {
            if (value === false) {

                // Remove boolean attributes when set to false
                jQuery.removeAttr(elem, name);
            } else {
                elem.setAttribute(name, name);
            }
            return name;
        }
    };

    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;

        attrHandle[name] = function (elem, name, isXML) {
            var ret, handle,
                lowercaseName = name.toLowerCase();

            if (!isXML) {

                // Avoid an infinite loop by temporarily removing this function from the getter
                handle = attrHandle[lowercaseName];
                attrHandle[lowercaseName] = ret;
                ret = getter(elem, name, isXML) != null ?
                    lowercaseName :
                    null;
                attrHandle[lowercaseName] = handle;
            }
            return ret;
        };
    });


    var rfocusable = /^(?:input|select|textarea|button)$/i,
        rclickable = /^(?:a|area)$/i;

    jQuery.fn.extend({
        prop: function (name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },

        removeProp: function (name) {
            return this.each(function () {
                delete this[jQuery.propFix[name] || name];
            });
        }
    });

    jQuery.extend({
        prop: function (elem, name, value) {
            var ret, hooks,
                nType = elem.nodeType;

            // Don't get/set properties on text, comment and attribute nodes
            if (nType === 3 || nType === 8 || nType === 2) {
                return;
            }

            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {

                // Fix name and attach hooks
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }

            if (value !== undefined) {
                if (hooks && "set" in hooks &&
                    (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                }

                return (elem[name] = value);
            }

            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            }

            return elem[name];
        },

        propHooks: {
            tabIndex: {
                get: function (elem) {

                    // Support: IE <=9 - 11 only
                    // elem.tabIndex doesn't always return the
                    // correct value when it hasn't been explicitly set
                    // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    // Use proper attribute retrieval(#12072)
                    var tabindex = jQuery.find.attr(elem, "tabindex");

                    if (tabindex) {
                        return parseInt(tabindex, 10);
                    }

                    if (
                        rfocusable.test(elem.nodeName) ||
                        rclickable.test(elem.nodeName) &&
                        elem.href
                    ) {
                        return 0;
                    }

                    return -1;
                }
            }
        },

        propFix: {
            "for": "htmlFor",
            "class": "className"
        }
    });

    // Support: IE <=11 only
    // Accessing the selectedIndex property
    // forces the browser to respect setting selected
    // on the option
    // The getter ensures a default option is selected
    // when in an optgroup
    // eslint rule "no-unused-expressions" is disabled for this code
    // since it considers such accessions noop
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function (elem) {

                /* eslint no-unused-expressions: "off" */

                var parent = elem.parentNode;
                if (parent && parent.parentNode) {
                    parent.parentNode.selectedIndex;
                }
                return null;
            },
            set: function (elem) {

                /* eslint no-unused-expressions: "off" */

                var parent = elem.parentNode;
                if (parent) {
                    parent.selectedIndex;

                    if (parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                }
            }
        };
    }

    jQuery.each([
        "tabIndex",
        "readOnly",
        "maxLength",
        "cellSpacing",
        "cellPadding",
        "rowSpan",
        "colSpan",
        "useMap",
        "frameBorder",
        "contentEditable"
    ], function () {
        jQuery.propFix[this.toLowerCase()] = this;
    });


    // Strip and collapse whitespace according to HTML spec
    // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
    function stripAndCollapse(value) {
        var tokens = value.match(rnothtmlwhite) || [];
        return tokens.join(" ");
    }


    function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
    }

    function classesToArray(value) {
        if (Array.isArray(value)) {
            return value;
        }
        if (typeof value === "string") {
            return value.match(rnothtmlwhite) || [];
        }
        return [];
    }

    jQuery.fn.extend({
        addClass: function (value) {
            var classes, elem, cur, curValue, clazz, j, finalValue,
                i = 0;

            if (isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, getClass(this)));
                });
            }

            classes = classesToArray(value);

            if (classes.length) {
                while ((elem = this[i++])) {
                    curValue = getClass(elem);
                    cur = elem.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");

                    if (cur) {
                        j = 0;
                        while ((clazz = classes[j++])) {
                            if (cur.indexOf(" " + clazz + " ") < 0) {
                                cur += clazz + " ";
                            }
                        }

                        // Only assign if different to avoid unneeded rendering.
                        finalValue = stripAndCollapse(cur);
                        if (curValue !== finalValue) {
                            elem.setAttribute("class", finalValue);
                        }
                    }
                }
            }

            return this;
        },

        removeClass: function (value) {
            var classes, elem, cur, curValue, clazz, j, finalValue,
                i = 0;

            if (isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).removeClass(value.call(this, j, getClass(this)));
                });
            }

            if (!arguments.length) {
                return this.attr("class", "");
            }

            classes = classesToArray(value);

            if (classes.length) {
                while ((elem = this[i++])) {
                    curValue = getClass(elem);

                    // This expression is here for better compressibility (see addClass)
                    cur = elem.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");

                    if (cur) {
                        j = 0;
                        while ((clazz = classes[j++])) {

                            // Remove *all* instances
                            while (cur.indexOf(" " + clazz + " ") > -1) {
                                cur = cur.replace(" " + clazz + " ", " ");
                            }
                        }

                        // Only assign if different to avoid unneeded rendering.
                        finalValue = stripAndCollapse(cur);
                        if (curValue !== finalValue) {
                            elem.setAttribute("class", finalValue);
                        }
                    }
                }
            }

            return this;
        },

        toggleClass: function (value, stateVal) {
            var type = typeof value,
                isValidValue = type === "string" || Array.isArray(value);

            if (typeof stateVal === "boolean" && isValidValue) {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }

            if (isFunction(value)) {
                return this.each(function (i) {
                    jQuery(this).toggleClass(
                        value.call(this, i, getClass(this), stateVal),
                        stateVal
                    );
                });
            }

            return this.each(function () {
                var className, i, self, classNames;

                if (isValidValue) {

                    // Toggle individual class names
                    i = 0;
                    self = jQuery(this);
                    classNames = classesToArray(value);

                    while ((className = classNames[i++])) {

                        // Check each className given, space separated list
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }

                    // Toggle whole class name
                } else if (value === undefined || type === "boolean") {
                    className = getClass(this);
                    if (className) {

                        // Store className if set
                        dataPriv.set(this, "__className__", className);
                    }

                    // If the element has a class name or if we're passed `false`,
                    // then remove the whole classname (if there was one, the above saved it).
                    // Otherwise bring back whatever was previously saved (if anything),
                    // falling back to the empty string if nothing was stored.
                    if (this.setAttribute) {
                        this.setAttribute("class",
                            className || value === false ?
                                "" :
                                dataPriv.get(this, "__className__") || ""
                        );
                    }
                }
            });
        },

        hasClass: function (selector) {
            var className, elem,
                i = 0;

            className = " " + selector + " ";
            while ((elem = this[i++])) {
                if (elem.nodeType === 1 &&
                    (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
                    return true;
                }
            }

            return false;
        }
    });


    var rreturn = /\r/g;

    jQuery.fn.extend({
        val: function (value) {
            var hooks, ret, valueIsFunction,
                elem = this[0];

            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] ||
                        jQuery.valHooks[elem.nodeName.toLowerCase()];

                    if (hooks &&
                        "get" in hooks &&
                        (ret = hooks.get(elem, "value")) !== undefined
                    ) {
                        return ret;
                    }

                    ret = elem.value;

                    // Handle most common string cases
                    if (typeof ret === "string") {
                        return ret.replace(rreturn, "");
                    }

                    // Handle cases where value is null/undef or number
                    return ret == null ? "" : ret;
                }

                return;
            }

            valueIsFunction = isFunction(value);

            return this.each(function (i) {
                var val;

                if (this.nodeType !== 1) {
                    return;
                }

                if (valueIsFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }

                // Treat null/undefined as ""; convert numbers to string
                if (val == null) {
                    val = "";

                } else if (typeof val === "number") {
                    val += "";

                } else if (Array.isArray(val)) {
                    val = jQuery.map(val, function (value) {
                        return value == null ? "" : value + "";
                    });
                }

                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

                // If set returns undefined, fall back to normal setting
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                    this.value = val;
                }
            });
        }
    });

    jQuery.extend({
        valHooks: {
            option: {
                get: function (elem) {

                    var val = jQuery.find.attr(elem, "value");
                    return val != null ?
                        val :

                        // Support: IE <=10 - 11 only
                        // option.text throws exceptions (#14686, #14858)
                        // Strip and collapse whitespace
                        // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                        stripAndCollapse(jQuery.text(elem));
                }
            },
            select: {
                get: function (elem) {
                    var value, option, i,
                        options = elem.options,
                        index = elem.selectedIndex,
                        one = elem.type === "select-one",
                        values = one ? null : [],
                        max = one ? index + 1 : options.length;

                    if (index < 0) {
                        i = max;

                    } else {
                        i = one ? index : 0;
                    }

                    // Loop through all the selected options
                    for (; i < max; i++) {
                        option = options[i];

                        // Support: IE <=9 only
                        // IE8-9 doesn't update selected after form reset (#2551)
                        if ((option.selected || i === index) &&

                            // Don't return options that are disabled or in a disabled optgroup
                            !option.disabled &&
                            (!option.parentNode.disabled ||
                                !nodeName(option.parentNode, "optgroup"))) {

                            // Get the specific value for the option
                            value = jQuery(option).val();

                            // We don't need an array for one selects
                            if (one) {
                                return value;
                            }

                            // Multi-Selects return an array
                            values.push(value);
                        }
                    }

                    return values;
                },

                set: function (elem, value) {
                    var optionSet, option,
                        options = elem.options,
                        values = jQuery.makeArray(value),
                        i = options.length;

                    while (i--) {
                        option = options[i];

                        /* eslint-disable no-cond-assign */

                        if (option.selected =
                            jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1
                        ) {
                            optionSet = true;
                        }

                        /* eslint-enable no-cond-assign */
                    }

                    // Force browsers to behave consistently when non-matching value is set
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        }
    });

    // Radios and checkboxes getter/setter
    jQuery.each(["radio", "checkbox"], function () {
        jQuery.valHooks[this] = {
            set: function (elem, value) {
                if (Array.isArray(value)) {
                    return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);
                }
            }
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function (elem) {
                return elem.getAttribute("value") === null ? "on" : elem.value;
            };
        }
    });


    // Return jQuery for attributes-only inclusion


    support.focusin = "onfocusin" in window;


    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
        stopPropagationCallback = function (e) {
            e.stopPropagation();
        };

    jQuery.extend(jQuery.event, {

        trigger: function (event, data, elem, onlyHandlers) {

            var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
                eventPath = [elem || document],
                type = hasOwn.call(event, "type") ? event.type : event,
                namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

            cur = lastElement = tmp = elem = elem || document;

            // Don't do events on text and comment nodes
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }

            // focus/blur morphs to focusin/out; ensure we're not firing them right now
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }

            if (type.indexOf(".") > -1) {

                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;

            // Caller can pass in a jQuery.Event object, Object, or just an event type string
            event = event[jQuery.expando] ?
                event :
                new jQuery.Event(type, typeof event === "object" && event);

            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.rnamespace = event.namespace ?
                new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") :
                null;

            // Clean up the event in case it is being reused
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }

            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data == null ?
                [event] :
                jQuery.makeArray(data, [event]);

            // Allow special events to draw outside the lines
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }

            // Determine event propagation path in advance, per W3C events spec (#9951)
            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
            if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {

                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (; cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }

                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }

            // Fire handlers on the event path
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                lastElement = cur;
                event.type = i > 1 ?
                    bubbleType :
                    special.bindType || type;

                // jQuery handler
                handle = (dataPriv.get(cur, "events") || {})[event.type] &&
                    dataPriv.get(cur, "handle");
                if (handle) {
                    handle.apply(cur, data);
                }

                // Native handler
                handle = ontype && cur[ontype];
                if (handle && handle.apply && acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;

            // If nobody prevented the default action, do it now
            if (!onlyHandlers && !event.isDefaultPrevented()) {

                if ((!special._default ||
                    special._default.apply(eventPath.pop(), data) === false) &&
                    acceptData(elem)) {

                    // Call a native DOM method on the target with the same name as the event.
                    // Don't do default actions on window, that's where global variables be (#6170)
                    if (ontype && isFunction(elem[type]) && !isWindow(elem)) {

                        // Don't re-trigger an onFOO event when we call its FOO() method
                        tmp = elem[ontype];

                        if (tmp) {
                            elem[ontype] = null;
                        }

                        // Prevent re-triggering of the same event, since we already bubbled it above
                        jQuery.event.triggered = type;

                        if (event.isPropagationStopped()) {
                            lastElement.addEventListener(type, stopPropagationCallback);
                        }

                        elem[type]();

                        if (event.isPropagationStopped()) {
                            lastElement.removeEventListener(type, stopPropagationCallback);
                        }

                        jQuery.event.triggered = undefined;

                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }

            return event.result;
        },

        // Piggyback on a donor event to simulate a different one
        // Used only for `focus(in | out)` events
        simulate: function (type, elem, event) {
            var e = jQuery.extend(
                new jQuery.Event(),
                event,
                {
                    type: type,
                    isSimulated: true
                }
            );

            jQuery.event.trigger(e, null, elem);
        }

    });

    jQuery.fn.extend({

        trigger: function (type, data) {
            return this.each(function () {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function (type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        }
    });


    // Support: Firefox <=44
    // Firefox doesn't have focus(in | out) events
    // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
    //
    // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
    // focus(in | out) events fire after focus & blur events,
    // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
    // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
    if (!support.focusin) {
        jQuery.each({focus: "focusin", blur: "focusout"}, function (orig, fix) {

            // Attach a single capturing handler on the document while someone wants focusin/focusout
            var handler = function (event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
            };

            jQuery.event.special[fix] = {
                setup: function () {
                    var doc = this.ownerDocument || this,
                        attaches = dataPriv.access(doc, fix);

                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    dataPriv.access(doc, fix, (attaches || 0) + 1);
                },
                teardown: function () {
                    var doc = this.ownerDocument || this,
                        attaches = dataPriv.access(doc, fix) - 1;

                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        dataPriv.remove(doc, fix);

                    } else {
                        dataPriv.access(doc, fix, attaches);
                    }
                }
            };
        });
    }
    var location = window.location;

    var nonce = Date.now();

    var rquery = (/\?/);


    // Cross-browser xml parsing
    jQuery.parseXML = function (data) {
        var xml;
        if (!data || typeof data !== "string") {
            return null;
        }

        // Support: IE 9 - 11 only
        // IE throws on parseFromString with invalid input.
        try {
            xml = (new window.DOMParser()).parseFromString(data, "text/xml");
        } catch (e) {
            xml = undefined;
        }

        if (!xml || xml.getElementsByTagName("parsererror").length) {
            jQuery.error("Invalid XML: " + data);
        }
        return xml;
    };


    var
        rbracket = /\[\]$/,
        rCRLF = /\r?\n/g,
        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
        rsubmittable = /^(?:input|select|textarea|keygen)/i;

    function buildParams(prefix, obj, traditional, add) {
        var name;

        if (Array.isArray(obj)) {

            // Serialize array item.
            jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {

                    // Treat each array item as a scalar.
                    add(prefix, v);

                } else {

                    // Item is non-scalar (array or object), encode its numeric index.
                    buildParams(
                        prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]",
                        v,
                        traditional,
                        add
                    );
                }
            });

        } else if (!traditional && toType(obj) === "object") {

            // Serialize object item.
            for (name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }

        } else {

            // Serialize scalar item.
            add(prefix, obj);
        }
    }

    // Serialize an array of form elements or a set of
    // key/values into a query string
    jQuery.param = function (a, traditional) {
        var prefix,
            s = [],
            add = function (key, valueOrFunction) {

                // If value is a function, invoke it and use its return value
                var value = isFunction(valueOrFunction) ?
                    valueOrFunction() :
                    valueOrFunction;

                s[s.length] = encodeURIComponent(key) + "=" +
                    encodeURIComponent(value == null ? "" : value);
            };

        if (a == null) {
            return "";
        }

        // If an array was passed in, assume that it is an array of form elements.
        if (Array.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {

            // Serialize the form elements
            jQuery.each(a, function () {
                add(this.name, this.value);
            });

        } else {

            // If traditional, encode the "old" way (the way 1.3.2 or older
            // did it), otherwise encode params recursively.
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }

        // Return the resulting serialization
        return s.join("&");
    };

    jQuery.fn.extend({
        serialize: function () {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function () {
            return this.map(function () {

                // Can add propHook for "elements" to filter or add form elements
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this;
            })
                .filter(function () {
                    var type = this.type;

                    // Use .is( ":disabled" ) so that fieldset[disabled] works
                    return this.name && !jQuery(this).is(":disabled") &&
                        rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) &&
                        (this.checked || !rcheckableType.test(type));
                })
                .map(function (i, elem) {
                    var val = jQuery(this).val();

                    if (val == null) {
                        return null;
                    }

                    if (Array.isArray(val)) {
                        return jQuery.map(val, function (val) {
                            return {name: elem.name, value: val.replace(rCRLF, "\r\n")};
                        });
                    }

                    return {name: elem.name, value: val.replace(rCRLF, "\r\n")};
                }).get();
        }
    });


    var
        r20 = /%20/g,
        rhash = /#.*$/,
        rantiCache = /([?&])_=[^&]*/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

        // #7653, #8125, #8152: local protocol detection
        rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,

        /* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
        prefilters = {},

        /* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
        transports = {},

        // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
        allTypes = "*/".concat("*"),

        // Anchor tag for parsing the document origin
        originAnchor = document.createElement("a");
    originAnchor.href = location.href;

    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports(structure) {

        // dataTypeExpression is optional and defaults to "*"
        return function (dataTypeExpression, func) {

            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }

            var dataType,
                i = 0,
                dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];

            if (isFunction(func)) {

                // For each dataType in the dataTypeExpression
                while ((dataType = dataTypes[i++])) {

                    // Prepend if requested
                    if (dataType[0] === "+") {
                        dataType = dataType.slice(1) || "*";
                        (structure[dataType] = structure[dataType] || []).unshift(func);

                        // Otherwise append
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }

    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

        var inspected = {},
            seekingTransport = (structure === transports);

        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === "string" &&
                    !seekingTransport && !inspected[dataTypeOrTransport]) {

                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport);
                }
            });
            return selected;
        }

        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }

    // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes #9887
    function ajaxExtend(target, src) {
        var key, deep,
            flatOptions = jQuery.ajaxSettings.flatOptions || {};

        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }

        return target;
    }

    /* Handles responses to an ajax request:
    * - finds the right dataType (mediates between content-type and expected dataType)
    * - returns the corresponding response
    */
    function ajaxHandleResponses(s, jqXHR, responses) {

        var ct, type, finalDataType, firstDataType,
            contents = s.contents,
            dataTypes = s.dataTypes;

        // Remove auto dataType and get content-type in the process
        while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
        }

        // Check if we're dealing with a known content-type
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }

        // Check to see if we have a response for the expected dataType
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {

            // Try convertible dataTypes
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }

            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }

        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }

    /* Chain conversions given the request and the original response
    * Also sets the responseXXX fields on the jqXHR instance
    */
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev,
            converters = {},

            // Work with a copy of dataTypes in case we need to modify it for conversion
            dataTypes = s.dataTypes.slice();

        // Create converters map with lowercased keys
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }

        current = dataTypes.shift();

        // Convert to each sequential dataType
        while (current) {

            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }

            // Apply the dataFilter if provided
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }

            prev = current;
            current = dataTypes.shift();

            if (current) {

                // There's only work to do if current dataType is non-auto
                if (current === "*") {

                    current = prev;

                    // Convert response if prev dataType is non-auto and differs from current
                } else if (prev !== "*" && prev !== current) {

                    // Seek a direct converter
                    conv = converters[prev + " " + current] || converters["* " + current];

                    // If none found, seek a pair
                    if (!conv) {
                        for (conv2 in converters) {

                            // If conv2 outputs current
                            tmp = conv2.split(" ");
                            if (tmp[1] === current) {

                                // If prev can be converted to accepted input
                                conv = converters[prev + " " + tmp[0]] ||
                                    converters["* " + tmp[0]];
                                if (conv) {

                                    // Condense equivalence converters
                                    if (conv === true) {
                                        conv = converters[conv2];

                                        // Otherwise, insert the intermediate dataType
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }

                    // Apply converter (if not an equivalence)
                    if (conv !== true) {

                        // Unless errors are allowed to bubble, catch and return them
                        if (conv && s.throws) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: "parsererror",
                                    error: conv ? e : "No conversion from " + prev + " to " + current
                                };
                            }
                        }
                    }
                }
            }
        }

        return {state: "success", data: response};
    }

    jQuery.extend({

        // Counter for holding the number of active queries
        active: 0,

        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},

        ajaxSettings: {
            url: location.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",

            /*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },

            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },

            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },

            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {

                // Convert anything to text
                "* text": String,

                // Text to html (true = no transformation)
                "text html": true,

                // Evaluate text as a json expression
                "text json": JSON.parse,

                // Parse text as xml
                "text xml": jQuery.parseXML
            },

            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
                url: true,
                context: true
            }
        },

        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function (target, settings) {
            return settings ?

                // Building a settings object
                ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :

                // Extending ajaxSettings
                ajaxExtend(jQuery.ajaxSettings, target);
        },

        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),

        // Main method
        ajax: function (url, options) {

            // If url is an object, simulate pre-1.5 signature
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }

            // Force options to be an object
            options = options || {};

            var transport,

                // URL without anti-cache param
                cacheURL,

                // Response headers
                responseHeadersString,
                responseHeaders,

                // timeout handle
                timeoutTimer,

                // Url cleanup var
                urlAnchor,

                // Request state (becomes false upon send and true upon completion)
                completed,

                // To know if global events are to be dispatched
                fireGlobals,

                // Loop variable
                i,

                // uncached part of the url
                uncached,

                // Create the final options object
                s = jQuery.ajaxSetup({}, options),

                // Callbacks context
                callbackContext = s.context || s,

                // Context for global events is callbackContext if it is a DOM node or jQuery collection
                globalEventContext = s.context &&
                (callbackContext.nodeType || callbackContext.jquery) ?
                    jQuery(callbackContext) :
                    jQuery.event,

                // Deferreds
                deferred = jQuery.Deferred(),
                completeDeferred = jQuery.Callbacks("once memory"),

                // Status-dependent callbacks
                statusCode = s.statusCode || {},

                // Headers (they are sent all at once)
                requestHeaders = {},
                requestHeadersNames = {},

                // Default abort message
                strAbort = "canceled",

                // Fake xhr
                jqXHR = {
                    readyState: 0,

                    // Builds headers hashtable if needed
                    getResponseHeader: function (key) {
                        var match;
                        if (completed) {
                            if (!responseHeaders) {
                                responseHeaders = {};
                                while ((match = rheaders.exec(responseHeadersString))) {
                                    responseHeaders[match[1].toLowerCase() + " "] =
                                        (responseHeaders[match[1].toLowerCase() + " "] || [])
                                            .concat(match[2]);
                                }
                            }
                            match = responseHeaders[key.toLowerCase() + " "];
                        }
                        return match == null ? null : match.join(", ");
                    },

                    // Raw string
                    getAllResponseHeaders: function () {
                        return completed ? responseHeadersString : null;
                    },

                    // Caches the header
                    setRequestHeader: function (name, value) {
                        if (completed == null) {
                            name = requestHeadersNames[name.toLowerCase()] =
                                requestHeadersNames[name.toLowerCase()] || name;
                            requestHeaders[name] = value;
                        }
                        return this;
                    },

                    // Overrides response content-type header
                    overrideMimeType: function (type) {
                        if (completed == null) {
                            s.mimeType = type;
                        }
                        return this;
                    },

                    // Status-dependent callbacks
                    statusCode: function (map) {
                        var code;
                        if (map) {
                            if (completed) {

                                // Execute the appropriate callbacks
                                jqXHR.always(map[jqXHR.status]);
                            } else {

                                // Lazy-add the new callbacks in a way that preserves old ones
                                for (code in map) {
                                    statusCode[code] = [statusCode[code], map[code]];
                                }
                            }
                        }
                        return this;
                    },

                    // Cancel the request
                    abort: function (statusText) {
                        var finalText = statusText || strAbort;
                        if (transport) {
                            transport.abort(finalText);
                        }
                        done(0, finalText);
                        return this;
                    }
                };

            // Attach deferreds
            deferred.promise(jqXHR);

            // Add protocol if not provided (prefilters might expect it)
            // Handle falsy url in the settings object (#10093: consistency with old signature)
            // We also use the url parameter if available
            s.url = ((url || s.url || location.href) + "")
                .replace(rprotocol, location.protocol + "//");

            // Alias method option to type as per ticket #12004
            s.type = options.method || options.type || s.method || s.type;

            // Extract dataTypes list
            s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];

            // A cross-domain request is in order when the origin doesn't match the current origin.
            if (s.crossDomain == null) {
                urlAnchor = document.createElement("a");

                // Support: IE <=8 - 11, Edge 12 - 15
                // IE throws exception on accessing the href property if url is malformed,
                // e.g. http://example.com:80x/
                try {
                    urlAnchor.href = s.url;

                    // Support: IE <=8 - 11 only
                    // Anchor's host property isn't correctly set when s.url is relative
                    urlAnchor.href = urlAnchor.href;
                    s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
                        urlAnchor.protocol + "//" + urlAnchor.host;
                } catch (e) {

                    // If there is an error parsing the URL, assume it is crossDomain,
                    // it can be rejected by the transport if it is invalid
                    s.crossDomain = true;
                }
            }

            // Convert data if not already a string
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
            }

            // Apply prefilters
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

            // If request was aborted inside a prefilter, stop there
            if (completed) {
                return jqXHR;
            }

            // We can fire global events as of now if asked to
            // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
            fireGlobals = jQuery.event && s.global;

            // Watch for a new set of requests
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
            }

            // Uppercase the type
            s.type = s.type.toUpperCase();

            // Determine if request has content
            s.hasContent = !rnoContent.test(s.type);

            // Save the URL in case we're toying with the If-Modified-Since
            // and/or If-None-Match header later on
            // Remove hash to simplify url manipulation
            cacheURL = s.url.replace(rhash, "");

            // More options handling for requests with no content
            if (!s.hasContent) {

                // Remember the hash so we can put it back
                uncached = s.url.slice(cacheURL.length);

                // If data is available and should be processed, append data to url
                if (s.data && (s.processData || typeof s.data === "string")) {
                    cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;

                    // #9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                }

                // Add or update anti-cache param if needed
                if (s.cache === false) {
                    cacheURL = cacheURL.replace(rantiCache, "$1");
                    uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + (nonce++) + uncached;
                }

                // Put hash and anti-cache on the URL that will be requested (gh-1732)
                s.url = cacheURL + uncached;

                // Change '%20' to '+' if this is encoded form body content (gh-2658)
            } else if (s.data && s.processData &&
                (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
                s.data = s.data.replace(r20, "+");
            }

            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
                }
            }

            // Set the correct header, if data is being sent
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType);
            }

            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader(
                "Accept",
                s.dataTypes[0] && s.accepts[s.dataTypes[0]] ?
                    s.accepts[s.dataTypes[0]] +
                    (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") :
                    s.accepts["*"]
            );

            // Check for headers option
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }

            // Allow custom headers/mimetypes and early abort
            if (s.beforeSend &&
                (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {

                // Abort if not done already and return
                return jqXHR.abort();
            }

            // Aborting is no longer a cancellation
            strAbort = "abort";

            // Install callbacks on deferreds
            completeDeferred.add(s.complete);
            jqXHR.done(s.success);
            jqXHR.fail(s.error);

            // Get transport
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

            // If no transport, we auto-abort
            if (!transport) {
                done(-1, "No Transport");
            } else {
                jqXHR.readyState = 1;

                // Send global event
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [jqXHR, s]);
                }

                // If request was aborted inside ajaxSend, stop there
                if (completed) {
                    return jqXHR;
                }

                // Timeout
                if (s.async && s.timeout > 0) {
                    timeoutTimer = window.setTimeout(function () {
                        jqXHR.abort("timeout");
                    }, s.timeout);
                }

                try {
                    completed = false;
                    transport.send(requestHeaders, done);
                } catch (e) {

                    // Rethrow post-completion exceptions
                    if (completed) {
                        throw e;
                    }

                    // Propagate others as results
                    done(-1, e);
                }
            }

            // Callback for when everything is done
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified,
                    statusText = nativeStatusText;

                // Ignore repeat invocations
                if (completed) {
                    return;
                }

                completed = true;

                // Clear timeout if it exists
                if (timeoutTimer) {
                    window.clearTimeout(timeoutTimer);
                }

                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;

                // Cache response headers
                responseHeadersString = headers || "";

                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0;

                // Determine if successful
                isSuccess = status >= 200 && status < 300 || status === 304;

                // Get response data
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }

                // Convert no matter what (that way responseXXX fields are always set)
                response = ajaxConvert(s, response, jqXHR, isSuccess);

                // If successful, handle type chaining
                if (isSuccess) {

                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader("etag");
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }

                    // if no content
                    if (status === 204 || s.type === "HEAD") {
                        statusText = "nocontent";

                        // if not modified
                    } else if (status === 304) {
                        statusText = "notmodified";

                        // If we have data, let's convert it
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {

                    // Extract error from statusText and normalize for non-aborts
                    error = statusText;
                    if (status || !statusText) {
                        statusText = "error";
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }

                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";

                // Success/Error
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                } else {
                    deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                }

                // Status-dependent callbacks
                jqXHR.statusCode(statusCode);
                statusCode = undefined;

                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError",
                        [jqXHR, s, isSuccess ? success : error]);
                }

                // Complete
                completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [jqXHR, s]);

                    // Handle the global AJAX counter
                    if (!(--jQuery.active)) {
                        jQuery.event.trigger("ajaxStop");
                    }
                }
            }

            return jqXHR;
        },

        getJSON: function (url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },

        getScript: function (url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        }
    });

    jQuery.each(["get", "post"], function (i, method) {
        jQuery[method] = function (url, data, callback, type) {

            // Shift arguments if data argument was omitted
            if (isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }

            // The url can be an options object (which then must have .url)
            return jQuery.ajax(jQuery.extend({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            }, jQuery.isPlainObject(url) && url));
        };
    });


    jQuery._evalUrl = function (url, options) {
        return jQuery.ajax({
            url: url,

            // Make this explicit, since user can override this through ajaxSetup (#11264)
            type: "GET",
            dataType: "script",
            cache: true,
            async: false,
            global: false,

            // Only evaluate the response if it is successful (gh-4126)
            // dataFilter is not invoked for failure responses, so using it instead
            // of the default converter is kludgy but it works.
            converters: {
                "text script": function () {
                }
            },
            dataFilter: function (response) {
                jQuery.globalEval(response, options);
            }
        });
    };


    jQuery.fn.extend({
        wrapAll: function (html) {
            var wrap;

            if (this[0]) {
                if (isFunction(html)) {
                    html = html.call(this[0]);
                }

                // The elements to wrap the target around
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }

                wrap.map(function () {
                    var elem = this;

                    while (elem.firstElementChild) {
                        elem = elem.firstElementChild;
                    }

                    return elem;
                }).append(this);
            }

            return this;
        },

        wrapInner: function (html) {
            if (isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }

            return this.each(function () {
                var self = jQuery(this),
                    contents = self.contents();

                if (contents.length) {
                    contents.wrapAll(html);

                } else {
                    self.append(html);
                }
            });
        },

        wrap: function (html) {
            var htmlIsFunction = isFunction(html);

            return this.each(function (i) {
                jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
            });
        },

        unwrap: function (selector) {
            this.parent(selector).not("body").each(function () {
                jQuery(this).replaceWith(this.childNodes);
            });
            return this;
        }
    });


    jQuery.expr.pseudos.hidden = function (elem) {
        return !jQuery.expr.pseudos.visible(elem);
    };
    jQuery.expr.pseudos.visible = function (elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    };


    jQuery.ajaxSettings.xhr = function () {
        try {
            return new window.XMLHttpRequest();
        } catch (e) {
        }
    };

    var xhrSuccessStatus = {

            // File protocol always yields status code 0, assume 200
            0: 200,

            // Support: IE <=9 only
            // #1450: sometimes IE returns 1223 when it should be 204
            1223: 204
        },
        xhrSupported = jQuery.ajaxSettings.xhr();

    support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
    support.ajax = xhrSupported = !!xhrSupported;

    jQuery.ajaxTransport(function (options) {
        var callback, errorCallback;

        // Cross domain only allowed if supported through XMLHttpRequest
        if (support.cors || xhrSupported && !options.crossDomain) {
            return {
                send: function (headers, complete) {
                    var i,
                        xhr = options.xhr();

                    xhr.open(
                        options.type,
                        options.url,
                        options.async,
                        options.username,
                        options.password
                    );

                    // Apply custom fields if provided
                    if (options.xhrFields) {
                        for (i in options.xhrFields) {
                            xhr[i] = options.xhrFields[i];
                        }
                    }

                    // Override mime type if needed
                    if (options.mimeType && xhr.overrideMimeType) {
                        xhr.overrideMimeType(options.mimeType);
                    }

                    // X-Requested-With header
                    // For cross-domain requests, seeing as conditions for a preflight are
                    // akin to a jigsaw puzzle, we simply never set it to be sure.
                    // (it can always be set on a per-request basis or even using ajaxSetup)
                    // For same-domain requests, won't change header if already provided.
                    if (!options.crossDomain && !headers["X-Requested-With"]) {
                        headers["X-Requested-With"] = "XMLHttpRequest";
                    }

                    // Set headers
                    for (i in headers) {
                        xhr.setRequestHeader(i, headers[i]);
                    }

                    // Callback
                    callback = function (type) {
                        return function () {
                            if (callback) {
                                callback = errorCallback = xhr.onload =
                                    xhr.onerror = xhr.onabort = xhr.ontimeout =
                                        xhr.onreadystatechange = null;

                                if (type === "abort") {
                                    xhr.abort();
                                } else if (type === "error") {

                                    // Support: IE <=9 only
                                    // On a manual native abort, IE9 throws
                                    // errors on any property access that is not readyState
                                    if (typeof xhr.status !== "number") {
                                        complete(0, "error");
                                    } else {
                                        complete(
                                            // File: protocol always yields status 0; see #8605, #14207
                                            xhr.status,
                                            xhr.statusText
                                        );
                                    }
                                } else {
                                    complete(
                                        xhrSuccessStatus[xhr.status] || xhr.status,
                                        xhr.statusText,

                                        // Support: IE <=9 only
                                        // IE9 has no XHR2 but throws on binary (trac-11426)
                                        // For XHR2 non-text, let the caller handle it (gh-2498)
                                        (xhr.responseType || "text") !== "text" ||
                                        typeof xhr.responseText !== "string" ?
                                            {binary: xhr.response} :
                                            {text: xhr.responseText},
                                        xhr.getAllResponseHeaders()
                                    );
                                }
                            }
                        };
                    };

                    // Listen to events
                    xhr.onload = callback();
                    errorCallback = xhr.onerror = xhr.ontimeout = callback("error");

                    // Support: IE 9 only
                    // Use onreadystatechange to replace onabort
                    // to handle uncaught aborts
                    if (xhr.onabort !== undefined) {
                        xhr.onabort = errorCallback;
                    } else {
                        xhr.onreadystatechange = function () {

                            // Check readyState before timeout as it changes
                            if (xhr.readyState === 4) {

                                // Allow onerror to be called first,
                                // but that will not handle a native abort
                                // Also, save errorCallback to a variable
                                // as xhr.onerror cannot be accessed
                                window.setTimeout(function () {
                                    if (callback) {
                                        errorCallback();
                                    }
                                });
                            }
                        };
                    }

                    // Create the abort callback
                    callback = callback("abort");

                    try {

                        // Do send the request (this may raise an exception)
                        xhr.send(options.hasContent && options.data || null);
                    } catch (e) {

                        // #14683: Only rethrow if this hasn't been notified as an error yet
                        if (callback) {
                            throw e;
                        }
                    }
                },

                abort: function () {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });


    // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
    jQuery.ajaxPrefilter(function (s) {
        if (s.crossDomain) {
            s.contents.script = false;
        }
    });

    // Install script dataType
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, " +
                "application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function (text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });

    // Handle cache's special case and crossDomain
    jQuery.ajaxPrefilter("script", function (s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = "GET";
        }
    });

    // Bind script tag hack transport
    jQuery.ajaxTransport("script", function (s) {

        // This transport only deals with cross domain or forced-by-attrs requests
        if (s.crossDomain || s.scriptAttrs) {
            var script, callback;
            return {
                send: function (_, complete) {
                    script = jQuery("<script>")
                        .attr(s.scriptAttrs || {})
                        .prop({charset: s.scriptCharset, src: s.url})
                        .on("load error", callback = function (evt) {
                            script.remove();
                            callback = null;
                            if (evt) {
                                complete(evt.type === "error" ? 404 : 200, evt.type);
                            }
                        });

                    // Use native DOM manipulation to avoid our domManip AJAX trickery
                    document.head.appendChild(script[0]);
                },
                abort: function () {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });


    var oldCallbacks = [],
        rjsonp = /(=)\?(?=&|$)|\?\?/;

    // Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function () {
            var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
            this[callback] = true;
            return callback;
        }
    });

    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {

        var callbackName, overwritten, responseContainer,
            jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ?
                    "url" :
                    typeof s.data === "string" &&
                    (s.contentType || "")
                        .indexOf("application/x-www-form-urlencoded") === 0 &&
                    rjsonp.test(s.data) && "data"
            );

        // Handle iff the expected data type is "jsonp" or we have a parameter to set
        if (jsonProp || s.dataTypes[0] === "jsonp") {

            // Get callback name, remembering preexisting value associated with it
            callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ?
                s.jsonpCallback() :
                s.jsonpCallback;

            // Insert callback into url or form data
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            }

            // Use data converter to retrieve json after script execution
            s.converters["script json"] = function () {
                if (!responseContainer) {
                    jQuery.error(callbackName + " was not called");
                }
                return responseContainer[0];
            };

            // Force json dataType
            s.dataTypes[0] = "json";

            // Install callback
            overwritten = window[callbackName];
            window[callbackName] = function () {
                responseContainer = arguments;
            };

            // Clean-up function (fires after converters)
            jqXHR.always(function () {

                // If previous value didn't exist - remove it
                if (overwritten === undefined) {
                    jQuery(window).removeProp(callbackName);

                    // Otherwise restore preexisting value
                } else {
                    window[callbackName] = overwritten;
                }

                // Save back as free
                if (s[callbackName]) {

                    // Make sure that re-using the options doesn't screw things around
                    s.jsonpCallback = originalSettings.jsonpCallback;

                    // Save the callback name for future use
                    oldCallbacks.push(callbackName);
                }

                // Call if it was a function and we have a response
                if (responseContainer && isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }

                responseContainer = overwritten = undefined;
            });

            // Delegate to script
            return "script";
        }
    });


    // Support: Safari 8 only
    // In Safari 8 documents created via document.implementation.createHTMLDocument
    // collapse sibling forms: the second one becomes a child of the first one.
    // Because of that, this security measure has to be disabled in Safari 8.
    // https://bugs.webkit.org/show_bug.cgi?id=137337
    support.createHTMLDocument = (function () {
        var body = document.implementation.createHTMLDocument("").body;
        body.innerHTML = "<form></form><form></form>";
        return body.childNodes.length === 2;
    })();


    // Argument "data" should be string of html
    // context (optional): If specified, the fragment will be created in this context,
    // defaults to document
    // keepScripts (optional): If true, will include scripts passed in the html string
    jQuery.parseHTML = function (data, context, keepScripts) {
        if (typeof data !== "string") {
            return [];
        }
        if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
        }

        var base, parsed, scripts;

        if (!context) {

            // Stop scripts or inline event handlers from being executed immediately
            // by using document.implementation
            if (support.createHTMLDocument) {
                context = document.implementation.createHTMLDocument("");

                // Set the base href for the created document
                // so any parsed elements with URLs
                // are based on the document's URL (gh-2965)
                base = context.createElement("base");
                base.href = document.location.href;
                context.head.appendChild(base);
            } else {
                context = document;
            }
        }

        parsed = rsingleTag.exec(data);
        scripts = !keepScripts && [];

        // Single tag
        if (parsed) {
            return [context.createElement(parsed[1])];
        }

        parsed = buildFragment([data], context, scripts);

        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }

        return jQuery.merge([], parsed.childNodes);
    };


    /**
     * Load a url into a page
     */
    jQuery.fn.load = function (url, params, callback) {
        var selector, type, response,
            self = this,
            off = url.indexOf(" ");

        if (off > -1) {
            selector = stripAndCollapse(url.slice(off));
            url = url.slice(0, off);
        }

        // If it's a function
        if (isFunction(params)) {

            // We assume that it's the callback
            callback = params;
            params = undefined;

            // Otherwise, build a param string
        } else if (params && typeof params === "object") {
            type = "POST";
        }

        // If we have elements to modify, make the request
        if (self.length > 0) {
            jQuery.ajax({
                url: url,

                // If "type" variable is undefined, then "GET" method will be used.
                // Make value of this field explicit since
                // user can override it through ajaxSetup method
                type: type || "GET",
                dataType: "html",
                data: params
            }).done(function (responseText) {

                // Save response for use in complete callback
                response = arguments;

                self.html(selector ?

                    // If a selector was specified, locate the right elements in a dummy div
                    // Exclude scripts to avoid IE 'Permission Denied' errors
                    jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :

                    // Otherwise use the full result
                    responseText);

                // If the request succeeds, this function gets "data", "status", "jqXHR"
                // but they are ignored because response was set above.
                // If it fails, this function gets "jqXHR", "status", "error"
            }).always(callback && function (jqXHR, status) {
                self.each(function () {
                    callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
                });
            });
        }

        return this;
    };


    // Attach a bunch of functions for handling common AJAX events
    jQuery.each([
        "ajaxStart",
        "ajaxStop",
        "ajaxComplete",
        "ajaxError",
        "ajaxSuccess",
        "ajaxSend"
    ], function (i, type) {
        jQuery.fn[type] = function (fn) {
            return this.on(type, fn);
        };
    });


    jQuery.expr.pseudos.animated = function (elem) {
        return jQuery.grep(jQuery.timers, function (fn) {
            return elem === fn.elem;
        }).length;
    };


    jQuery.offset = {
        setOffset: function (elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
                position = jQuery.css(elem, "position"),
                curElem = jQuery(elem),
                props = {};

            // Set position first, in-case top/left are set even on static elem
            if (position === "static") {
                elem.style.position = "relative";
            }

            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, "top");
            curCSSLeft = jQuery.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") &&
                (curCSSTop + curCSSLeft).indexOf("auto") > -1;

            // Need to be able to calculate position if either
            // top or left is auto and position is either absolute or fixed
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;

            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }

            if (isFunction(options)) {

                // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
                options = options.call(elem, i, jQuery.extend({}, curOffset));
            }

            if (options.top != null) {
                props.top = (options.top - curOffset.top) + curTop;
            }
            if (options.left != null) {
                props.left = (options.left - curOffset.left) + curLeft;
            }

            if ("using" in options) {
                options.using.call(elem, props);

            } else {
                curElem.css(props);
            }
        }
    };

    jQuery.fn.extend({

        // offset() relates an element's border box to the document origin
        offset: function (options) {

            // Preserve chaining for setter
            if (arguments.length) {
                return options === undefined ?
                    this :
                    this.each(function (i) {
                        jQuery.offset.setOffset(this, options, i);
                    });
            }

            var rect, win,
                elem = this[0];

            if (!elem) {
                return;
            }

            // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
            // Support: IE <=11 only
            // Running getBoundingClientRect on a
            // disconnected node in IE throws an error
            if (!elem.getClientRects().length) {
                return {top: 0, left: 0};
            }

            // Get document-relative position by adding viewport scroll to viewport-relative gBCR
            rect = elem.getBoundingClientRect();
            win = elem.ownerDocument.defaultView;
            return {
                top: rect.top + win.pageYOffset,
                left: rect.left + win.pageXOffset
            };
        },

        // position() relates an element's margin box to its offset parent's padding box
        // This corresponds to the behavior of CSS absolute positioning
        position: function () {
            if (!this[0]) {
                return;
            }

            var offsetParent, offset, doc,
                elem = this[0],
                parentOffset = {top: 0, left: 0};

            // position:fixed elements are offset from the viewport, which itself always has zero offset
            if (jQuery.css(elem, "position") === "fixed") {

                // Assume position:fixed implies availability of getBoundingClientRect
                offset = elem.getBoundingClientRect();

            } else {
                offset = this.offset();

                // Account for the *real* offset parent, which can be the document or its root element
                // when a statically positioned element is identified
                doc = elem.ownerDocument;
                offsetParent = elem.offsetParent || doc.documentElement;
                while (offsetParent &&
                (offsetParent === doc.body || offsetParent === doc.documentElement) &&
                jQuery.css(offsetParent, "position") === "static") {

                    offsetParent = offsetParent.parentNode;
                }
                if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {

                    // Incorporate borders into its offset, since they are outside its content origin
                    parentOffset = jQuery(offsetParent).offset();
                    parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
                    parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
                }
            }

            // Subtract parent offsets and element margins
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
            };
        },

        // This method will return documentElement in the following cases:
        // 1) For the element inside the iframe without offsetParent, this method will return
        //    documentElement of the parent window
        // 2) For the hidden or detached element
        // 3) For body or html element, i.e. in case of the html node - it will return itself
        //
        // but those exceptions were never presented as a real life use-cases
        // and might be considered as more preferable results.
        //
        // This logic, however, is not guaranteed and can change at any point in the future
        offsetParent: function () {
            return this.map(function () {
                var offsetParent = this.offsetParent;

                while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
                    offsetParent = offsetParent.offsetParent;
                }

                return offsetParent || documentElement;
            });
        }
    });

    // Create scrollLeft and scrollTop methods
    jQuery.each({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function (method, prop) {
        var top = "pageYOffset" === prop;

        jQuery.fn[method] = function (val) {
            return access(this, function (elem, method, val) {

                // Coalesce documents and windows
                var win;
                if (isWindow(elem)) {
                    win = elem;
                } else if (elem.nodeType === 9) {
                    win = elem.defaultView;
                }

                if (val === undefined) {
                    return win ? win[prop] : elem[method];
                }

                if (win) {
                    win.scrollTo(
                        !top ? val : win.pageXOffset,
                        top ? val : win.pageYOffset
                    );

                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length);
        };
    });

    // Support: Safari <=7 - 9.1, Chrome <=37 - 49
    // Add the top/left cssHooks using jQuery.fn.position
    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
    // getComputedStyle returns percent when specified for top/left/bottom/right;
    // rather than make the css module depend on the offset module, just check for it here
    jQuery.each(["top", "left"], function (i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition,
            function (elem, computed) {
                if (computed) {
                    computed = curCSS(elem, prop);

                    // If curCSS returns percentage, fallback to offset
                    return rnumnonpx.test(computed) ?
                        jQuery(elem).position()[prop] + "px" :
                        computed;
                }
            }
        );
    });


    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
    jQuery.each({Height: "height", Width: "width"}, function (name, type) {
        jQuery.each({padding: "inner" + name, content: type, "": "outer" + name},
            function (defaultExtra, funcName) {

                // Margin is only for outerHeight, outerWidth
                jQuery.fn[funcName] = function (margin, value) {
                    var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
                        extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

                    return access(this, function (elem, type, value) {
                        var doc;

                        if (isWindow(elem)) {

                            // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
                            return funcName.indexOf("outer") === 0 ?
                                elem["inner" + name] :
                                elem.document.documentElement["client" + name];
                        }

                        // Get document width or height
                        if (elem.nodeType === 9) {
                            doc = elem.documentElement;

                            // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                            // whichever is greatest
                            return Math.max(
                                elem.body["scroll" + name], doc["scroll" + name],
                                elem.body["offset" + name], doc["offset" + name],
                                doc["client" + name]
                            );
                        }

                        return value === undefined ?

                            // Get width or height on the element, requesting but not forcing parseFloat
                            jQuery.css(elem, type, extra) :

                            // Set width or height on the element
                            jQuery.style(elem, type, value, extra);
                    }, type, chainable ? margin : undefined, chainable);
                };
            });
    });


    jQuery.each(("blur focus focusin focusout resize scroll click dblclick " +
        "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
        "change select submit keydown keypress keyup contextmenu").split(" "),
        function (i, name) {

            // Handle event binding
            jQuery.fn[name] = function (data, fn) {
                return arguments.length > 0 ?
                    this.on(name, null, data, fn) :
                    this.trigger(name);
            };
        });

    jQuery.fn.extend({
        hover: function (fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    });


    jQuery.fn.extend({

        bind: function (types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function (types, fn) {
            return this.off(types, null, fn);
        },

        delegate: function (selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function (selector, types, fn) {

            // ( namespace ) or ( selector, types [, fn] )
            return arguments.length === 1 ?
                this.off(selector, "**") :
                this.off(types, selector || "**", fn);
        }
    });

    // Bind a function to a context, optionally partially applying any
    // arguments.
    // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
    // However, it is not slated for removal any time soon
    jQuery.proxy = function (fn, context) {
        var tmp, args, proxy;

        if (typeof context === "string") {
            tmp = fn[context];
            context = fn;
            fn = tmp;
        }

        // Quick check to determine if target is callable, in the spec
        // this throws a TypeError, but we will just return undefined.
        if (!isFunction(fn)) {
            return undefined;
        }

        // Simulated bind
        args = slice.call(arguments, 2);
        proxy = function () {
            return fn.apply(context || this, args.concat(slice.call(arguments)));
        };

        // Set the guid of unique handler to the same of original handler, so it can be removed
        proxy.guid = fn.guid = fn.guid || jQuery.guid++;

        return proxy;
    };

    jQuery.holdReady = function (hold) {
        if (hold) {
            jQuery.readyWait++;
        } else {
            jQuery.ready(true);
        }
    };
    jQuery.isArray = Array.isArray;
    jQuery.parseJSON = JSON.parse;
    jQuery.nodeName = nodeName;
    jQuery.isFunction = isFunction;
    jQuery.isWindow = isWindow;
    jQuery.camelCase = camelCase;
    jQuery.type = toType;

    jQuery.now = Date.now;

    jQuery.isNumeric = function (obj) {

        // As of jQuery 3.0, isNumeric is limited to
        // strings and numbers (primitives or objects)
        // that can be coerced to finite numbers (gh-2662)
        var type = jQuery.type(obj);
        return (type === "number" || type === "string") &&

            // parseFloat NaNs numeric-cast false positives ("")
            // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
            // subtraction forces infinities to NaN
            !isNaN(obj - parseFloat(obj));
    };


    // Register as a named AMD module, since jQuery can be concatenated with other
    // files that may use define, but not via a proper concatenation script that
    // understands anonymous AMD modules. A named AMD is safest and most robust
    // way to register. Lowercase jquery is used because AMD module names are
    // derived from file names, and jQuery is normally delivered in a lowercase
    // file name. Do this after creating the global so that if an AMD module wants
    // to call noConflict to hide this version of jQuery, it will work.

    // Note that for maximum portability, libraries that are not jQuery should
    // declare themselves as anonymous modules, and avoid setting a global if an
    // AMD loader is present. jQuery is a special case. For more information, see
    // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
            return jQuery;
        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }


    var

        // Map over jQuery in case of overwrite
        _jQuery = window.jQuery,

        // Map over the $ in case of overwrite
        _$ = window.$;

    jQuery.noConflict = function (deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }

        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }

        return jQuery;
    };

    // Expose jQuery and $ identifiers, even in AMD
    // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
    // and CommonJS for browser emulators (#13566)
    if (!noGlobal) {
        window.jQuery = window.$ = jQuery;
    }


    return jQuery;
});


/***/ }),
/* 1 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(8);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {
		return null;
	}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 3 */
/***/ (function(module, exports) {

var EventCenter = (function(){

	var events = {}

	function on(evt,handler){
		events[evt] = events[evt] || []

		events[evt].push({
			handler:handler
		})
	}

	function fire(evt,args){
		if(!events[evt]){
			return
		}
		for(var i=0; i<events[evt].length; i++){
			events[evt][i].handler(args)
		}
	}

	return{
		on: on,
		fire: fire
	}

})()

module.exports = EventCenter

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(13)

var $ = __webpack_require__(0)

function toast(msg,time) {
	this.msg = msg
	this.dismissTime = time||1000
	this.createToast()
	this.showToast()
}

toast.prototype.createToast = function(){
	var tpl = '<div class="toast">'+this.msg+'</div>'
	this.$toast = $(tpl)
	$('body').append(this.$toast)
}

toast.prototype.showToast = function(){
	var self = this
	self.$toast.fadeIn(300,function(){
		setTimeout(function(){
			self.$toast.fadeOut(300,function(){
				self.$toast.remove()
			})
		},self.dismissTime)
	})
}

function Toast(msg,time){
	return new toast(msg,time)
}
module.exports.Toast = Toast

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(0)
__webpack_require__(6);

var NoteManager = __webpack_require__(9).NoteManager;
var Event = __webpack_require__(3);
var WaterFall = __webpack_require__(15);

NoteManager.load();

$('.add-note').on('click', function() {
    NoteManager.add();
})

Event.on('waterfall', function(){
    WaterFall.init($('#content'));
})

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(7);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(2)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {
	module.hot.accept("!!../../node_modules/css-loader/index.js!../../node_modules/less-loader/dist/cjs.js!./index.less", function() {
		var newContent = require("!!../../node_modules/css-loader/index.js!../../node_modules/less-loader/dist/cjs.js!./index.less");

		if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];

		var locals = (function(a, b) {
			var key, idx = 0;

			for(key in a) {
				if(!b || a[key] !== b[key]) return false;
				idx++;
			}

			for(key in b) idx--;

			return idx === 0;
		}(content.locals, newContent.locals));

		if(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');

		update(newContent);
	});

	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(false);
// imports


// module
exports.push([module.i, "html,\nbody {\n  margin: 0;\n}\nbody {\n  position: relative;\n  padding-top: 1px;\n}\nul,\nli {\n  margin: 0;\n  padding: 0;\n  list-style: none;\n}\nbody {\n  font: 14px/1.4 'Arial';\n}\na {\n  text-decoration: none;\n  color: #fff;\n}\n#header {\n  position: fixed;\n  z-index: 100;\n  width: 100%;\n  height: 30px;\n  font-size: 12px;\n}\n#header a {\n  display: block;\n  font-size: 12px;\n  margin-top: 6px;\n}\n#header .user-area {\n  padding-right: 16px;\n  float: right;\n}\n#header .user-area li {\n  float: left;\n  margin-left: 5px;\n}\n#header .user-area li span {\n  color: #fff;\n  display: block;\n  margin-top: 6px;\n}\n#header .user-area img {\n  height: 18px;\n  margin-top: 5px;\n  border-radius: 50%;\n}\n#header .setting {\n  float: right;\n  margin-left: 9px;\n  display: none;\n}\n#header .add-note {\n  float: left;\n  margin-left: 16px;\n  border: 1px solid #fff;\n  border-radius: 4px;\n  padding: 2px 4px;\n}\n#header .login {\n  float: right;\n  margin-left: 16px;\n}\n#content {\n  position: relative;\n  margin-top: 30px;\n  height: -webkit-calc(70%);\n  height: calc(70%);\n}\n@keyframes move-twink-back {\n  from {\n    background-position: 0 0;\n  }\n  to {\n    background-position: -10000px 5000px;\n  }\n}\n.stars {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  width: 100%;\n  height: 100%;\n  display: block;\n}\n.stars {\n  background: #000 url('data:image/jpeg;base64,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') repeat top center;\n  z-index: -2;\n}\n", ""]);

// exports


/***/ }),
/* 8 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(0)
var Note = __webpack_require__(10).Note;
var Toast = __webpack_require__(4).Toast;
var Event = __webpack_require__(3);



var NoteManager = (function(){
  var uname = null,clk = null
  function setLayout() {
      if(clk){
          clearTimeout(clk);
      }
      clk = setTimeout(function(){
          Event.fire('waterfall');
      },100);
  }
  function load() {
    $.get('/api/notes')
      .done(function(ret){
        if(ret.status == 0){
          uname = ret.data.uname
          $.each(ret.data.notes, function(idx, article) {
              new Note({
                id: article.id,
                context: article.content,
                uname: article.uname
              });
          });

          Event.fire('waterfall');
        }else{
          Toast(ret.errorMsg);
        }
      })
      .fail(function(){
        Toast('网络异常');
      });


  }

  function add(){
    new Note({uname:uname});
    setLayout()
  }

  return {
    load: load,
    add: add
  }

})();

module.exports.NoteManager = NoteManager

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(11);

var $ = __webpack_require__(0)
var Toast = __webpack_require__(4).Toast;
var Event = __webpack_require__(3);

function Note(opts){
  this.initOpts(opts);
  this.createNote();
  this.setStyle();
  this.bindEvent();
}
Note.prototype = {
  colors: [
    ['#ea9b35','#efb04e'], // headColor, containerColor
    ['#dd598b','#e672a2'],
    ['#eee34b','#f2eb67'],
    ['#c24226','#d15a39'],
    ['#c1c341','#d0d25c'],
    ['#3f78c3','#5591d2']
  ],

  defaultOpts: {
    id: '',   //Note的 id
    $ct: $('#content').length>0?$('#content'):$('body'),  //默认存放 Note 的容器
    context: 'input here'  //Note 的内容
  },

  initOpts: function (opts) {
    this.opts = $.extend({}, this.defaultOpts, opts||{});
    if(this.opts.id){
       this.id = this.opts.id;
    }
  },

  createNote: function () {
    var tpl =  '<div class="note">'
              + '<div class="note-head"><span class="username"></span><span class="delete">&times;</span></div>'
              + '<div class="note-ct" contenteditable="true"></div>'
              +'</div>';
    this.$note = $(tpl);
    //console.log(this.opts,this.opts.uname)
    this.$note.find('.note-head>.username').html(this.opts.uname+':说')
    this.$note.find('.note-ct').html(this.opts.context);
    this.opts.$ct.append(this.$note);
    // if(!this.id)  this.$note.css('bottom', '10px');  //新增放到右边
  },

  setStyle: function () {
    var color = this.colors[Math.floor(Math.random()*6)];
    this.$note.find('.note-head').css('background-color', color[0]);
    this.$note.find('.note-ct').css('background-color', color[1]);
  },

  setLayout: function(){
    var self = this;
    if(self.clk){
      clearTimeout(self.clk);
    }
    self.clk = setTimeout(function(){
      Event.fire('waterfall');
    },100);
  },

  bindEvent: function () {
    var self = this,
        $note = this.$note,
        $noteHead = $note.find('.note-head'),
        $noteCt = $note.find('.note-ct'),
        $delete = $note.find('.delete');

    $delete.on('click', function(){
      self.delete();
    })

    //contenteditable没有 change 事件，所有这里做了模拟通过判断元素内容变动，执行 save
    $noteCt.on('focus', function() {
      if($noteCt.html()=='input here') $noteCt.html('');
      $noteCt.data('before', $noteCt.html());
    }).on('blur paste', function() {
      if( $noteCt.data('before') != $noteCt.html() ) {
        $noteCt.data('before',$noteCt.html());
        self.setLayout();
        if(self.id){
          self.edit($noteCt.html())
        }else{
          self.add($noteCt.html())
        }
      }else{
          self.setLayout();
      }
    });

    //设置笔记的移动
    $noteHead.on('mousedown', function(e){
      var evtX = e.pageX - $note.offset().left,   //evtX 计算事件的触发点在 dialog内部到 dialog 的左边缘的距离
          evtY = e.pageY - $note.offset().top;
      $note.addClass('draggable').data('evtPos', {x:evtX, y:evtY}); //把事件到 dialog 边缘的距离保存下来
    }).on('mouseup', function(){
       $note.removeClass('draggable').removeData('pos');
    });

    $('body').on('mousemove', function(e){
      $('.draggable').length && $('.draggable').offset({
        top: e.pageY-$('.draggable').data('evtPos').y,    // 当用户鼠标移动时，根据鼠标的位置和前面保存的距离，计算 dialog 的绝对位置
        left: e.pageX-$('.draggable').data('evtPos').x
      });
    });
  },

  edit: function (msg) {
    $.post('/api/note/edit',{
        id: this.id,
        note: msg
      }).done(function(ret){
      if(ret.status === 0){
        Toast(ret.data.msg);
      }else{
        Toast(ret.msg);
      }
    })
  },

  add: function (msg){
    var self = this;
    $.post('/api/note/add', {note: msg})
      .done(function(ret){
        if(ret.data.code == -200) {
            self.$note.remove();
        }
          if(ret.data.code == 200) {
              self.id = ret.data.insertId;
          }
        Toast(ret.data.msg);
        Event.fire('waterfall');
      });
    //todo
  },

  delete: function(){
    var self = this;
      if(!this.id){
          Toast('delete success');
          self.$note.remove();
          Event.fire('waterfall');
          return;
      }
    $.post('/api/note/delete', {id: this.id})
      .done(function(ret){
        if(ret.status === 0){
          Toast(ret.data.msg);
          if(ret.data.code == 200){
              self.$note.remove();
              Event.fire('waterfall')
          }

        }else{
          Toast(ret.msg);
        }
    });

  }

};

module.exports.Note = Note;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(12);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(2)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {
	module.hot.accept("!!../../node_modules/css-loader/index.js!../../node_modules/less-loader/dist/cjs.js!./note.less", function() {
		var newContent = require("!!../../node_modules/css-loader/index.js!../../node_modules/less-loader/dist/cjs.js!./note.less");

		if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];

		var locals = (function(a, b) {
			var key, idx = 0;

			for(key in a) {
				if(!b || a[key] !== b[key]) return false;
				idx++;
			}

			for(key in b) idx--;

			return idx === 0;
		}(content.locals, newContent.locals));

		if(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');

		update(newContent);
	});

	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(false);
// imports


// module
exports.push([module.i, ".note {\n  position: absolute;\n  color: #333;\n  width: 160px;\n  margin: 20px 10px;\n  transition: all 0.5s;\n}\n.note .note-head {\n  height: 30px;\n  background-color: #ea9b35;\n  cursor: move;\n}\n.note .note-head .username {\n  color: #777;\n  font-size: 12px;\n  padding-left: 3px;\n  line-height: 30px;\n}\n.note .note-head:hover .delete {\n  opacity: 1;\n}\n.note .note-head:before {\n  position: absolute;\n  left: 50%;\n  top: -11px;\n  margin-left: -32px;\n  content: ' ';\n  display: block;\n  width: 64px;\n  height: 18px;\n  background: #35bba3;\n}\n.note .note-head:after {\n  position: absolute;\n  left: 50%;\n  margin-left: 32px;\n  top: -11px;\n  z-index: -1;\n  content: '';\n  display: block;\n  width: 0;\n  height: 0;\n  border-left: 5px solid #299683;\n  border-top: 18px solid transparent;\n}\n.note .note-ct {\n  padding: 10px;\n  background-color: #efb04e;\n  outline: none;\n}\n.note .note-ct div {\n  border-top: 1px solid #a776;\n}\n.note .delete {\n  position: absolute;\n  top: 4px;\n  right: 4px;\n  font-size: 16px;\n  color: #fff;\n  cursor: pointer;\n  opacity: 0;\n  transition: opacity .3s;\n}\n.draggable {\n  opacity: 0.8;\n  cursor: move;\n  transition: none;\n}\n", ""]);

// exports


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(14);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(2)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {
	module.hot.accept("!!../../node_modules/css-loader/index.js!../../node_modules/less-loader/dist/cjs.js!./toast.less", function() {
		var newContent = require("!!../../node_modules/css-loader/index.js!../../node_modules/less-loader/dist/cjs.js!./toast.less");

		if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];

		var locals = (function(a, b) {
			var key, idx = 0;

			for(key in a) {
				if(!b || a[key] !== b[key]) return false;
				idx++;
			}

			for(key in b) idx--;

			return idx === 0;
		}(content.locals, newContent.locals));

		if(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');

		update(newContent);
	});

	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(false);
// imports


// module
exports.push([module.i, ".toast {\n  position: fixed;\n  left: 50%;\n  transform: translateX(-50%);\n  bottom: 20px;\n  color: #D15A39;\n  background: #fff;\n  padding: 5px 10px;\n  border-radius: 3px;\n  box-shadow: 0px 0px 3px 1px rgba(255, 255, 255, 0.6);\n  display: none;\n}\n", ""]);

// exports


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(0)
var WaterFall = (function(){
  var $ct;
  var $items;

  function render($c){
    if(!$c)return;
    $ct = $c;
    $items = $ct.children() ? $ct.children() : null;

    if(!$items)return;

    var nodeWidth = $items.outerWidth(true),
      colNum = parseInt($(window).width()/nodeWidth),
      colSumHeight = [];

    for(var i = 0; i<colNum;i++){
      colSumHeight.push(0);
    }

    $items.each(function(){
      var $cur = $(this);

      //colSumHeight = [100, 250, 80, 200]

      var idx = 0,
          minSumHeight = colSumHeight[0];
          maxSumHeight = colSumHeight[0];

      for(var i=0;i<colSumHeight.length; i++){
        if(colSumHeight[i] < minSumHeight){
          idx = i;
          minSumHeight = colSumHeight[i];
        }else{
            maxSumHeight = colSumHeight[i];
        }
      }

      $cur.css({
        left: nodeWidth*idx,
        top: minSumHeight
      });
      $ct.css({
          height: maxSumHeight + 500
      })
      colSumHeight[idx] = $cur.outerHeight(true) + colSumHeight[idx];
    });
  }


  $(window).on('resize', function(){
    render($ct);
  })


  return {
    init: render
  }
})();

module.exports = WaterFall

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNTI0ODkzMDE5MTQzOWE5ZmQ3MjYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9qcXVlcnktMy40LjAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbW9kL2V2ZW50LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9tb2QvdG9hc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2FwcC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbGVzcy9pbmRleC5sZXNzP2Y2YjIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xlc3MvaW5kZXgubGVzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9tb2Qvbm90ZS1tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9tb2Qvbm90ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbGVzcy9ub3RlLmxlc3M/NzdiZSIsIndlYnBhY2s6Ly8vLi9zcmMvbGVzcy9ub3RlLmxlc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xlc3MvdG9hc3QubGVzcz83MTFhIiwid2VicGFjazovLy8uL3NyYy9sZXNzL3RvYXN0Lmxlc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL21vZC93YXRlcmZhbGwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsWUFBWTs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsMkJBQTJCLGdDQUFnQztBQUMzRCxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3Qix1Q0FBdUMsd0JBQXdCOztBQUUvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtEQUFrRDtBQUNsRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjs7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a0RBQWtEO0FBQ2xELGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxhQUFhO0FBQ2xELGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsU0FBUztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOzs7QUFHQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7O0FBRUEsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxPQUFPO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCOztBQUVsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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Q0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7OztBQUdMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0QsT0FBTztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxPQUFPOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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Q0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsU0FBUztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxQkFBcUI7QUFDbEUsNkNBQTZDLHVCQUF1QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsK0JBQStCLHFDQUFxQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0VBQWdFO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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Y0FBYyxtQkFBTyxDQUFDLEVBQWtHOztBQUV4SCw0Q0FBNEMsUUFBUzs7QUFFckQ7QUFDQTs7OztBQUlBLGVBQWU7O0FBRWY7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsQ0FBbUQ7O0FBRXhFOztBQUVBLEdBQUcsS0FBVTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQSxFQUFFOztBQUVGLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMsQzs7Ozs7O0FDNUNBLDJCQUEyQixtQkFBTyxDQUFDLENBQStDO0FBQ2xGOzs7QUFHQTtBQUNBLGNBQWMsUUFBUyxXQUFXLG9CQUFvQixjQUFjLGdDQUFnQyxpQkFBaUIsbUJBQW1CLHFCQUFxQixzQkFBc0IsdUJBQXVCLHlEQUF5RCxrQkFBa0IsR0FBRzs7QUFFeFI7Ozs7Ozs7QUNQQSxRQUFRLG1CQUFPLENBQUMsQ0FBUTtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCwwQiIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDUyNDg5MzAxOTE0MzlhOWZkNzI2IiwiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYzLjQuMFxuICogaHR0cHM6Ly9qcXVlcnkuY29tL1xuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTktMDQtMTBUMTk6NDhaXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXG4gICAgICAgIC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2BcbiAgICAgICAgLy8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cbiAgICAgICAgLy8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBoYXZlIGEgYHdpbmRvd2Agd2l0aCBhIGBkb2N1bWVudGBcbiAgICAgICAgLy8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG4gICAgICAgIC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG4gICAgICAgIC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcbiAgICAgICAgLy8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuICAgICAgICAgICAgZmFjdG9yeShnbG9iYWwsIHRydWUpIDpcbiAgICAgICAgICAgIGZ1bmN0aW9uICh3KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3LmRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KHcpO1xuICAgICAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmYWN0b3J5KGdsb2JhbCk7XG4gICAgfVxuXG4gICAgLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0pKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiAod2luZG93LCBub0dsb2JhbCkge1xuXG4gICAgLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4gICAgLy8gdGhyb3cgZXhjZXB0aW9ucyB3aGVuIG5vbi1zdHJpY3QgY29kZSAoZS5nLiwgQVNQLk5FVCA0LjUpIGFjY2Vzc2VzIHN0cmljdCBtb2RlXG4gICAgLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cbiAgICAvLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBhcnIgPSBbXTtcblxuICAgIHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxuICAgIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxuICAgIHZhciBzbGljZSA9IGFyci5zbGljZTtcblxuICAgIHZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG4gICAgdmFyIHB1c2ggPSBhcnIucHVzaDtcblxuICAgIHZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XG5cbiAgICB2YXIgY2xhc3MydHlwZSA9IHt9O1xuXG4gICAgdmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxuICAgIHZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuXG4gICAgdmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbiAgICB2YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuICAgIHZhciBzdXBwb3J0ID0ge307XG5cbiAgICB2YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9NTcsIEZpcmVmb3ggPD01MlxuICAgICAgICAvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcbiAgICAgICAgLy8gKGkuZS4sIGB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvYmplY3RcIiApID09PSBcImZ1bmN0aW9uXCJgKS5cbiAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBjbGFzc2lmeSAqYW55KiBET00gbm9kZSBhcyBhIGZ1bmN0aW9uLlxuICAgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgIT09IFwibnVtYmVyXCI7XG4gICAgfTtcblxuXG4gICAgdmFyIGlzV2luZG93ID0gZnVuY3Rpb24gaXNXaW5kb3cob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG4gICAgfTtcblxuXG4gICAgdmFyIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIHR5cGU6IHRydWUsXG4gICAgICAgIHNyYzogdHJ1ZSxcbiAgICAgICAgbm9uY2U6IHRydWUsXG4gICAgICAgIG5vTW9kdWxlOiB0cnVlXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIERPTUV2YWwoY29kZSwgbm9kZSwgZG9jKSB7XG4gICAgICAgIGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuICAgICAgICB2YXIgaSwgdmFsLFxuICAgICAgICAgICAgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG5cbiAgICAgICAgc2NyaXB0LnRleHQgPSBjb2RlO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgZm9yIChpIGluIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMpIHtcblxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggNjQrLCBFZGdlIDE4K1xuICAgICAgICAgICAgICAgIC8vIFNvbWUgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgXCJub25jZVwiIHByb3BlcnR5IG9uIHNjcmlwdHMuXG4gICAgICAgICAgICAgICAgLy8gT24gdGhlIG90aGVyIGhhbmQsIGp1c3QgdXNpbmcgYGdldEF0dHJpYnV0ZWAgaXMgbm90IGVub3VnaCBhc1xuICAgICAgICAgICAgICAgIC8vIHRoZSBgbm9uY2VgIGF0dHJpYnV0ZSBpcyByZXNldCB0byBhbiBlbXB0eSBzdHJpbmcgd2hlbmV2ZXIgaXRcbiAgICAgICAgICAgICAgICAvLyBiZWNvbWVzIGJyb3dzaW5nLWNvbnRleHQgY29ubmVjdGVkLlxuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2h0bWwvaXNzdWVzLzIzNjlcbiAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jbm9uY2UtYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIC8vIFRoZSBgbm9kZS5nZXRBdHRyaWJ1dGVgIGNoZWNrIHdhcyBhZGRlZCBmb3IgdGhlIHNha2Ugb2ZcbiAgICAgICAgICAgICAgICAvLyBgalF1ZXJ5Lmdsb2JhbEV2YWxgIHNvIHRoYXQgaXQgY2FuIGZha2UgYSBub25jZS1jb250YWluaW5nIG5vZGVcbiAgICAgICAgICAgICAgICAvLyB2aWEgYW4gb2JqZWN0LlxuICAgICAgICAgICAgICAgIHZhbCA9IG5vZGVbaV0gfHwgbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoaSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHQuc2V0QXR0cmlidXRlKGksIHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRvYy5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gdG9UeXBlKG9iaikge1xuICAgICAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogKyBcIlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG4gICAgICAgICAgICBjbGFzczJ0eXBlW3RvU3RyaW5nLmNhbGwob2JqKV0gfHwgXCJvYmplY3RcIiA6XG4gICAgICAgICAgICB0eXBlb2Ygb2JqO1xuICAgIH1cblxuICAgIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgICAvLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMuanNvbiB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuICAgIC8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuICAgIHZhclxuICAgICAgICB2ZXJzaW9uID0gXCIzLjQuMFwiLFxuXG4gICAgICAgIC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG4gICAgICAgIGpRdWVyeSA9IGZ1bmN0aW9uIChzZWxlY3RvciwgY29udGV4dCkge1xuXG4gICAgICAgICAgICAvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcbiAgICAgICAgICAgIC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG4gICAgICAgICAgICByZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KHNlbGVjdG9yLCBjb250ZXh0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG4gICAgICAgIHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nO1xuXG4gICAgalF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG4gICAgICAgIGpxdWVyeTogdmVyc2lvbixcblxuICAgICAgICBjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG4gICAgICAgIC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuICAgICAgICBsZW5ndGg6IDAsXG5cbiAgICAgICAgdG9BcnJheTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuICAgICAgICAvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChudW0pIHtcblxuICAgICAgICAgICAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuICAgICAgICAgICAgaWYgKG51bSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcbiAgICAgICAgICAgIHJldHVybiBudW0gPCAwID8gdGhpc1tudW0gKyB0aGlzLmxlbmd0aF0gOiB0aGlzW251bV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuICAgICAgICAvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcbiAgICAgICAgcHVzaFN0YWNrOiBmdW5jdGlvbiAoZWxlbXMpIHtcblxuICAgICAgICAgICAgLy8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcbiAgICAgICAgICAgIHZhciByZXQgPSBqUXVlcnkubWVyZ2UodGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyk7XG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG4gICAgICAgICAgICByZXQucHJldk9iamVjdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG4gICAgICAgIGVhY2g6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5lYWNoKHRoaXMsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICBtYXA6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGpRdWVyeS5tYXAodGhpcywgZnVuY3Rpb24gKGVsZW0sIGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChlbGVtLCBpLCBlbGVtKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzbGljZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpcnN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcSgwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBsYXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcSgtMSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXE6IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaiA9ICtpICsgKGkgPCAwID8gbGVuIDogMCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soaiA+PSAwICYmIGogPCBsZW4gPyBbdGhpc1tqXV0gOiBbXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gICAgICAgIC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuICAgICAgICBwdXNoOiBwdXNoLFxuICAgICAgICBzb3J0OiBhcnIuc29ydCxcbiAgICAgICAgc3BsaWNlOiBhcnIuc3BsaWNlXG4gICAgfTtcblxuICAgIGpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG4gICAgICAgICAgICB0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sXG4gICAgICAgICAgICBpID0gMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBkZWVwID0gZmFsc2U7XG5cbiAgICAgICAgLy8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIGRlZXAgPSB0YXJnZXQ7XG5cbiAgICAgICAgICAgIC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcbiAgICAgICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1tpXSB8fCB7fTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhaXNGdW5jdGlvbih0YXJnZXQpKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuICAgICAgICBpZiAoaSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICAvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG4gICAgICAgICAgICBpZiAoKG9wdGlvbnMgPSBhcmd1bWVudHNbaV0pICE9IG51bGwpIHtcblxuICAgICAgICAgICAgICAgIC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3RcbiAgICAgICAgICAgICAgICBmb3IgKG5hbWUgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gb3B0aW9uc1tuYW1lXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IE9iamVjdC5wcm90b3R5cGUgcG9sbHV0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwiX19wcm90b19fXCIgfHwgdGFyZ2V0ID09PSBjb3B5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVlcCAmJiBjb3B5ICYmIChqUXVlcnkuaXNQbGFpbk9iamVjdChjb3B5KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheShjb3B5KSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcmMgPSB0YXJnZXRbbmFtZV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBwcm9wZXIgdHlwZSBmb3IgdGhlIHNvdXJjZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvcHlJc0FycmF5ICYmICFBcnJheS5pc0FycmF5KHNyYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghY29weUlzQXJyYXkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KHNyYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0galF1ZXJ5LmV4dGVuZChkZWVwLCBjbG9uZSwgY29weSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb3B5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IGNvcHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG5cbiAgICBqUXVlcnkuZXh0ZW5kKHtcblxuICAgICAgICAvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2VcbiAgICAgICAgZXhwYW5kbzogXCJqUXVlcnlcIiArICh2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSkucmVwbGFjZSgvXFxEL2csIFwiXCIpLFxuXG4gICAgICAgIC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG4gICAgICAgIGlzUmVhZHk6IHRydWUsXG5cbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG5vb3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgfSxcblxuICAgICAgICBpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICB2YXIgcHJvdG8sIEN0b3I7XG5cbiAgICAgICAgICAgIC8vIERldGVjdCBvYnZpb3VzIG5lZ2F0aXZlc1xuICAgICAgICAgICAgLy8gVXNlIHRvU3RyaW5nIGluc3RlYWQgb2YgalF1ZXJ5LnR5cGUgdG8gY2F0Y2ggaG9zdCBvYmplY3RzXG4gICAgICAgICAgICBpZiAoIW9iaiB8fCB0b1N0cmluZy5jYWxsKG9iaikgIT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByb3RvID0gZ2V0UHJvdG8ob2JqKTtcblxuICAgICAgICAgICAgLy8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxuICAgICAgICAgICAgaWYgKCFwcm90bykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuICAgICAgICAgICAgQ3RvciA9IGhhc093bi5jYWxsKHByb3RvLCBcImNvbnN0cnVjdG9yXCIpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBDdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgZm5Ub1N0cmluZy5jYWxsKEN0b3IpID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcbiAgICAgICAgfSxcblxuICAgICAgICBpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICB2YXIgbmFtZTtcblxuICAgICAgICAgICAgZm9yIChuYW1lIGluIG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG4gICAgICAgIGdsb2JhbEV2YWw6IGZ1bmN0aW9uIChjb2RlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBET01FdmFsKGNvZGUsIHtub25jZTogb3B0aW9ucyAmJiBvcHRpb25zLm5vbmNlfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZWFjaDogZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGgsIGkgPSAwO1xuXG4gICAgICAgICAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IG9iai5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChvYmpbaV0sIGksIG9ialtpXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChvYmpbaV0sIGksIG9ialtpXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcbiAgICAgICAgdHJpbTogZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0ID09IG51bGwgP1xuICAgICAgICAgICAgICAgIFwiXCIgOlxuICAgICAgICAgICAgICAgICh0ZXh0ICsgXCJcIikucmVwbGFjZShydHJpbSwgXCJcIik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuICAgICAgICBtYWtlQXJyYXk6IGZ1bmN0aW9uIChhcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG4gICAgICAgICAgICBpZiAoYXJyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheUxpa2UoT2JqZWN0KGFycikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZShyZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbYXJyXSA6IGFyclxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2guY2FsbChyZXQsIGFycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGluQXJyYXk6IGZ1bmN0aW9uIChlbGVtLCBhcnIsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKGFyciwgZWxlbSwgaSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG4gICAgICAgIC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcbiAgICAgICAgbWVyZ2U6IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaiA9IDAsXG4gICAgICAgICAgICAgICAgaSA9IGZpcnN0Lmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yICg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgIGZpcnN0W2krK10gPSBzZWNvbmRbal07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpcnN0Lmxlbmd0aCA9IGk7XG5cbiAgICAgICAgICAgIHJldHVybiBmaXJzdDtcbiAgICAgICAgfSxcblxuICAgICAgICBncmVwOiBmdW5jdGlvbiAoZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQpIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFja0ludmVyc2UsXG4gICAgICAgICAgICAgICAgbWF0Y2hlcyA9IFtdLFxuICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cbiAgICAgICAgICAgIC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcbiAgICAgICAgICAgIC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKGVsZW1zW2ldLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goZWxlbXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG4gICAgICAgIG1hcDogZnVuY3Rpb24gKGVsZW1zLCBjYWxsYmFjaywgYXJnKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoLCB2YWx1ZSxcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICByZXQgPSBbXTtcblxuICAgICAgICAgICAgLy8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcbiAgICAgICAgICAgIGlmIChpc0FycmF5TGlrZShlbGVtcykpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrKGVsZW1zW2ldLCBpLCBhcmcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgaW4gZWxlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjayhlbGVtc1tpXSwgaSwgYXJnKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG4gICAgICAgICAgICByZXR1cm4gY29uY2F0LmFwcGx5KFtdLCByZXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuICAgICAgICBndWlkOiAxLFxuXG4gICAgICAgIC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuICAgICAgICAvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuICAgICAgICBzdXBwb3J0OiBzdXBwb3J0XG4gICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGpRdWVyeS5mbltTeW1ib2wuaXRlcmF0b3JdID0gYXJyW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgfVxuXG4gICAgLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG4gICAgalF1ZXJ5LmVhY2goXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KFwiIFwiKSxcbiAgICAgICAgZnVuY3Rpb24gKGksIG5hbWUpIHtcbiAgICAgICAgICAgIGNsYXNzMnR5cGVbXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSk7XG5cbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZShvYmopIHtcblxuICAgICAgICAvLyBTdXBwb3J0OiByZWFsIGlPUyA4LjIgb25seSAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG4gICAgICAgIC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcbiAgICAgICAgLy8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG4gICAgICAgIC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcbiAgICAgICAgdmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG4gICAgICAgICAgICB0eXBlID0gdG9UeXBlKG9iaik7XG5cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ob2JqKSB8fCBpc1dpbmRvdyhvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgdHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmIChsZW5ndGggLSAxKSBpbiBvYmo7XG4gICAgfVxuXG4gICAgdmFyIFNpenpsZSA9XG4gICAgLyohXG4gICAgKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjRcbiAgICAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICAgICpcbiAgICAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAgICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICAgICogaHR0cHM6Ly9qcy5mb3VuZGF0aW9uL1xuICAgICpcbiAgICAqIERhdGU6IDIwMTktMDQtMDhcbiAgICAqL1xuICAgICAgICAoZnVuY3Rpb24gKHdpbmRvdykge1xuXG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICBzdXBwb3J0LFxuICAgICAgICAgICAgICAgIEV4cHIsXG4gICAgICAgICAgICAgICAgZ2V0VGV4dCxcbiAgICAgICAgICAgICAgICBpc1hNTCxcbiAgICAgICAgICAgICAgICB0b2tlbml6ZSxcbiAgICAgICAgICAgICAgICBjb21waWxlLFxuICAgICAgICAgICAgICAgIHNlbGVjdCxcbiAgICAgICAgICAgICAgICBvdXRlcm1vc3RDb250ZXh0LFxuICAgICAgICAgICAgICAgIHNvcnRJbnB1dCxcbiAgICAgICAgICAgICAgICBoYXNEdXBsaWNhdGUsXG5cbiAgICAgICAgICAgICAgICAvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG4gICAgICAgICAgICAgICAgc2V0RG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgZG9jRWxlbSxcbiAgICAgICAgICAgICAgICBkb2N1bWVudElzSFRNTCxcbiAgICAgICAgICAgICAgICByYnVnZ3lRU0EsXG4gICAgICAgICAgICAgICAgcmJ1Z2d5TWF0Y2hlcyxcbiAgICAgICAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5zLFxuXG4gICAgICAgICAgICAgICAgLy8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuICAgICAgICAgICAgICAgIGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgcHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuICAgICAgICAgICAgICAgIGRpcnJ1bnMgPSAwLFxuICAgICAgICAgICAgICAgIGRvbmUgPSAwLFxuICAgICAgICAgICAgICAgIGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuICAgICAgICAgICAgICAgIHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuICAgICAgICAgICAgICAgIGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuICAgICAgICAgICAgICAgIG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuICAgICAgICAgICAgICAgIHNvcnRPcmRlciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNEdXBsaWNhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBJbnN0YW5jZSBtZXRob2RzXG4gICAgICAgICAgICAgICAgaGFzT3duID0gKHt9KS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBhcnIgPSBbXSxcbiAgICAgICAgICAgICAgICBwb3AgPSBhcnIucG9wLFxuICAgICAgICAgICAgICAgIHB1c2hfbmF0aXZlID0gYXJyLnB1c2gsXG4gICAgICAgICAgICAgICAgcHVzaCA9IGFyci5wdXNoLFxuICAgICAgICAgICAgICAgIHNsaWNlID0gYXJyLnNsaWNlLFxuICAgICAgICAgICAgICAgIC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcbiAgICAgICAgICAgICAgICBpbmRleE9mID0gZnVuY3Rpb24gKGxpc3QsIGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaXN0W2ldID09PSBlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuICAgICAgICAgICAgICAgIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG4gICAgICAgICAgICAgICAgd2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcMC1cXFxceGEwXSkrXCIsXG5cbiAgICAgICAgICAgICAgICAvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuICAgICAgICAgICAgICAgICAgICBcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuICAgICAgICAgICAgICAgICAgICAvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuICAgICAgICAgICAgICAgICAgICBcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICsgd2hpdGVzcGFjZSArXG4gICAgICAgICAgICAgICAgICAgIFwiKlxcXFxdXCIsXG5cbiAgICAgICAgICAgICAgICBwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICtcbiAgICAgICAgICAgICAgICAgICAgLy8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcbiAgICAgICAgICAgICAgICAgICAgLy8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG4gICAgICAgICAgICAgICAgICAgIFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuICAgICAgICAgICAgICAgICAgICAvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcbiAgICAgICAgICAgICAgICAgICAgXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuICAgICAgICAgICAgICAgICAgICAvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG4gICAgICAgICAgICAgICAgICAgIFwiLipcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiKVxcXFwpfClcIixcblxuICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcbiAgICAgICAgICAgICAgICByd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAod2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiksXG4gICAgICAgICAgICAgICAgcnRyaW0gPSBuZXcgUmVnRXhwKFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiKSxcblxuICAgICAgICAgICAgICAgIHJjb21tYSA9IG5ldyBSZWdFeHAoXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiKSxcbiAgICAgICAgICAgICAgICByY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgKyBcIipcIiksXG4gICAgICAgICAgICAgICAgcmRlc2NlbmQgPSBuZXcgUmVnRXhwKHdoaXRlc3BhY2UgKyBcInw+XCIpLFxuXG4gICAgICAgICAgICAgICAgcnBzZXVkbyA9IG5ldyBSZWdFeHAocHNldWRvcyksXG4gICAgICAgICAgICAgICAgcmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiKSxcblxuICAgICAgICAgICAgICAgIG1hdGNoRXhwciA9IHtcbiAgICAgICAgICAgICAgICAgICAgXCJJRFwiOiBuZXcgUmVnRXhwKFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIpLFxuICAgICAgICAgICAgICAgICAgICBcIkNMQVNTXCI6IG5ldyBSZWdFeHAoXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIpLFxuICAgICAgICAgICAgICAgICAgICBcIlRBR1wiOiBuZXcgUmVnRXhwKFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIpLFxuICAgICAgICAgICAgICAgICAgICBcIkFUVFJcIjogbmV3IFJlZ0V4cChcIl5cIiArIGF0dHJpYnV0ZXMpLFxuICAgICAgICAgICAgICAgICAgICBcIlBTRVVET1wiOiBuZXcgUmVnRXhwKFwiXlwiICsgcHNldWRvcyksXG4gICAgICAgICAgICAgICAgICAgIFwiQ0hJTERcIjogbmV3IFJlZ0V4cChcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIpLFxuICAgICAgICAgICAgICAgICAgICBcImJvb2xcIjogbmV3IFJlZ0V4cChcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiksXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuICAgICAgICAgICAgICAgICAgICAvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG4gICAgICAgICAgICAgICAgICAgIFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIpXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHJodG1sID0gL0hUTUwkL2ksXG4gICAgICAgICAgICAgICAgcmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG4gICAgICAgICAgICAgICAgcmhlYWRlciA9IC9eaFxcZCQvaSxcblxuICAgICAgICAgICAgICAgIHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG4gICAgICAgICAgICAgICAgLy8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG4gICAgICAgICAgICAgICAgcnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG4gICAgICAgICAgICAgICAgcnNpYmxpbmcgPSAvWyt+XS8sXG5cbiAgICAgICAgICAgICAgICAvLyBDU1MgZXNjYXBlc1xuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICBydW5lc2NhcGUgPSBuZXcgUmVnRXhwKFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fChcIiArIHdoaXRlc3BhY2UgKyBcIil8LilcIiwgXCJpZ1wiKSxcbiAgICAgICAgICAgICAgICBmdW5lc2NhcGUgPSBmdW5jdGlvbiAoXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogRmlyZWZveDwyNFxuICAgICAgICAgICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xuICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZCA6XG4gICAgICAgICAgICAgICAgICAgICAgICBoaWdoIDwgMCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQk1QIGNvZGVwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaGlnaCArIDB4MTAwMDApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNjb21tb24tc2VyaWFsaXppbmctaWRpb21zXG4gICAgICAgICAgICAgICAgcmNzc2VzY2FwZSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxcMC1cXHgxZlxceDdmLVxcdUZGRkZcXHctXS9nLFxuICAgICAgICAgICAgICAgIGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiAoY2gsIGFzQ29kZVBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhc0NvZGVQb2ludCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVKzAwMDAgTlVMTCBiZWNvbWVzIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gXCJcXDBcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlxcdUZGRkRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaC5zbGljZSgwLCAtMSkgKyBcIlxcXFxcIiArIGNoLmNoYXJDb2RlQXQoY2gubGVuZ3RoIC0gMSkudG9TdHJpbmcoMTYpICsgXCIgXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlxcXFxcIiArIGNoO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBVc2VkIGZvciBpZnJhbWVzXG4gICAgICAgICAgICAgICAgLy8gU2VlIHNldERvY3VtZW50KClcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcbiAgICAgICAgICAgICAgICAvLyBlcnJvciBpbiBJRVxuICAgICAgICAgICAgICAgIHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldERvY3VtZW50KCk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGluRGlzYWJsZWRGaWVsZHNldCA9IGFkZENvbWJpbmF0b3IoXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZmllbGRzZXRcIjtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge2RpcjogXCJwYXJlbnROb2RlXCIsIG5leHQ6IFwibGVnZW5kXCJ9XG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHB1c2guYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIChhcnIgPSBzbGljZS5jYWxsKHByZWZlcnJlZERvYy5jaGlsZE5vZGVzKSksXG4gICAgICAgICAgICAgICAgICAgIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuICAgICAgICAgICAgICAgIC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcbiAgICAgICAgICAgICAgICBhcnJbcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoXS5ub2RlVHlwZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBwdXNoID0ge1xuICAgICAgICAgICAgICAgICAgICBhcHBseTogYXJyLmxlbmd0aCA/XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodGFyZ2V0LCBlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoX25hdGl2ZS5hcHBseSh0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU8OVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHRhcmdldCwgZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKHRhcmdldFtqKytdID0gZWxzW2krK10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5sZW5ndGggPSBqIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBTaXp6bGUoc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3RvcixcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgbm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cbiAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuICAgICAgICAgICAgICAgIC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgbm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuICAgICAgICAgICAgICAgIGlmICghc2VlZCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgoY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jKSAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldERvY3VtZW50KGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudElzSFRNTCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVUeXBlICE9PSAxMSAmJiAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoc2VsZWN0b3IpKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUQgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG0gPSBtYXRjaFsxXSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb2N1bWVudCBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PT0gOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZChtKSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0uaWQgPT09IG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbGVtZW50IGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3Q29udGV4dCAmJiAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQobSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbnMoY29udGV4dCwgZWxlbSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmlkID09PSBtKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUeXBlIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaFsyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoc2VsZWN0b3IpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xhc3Mgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShtKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1cHBvcnQucXNhICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbc2VsZWN0b3IgKyBcIiBcIl0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3Qoc2VsZWN0b3IpKSAmJlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgOCBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobm9kZVR5cGUgIT09IDEgfHwgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0ID0gY29udGV4dDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHFTQSBjb25zaWRlcnMgZWxlbWVudHMgb3V0c2lkZSBhIHNjb3Bpbmcgcm9vdCB3aGVuIGV2YWx1YXRpbmcgY2hpbGQgb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZXNjZW5kYW50IGNvbWJpbmF0b3JzLCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIHN1Y2ggY2FzZXMsIHdlIHdvcmsgYXJvdW5kIHRoZSBiZWhhdmlvciBieSBwcmVmaXhpbmcgZXZlcnkgc2VsZWN0b3IgaW4gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGlzdCB3aXRoIGFuIElEIHNlbGVjdG9yIHJlZmVyZW5jaW5nIHRoZSBzY29wZSBjb250ZXh0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHRlY2huaXF1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IDEgJiYgcmRlc2NlbmQudGVzdChzZWxlY3RvcikpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKFwiaWRcIikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuaWQgPSBuaWQucmVwbGFjZShyY3NzZXNjYXBlLCBmY3NzZXNjYXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0QXR0cmlidXRlKFwiaWRcIiwgKG5pZCA9IGV4cGFuZG8pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cHMgPSB0b2tlbml6ZShzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBncm91cHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cHNbaV0gPSBcIiNcIiArIG5pZCArIFwiIFwiICsgdG9TZWxlY3Rvcihncm91cHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oXCIsXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdChzZWxlY3RvcikgJiYgdGVzdENvbnRleHQoY29udGV4dC5wYXJlbnROb2RlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwobmV3U2VsZWN0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHFzYUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoc2VsZWN0b3IsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuaWQgPT09IGV4cGFuZG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKFwiaWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBbGwgb3RoZXJzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdChzZWxlY3Rvci5yZXBsYWNlKHJ0cmltLCBcIiQxXCIpLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAgICAgICAgICAgICAqICAgIHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gICAgICAgICAgICAgKiAgICBkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gW107XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjYWNoZShrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlzLnB1c2goa2V5ICsgXCIgXCIpID4gRXhwci5jYWNoZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2FjaGVba2V5cy5zaGlmdCgpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGNhY2hlW2tleSArIFwiIFwiXSA9IHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1hcmtGdW5jdGlvbihmbikge1xuICAgICAgICAgICAgICAgIGZuW2V4cGFuZG9dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gYXNzZXJ0KGZuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhZm4oZWwpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuICAgICAgICAgICAgICAgICAgICBpZiAoZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcbiAgICAgICAgICAgICAgICAgICAgZWwgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gYWRkSGFuZGxlKGF0dHJzLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyciA9IGF0dHJzLnNwbGl0KFwifFwiKSxcbiAgICAgICAgICAgICAgICAgICAgaSA9IGFyci5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIEV4cHIuYXR0ckhhbmRsZVthcnJbaV1dID0gaGFuZGxlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBhXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBzaWJsaW5nQ2hlY2soYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciBjdXIgPSBiICYmIGEsXG4gICAgICAgICAgICAgICAgICAgIGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhLnNvdXJjZUluZGV4IC0gYi5zb3VyY2VJbmRleDtcblxuICAgICAgICAgICAgICAgIC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuICAgICAgICAgICAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG4gICAgICAgICAgICAgICAgaWYgKGN1cikge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGN1ciA9IGN1ci5uZXh0U2libGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXIgPT09IGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYSA/IDEgOiAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyh0eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKHR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKGRpc2FibGVkKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChcImZvcm1cIiBpbiBlbGVtKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImxhYmVsXCIgaW4gZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA2IC0gMTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGlzRGlzYWJsZWQgc2hvcnRjdXQgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGRpc2FibGVkIGZpZWxkc2V0IGFuY2VzdG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlcmUgdGhlcmUgaXMgbm8gaXNEaXNhYmxlZCwgY2hlY2sgbWFudWFsbHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoganNoaW50IC1XMDE4ICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluRGlzYWJsZWRGaWVsZHNldChlbGVtKSA9PT0gZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHdpbm5vdyBvdXQgZWxlbWVudHMgdGhhdCBjYW4ndCBiZSBkaXNhYmxlZCBiZWZvcmUgdHJ1c3RpbmcgdGhlIGRpc2FibGVkIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcImxhYmVsXCIgaW4gZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uIChzZWVkLCBtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMgPSBmbihbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlZWRbKGogPSBtYXRjaEluZGV4ZXNbaV0pXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICAgICAgICAgICAgICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIHRlc3RDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbiAgICAgICAgICAgIHN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERldGVjdHMgWE1MIG5vZGVzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICAgICAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IGVsZW0ubmFtZXNwYWNlVVJJLFxuICAgICAgICAgICAgICAgICAgICBkb2NFbGVtID0gKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PThcbiAgICAgICAgICAgICAgICAvLyBBc3N1bWUgSFRNTCB3aGVuIGRvY3VtZW50RWxlbWVudCBkb2Vzbid0IHlldCBleGlzdCwgc3VjaCBhcyBpbnNpZGUgbG9hZGluZyBpZnJhbWVzXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzQ4MzNcbiAgICAgICAgICAgICAgICByZXR1cm4gIXJodG1sLnRlc3QobmFtZXNwYWNlIHx8IGRvY0VsZW0gJiYgZG9jRWxlbS5ub2RlTmFtZSB8fCBcIkhUTUxcIik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXG4gICAgICAgICAgICAgICAgICAgIGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuICAgICAgICAgICAgICAgIC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgaWYgKGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuICAgICAgICAgICAgICAgIGRvY3VtZW50ID0gZG9jO1xuICAgICAgICAgICAgICAgIGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoZG9jdW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgOS0xMSwgRWRnZVxuICAgICAgICAgICAgICAgIC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcbiAgICAgICAgICAgICAgICBpZiAocHJlZmVycmVkRG9jICE9PSBkb2N1bWVudCAmJlxuICAgICAgICAgICAgICAgICAgICAoc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdykge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTAgb25seVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN1YldpbmRvdy5hdHRhY2hFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViV2luZG93LmF0dGFjaEV2ZW50KFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFPDhcbiAgICAgICAgICAgICAgICAvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcbiAgICAgICAgICAgICAgICBzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWVsLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8qIGdldEVsZW1lbnQocylCeSpcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuICAgICAgICAgICAgICAgIHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJcIikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTw5XG4gICAgICAgICAgICAgICAgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUpO1xuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU8MTBcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcbiAgICAgICAgICAgICAgICAvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcbiAgICAgICAgICAgICAgICAvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3RcbiAgICAgICAgICAgICAgICBzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY0VsZW0uYXBwZW5kQ2hpbGQoZWwpLmlkID0gZXhwYW5kbztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoZXhwYW5kbykubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gSUQgZmlsdGVyIGFuZCBmaW5kXG4gICAgICAgICAgICAgICAgaWYgKHN1cHBvcnQuZ2V0QnlJZCkge1xuICAgICAgICAgICAgICAgICAgICBFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cklkID0gaWQucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgRXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiAoaWQsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0gPyBbZWxlbV0gOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cklkID0gaWQucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcbiAgICAgICAgICAgICAgICAgICAgRXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiAoaWQsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlLCBpLCBlbGVtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0pIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWZXJpZnkgdGhlIGlkIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlICYmIG5vZGUudmFsdWUgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2VsZW1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1zID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZShpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGVsZW0gPSBlbGVtc1tpKytdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2VsZW1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRhZ1xuICAgICAgICAgICAgICAgIEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodGFnLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQucXNhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCh0YWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IDpcblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodGFnLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGVsZW0gPSByZXN1bHRzW2krK10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAucHVzaChlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIENsYXNzXG4gICAgICAgICAgICAgICAgRXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24gKGNsYXNzTmFtZSwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gICAgICAgICAgICAgICAgLy8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG4gICAgICAgICAgICAgICAgLy8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcbiAgICAgICAgICAgICAgICByYnVnZ3lNYXRjaGVzID0gW107XG5cbiAgICAgICAgICAgICAgICAvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuICAgICAgICAgICAgICAgIC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuICAgICAgICAgICAgICAgIC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcbiAgICAgICAgICAgICAgICAvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcbiAgICAgICAgICAgICAgICByYnVnZ3lRU0EgPSBbXTtcblxuICAgICAgICAgICAgICAgIGlmICgoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1aWxkIFFTQSByZWdleFxuICAgICAgICAgICAgICAgICAgICAvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2NFbGVtLmFwcGVuZENoaWxkKGVsKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRThcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZWwucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwifj1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZWwucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJsaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIikubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxzZWxlY3QgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uLz48L3NlbGVjdD5cIjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJoaWRkZW5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChpbnB1dCkuc2V0QXR0cmlidXRlKFwibmFtZVwiLCBcIkRcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFOFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTktMTErXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY0VsZW0uYXBwZW5kQ2hpbGQoZWwpLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmRpc2FibGVkXCIpLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCgobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuICAgICAgICAgICAgICAgICAgICBkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgICAgICAgICBkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgICAgICAgICBkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikpKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoZWwsIFwiKlwiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5jYWxsKGVsLCBcIltzIT0nJ106eFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJidWdneU1hdGNoZXMucHVzaChcIiE9XCIsIHBzZXVkb3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAocmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpKTtcbiAgICAgICAgICAgICAgICByYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cChyYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpKTtcblxuICAgICAgICAgICAgICAgIC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgICAgICAgICAgICAgICBoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24pO1xuXG4gICAgICAgICAgICAgICAgLy8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG4gICAgICAgICAgICAgICAgLy8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXG4gICAgICAgICAgICAgICAgLy8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcbiAgICAgICAgICAgICAgICBjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KGRvY0VsZW0uY29udGFpbnMpID9cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA9PT0gYnVwIHx8ICEhKGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkb3duLmNvbnRhaW5zID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRvd24uY29udGFpbnMoYnVwKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihidXApICYgMTZcbiAgICAgICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgICAgICB9IDpcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChiID0gYi5wYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYiA9PT0gYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAgICAgICAgICAgICAgIC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcbiAgICAgICAgICAgICAgICBzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGEsIGIpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzRHVwbGljYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyZSA9IChhLm93bmVyRG9jdW1lbnQgfHwgYSkgPT09IChiLm93bmVyRG9jdW1lbnQgfHwgYikgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikgOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzY29ubmVjdGVkIG5vZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyZSAmIDEgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYSkgPT09IGNvbXBhcmUpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYSA9PT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvcnRJbnB1dCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpbmRleE9mKHNvcnRJbnB1dCwgYSkgLSBpbmRleE9mKHNvcnRJbnB1dCwgYikpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgICAgICB9IDpcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzRHVwbGljYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXAgPSBhLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVwID0gYi5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwID0gW2FdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJwID0gW2JdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhdXAgfHwgIWJ1cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9PT0gZG9jdW1lbnQgPyAxIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1cCA/IC0xIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXAgPyAxIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ydElucHV0ID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpbmRleE9mKHNvcnRJbnB1dCwgYSkgLSBpbmRleE9mKHNvcnRJbnB1dCwgYikpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhdXAgPT09IGJ1cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWJsaW5nQ2hlY2soYSwgYik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjdXIgPSBjdXIucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcC51bnNoaWZ0KGN1cik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSBiO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjdXIgPSBjdXIucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicC51bnNoaWZ0KGN1cik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYXBbaV0gPT09IGJwW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2libGluZ0NoZWNrKGFwW2ldLCBicFtpXSkgOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBbaV0gPT09IHByZWZlcnJlZERvYyA/IC0xIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24gKGV4cHIsIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNpenpsZShleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBTaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24gKGVsZW0sIGV4cHIpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICBpZiAoKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKSAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RG9jdW1lbnQoZWxlbSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG4gICAgICAgICAgICAgICAgICAgICFub25uYXRpdmVTZWxlY3RvckNhY2hlW2V4cHIgKyBcIiBcIl0gJiZcbiAgICAgICAgICAgICAgICAgICAgKCFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoZXhwcikpICYmXG4gICAgICAgICAgICAgICAgICAgICghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdChleHByKSkpIHtcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IG1hdGNoZXMuY2FsbChlbGVtLCBleHByKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcmFnbWVudCBpbiBJRSA5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoZXhwciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gU2l6emxlKGV4cHIsIGRvY3VtZW50LCBudWxsLCBbZWxlbV0pLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBTaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlbSkge1xuICAgICAgICAgICAgICAgIC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIGlmICgoY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQpICE9PSBkb2N1bWVudCkge1xuICAgICAgICAgICAgICAgICAgICBzZXREb2N1bWVudChjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zKGNvbnRleHQsIGVsZW0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgU2l6emxlLmF0dHIgPSBmdW5jdGlvbiAoZWxlbSwgbmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIGlmICgoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pICE9PSBkb2N1bWVudCkge1xuICAgICAgICAgICAgICAgICAgICBzZXREb2N1bWVudChlbGVtKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbbmFtZS50b0xvd2VyQ2FzZSgpXSxcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGZuICYmIGhhc093bi5jYWxsKEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBmbihlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgIHZhbCA6XG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5nZXRBdHRyaWJ1dGUobmFtZSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgKHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsLnZhbHVlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uIChzZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHNlbCArIFwiXCIpLnJlcGxhY2UocmNzc2VzY2FwZSwgZmNzc2VzY2FwZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBTaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW0sXG4gICAgICAgICAgICAgICAgICAgIGR1cGxpY2F0ZXMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgaiA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICAgICAgLy8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuICAgICAgICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG4gICAgICAgICAgICAgICAgc29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMuc29ydChzb3J0T3JkZXIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGhhc0R1cGxpY2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGVsZW0gPSByZXN1bHRzW2krK10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbSA9PT0gcmVzdWx0c1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPSBkdXBsaWNhdGVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5zcGxpY2UoZHVwbGljYXRlc1tqXSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuICAgICAgICAgICAgICAgIHNvcnRJbnB1dCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlLFxuICAgICAgICAgICAgICAgICAgICByZXQgPSBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKG5vZGUgPSBlbGVtW2krK10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ICs9IGdldFRleHQobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgKz0gZ2V0VGV4dChlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBFeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuICAgICAgICAgICAgICAgIC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuICAgICAgICAgICAgICAgIGNhY2hlTGVuZ3RoOiA1MCxcblxuICAgICAgICAgICAgICAgIGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG4gICAgICAgICAgICAgICAgbWF0Y2g6IG1hdGNoRXhwcixcblxuICAgICAgICAgICAgICAgIGF0dHJIYW5kbGU6IHt9LFxuXG4gICAgICAgICAgICAgICAgZmluZDoge30sXG5cbiAgICAgICAgICAgICAgICByZWxhdGl2ZToge1xuICAgICAgICAgICAgICAgICAgICBcIj5cIjoge2RpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlfSxcbiAgICAgICAgICAgICAgICAgICAgXCIgXCI6IHtkaXI6IFwicGFyZW50Tm9kZVwifSxcbiAgICAgICAgICAgICAgICAgICAgXCIrXCI6IHtkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlfSxcbiAgICAgICAgICAgICAgICAgICAgXCJ+XCI6IHtkaXI6IFwicHJldmlvdXNTaWJsaW5nXCJ9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHByZUZpbHRlcjoge1xuICAgICAgICAgICAgICAgICAgICBcIkFUVFJcIjogZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbM10gPSAobWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIikucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaFsyXSA9PT0gXCJ+PVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaC5zbGljZSgwLCA0KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBcIkNISUxEXCI6IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoWzFdLnNsaWNlKDAsIDMpID09PSBcIm50aFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNpenpsZS5lcnJvcihtYXRjaFswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzRdID0gKyhtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqIChtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFs1XSA9ICsoKG1hdGNoWzddICsgbWF0Y2hbOF0pIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNpenpsZS5lcnJvcihtYXRjaFswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBcIlBTRVVET1wiOiBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleGNlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KG1hdGNoWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KHVucXVvdGVkKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGV4Y2VzcyA9IHRva2VuaXplKHVucXVvdGVkLCB0cnVlKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZihcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzKSAtIHVucXVvdGVkLmxlbmd0aCkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSgwLCBleGNlc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoMCwgZXhjZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2guc2xpY2UoMCwgMyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgZmlsdGVyOiB7XG5cbiAgICAgICAgICAgICAgICAgICAgXCJUQUdcIjogZnVuY3Rpb24gKG5vZGVOYW1lU2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgXCJDTEFTU1wiOiBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbY2xhc3NOYW1lICsgXCIgXCJdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0dGVybiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwYXR0ZXJuID0gbmV3IFJlZ0V4cChcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIikpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NDYWNoZShjbGFzc05hbWUsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QodHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIFwiQVRUUlwiOiBmdW5jdGlvbiAobmFtZSwgb3BlcmF0b3IsIGNoZWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoZWxlbSwgbmFtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZihjaGVjaykgPT09IDAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZihjaGVjaykgPiAtMSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoLWNoZWNrLmxlbmd0aCkgPT09IGNoZWNrIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID09PSBcIn49XCIgPyAoXCIgXCIgKyByZXN1bHQucmVwbGFjZShyd2hpdGVzcGFjZSwgXCIgXCIpICsgXCIgXCIpLmluZGV4T2YoY2hlY2spID4gLTEgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSgwLCBjaGVjay5sZW5ndGggKyAxKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBcIkNISUxEXCI6IGZ1bmN0aW9uICh0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKDAsIDMpICE9PSBcIm50aFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcndhcmQgPSB0eXBlLnNsaWNlKC00KSAhPT0gXCJsYXN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZWxlbSwgY29udGV4dCwgeG1sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaW1wbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBlbGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKG5vZGUgPSBub2RlW2Rpcl0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2ZUeXBlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubm9kZVR5cGUgPT09IDEpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBbZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9yd2FyZCAmJiB1c2VDYWNoZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlckNhY2hlID0gbm9kZVtleHBhbmRvXSB8fCAobm9kZVtleHBhbmRvXSA9IHt9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbbm9kZS51bmlxdWVJRF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG91dGVyQ2FjaGVbbm9kZS51bmlxdWVJRF0gPSB7fSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZSA9IHVuaXF1ZUNhY2hlW3R5cGVdIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IGNhY2hlWzBdID09PSBkaXJydW5zICYmIGNhY2hlWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1tub2RlSW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlW2Rpcl0gfHxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZVt0eXBlXSA9IFtkaXJydW5zLCBub2RlSW5kZXgsIGRpZmZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGUgPSBub2RlW2V4cGFuZG9dIHx8IChub2RlW2V4cGFuZG9dID0ge30pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVtub2RlLnVuaXF1ZUlEXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG91dGVyQ2FjaGVbbm9kZS51bmlxdWVJRF0gPSB7fSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUgPSB1bmlxdWVDYWNoZVt0eXBlXSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUluZGV4ID0gY2FjaGVbMF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYgPSBub2RlSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8geG1sIDpudGgtY2hpbGQoLi4uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlW2Rpcl0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgob2ZUeXBlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubm9kZVR5cGUgPT09IDEpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKytkaWZmKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGUgPSBub2RlW2V4cGFuZG9dIHx8IChub2RlW2V4cGFuZG9dID0ge30pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVtub2RlLnVuaXF1ZUlEXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG91dGVyQ2FjaGVbbm9kZS51bmlxdWVJRF0gPSB7fSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGVbdHlwZV0gPSBbZGlycnVucywgZGlmZl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZiAtPSBsYXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8IChkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBcIlBTRVVET1wiOiBmdW5jdGlvbiAocHNldWRvLCBhcmd1bWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4gPSBFeHByLnBzZXVkb3NbcHNldWRvXSB8fCBFeHByLnNldEZpbHRlcnNbcHNldWRvLnRvTG93ZXJDYXNlKCldIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNpenpsZS5lcnJvcihcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBhcyBTaXp6bGUgZG9lc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZuW2V4cGFuZG9dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKGFyZ3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBbcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KHBzZXVkby50b0xvd2VyQ2FzZSgpKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtGdW5jdGlvbihmdW5jdGlvbiAoc2VlZCwgbWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gZm4oc2VlZCwgYXJndW1lbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBtYXRjaGVkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHggPSBpbmRleE9mKHNlZWQsIG1hdGNoZWRbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZWRbaWR4XSA9ICEobWF0Y2hlc1tpZHhdID0gbWF0Y2hlZFtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihlbGVtLCAwLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHBzZXVkb3M6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG4gICAgICAgICAgICAgICAgICAgIFwibm90XCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciA9IGNvbXBpbGUoc2VsZWN0b3IucmVwbGFjZShydHJpbSwgXCIkMVwiKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVyW2V4cGFuZG9dID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrRnVuY3Rpb24oZnVuY3Rpb24gKHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVubWF0Y2hlZCA9IG1hdGNoZXIoc2VlZCwgbnVsbCwgeG1sLCBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gc2VlZC5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGVsZW0gPSB1bm1hdGNoZWRbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlbGVtLCBjb250ZXh0LCB4bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRbMF0gPSBlbGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyKGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFswXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhcmVzdWx0cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgICAgICAgICBcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2l6emxlKHNlbGVjdG9yLCBlbGVtKS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgICAgICAgICAgXCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlbGVtLnRleHRDb250ZW50IHx8IGdldFRleHQoZWxlbSkpLmluZGV4T2YodGV4dCkgPiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuICAgICAgICAgICAgICAgICAgICAvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG4gICAgICAgICAgICAgICAgICAgIFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24gKGxhbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU2l6emxlLmVycm9yKFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmcgPSBsYW5nLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbUxhbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5sYW5nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZihsYW5nICsgXCItXCIpID09PSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1pc2NlbGxhbmVvdXNcbiAgICAgICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSgxKSA9PT0gZWxlbS5pZDtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBcInJvb3RcIjogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIFwiZm9jdXNcIjogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQm9vbGVhbiBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgIFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyhmYWxzZSksXG4gICAgICAgICAgICAgICAgICAgIFwiZGlzYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8odHJ1ZSksXG5cbiAgICAgICAgICAgICAgICAgICAgXCJjaGVja2VkXCI6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIFwic2VsZWN0ZWRcIjogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udGVudHNcbiAgICAgICAgICAgICAgICAgICAgXCJlbXB0eVwiOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPCA2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBcInBhcmVudFwiOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXShlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBFbGVtZW50L2lucHV0IHR5cGVzXG4gICAgICAgICAgICAgICAgICAgIFwiaGVhZGVyXCI6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmhlYWRlci50ZXN0KGVsZW0ubm9kZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIFwiaW5wdXRcIjogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByaW5wdXRzLnRlc3QoZWxlbS5ub2RlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgXCJidXR0b25cIjogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU8OFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgXCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMF07XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICAgICAgICAgIFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uIChtYXRjaEluZGV4ZXMsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtsZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgICAgICAgICAgXCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uIChtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudF07XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICAgICAgICAgIFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uIChtYXRjaEluZGV4ZXMsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoSW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoSW5kZXhlcztcbiAgICAgICAgICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgICAgICAgICAgXCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiAobWF0Y2hJbmRleGVzLCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaEluZGV4ZXM7XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICAgICAgICAgIFwibHRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiAobWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGFyZ3VtZW50IDwgMCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQgKyBsZW5ndGggOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50ID4gbGVuZ3RoID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hJbmRleGVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hJbmRleGVzO1xuICAgICAgICAgICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgICAgICAgICBcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24gKG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7ICsraSA8IGxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaEluZGV4ZXM7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbiAgICAvLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuICAgICAgICAgICAgZm9yIChpIGluIHtyYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZX0pIHtcbiAgICAgICAgICAgICAgICBFeHByLnBzZXVkb3NbaV0gPSBjcmVhdGVJbnB1dFBzZXVkbyhpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSBpbiB7c3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZX0pIHtcbiAgICAgICAgICAgICAgICBFeHByLnBzZXVkb3NbaV0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAvLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuICAgICAgICAgICAgRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxuICAgICAgICAgICAgdG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHBhcnNlT25seSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgICBzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuICAgICAgICAgICAgICAgICAgICBjYWNoZWQgPSB0b2tlbkNhY2hlW3NlbGVjdG9yICsgXCIgXCJdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzb0ZhciA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgICAgIGdyb3VwcyA9IFtdO1xuICAgICAgICAgICAgICAgIHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChzb0Zhcikge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbW1hIGFuZCBmaXJzdCBydW5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKHNvRmFyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29GYXIgPSBzb0Zhci5zbGljZShtYXRjaFswXS5sZW5ndGgpIHx8IHNvRmFyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBzLnB1c2goKHRva2VucyA9IFtdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tYmluYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKHNvRmFyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtYXRjaGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UocnRyaW0sIFwiIFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb0ZhciA9IHNvRmFyLnNsaWNlKG1hdGNoZWQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbHRlcnNcbiAgICAgICAgICAgICAgICAgICAgZm9yICh0eXBlIGluIEV4cHIuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG1hdGNoID0gbWF0Y2hFeHByW3R5cGVdLmV4ZWMoc29GYXIpKSAmJiAoIXByZUZpbHRlcnNbdHlwZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWF0Y2ggPSBwcmVGaWx0ZXJzW3R5cGVdKG1hdGNoKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWF0Y2hlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlczogbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb0ZhciA9IHNvRmFyLnNsaWNlKG1hdGNoZWQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3NcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VPbmx5ID9cbiAgICAgICAgICAgICAgICAgICAgc29GYXIubGVuZ3RoIDpcbiAgICAgICAgICAgICAgICAgICAgc29GYXIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgU2l6emxlLmVycm9yKHNlbGVjdG9yKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgdG9rZW5zXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbkNhY2hlKHNlbGVjdG9yLCBncm91cHMpLnNsaWNlKDApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gdG9TZWxlY3Rvcih0b2tlbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IHRva2Vucy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gXCJcIjtcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yICs9IHRva2Vuc1tpXS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRDb21iaW5hdG9yKG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG4gICAgICAgICAgICAgICAgICAgIHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHNraXAgfHwgZGlyLFxuICAgICAgICAgICAgICAgICAgICBjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBrZXkgPT09IFwicGFyZW50Tm9kZVwiLFxuICAgICAgICAgICAgICAgICAgICBkb25lTmFtZSA9IGRvbmUrKztcblxuICAgICAgICAgICAgICAgIHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlbGVtLCBjb250ZXh0LCB4bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoZWxlbSA9IGVsZW1bZGlyXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVyKGVsZW0sIGNvbnRleHQsIHhtbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9IDpcblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVsZW0sIGNvbnRleHQsIHhtbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZENhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDYWNoZSA9IFtkaXJydW5zLCBkb25lTmFtZV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhtbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoZWxlbSA9IGVsZW1bZGlyXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXIoZWxlbSwgY29udGV4dCwgeG1sKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGVsZW0gPSBlbGVtW2Rpcl0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGUgPSBlbGVtW2V4cGFuZG9dIHx8IChlbGVtW2V4cGFuZG9dID0ge30pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVtlbGVtLnVuaXF1ZUlEXSB8fCAob3V0ZXJDYWNoZVtlbGVtLnVuaXF1ZUlEXSA9IHt9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNraXAgJiYgc2tpcCA9PT0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGVsZW1bZGlyXSB8fCBlbGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgob2xkQ2FjaGUgPSB1bmlxdWVDYWNoZVtrZXldKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZENhY2hlWzBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWzFdID09PSBkb25lTmFtZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG5ld0NhY2hlWzJdID0gb2xkQ2FjaGVbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGVba2V5XSA9IG5ld0NhY2hlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChuZXdDYWNoZVsyXSA9IG1hdGNoZXIoZWxlbSwgY29udGV4dCwgeG1sKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBlbGVtZW50TWF0Y2hlcihtYXRjaGVycykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVsZW0sIGNvbnRleHQsIHhtbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVyc1tpXShlbGVtLCBjb250ZXh0LCB4bWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXJzWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gY29udGV4dHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgU2l6emxlKHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjb25kZW5zZSh1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSxcbiAgICAgICAgICAgICAgICAgICAgbmV3VW5tYXRjaGVkID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgICAgICBsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChlbGVtID0gdW5tYXRjaGVkW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGVsZW0sIGNvbnRleHQsIHhtbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdVbm1hdGNoZWQucHVzaChlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdVbm1hdGNoZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNldE1hdGNoZXIocHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbZXhwYW5kb10pIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zdEZpbHRlciA9IHNldE1hdGNoZXIocG9zdEZpbHRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3N0RmluZGVyICYmICFwb3N0RmluZGVyW2V4cGFuZG9dKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKHBvc3RGaW5kZXIsIHBvc3RTZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24gKHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCwgaSwgZWxlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZU1hcCA9IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdE1hcCA9IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKHNlbGVjdG9yIHx8IFwiKlwiLCBjb250ZXh0Lm5vZGVUeXBlID8gW2NvbnRleHRdIDogY29udGV4dCwgW10pLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoc2VlZCB8fCAhc2VsZWN0b3IpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25kZW5zZShlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1zLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3N0RmluZGVyIHx8IChzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlcikgP1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXSA6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJJbjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcihtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwb3N0RmlsdGVyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3N0RmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gY29uZGVuc2UobWF0Y2hlck91dCwgcG9zdE1hcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0RmlsdGVyKHRlbXAsIFtdLCBjb250ZXh0LCB4bWwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gdGVtcC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChlbGVtID0gdGVtcFtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlck91dFtwb3N0TWFwW2ldXSA9ICEobWF0Y2hlckluW3Bvc3RNYXBbaV1dID0gZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3N0RmluZGVyIHx8IHByZUZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3N0RmluZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChlbGVtID0gbWF0Y2hlck91dFtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAucHVzaCgobWF0Y2hlckluW2ldID0gZWxlbSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RGaW5kZXIobnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gbWF0Y2hlck91dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZihzZWVkLCBlbGVtKSA6IHByZU1hcFtpXSkgPiAtMSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlck91dCA9IGNvbmRlbnNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyT3V0LnNwbGljZShwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGgpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlck91dFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3N0RmluZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zdEZpbmRlcihudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIG1hdGNoZXJPdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKHRva2Vucykge1xuICAgICAgICAgICAgICAgIHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IHRva2Vucy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbdG9rZW5zWzBdLnR5cGVdLFxuICAgICAgICAgICAgICAgICAgICBpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuICAgICAgICAgICAgICAgICAgICBpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvcihmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleE9mKGNoZWNrQ29udGV4dCwgZWxlbSkgPiAtMTtcbiAgICAgICAgICAgICAgICAgICAgfSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXJzID0gW2Z1bmN0aW9uIChlbGVtLCBjb250ZXh0LCB4bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSAoIWxlYWRpbmdSZWxhdGl2ZSAmJiAoeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQpKSB8fCAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hDb250ZXh0KGVsZW0sIGNvbnRleHQsIHhtbCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEFueUNvbnRleHQoZWxlbSwgY29udGV4dCwgeG1sKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICB9XTtcblxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVt0b2tlbnNbaV0udHlwZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVycyA9IFthZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKG1hdGNoZXJzKSwgbWF0Y2hlcildO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciA9IEV4cHIuZmlsdGVyW3Rva2Vuc1tpXS50eXBlXS5hcHBseShudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcltleHBhbmRvXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPSArK2k7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoRXhwci5yZWxhdGl2ZVt0b2tlbnNbal0udHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRNYXRjaGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID4gMSAmJiBlbGVtZW50TWF0Y2hlcihtYXRjaGVycyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPiAxICYmIHRvU2VsZWN0b3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5zbGljZSgwLCBpIC0gMSkuY29uY2F0KHt2YWx1ZTogdG9rZW5zW2kgLSAyXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIn0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkucmVwbGFjZShydHJpbSwgXCIkMVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnModG9rZW5zLnNsaWNlKGksIGopKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucygodG9rZW5zID0gdG9rZW5zLnNsaWNlKGopKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPCBsZW4gJiYgdG9TZWxlY3Rvcih0b2tlbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJzLnB1c2gobWF0Y2hlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudE1hdGNoZXIobWF0Y2hlcnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycykge1xuICAgICAgICAgICAgICAgIHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICAgICAgICAgIGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuICAgICAgICAgICAgICAgICAgICBzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiAoc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRDb3VudCA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IFwiMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0TWF0Y2hlZCA9IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXShcIipcIiwgb3V0ZXJtb3N0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dGVybW9zdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChieUVsZW1lbnQgJiYgZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldERvY3VtZW50KGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeG1sID0gIWRvY3VtZW50SXNIVE1MO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXIoZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0ZXJtb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnlTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZENvdW50LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bm1hdGNoZWQucHVzaChlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRDb3VudCArPSBpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFwiMFwiIGBpYCBhbGxvd3MgYGlgIHRvIHJlbWFpbiBhIHN0cmluZyBvbmx5IGluIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXCIwMFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVtZXJpY2FsbHkgemVyby5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyKHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbChyZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRNYXRjaGVkID0gY29uZGVuc2Uoc2V0TWF0Y2hlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgc2V0TWF0Y2hlZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoKSA+IDEpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUudW5pcXVlU29ydChyZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dGVybW9zdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5tYXRjaGVkO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ5U2V0ID9cbiAgICAgICAgICAgICAgICAgICAgbWFya0Z1bmN0aW9uKHN1cGVyTWF0Y2hlcikgOlxuICAgICAgICAgICAgICAgICAgICBzdXBlck1hdGNoZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uIChzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8pIHtcbiAgICAgICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICAgICAgc2V0TWF0Y2hlcnMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudE1hdGNoZXJzID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbc2VsZWN0b3IgKyBcIiBcIl07XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSB0b2tlbml6ZShzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaSA9IG1hdGNoLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMobWF0Y2hbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZFtleHBhbmRvXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldE1hdGNoZXJzLnB1c2goY2FjaGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudE1hdGNoZXJzLnB1c2goY2FjaGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICBjYWNoZWQgPSBjb21waWxlckNhY2hlKHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycykpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuICAgICAgICAgICAgICAgICAgICBjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICAgICAgICAgICAgICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAgICAgICAgICAgICAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uIChzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCkge1xuICAgICAgICAgICAgICAgIHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuICAgICAgICAgICAgICAgICAgICBjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKChzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yKSk7XG5cbiAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG4gICAgICAgICAgICAgICAgLy8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuICAgICAgICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPT09IDEpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiYgRXhwci5yZWxhdGl2ZVt0b2tlbnNbMV0udHlwZV0pIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IChFeHByLmZpbmRbXCJJRFwiXSh0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLCBjb250ZXh0KSB8fCBbXSlbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tcGlsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG4gICAgICAgICAgICAgICAgICAgIGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdChzZWxlY3RvcikgPyAwIDogdG9rZW5zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChFeHByLnJlbGF0aXZlWyh0eXBlID0gdG9rZW4udHlwZSldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGZpbmQgPSBFeHByLmZpbmRbdHlwZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChzZWVkID0gZmluZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnNpYmxpbmcudGVzdCh0b2tlbnNbMF0udHlwZSkgJiYgdGVzdENvbnRleHQoY29udGV4dC5wYXJlbnROb2RlKSB8fCBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKHRva2Vucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgc2VlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuICAgICAgICAgICAgICAgIC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcbiAgICAgICAgICAgICAgICAoY29tcGlsZWQgfHwgY29tcGlsZShzZWxlY3RvciwgbWF0Y2gpKShcbiAgICAgICAgICAgICAgICAgICAgc2VlZCxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgIWRvY3VtZW50SXNIVE1MLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLFxuICAgICAgICAgICAgICAgICAgICAhY29udGV4dCB8fCByc2libGluZy50ZXN0KHNlbGVjdG9yKSAmJiB0ZXN0Q29udGV4dChjb250ZXh0LnBhcmVudE5vZGUpIHx8IGNvbnRleHRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfTtcblxuICAgIC8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbiAgICAvLyBTb3J0IHN0YWJpbGl0eVxuICAgICAgICAgICAgc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdChcIlwiKS5zb3J0KHNvcnRPcmRlcikuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuICAgIC8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbiAgICAvLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG4gICAgICAgICAgICBzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuICAgIC8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuICAgICAgICAgICAgc2V0RG9jdW1lbnQoKTtcblxuICAgIC8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4gICAgLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG4gICAgICAgICAgICBzdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpKSAmIDE7XG4gICAgICAgICAgICB9KTtcblxuICAgIC8vIFN1cHBvcnQ6IElFPDhcbiAgICAvLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuICAgIC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG4gICAgICAgICAgICBpZiAoIWFzc2VydChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIjtcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgYWRkSGFuZGxlKFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiAoZWxlbSwgbmFtZSwgaXNYTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1hNTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0eXBlXCIgPyAxIDogMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgIC8vIFN1cHBvcnQ6IElFPDlcbiAgICAvLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG4gICAgICAgICAgICBpZiAoIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcbiAgICAgICAgICAgICAgICBlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIFwiXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpID09PSBcIlwiO1xuICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICBhZGRIYW5kbGUoXCJ2YWx1ZVwiLCBmdW5jdGlvbiAoZWxlbSwgbmFtZSwgaXNYTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAvLyBTdXBwb3J0OiBJRTw5XG4gICAgLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuICAgICAgICAgICAgaWYgKCFhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIGFkZEhhbmRsZShib29sZWFucywgZnVuY3Rpb24gKGVsZW0sIG5hbWUsIGlzWE1MKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNYTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtW25hbWVdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsLnZhbHVlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gU2l6emxlO1xuXG4gICAgICAgIH0pKHdpbmRvdyk7XG5cblxuICAgIGpRdWVyeS5maW5kID0gU2l6emxlO1xuICAgIGpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcblxuICAgIC8vIERlcHJlY2F0ZWRcbiAgICBqUXVlcnkuZXhwcltcIjpcIl0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xuICAgIGpRdWVyeS51bmlxdWVTb3J0ID0galF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xuICAgIGpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG4gICAgalF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xuICAgIGpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcbiAgICBqUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cbiAgICB2YXIgZGlyID0gZnVuY3Rpb24gKGVsZW0sIGRpciwgdW50aWwpIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBbXSxcbiAgICAgICAgICAgIHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuICAgICAgICB3aGlsZSAoKGVsZW0gPSBlbGVtW2Rpcl0pICYmIGVsZW0ubm9kZVR5cGUgIT09IDkpIHtcbiAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRydW5jYXRlICYmIGpRdWVyeShlbGVtKS5pcyh1bnRpbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hdGNoZWQucHVzaChlbGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0Y2hlZDtcbiAgICB9O1xuXG5cbiAgICB2YXIgc2libGluZ3MgPSBmdW5jdGlvbiAobiwgZWxlbSkge1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IFtdO1xuXG4gICAgICAgIGZvciAoOyBuOyBuID0gbi5uZXh0U2libGluZykge1xuICAgICAgICAgICAgaWYgKG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWQucHVzaChuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRjaGVkO1xuICAgIH07XG5cblxuICAgIHZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG5cbiAgICBmdW5jdGlvbiBub2RlTmFtZShlbGVtLCBuYW1lKSB7XG5cbiAgICAgICAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICB9O1xuICAgIHZhciByc2luZ2xlVGFnID0gKC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pKTtcblxuXG4gICAgLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbiAgICBmdW5jdGlvbiB3aW5ub3coZWxlbWVudHMsIHF1YWxpZmllciwgbm90KSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHF1YWxpZmllcikpIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZ3JlcChlbGVtZW50cywgZnVuY3Rpb24gKGVsZW0sIGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFxdWFsaWZpZXIuY2FsbChlbGVtLCBpLCBlbGVtKSAhPT0gbm90O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaW5nbGUgZWxlbWVudFxuICAgICAgICBpZiAocXVhbGlmaWVyLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmdyZXAoZWxlbWVudHMsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChlbGVtID09PSBxdWFsaWZpZXIpICE9PSBub3Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxuICAgICAgICBpZiAodHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKGVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoaW5kZXhPZi5jYWxsKHF1YWxpZmllciwgZWxlbSkgPiAtMSkgIT09IG5vdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xuICAgICAgICByZXR1cm4galF1ZXJ5LmZpbHRlcihxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QpO1xuICAgIH1cblxuICAgIGpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiAoZXhwciwgZWxlbXMsIG5vdCkge1xuICAgICAgICB2YXIgZWxlbSA9IGVsZW1zWzBdO1xuXG4gICAgICAgIGlmIChub3QpIHtcbiAgICAgICAgICAgIGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoZWxlbSwgZXhwcikgPyBbZWxlbV0gOiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzKGV4cHIsIGpRdWVyeS5ncmVwKGVsZW1zLCBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG4gICAgICAgIH0pKTtcbiAgICB9O1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgdmFyIGksIHJldCxcbiAgICAgICAgICAgICAgICBsZW4gPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhqUXVlcnkoc2VsZWN0b3IpLmZpbHRlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5jb250YWlucyhzZWxmW2ldLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXQgPSB0aGlzLnB1c2hTdGFjayhbXSk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5maW5kKHNlbGVjdG9yLCBzZWxmW2ldLCByZXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KHJldCkgOiByZXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbHRlcjogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2sod2lubm93KHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSkpO1xuICAgICAgICB9LFxuICAgICAgICBub3Q6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHdpbm5vdyh0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSkpO1xuICAgICAgICB9LFxuICAgICAgICBpczogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gISF3aW5ub3coXG4gICAgICAgICAgICAgICAgdGhpcyxcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcbiAgICAgICAgICAgICAgICAvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG4gICAgICAgICAgICAgICAgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdChzZWxlY3RvcikgP1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoc2VsZWN0b3IpIDpcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgfHwgW10sXG4gICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuICAgIC8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuICAgIC8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxuICAgIHZhciByb290alF1ZXJ5LFxuXG4gICAgICAgIC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG4gICAgICAgIC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcbiAgICAgICAgLy8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG4gICAgICAgIC8vIFNob3J0Y3V0IHNpbXBsZSAjaWQgY2FzZSBmb3Igc3BlZWRcbiAgICAgICAgcnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvLFxuXG4gICAgICAgIGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uIChzZWxlY3RvciwgY29udGV4dCwgcm9vdCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoLCBlbGVtO1xuXG4gICAgICAgICAgICAvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcbiAgICAgICAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG4gICAgICAgICAgICAvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG4gICAgICAgICAgICByb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xuXG4gICAgICAgICAgICAvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yWzBdID09PSBcIjxcIiAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXSA9PT0gXCI+XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IubGVuZ3RoID49IDMpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IFtudWxsLCBzZWxlY3RvciwgbnVsbF07XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyhzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuICAgICAgICAgICAgICAgIGlmIChtYXRjaCAmJiAobWF0Y2hbMV0gfHwgIWNvbnRleHQpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WzBdIDogY29udGV4dDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICApKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJzaW5nbGVUYWcudGVzdChtYXRjaFsxXSkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKG1hdGNoIGluIGNvbnRleHQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbbWF0Y2hdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1ttYXRjaF0oY29udGV4dFttYXRjaF0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHIobWF0Y2gsIGNvbnRleHRbbWF0Y2hdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhBTkRMRTogJCgjaWQpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobWF0Y2hbMl0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzWzBdID0gZWxlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGNvbnRleHQgfHwgcm9vdCkuZmluZChzZWxlY3Rvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG4gICAgICAgICAgICAgICAgICAgIC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKGNvbnRleHQpLmZpbmQoc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3Rvci5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgIHRoaXNbMF0gPSBzZWxlY3RvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgICAgICAvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG4gICAgICAgICAgICAgICAgLy8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgIHJvb3QucmVhZHkoc2VsZWN0b3IpIDpcblxuICAgICAgICAgICAgICAgICAgICAvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yKGpRdWVyeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkubWFrZUFycmF5KHNlbGVjdG9yLCB0aGlzKTtcbiAgICAgICAgfTtcblxuICAgIC8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbiAgICBpbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuICAgIC8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbiAgICByb290alF1ZXJ5ID0galF1ZXJ5KGRvY3VtZW50KTtcblxuXG4gICAgdmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG4gICAgICAgIC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG4gICAgICAgIGd1YXJhbnRlZWRVbmlxdWUgPSB7XG4gICAgICAgICAgICBjaGlsZHJlbjogdHJ1ZSxcbiAgICAgICAgICAgIGNvbnRlbnRzOiB0cnVlLFxuICAgICAgICAgICAgbmV4dDogdHJ1ZSxcbiAgICAgICAgICAgIHByZXY6IHRydWVcbiAgICAgICAgfTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgICAgICBoYXM6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRzID0galF1ZXJ5KHRhcmdldCwgdGhpcyksXG4gICAgICAgICAgICAgICAgbCA9IHRhcmdldHMubGVuZ3RoO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LmNvbnRhaW5zKHRoaXMsIHRhcmdldHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsb3Nlc3Q6IGZ1bmN0aW9uIChzZWxlY3RvcnMsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBjdXIsXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgbCA9IHRoaXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBbXSxcbiAgICAgICAgICAgICAgICB0YXJnZXRzID0gdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiAmJiBqUXVlcnkoc2VsZWN0b3JzKTtcblxuICAgICAgICAgICAgLy8gUG9zaXRpb25hbCBzZWxlY3RvcnMgbmV2ZXIgbWF0Y2gsIHNpbmNlIHRoZXJlJ3Mgbm8gX3NlbGVjdGlvbl8gY29udGV4dFxuICAgICAgICAgICAgaWYgKCFybmVlZHNDb250ZXh0LnRlc3Qoc2VsZWN0b3JzKSkge1xuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY3VyID0gdGhpc1tpXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyLm5vZGVUeXBlIDwgMTEgJiYgKHRhcmdldHMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldHMuaW5kZXgoY3VyKSA+IC0xIDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvcihjdXIsIHNlbGVjdG9ycykpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkLnB1c2goY3VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KG1hdGNoZWQpIDogbWF0Y2hlZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XG4gICAgICAgIGluZGV4OiBmdW5jdGlvbiAoZWxlbSkge1xuXG4gICAgICAgICAgICAvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuICAgICAgICAgICAgaWYgKCFlbGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzWzBdICYmIHRoaXNbMF0ucGFyZW50Tm9kZSkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbmRleCBpbiBzZWxlY3RvclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4T2YuY2FsbChqUXVlcnkoZWxlbSksIHRoaXNbMF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcbiAgICAgICAgICAgIHJldHVybiBpbmRleE9mLmNhbGwodGhpcyxcblxuICAgICAgICAgICAgICAgIC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuICAgICAgICAgICAgICAgIGVsZW0uanF1ZXJ5ID8gZWxlbVswXSA6IGVsZW1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkOiBmdW5jdGlvbiAoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhcbiAgICAgICAgICAgICAgICBqUXVlcnkudW5pcXVlU29ydChcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKHRoaXMuZ2V0KCksIGpRdWVyeShzZWxlY3RvciwgY29udGV4dCkpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRCYWNrOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChzZWxlY3RvciA9PSBudWxsID9cbiAgICAgICAgICAgICAgICB0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKHNlbGVjdG9yKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gc2libGluZyhjdXIsIGRpcikge1xuICAgICAgICB3aGlsZSAoKGN1ciA9IGN1cltkaXJdKSAmJiBjdXIubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VyO1xuICAgIH1cblxuICAgIGpRdWVyeS5lYWNoKHtcbiAgICAgICAgcGFyZW50OiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIHBhcmVudHM6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlyKGVsZW0sIFwicGFyZW50Tm9kZVwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyZW50c1VudGlsOiBmdW5jdGlvbiAoZWxlbSwgaSwgdW50aWwpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXIoZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsKTtcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBzaWJsaW5nKGVsZW0sIFwibmV4dFNpYmxpbmdcIik7XG4gICAgICAgIH0sXG4gICAgICAgIHByZXY6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gc2libGluZyhlbGVtLCBcInByZXZpb3VzU2libGluZ1wiKTtcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dEFsbDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBkaXIoZWxlbSwgXCJuZXh0U2libGluZ1wiKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJldkFsbDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBkaXIoZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIik7XG4gICAgICAgIH0sXG4gICAgICAgIG5leHRVbnRpbDogZnVuY3Rpb24gKGVsZW0sIGksIHVudGlsKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlyKGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwpO1xuICAgICAgICB9LFxuICAgICAgICBwcmV2VW50aWw6IGZ1bmN0aW9uIChlbGVtLCBpLCB1bnRpbCkge1xuICAgICAgICAgICAgcmV0dXJuIGRpcihlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNpYmxpbmdzOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmdzKChlbGVtLnBhcmVudE5vZGUgfHwge30pLmZpcnN0Q2hpbGQsIGVsZW0pO1xuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBzaWJsaW5ncyhlbGVtLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9LFxuICAgICAgICBjb250ZW50czogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZWxlbS5jb250ZW50RG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5LCBpT1MgNyBvbmx5LCBBbmRyb2lkIEJyb3dzZXIgPD00LjMgb25seVxuICAgICAgICAgICAgLy8gVHJlYXQgdGhlIHRlbXBsYXRlIGVsZW1lbnQgYXMgYSByZWd1bGFyIG9uZSBpbiBicm93c2VycyB0aGF0XG4gICAgICAgICAgICAvLyBkb24ndCBzdXBwb3J0IGl0LlxuICAgICAgICAgICAgaWYgKG5vZGVOYW1lKGVsZW0sIFwidGVtcGxhdGVcIikpIHtcbiAgICAgICAgICAgICAgICBlbGVtID0gZWxlbS5jb250ZW50IHx8IGVsZW07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkubWVyZ2UoW10sIGVsZW0uY2hpbGROb2Rlcyk7XG4gICAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICAgICAgalF1ZXJ5LmZuW25hbWVdID0gZnVuY3Rpb24gKHVudGlsLCBzZWxlY3Rvcikge1xuICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKHRoaXMsIGZuLCB1bnRpbCk7XG5cbiAgICAgICAgICAgIGlmIChuYW1lLnNsaWNlKC01KSAhPT0gXCJVbnRpbFwiKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB1bnRpbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKHNlbGVjdG9yLCBtYXRjaGVkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMSkge1xuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZXNcbiAgICAgICAgICAgICAgICBpZiAoIWd1YXJhbnRlZWRVbmlxdWVbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnVuaXF1ZVNvcnQobWF0Y2hlZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcbiAgICAgICAgICAgICAgICBpZiAocnBhcmVudHNwcmV2LnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZC5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2sobWF0Y2hlZCk7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgdmFyIHJub3RodG1sd2hpdGUgPSAoL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nKTtcblxuXG4gICAgLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbiAgICBmdW5jdGlvbiBjcmVhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICBqUXVlcnkuZWFjaChvcHRpb25zLm1hdGNoKHJub3RodG1sd2hpdGUpIHx8IFtdLCBmdW5jdGlvbiAoXywgZmxhZykge1xuICAgICAgICAgICAgb2JqZWN0W2ZsYWddID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLypcbiAgICAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICAgICpcbiAgICAgKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICAgICAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAgICAgKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gICAgICpcbiAgICAgKiBQb3NzaWJsZSBvcHRpb25zOlxuICAgICAqXG4gICAgICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICAgICAqXG4gICAgICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gICAgICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICAgICAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICAgICAqXG4gICAgICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAgICAgKlxuICAgICAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICAgICAqXG4gICAgICovXG4gICAgalF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICAgICAgLy8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuICAgICAgICAvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG4gICAgICAgIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG4gICAgICAgICAgICBjcmVhdGVPcHRpb25zKG9wdGlvbnMpIDpcbiAgICAgICAgICAgIGpRdWVyeS5leHRlbmQoe30sIG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG4gICAgICAgICAgICBmaXJpbmcsXG5cbiAgICAgICAgICAgIC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG4gICAgICAgICAgICBtZW1vcnksXG5cbiAgICAgICAgICAgIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG4gICAgICAgICAgICBmaXJlZCxcblxuICAgICAgICAgICAgLy8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuICAgICAgICAgICAgbG9ja2VkLFxuXG4gICAgICAgICAgICAvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuICAgICAgICAgICAgbGlzdCA9IFtdLFxuXG4gICAgICAgICAgICAvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuICAgICAgICAgICAgcXVldWUgPSBbXSxcblxuICAgICAgICAgICAgLy8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG4gICAgICAgICAgICBmaXJpbmdJbmRleCA9IC0xLFxuXG4gICAgICAgICAgICAvLyBGaXJlIGNhbGxiYWNrc1xuICAgICAgICAgICAgZmlyZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuICAgICAgICAgICAgICAgIGxvY2tlZCA9IGxvY2tlZCB8fCBvcHRpb25zLm9uY2U7XG5cbiAgICAgICAgICAgICAgICAvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcbiAgICAgICAgICAgICAgICAvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvciAoOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RbZmlyaW5nSW5kZXhdLmFwcGx5KG1lbW9yeVswXSwgbWVtb3J5WzFdKSA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN0b3BPbkZhbHNlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW1vcnkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMubWVtb3J5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbW9yeSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZpcmluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2RcbiAgICAgICAgICAgICAgICBpZiAobG9ja2VkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVtb3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3RcbiAgICAgICAgICAgIHNlbGYgPSB7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgYWRkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVtb3J5ICYmICFmaXJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKG1lbW9yeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbiBhZGQoYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5lYWNoKGFyZ3MsIGZ1bmN0aW9uIChfLCBhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oYXJnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoYXJnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaChhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZShhcmcpICE9PSBcInN0cmluZ1wiKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZChhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KShhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVtb3J5ICYmICFmaXJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmVhY2goYXJndW1lbnRzLCBmdW5jdGlvbiAoXywgYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGluZGV4ID0galF1ZXJ5LmluQXJyYXkoYXJnLCBsaXN0LCBpbmRleCkpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPD0gZmlyaW5nSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyaW5nSW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAgICAgICAvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cbiAgICAgICAgICAgICAgICBoYXM6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4gP1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmluQXJyYXkoZm4sIGxpc3QpID4gLTEgOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgZW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxuICAgICAgICAgICAgICAgIC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xuICAgICAgICAgICAgICAgIC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuICAgICAgICAgICAgICAgIGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9ja2VkID0gcXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdCA9IG1lbW9yeSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFsaXN0O1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBEaXNhYmxlIC5maXJlXG4gICAgICAgICAgICAgICAgLy8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcbiAgICAgICAgICAgICAgICAvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG4gICAgICAgICAgICAgICAgbG9jazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1lbW9yeSAmJiAhZmlyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ID0gbWVtb3J5ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxvY2tlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFsb2NrZWQ7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICBmaXJlV2l0aDogZnVuY3Rpb24gKGNvbnRleHQsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IFtjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJnc107XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaXJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgZmlyZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmZpcmVXaXRoKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2VcbiAgICAgICAgICAgICAgICBmaXJlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFmaXJlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cblxuICAgIGZ1bmN0aW9uIElkZW50aXR5KHYpIHtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVGhyb3dlcihleCkge1xuICAgICAgICB0aHJvdyBleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZG9wdFZhbHVlKHZhbHVlLCByZXNvbHZlLCByZWplY3QsIG5vVmFsdWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZDtcblxuICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgaXNGdW5jdGlvbigobWV0aG9kID0gdmFsdWUucHJvbWlzZSkpKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLmNhbGwodmFsdWUpLmRvbmUocmVzb2x2ZSkuZmFpbChyZWplY3QpO1xuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXIgdGhlbmFibGVzXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICYmIGlzRnVuY3Rpb24oKG1ldGhvZCA9IHZhbHVlLnRoZW4pKSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZC5jYWxsKHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcbiAgICAgICAgICAgICAgICAvLyAqIGZhbHNlOiBbIHZhbHVlIF0uc2xpY2UoIDAgKSA9PiByZXNvbHZlKCB2YWx1ZSApXG4gICAgICAgICAgICAgICAgLy8gKiB0cnVlOiBbIHZhbHVlIF0uc2xpY2UoIDEgKSA9PiByZXNvbHZlKClcbiAgICAgICAgICAgICAgICByZXNvbHZlLmFwcGx5KHVuZGVmaW5lZCwgW3ZhbHVlXS5zbGljZShub1ZhbHVlKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuICAgICAgICAgICAgLy8gU2luY2UgalF1ZXJ5LndoZW4gZG9lc24ndCB1bndyYXAgdGhlbmFibGVzLCB3ZSBjYW4gc2tpcCB0aGUgZXh0cmEgY2hlY2tzIGFwcGVhcmluZyBpblxuICAgICAgICAgICAgLy8gRGVmZXJyZWQjdGhlbiB0byBjb25kaXRpb25hbGx5IHN1cHByZXNzIHJlamVjdGlvbi5cbiAgICAgICAgfSBjYXRjaCAodmFsdWUpIHtcblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxuICAgICAgICAgICAgLy8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuICAgICAgICAgICAgcmVqZWN0LmFwcGx5KHVuZGVmaW5lZCwgW3ZhbHVlXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBqUXVlcnkuZXh0ZW5kKHtcblxuICAgICAgICBEZWZlcnJlZDogZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICAgIHZhciB0dXBsZXMgPSBbXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGNhbGxiYWNrcyxcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxuICAgICAgICAgICAgICAgICAgICBbXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKFwibWVtb3J5XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LkNhbGxiYWNrcyhcIm1lbW9yeVwiKSwgMl0sXG4gICAgICAgICAgICAgICAgICAgIFtcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwgMCwgXCJyZXNvbHZlZFwiXSxcbiAgICAgICAgICAgICAgICAgICAgW1wicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIDEsIFwicmVqZWN0ZWRcIl1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHN0YXRlID0gXCJwZW5kaW5nXCIsXG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYWx3YXlzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5kb25lKGFyZ3VtZW50cykuZmFpbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKG51bGwsIGZuKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG4gICAgICAgICAgICAgICAgICAgIHBpcGU6IGZ1bmN0aW9uICgvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZucyA9IGFyZ3VtZW50cztcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5EZWZlcnJlZChmdW5jdGlvbiAobmV3RGVmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZWFjaCh0dXBsZXMsIGZ1bmN0aW9uIChpLCB0dXBsZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBpc0Z1bmN0aW9uKGZuc1t0dXBsZVs0XV0pICYmIGZuc1t0dXBsZVs0XV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZFt0dXBsZVsxXV0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5lZCAmJiBpc0Z1bmN0aW9uKHJldHVybmVkLnByb21pc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWQucHJvbWlzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wcm9ncmVzcyhuZXdEZWZlci5ub3RpZnkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kb25lKG5ld0RlZmVyLnJlc29sdmUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5mYWlsKG5ld0RlZmVyLnJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RlZmVyW3R1cGxlWzBdICsgXCJXaXRoXCJdKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbiA/IFtyZXR1cm5lZF0gOiBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbnMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkucHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0aGVuOiBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhEZXB0aCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlc29sdmUoZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pZ2h0VGhyb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVybmVkLCB0aGVuO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA8IG1heERlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZCA9IGhhbmRsZXIuYXBwbHkodGhhdCwgYXJncyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNDhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuZWQgPT09IGRlZmVycmVkLnByb21pc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiA9IHJldHVybmVkICYmXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuNFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGNoZWNrIG9iamVjdHMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlbmFiaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkLnRoZW47XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoZW4pKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BlY2lhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbi5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4RGVwdGgrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbi5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5V2l0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIgIT09IElkZW50aXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IFtyZXR1cm5lZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSB2YWx1ZShzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IHByb2Nlc3MgaXMgcmVzb2x2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCkodGhhdCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzID0gc3BlY2lhbCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlnaHRUaHJvdyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlnaHRUaHJvdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3Muc3RhY2tUcmFjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy40LjFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCArIDEgPj0gbWF4RGVwdGgpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlciAhPT0gVGhyb3dlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gW2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdFdpdGgodGhhdCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlLXJlc29sdmUgcHJvbWlzZXMgaW1tZWRpYXRlbHkgdG8gZG9kZ2UgZmFsc2UgcmVqZWN0aW9uIGZyb21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3Vic2VxdWVudCBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIHN0YWNrLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KHByb2Nlc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5EZWZlcnJlZChmdW5jdGlvbiAobmV3RGVmZXIpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dXBsZXNbMF1bM10uYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RlZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGdW5jdGlvbihvblByb2dyZXNzKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Qcm9ncmVzcyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWRlbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdEZWZlci5ub3RpZnlXaXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnVsZmlsbGVkX2hhbmRsZXJzLmFkZCggLi4uIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dXBsZXNbMV1bM10uYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RlZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGdW5jdGlvbihvbkZ1bGZpbGxlZCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRnVsZmlsbGVkIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZGVudGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dXBsZXNbMl1bM10uYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RlZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGdW5jdGlvbihvblJlamVjdGVkKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25SZWplY3RlZCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhyb3dlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZChvYmosIHByb21pc2UpIDogcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQgPSB7fTtcblxuICAgICAgICAgICAgLy8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuICAgICAgICAgICAgalF1ZXJ5LmVhY2godHVwbGVzLCBmdW5jdGlvbiAoaSwgdHVwbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IHR1cGxlWzJdLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVN0cmluZyA9IHR1cGxlWzVdO1xuXG4gICAgICAgICAgICAgICAgLy8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG4gICAgICAgICAgICAgICAgLy8gcHJvbWlzZS5kb25lID0gbGlzdC5hZGRcbiAgICAgICAgICAgICAgICAvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuICAgICAgICAgICAgICAgIHByb21pc2VbdHVwbGVbMV1dID0gbGlzdC5hZGQ7XG5cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgc3RhdGVcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXRlID0gXCJyZWplY3RlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZVN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHR1cGxlc1szIC0gaV1bMl0uZGlzYWJsZSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnVsZmlsbGVkX2hhbmRsZXJzLmRpc2FibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHR1cGxlc1szIC0gaV1bM10uZGlzYWJsZSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvZ3Jlc3NfY2FsbGJhY2tzLmxvY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHR1cGxlc1swXVsyXS5sb2NrLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9ncmVzc19oYW5kbGVycy5sb2NrXG4gICAgICAgICAgICAgICAgICAgICAgICB0dXBsZXNbMF1bM10ubG9ja1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHByb2dyZXNzX2hhbmRsZXJzLmZpcmVcbiAgICAgICAgICAgICAgICAvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuICAgICAgICAgICAgICAgIC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcbiAgICAgICAgICAgICAgICBsaXN0LmFkZCh0dXBsZVszXS5maXJlKTtcblxuICAgICAgICAgICAgICAgIC8vIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5ub3RpZnlXaXRoKC4uLikgfVxuICAgICAgICAgICAgICAgIC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG4gICAgICAgICAgICAgICAgLy8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG4gICAgICAgICAgICAgICAgZGVmZXJyZWRbdHVwbGVbMF1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZFt0dXBsZVswXSArIFwiV2l0aFwiXSh0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuICAgICAgICAgICAgICAgIC8vIGRlZmVycmVkLnJlc29sdmVXaXRoID0gbGlzdC5maXJlV2l0aFxuICAgICAgICAgICAgICAgIC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG4gICAgICAgICAgICAgICAgZGVmZXJyZWRbdHVwbGVbMF0gKyBcIldpdGhcIl0gPSBsaXN0LmZpcmVXaXRoO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuICAgICAgICAgICAgcHJvbWlzZS5wcm9taXNlKGRlZmVycmVkKTtcblxuICAgICAgICAgICAgLy8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuICAgICAgICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgICAgICAgICBmdW5jLmNhbGwoZGVmZXJyZWQsIGRlZmVycmVkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWxsIGRvbmUhXG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRGVmZXJyZWQgaGVscGVyXG4gICAgICAgIHdoZW46IGZ1bmN0aW9uIChzaW5nbGVWYWx1ZSkge1xuICAgICAgICAgICAgdmFyXG5cbiAgICAgICAgICAgICAgICAvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcbiAgICAgICAgICAgICAgICByZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuXG4gICAgICAgICAgICAgICAgLy8gY291bnQgb2YgdW5wcm9jZXNzZWQgYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgaSA9IHJlbWFpbmluZyxcblxuICAgICAgICAgICAgICAgIC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcbiAgICAgICAgICAgICAgICByZXNvbHZlQ29udGV4dHMgPSBBcnJheShpKSxcbiAgICAgICAgICAgICAgICByZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuXG4gICAgICAgICAgICAgICAgLy8gdGhlIG1hc3RlciBEZWZlcnJlZFxuICAgICAgICAgICAgICAgIG1hc3RlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG4gICAgICAgICAgICAgICAgLy8gc3Vib3JkaW5hdGUgY2FsbGJhY2sgZmFjdG9yeVxuICAgICAgICAgICAgICAgIHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlQ29udGV4dHNbaV0gPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZVZhbHVlc1tpXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbChhcmd1bWVudHMpIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgtLXJlbWFpbmluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXN0ZXIucmVzb2x2ZVdpdGgocmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcbiAgICAgICAgICAgIGlmIChyZW1haW5pbmcgPD0gMSkge1xuICAgICAgICAgICAgICAgIGFkb3B0VmFsdWUoc2luZ2xlVmFsdWUsIG1hc3Rlci5kb25lKHVwZGF0ZUZ1bmMoaSkpLnJlc29sdmUsIG1hc3Rlci5yZWplY3QsXG4gICAgICAgICAgICAgICAgICAgICFyZW1haW5pbmcpO1xuXG4gICAgICAgICAgICAgICAgLy8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuICAgICAgICAgICAgICAgIGlmIChtYXN0ZXIuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgaXNGdW5jdGlvbihyZXNvbHZlVmFsdWVzW2ldICYmIHJlc29sdmVWYWx1ZXNbaV0udGhlbikpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFzdGVyLnRoZW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgYWRvcHRWYWx1ZShyZXNvbHZlVmFsdWVzW2ldLCB1cGRhdGVGdW5jKGkpLCBtYXN0ZXIucmVqZWN0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXG4gICAgLy8gd2FybiBhYm91dCB0aGVtIEFTQVAgcmF0aGVyIHRoYW4gc3dhbGxvd2luZyB0aGVtIGJ5IGRlZmF1bHQuXG4gICAgdmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbiAgICBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uIChlcnJvciwgc3RhY2spIHtcblxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG4gICAgICAgIC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG4gICAgICAgIGlmICh3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS53YXJuICYmIGVycm9yICYmIHJlcnJvck5hbWVzLnRlc3QoZXJyb3IubmFtZSkpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLndhcm4oXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICBqUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgIH07XG5cblxuICAgIC8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxuICAgIHZhciByZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxuICAgIGpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uIChmbikge1xuXG4gICAgICAgIHJlYWR5TGlzdFxuICAgICAgICAgICAgLnRoZW4oZm4pXG5cbiAgICAgICAgICAgIC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXG4gICAgICAgICAgICAvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcbiAgICAgICAgICAgIC8vIHJlZ2lzdHJhdGlvbi5cbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkucmVhZHlFeGNlcHRpb24oZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGpRdWVyeS5leHRlbmQoe1xuXG4gICAgICAgIC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG4gICAgICAgIGlzUmVhZHk6IGZhbHNlLFxuXG4gICAgICAgIC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcbiAgICAgICAgLy8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcbiAgICAgICAgcmVhZHlXYWl0OiAxLFxuXG4gICAgICAgIC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcbiAgICAgICAgcmVhZHk6IGZ1bmN0aW9uICh3YWl0KSB7XG5cbiAgICAgICAgICAgIC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcbiAgICAgICAgICAgIGlmICh3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuICAgICAgICAgICAgalF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuICAgICAgICAgICAgaWYgKHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuICAgICAgICAgICAgcmVhZHlMaXN0LnJlc29sdmVXaXRoKGRvY3VtZW50LCBbalF1ZXJ5XSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGpRdWVyeS5yZWFkeS50aGVuID0gcmVhZHlMaXN0LnRoZW47XG5cbiAgICAvLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGNvbXBsZXRlZCk7XG4gICAgICAgIGpRdWVyeS5yZWFkeSgpO1xuICAgIH1cblxuICAgIC8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkXG4gICAgLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4gICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxuICAgIC8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHxcbiAgICAgICAgKGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwpKSB7XG5cbiAgICAgICAgLy8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGpRdWVyeS5yZWFkeSk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkKTtcblxuICAgICAgICAvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgY29tcGxldGVkKTtcbiAgICB9XG5cblxuICAgIC8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuICAgIC8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxuICAgIHZhciBhY2Nlc3MgPSBmdW5jdGlvbiAoZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcpIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgbGVuID0gZWxlbXMubGVuZ3RoLFxuICAgICAgICAgICAgYnVsayA9IGtleSA9PSBudWxsO1xuXG4gICAgICAgIC8vIFNldHMgbWFueSB2YWx1ZXNcbiAgICAgICAgaWYgKHRvVHlwZShrZXkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBjaGFpbmFibGUgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChpIGluIGtleSkge1xuICAgICAgICAgICAgICAgIGFjY2VzcyhlbGVtcywgZm4sIGksIGtleVtpXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldHMgb25lIHZhbHVlXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hhaW5hYmxlID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJhdyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChidWxrKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcbiAgICAgICAgICAgICAgICBpZiAocmF3KSB7XG4gICAgICAgICAgICAgICAgICAgIGZuLmNhbGwoZWxlbXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgZm4gPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBidWxrID0gZm47XG4gICAgICAgICAgICAgICAgICAgIGZuID0gZnVuY3Rpb24gKGVsZW0sIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBidWxrLmNhbGwoalF1ZXJ5KGVsZW0pLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuKFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbXNbaV0sIGtleSwgcmF3ID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuY2FsbChlbGVtc1tpXSwgaSwgZm4oZWxlbXNbaV0sIGtleSkpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYWluYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1zO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0c1xuICAgICAgICBpZiAoYnVsaykge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwoZWxlbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxlbiA/IGZuKGVsZW1zWzBdLCBrZXkpIDogZW1wdHlHZXQ7XG4gICAgfTtcblxuXG4gICAgLy8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG4gICAgdmFyIHJtc1ByZWZpeCA9IC9eLW1zLS8sXG4gICAgICAgIHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZztcblxuICAgIC8vIFVzZWQgYnkgY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuICAgIGZ1bmN0aW9uIGZjYW1lbENhc2UoYWxsLCBsZXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcbiAgICAvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG4gICAgLy8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuICAgIGZ1bmN0aW9uIGNhbWVsQ2FzZShzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJtc1ByZWZpeCwgXCJtcy1cIikucmVwbGFjZShyZGFzaEFscGhhLCBmY2FtZWxDYXNlKTtcbiAgICB9XG5cbiAgICB2YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uIChvd25lcikge1xuXG4gICAgICAgIC8vIEFjY2VwdHMgb25seTpcbiAgICAgICAgLy8gIC0gTm9kZVxuICAgICAgICAvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG4gICAgICAgIC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG4gICAgICAgIC8vICAtIE9iamVjdFxuICAgICAgICAvLyAgICAtIEFueVxuICAgICAgICByZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISgrb3duZXIubm9kZVR5cGUpO1xuICAgIH07XG5cblxuICAgIGZ1bmN0aW9uIERhdGEoKSB7XG4gICAgICAgIHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbiAgICB9XG5cbiAgICBEYXRhLnVpZCA9IDE7XG5cbiAgICBEYXRhLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjYWNoZTogZnVuY3Rpb24gKG93bmVyKSB7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gb3duZXJbdGhpcy5leHBhbmRvXTtcblxuICAgICAgICAgICAgLy8gSWYgbm90LCBjcmVhdGUgb25lXG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB7fTtcblxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG4gICAgICAgICAgICAgICAgaWYgKGFjY2VwdERhdGEob3duZXIpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAob3duZXIubm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyW3RoaXMuZXhwYW5kb10gPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChvd25lciwgZGF0YSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBwcm9wLFxuICAgICAgICAgICAgICAgIGNhY2hlID0gdGhpcy5jYWNoZShvd25lcik7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3NcbiAgICAgICAgICAgIC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1NylcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGNhY2hlW2NhbWVsQ2FzZShkYXRhKV0gPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gQ29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3RcbiAgICAgICAgICAgICAgICBmb3IgKHByb3AgaW4gZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZVtjYW1lbENhc2UocHJvcCldID0gZGF0YVtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldDogZnVuY3Rpb24gKG93bmVyLCBrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZShvd25lcikgOlxuXG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuICAgICAgICAgICAgICAgIG93bmVyW3RoaXMuZXhwYW5kb10gJiYgb3duZXJbdGhpcy5leHBhbmRvXVtjYW1lbENhc2Uoa2V5KV07XG4gICAgICAgIH0sXG4gICAgICAgIGFjY2VzczogZnVuY3Rpb24gKG93bmVyLCBrZXksIHZhbHVlKSB7XG5cbiAgICAgICAgICAgIC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG4gICAgICAgICAgICAvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcbiAgICAgICAgICAgIC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG4gICAgICAgICAgICAvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgKChrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIikgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChvd25lciwga2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcbiAgICAgICAgICAgIC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcbiAgICAgICAgICAgIC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdGhpcy5zZXQob3duZXIsIGtleSwgdmFsdWUpO1xuXG4gICAgICAgICAgICAvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAob3duZXIsIGtleSkge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgY2FjaGUgPSBvd25lclt0aGlzLmV4cGFuZG9dO1xuXG4gICAgICAgICAgICBpZiAoY2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGtleSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbHdheXMgc2V0IGNhbWVsQ2FzZSBrZXlzLCBzbyByZW1vdmUgdGhhdC5cbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5Lm1hcChjYW1lbENhc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGNhbWVsQ2FzZShrZXkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5IGluIGNhY2hlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIFtrZXldIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIChrZXkubWF0Y2gocm5vdGh0bWx3aGl0ZSkgfHwgW10pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGkgPSBrZXkubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2FjaGVba2V5W2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KGNhY2hlKSkge1xuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxuICAgICAgICAgICAgICAgIC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgLy8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXG4gICAgICAgICAgICAgICAgaWYgKG93bmVyLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIG93bmVyW3RoaXMuZXhwYW5kb10gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG93bmVyW3RoaXMuZXhwYW5kb107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBoYXNEYXRhOiBmdW5jdGlvbiAob3duZXIpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IG93bmVyW3RoaXMuZXhwYW5kb107XG4gICAgICAgICAgICByZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoY2FjaGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG4gICAgdmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG4gICAgLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbiAgICAvL1xuICAgIC8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4gICAgLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuICAgIC8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbiAgICAvL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbiAgICAvL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuICAgIC8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbiAgICAvL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbiAgICB2YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuICAgICAgICBybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbiAgICBmdW5jdGlvbiBnZXREYXRhKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhID09PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhID09PSBcIm51bGxcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuICAgICAgICBpZiAoZGF0YSA9PT0gK2RhdGEgKyBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gK2RhdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmJyYWNlLnRlc3QoZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF0YUF0dHIoZWxlbSwga2V5LCBkYXRhKSB7XG4gICAgICAgIHZhciBuYW1lO1xuXG4gICAgICAgIC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcbiAgICAgICAgLy8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgbmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKHJtdWx0aURhc2gsIFwiLSQmXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUobmFtZSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBnZXREYXRhKGRhdGEpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcbiAgICAgICAgICAgICAgICBkYXRhVXNlci5zZXQoZWxlbSwga2V5LCBkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBqUXVlcnkuZXh0ZW5kKHtcbiAgICAgICAgaGFzRGF0YTogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhVXNlci5oYXNEYXRhKGVsZW0pIHx8IGRhdGFQcml2Lmhhc0RhdGEoZWxlbSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGF0YTogZnVuY3Rpb24gKGVsZW0sIG5hbWUsIGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhVXNlci5hY2Nlc3MoZWxlbSwgbmFtZSwgZGF0YSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlRGF0YTogZnVuY3Rpb24gKGVsZW0sIG5hbWUpIHtcbiAgICAgICAgICAgIGRhdGFVc2VyLnJlbW92ZShlbGVtLCBuYW1lKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuICAgICAgICAvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cbiAgICAgICAgX2RhdGE6IGZ1bmN0aW9uIChlbGVtLCBuYW1lLCBkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVByaXYuYWNjZXNzKGVsZW0sIG5hbWUsIGRhdGEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9yZW1vdmVEYXRhOiBmdW5jdGlvbiAoZWxlbSwgbmFtZSkge1xuICAgICAgICAgICAgZGF0YVByaXYucmVtb3ZlKGVsZW0sIG5hbWUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgICAgZGF0YTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBpLCBuYW1lLCBkYXRhLFxuICAgICAgICAgICAgICAgIGVsZW0gPSB0aGlzWzBdLFxuICAgICAgICAgICAgICAgIGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgIC8vIEdldHMgYWxsIHZhbHVlc1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhVXNlci5nZXQoZWxlbSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldChlbGVtLCBcImhhc0RhdGFBdHRyc1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGF0dHJzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGF0dHJzW2ldLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lLmluZGV4T2YoXCJkYXRhLVwiKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGNhbWVsQ2FzZShuYW1lLnNsaWNlKDUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFBdHRyKGVsZW0sIG5hbWUsIGRhdGFbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByaXYuc2V0KGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhVXNlci5zZXQodGhpcywga2V5KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFjY2Vzcyh0aGlzLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YTtcblxuICAgICAgICAgICAgICAgIC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG4gICAgICAgICAgICAgICAgLy8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcbiAgICAgICAgICAgICAgICAvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuICAgICAgICAgICAgICAgIGlmIChlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhVXNlci5nZXQoZWxlbSwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuICAgICAgICAgICAgICAgICAgICAvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhQXR0cihlbGVtLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgZGF0YS4uLlxuICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgYWx3YXlzIHN0b3JlIHRoZSBjYW1lbENhc2VkIGtleVxuICAgICAgICAgICAgICAgICAgICBkYXRhVXNlci5zZXQodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZURhdGE6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGRhdGFVc2VyLnJlbW92ZSh0aGlzLCBrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgalF1ZXJ5LmV4dGVuZCh7XG4gICAgICAgIHF1ZXVlOiBmdW5jdGlvbiAoZWxlbSwgdHlwZSwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIHF1ZXVlO1xuXG4gICAgICAgICAgICBpZiAoZWxlbSkge1xuICAgICAgICAgICAgICAgIHR5cGUgPSAodHlwZSB8fCBcImZ4XCIpICsgXCJxdWV1ZVwiO1xuICAgICAgICAgICAgICAgIHF1ZXVlID0gZGF0YVByaXYuZ2V0KGVsZW0sIHR5cGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcXVldWUgfHwgQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheShkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBxdWV1ZSB8fCBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkZXF1ZXVlOiBmdW5jdGlvbiAoZWxlbSwgdHlwZSkge1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG4gICAgICAgICAgICB2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoZWxlbSwgdHlwZSksXG4gICAgICAgICAgICAgICAgc3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgZm4gPSBxdWV1ZS5zaGlmdCgpLFxuICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKGVsZW0sIHR5cGUpLFxuICAgICAgICAgICAgICAgIG5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKGVsZW0sIHR5cGUpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcbiAgICAgICAgICAgIGlmIChmbiA9PT0gXCJpbnByb2dyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgc3RhcnRMZW5ndGgtLTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZuKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG4gICAgICAgICAgICAgICAgLy8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImZ4XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVldWUudW5zaGlmdChcImlucHJvZ3Jlc3NcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBob29rcy5zdG9wO1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoZWxlbSwgbmV4dCwgaG9va3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXN0YXJ0TGVuZ3RoICYmIGhvb2tzKSB7XG4gICAgICAgICAgICAgICAgaG9va3MuZW1wdHkuZmlyZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG4gICAgICAgIF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiAoZWxlbSwgdHlwZSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcbiAgICAgICAgICAgIHJldHVybiBkYXRhUHJpdi5nZXQoZWxlbSwga2V5KSB8fCBkYXRhUHJpdi5hY2Nlc3MoZWxlbSwga2V5LCB7XG4gICAgICAgICAgICAgICAgZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKS5hZGQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhUHJpdi5yZW1vdmUoZWxlbSwgW3R5cGUgKyBcInF1ZXVlXCIsIGtleV0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICAgIHF1ZXVlOiBmdW5jdGlvbiAodHlwZSwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIHNldHRlciA9IDI7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB0eXBlO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBcImZ4XCI7XG4gICAgICAgICAgICAgICAgc2V0dGVyLS07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5xdWV1ZSh0aGlzWzBdLCB0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgdGhpcyA6XG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKHRoaXMsIHR5cGUsIGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5fcXVldWVIb29rcyh0aGlzLCB0eXBlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWzBdICE9PSBcImlucHJvZ3Jlc3NcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmRlcXVldWUodGhpcywgdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVxdWV1ZTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKHRoaXMsIHR5cGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFyUXVldWU6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZSh0eXBlIHx8IFwiZnhcIiwgW10pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcbiAgICAgICAgLy8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG4gICAgICAgIHByb21pc2U6IGZ1bmN0aW9uICh0eXBlLCBvYmopIHtcbiAgICAgICAgICAgIHZhciB0bXAsXG4gICAgICAgICAgICAgICAgY291bnQgPSAxLFxuICAgICAgICAgICAgICAgIGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG4gICAgICAgICAgICAgICAgZWxlbWVudHMgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGkgPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICByZXNvbHZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgtLWNvdW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZVdpdGgoZWxlbWVudHMsIFtlbGVtZW50c10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gdHlwZTtcbiAgICAgICAgICAgICAgICB0eXBlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgdG1wID0gZGF0YVByaXYuZ2V0KGVsZW1lbnRzW2ldLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIpO1xuICAgICAgICAgICAgICAgIGlmICh0bXAgJiYgdG1wLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIHRtcC5lbXB0eS5hZGQocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmVyLnByb21pc2Uob2JqKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBwbnVtID0gKC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvKS5zb3VyY2U7XG5cbiAgICB2YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIpO1xuXG5cbiAgICB2YXIgY3NzRXhwYW5kID0gW1wiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCJdO1xuXG4gICAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG4gICAgdmFyIGlzQXR0YWNoZWQgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5jb250YWlucyhlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0pO1xuICAgICAgICB9LFxuICAgICAgICBjb21wb3NlZCA9IHtjb21wb3NlZDogdHJ1ZX07XG5cbiAgICAvLyBDaGVjayBhdHRhY2htZW50IGFjcm9zcyBzaGFkb3cgRE9NIGJvdW5kYXJpZXMgd2hlbiBwb3NzaWJsZSAoZ2gtMzUwNClcbiAgICBpZiAoZG9jdW1lbnRFbGVtZW50LmF0dGFjaFNoYWRvdykge1xuICAgICAgICBpc0F0dGFjaGVkID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuY29udGFpbnMoZWxlbS5vd25lckRvY3VtZW50LCBlbGVtKSB8fFxuICAgICAgICAgICAgICAgIGVsZW0uZ2V0Um9vdE5vZGUoY29tcG9zZWQpID09PSBlbGVtLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBpc0hpZGRlbldpdGhpblRyZWUgPSBmdW5jdGlvbiAoZWxlbSwgZWwpIHtcblxuICAgICAgICAvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcbiAgICAgICAgLy8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG4gICAgICAgIGVsZW0gPSBlbCB8fCBlbGVtO1xuXG4gICAgICAgIC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG4gICAgICAgIHJldHVybiBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8XG4gICAgICAgICAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiZcblxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxuICAgICAgICAgICAgLy8gU3VwcG9ydDogRmlyZWZveCA8PTQzIC0gNDVcbiAgICAgICAgICAgIC8vIERpc2Nvbm5lY3RlZCBlbGVtZW50cyBjYW4gaGF2ZSBjb21wdXRlZCBkaXNwbGF5OiBub25lLCBzbyBmaXJzdCBjb25maXJtIHRoYXQgZWxlbSBpc1xuICAgICAgICAgICAgLy8gaW4gdGhlIGRvY3VtZW50LlxuICAgICAgICAgICAgaXNBdHRhY2hlZChlbGVtKSAmJlxuXG4gICAgICAgICAgICBqUXVlcnkuY3NzKGVsZW0sIFwiZGlzcGxheVwiKSA9PT0gXCJub25lXCI7XG4gICAgfTtcblxuICAgIHZhciBzd2FwID0gZnVuY3Rpb24gKGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgICAgIHZhciByZXQsIG5hbWUsXG4gICAgICAgICAgICBvbGQgPSB7fTtcblxuICAgICAgICAvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcbiAgICAgICAgZm9yIChuYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9sZFtuYW1lXSA9IGVsZW0uc3R5bGVbbmFtZV07XG4gICAgICAgICAgICBlbGVtLnN0eWxlW25hbWVdID0gb3B0aW9uc1tuYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IGNhbGxiYWNrLmFwcGx5KGVsZW0sIGFyZ3MgfHwgW10pO1xuXG4gICAgICAgIC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuICAgICAgICBmb3IgKG5hbWUgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgZWxlbS5zdHlsZVtuYW1lXSA9IG9sZFtuYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuXG4gICAgZnVuY3Rpb24gYWRqdXN0Q1NTKGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuKSB7XG4gICAgICAgIHZhciBhZGp1c3RlZCwgc2NhbGUsXG4gICAgICAgICAgICBtYXhJdGVyYXRpb25zID0gMjAsXG4gICAgICAgICAgICBjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHdlZW4uY3VyKCk7XG4gICAgICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LmNzcyhlbGVtLCBwcm9wLCBcIlwiKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuICAgICAgICAgICAgdW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1szXSB8fCAoalF1ZXJ5LmNzc051bWJlcltwcm9wXSA/IFwiXCIgOiBcInB4XCIpLFxuXG4gICAgICAgICAgICAvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuICAgICAgICAgICAgaW5pdGlhbEluVW5pdCA9IGVsZW0ubm9kZVR5cGUgJiZcbiAgICAgICAgICAgICAgICAoalF1ZXJ5LmNzc051bWJlcltwcm9wXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwpICYmXG4gICAgICAgICAgICAgICAgcmNzc051bS5leGVjKGpRdWVyeS5jc3MoZWxlbSwgcHJvcCkpO1xuXG4gICAgICAgIGlmIChpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbM10gIT09IHVuaXQpIHtcblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG4gICAgICAgICAgICAvLyBIYWx2ZSB0aGUgaXRlcmF0aW9uIHRhcmdldCB2YWx1ZSB0byBwcmV2ZW50IGludGVyZmVyZW5jZSBmcm9tIENTUyB1cHBlciBib3VuZHMgKGdoLTIxNDQpXG4gICAgICAgICAgICBpbml0aWFsID0gaW5pdGlhbCAvIDI7XG5cbiAgICAgICAgICAgIC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3NcbiAgICAgICAgICAgIHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbM107XG5cbiAgICAgICAgICAgIC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG4gICAgICAgICAgICBpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuICAgICAgICAgICAgd2hpbGUgKG1heEl0ZXJhdGlvbnMtLSkge1xuXG4gICAgICAgICAgICAgICAgLy8gRXZhbHVhdGUgYW5kIHVwZGF0ZSBvdXIgYmVzdCBndWVzcyAoZG91YmxpbmcgZ3Vlc3NlcyB0aGF0IHplcm8gb3V0KS5cbiAgICAgICAgICAgICAgICAvLyBGaW5pc2ggaWYgdGhlIHNjYWxlIGVxdWFscyBvciBjcm9zc2VzIDEgKG1ha2luZyB0aGUgb2xkKm5ldyBwcm9kdWN0IG5vbi1wb3NpdGl2ZSkuXG4gICAgICAgICAgICAgICAgalF1ZXJ5LnN0eWxlKGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0KTtcbiAgICAgICAgICAgICAgICBpZiAoKDEgLSBzY2FsZSkgKiAoMSAtIChzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCB8fCAwLjUpKSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heEl0ZXJhdGlvbnMgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0ICogMjtcbiAgICAgICAgICAgIGpRdWVyeS5zdHlsZShlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCk7XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cbiAgICAgICAgICAgIHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlUGFydHMpIHtcbiAgICAgICAgICAgIGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xuXG4gICAgICAgICAgICAvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcbiAgICAgICAgICAgIGFkanVzdGVkID0gdmFsdWVQYXJ0c1sxXSA/XG4gICAgICAgICAgICAgICAgaW5pdGlhbEluVW5pdCArICh2YWx1ZVBhcnRzWzFdICsgMSkgKiB2YWx1ZVBhcnRzWzJdIDpcbiAgICAgICAgICAgICAgICArdmFsdWVQYXJ0c1syXTtcbiAgICAgICAgICAgIGlmICh0d2Vlbikge1xuICAgICAgICAgICAgICAgIHR3ZWVuLnVuaXQgPSB1bml0O1xuICAgICAgICAgICAgICAgIHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcbiAgICAgICAgICAgICAgICB0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRqdXN0ZWQ7XG4gICAgfVxuXG5cbiAgICB2YXIgZGVmYXVsdERpc3BsYXlNYXAgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KGVsZW0pIHtcbiAgICAgICAgdmFyIHRlbXAsXG4gICAgICAgICAgICBkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgICBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUsXG4gICAgICAgICAgICBkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbbm9kZU5hbWVdO1xuXG4gICAgICAgIGlmIChkaXNwbGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gZGlzcGxheTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRlbXAgPSBkb2MuYm9keS5hcHBlbmRDaGlsZChkb2MuY3JlYXRlRWxlbWVudChub2RlTmFtZSkpO1xuICAgICAgICBkaXNwbGF5ID0galF1ZXJ5LmNzcyh0ZW1wLCBcImRpc3BsYXlcIik7XG5cbiAgICAgICAgdGVtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRlbXApO1xuXG4gICAgICAgIGlmIChkaXNwbGF5ID09PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0RGlzcGxheU1hcFtub2RlTmFtZV0gPSBkaXNwbGF5O1xuXG4gICAgICAgIHJldHVybiBkaXNwbGF5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3dIaWRlKGVsZW1lbnRzLCBzaG93KSB7XG4gICAgICAgIHZhciBkaXNwbGF5LCBlbGVtLFxuICAgICAgICAgICAgdmFsdWVzID0gW10sXG4gICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICBsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXG4gICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgZWxlbSA9IGVsZW1lbnRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghZWxlbS5zdHlsZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuICAgICAgICAgICAgaWYgKHNob3cpIHtcblxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIHdlIGZvcmNlIHZpc2liaWxpdHkgdXBvbiBjYXNjYWRlLWhpZGRlbiBlbGVtZW50cywgYW4gaW1tZWRpYXRlIChhbmQgc2xvdylcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcbiAgICAgICAgICAgICAgICAvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG4gICAgICAgICAgICAgICAgaWYgKGRpc3BsYXkgPT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSBkYXRhUHJpdi5nZXQoZWxlbSwgXCJkaXNwbGF5XCIpIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWVzW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZShlbGVtKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gZ2V0RGVmYXVsdERpc3BsYXkoZWxlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZGlzcGxheSAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2luZGV4XSA9IFwibm9uZVwiO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcbiAgICAgICAgICAgICAgICAgICAgZGF0YVByaXYuc2V0KGVsZW0sIFwiZGlzcGxheVwiLCBkaXNwbGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG4gICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKHZhbHVlc1tpbmRleF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzW2luZGV4XS5zdHlsZS5kaXNwbGF5ID0gdmFsdWVzW2luZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgICAgc2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNob3dIaWRlKHRoaXMsIHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2hvd0hpZGUodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvZ2dsZTogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0hpZGRlbldpdGhpblRyZWUodGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLnNob3coKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkodGhpcykuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIHJjaGVja2FibGVUeXBlID0gKC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pKTtcblxuICAgIHZhciBydGFnTmFtZSA9ICgvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopL2kpO1xuXG4gICAgdmFyIHJzY3JpcHRUeXBlID0gKC9eJHxebW9kdWxlJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kpO1xuXG5cbiAgICAvLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxuICAgIHZhciB3cmFwTWFwID0ge1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4gICAgICAgIG9wdGlvbjogWzEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiXSxcblxuICAgICAgICAvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuICAgICAgICAvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG4gICAgICAgIC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cbiAgICAgICAgdGhlYWQ6IFsxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiXSxcbiAgICAgICAgY29sOiBbMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIl0sXG4gICAgICAgIHRyOiBbMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIl0sXG4gICAgICAgIHRkOiBbMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIl0sXG5cbiAgICAgICAgX2RlZmF1bHQ6IFswLCBcIlwiLCBcIlwiXVxuICAgIH07XG5cbiAgICAvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuICAgIHdyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbjtcblxuICAgIHdyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG4gICAgd3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cblxuICAgIGZ1bmN0aW9uIGdldEFsbChjb250ZXh0LCB0YWcpIHtcblxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG4gICAgICAgIC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcbiAgICAgICAgdmFyIHJldDtcblxuICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnIHx8IFwiKlwiKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCh0YWcgfHwgXCIqXCIpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoY29udGV4dCwgdGFnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5tZXJnZShbY29udGV4dF0sIHJldCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuXG4gICAgLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG4gICAgZnVuY3Rpb24gc2V0R2xvYmFsRXZhbChlbGVtcywgcmVmRWxlbWVudHMpIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgbCA9IGVsZW1zLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZGF0YVByaXYuc2V0KFxuICAgICAgICAgICAgICAgIGVsZW1zW2ldLFxuICAgICAgICAgICAgICAgIFwiZ2xvYmFsRXZhbFwiLFxuICAgICAgICAgICAgICAgICFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQocmVmRWxlbWVudHNbaV0sIFwiZ2xvYmFsRXZhbFwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgdmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG4gICAgZnVuY3Rpb24gYnVpbGRGcmFnbWVudChlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkKSB7XG4gICAgICAgIHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgYXR0YWNoZWQsIGosXG4gICAgICAgICAgICBmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuICAgICAgICAgICAgbm9kZXMgPSBbXSxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgbCA9IGVsZW1zLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZWxlbSA9IGVsZW1zW2ldO1xuXG4gICAgICAgICAgICBpZiAoZWxlbSB8fCBlbGVtID09PSAwKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgbm9kZXMgZGlyZWN0bHlcbiAgICAgICAgICAgICAgICBpZiAodG9UeXBlKGVsZW0pID09PSBcIm9iamVjdFwiKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG4gICAgICAgICAgICAgICAgICAgIC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gW2VsZW1dIDogZWxlbSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghcmh0bWwudGVzdChlbGVtKSkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoZWxlbSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZChjb250ZXh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgdGFnID0gKHJ0YWdOYW1lLmV4ZWMoZWxlbSkgfHwgW1wiXCIsIFwiXCJdKVsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICB3cmFwID0gd3JhcE1hcFt0YWddIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG4gICAgICAgICAgICAgICAgICAgIHRtcC5pbm5lckhUTUwgPSB3cmFwWzFdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoZWxlbSkgKyB3cmFwWzJdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuICAgICAgICAgICAgICAgICAgICBqID0gd3JhcFswXTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gdG1wLmxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuICAgICAgICAgICAgICAgICAgICAvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZShub2RlcywgdG1wLmNoaWxkTm9kZXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgIHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAoIzEyMzkyKVxuICAgICAgICAgICAgICAgICAgICB0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcbiAgICAgICAgZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG4gICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoKGVsZW0gPSBub2Rlc1tpKytdKSkge1xuXG4gICAgICAgICAgICAvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheShlbGVtLCBzZWxlY3Rpb24pID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWdub3JlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZ25vcmVkLnB1c2goZWxlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhdHRhY2hlZCA9IGlzQXR0YWNoZWQoZWxlbSk7XG5cbiAgICAgICAgICAgIC8vIEFwcGVuZCB0byBmcmFnbWVudFxuICAgICAgICAgICAgdG1wID0gZ2V0QWxsKGZyYWdtZW50LmFwcGVuZENoaWxkKGVsZW0pLCBcInNjcmlwdFwiKTtcblxuICAgICAgICAgICAgLy8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuICAgICAgICAgICAgaWYgKGF0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgc2V0R2xvYmFsRXZhbCh0bXApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG4gICAgICAgICAgICBpZiAoc2NyaXB0cykge1xuICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlICgoZWxlbSA9IHRtcFtqKytdKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocnNjcmlwdFR5cGUudGVzdChlbGVtLnR5cGUgfHwgXCJcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdHMucHVzaChlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICB9XG5cblxuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcbiAgICAgICAgICAgIGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLFxuICAgICAgICAgICAgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuICAgICAgICAvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuICAgICAgICAvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG4gICAgICAgIC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwicmFkaW9cIik7XG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIpO1xuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIFwidFwiKTtcblxuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgb25seVxuICAgICAgICAvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcbiAgICAgICAgc3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSh0cnVlKS5jbG9uZU5vZGUodHJ1ZSkubGFzdENoaWxkLmNoZWNrZWQ7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG4gICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcbiAgICAgICAgc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSh0cnVlKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xuICAgIH0pKCk7XG5cblxuICAgIHZhclxuICAgICAgICBya2V5RXZlbnQgPSAvXmtleS8sXG4gICAgICAgIHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxuICAgICAgICBydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbiAgICBmdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuICAgIC8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzLCBleGNlcHQgd2hlbiB0aGV5IGFyZSBuby1vcC5cbiAgICAvLyBTbyBleHBlY3QgZm9jdXMgdG8gYmUgc3luY2hyb25vdXMgd2hlbiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IGFjdGl2ZSxcbiAgICAvLyBhbmQgYmx1ciB0byBiZSBzeW5jaHJvbm91cyB3aGVuIHRoZSBlbGVtZW50IGlzIG5vdCBhbHJlYWR5IGFjdGl2ZS5cbiAgICAvLyAoZm9jdXMgYW5kIGJsdXIgYXJlIGFsd2F5cyBzeW5jaHJvbm91cyBpbiBvdGhlciBzdXBwb3J0ZWQgYnJvd3NlcnMsXG4gICAgLy8gdGhpcyBqdXN0IGRlZmluZXMgd2hlbiB3ZSBjYW4gY291bnQgb24gaXQpLlxuICAgIGZ1bmN0aW9uIGV4cGVjdFN5bmMoZWxlbSwgdHlwZSkge1xuICAgICAgICByZXR1cm4gKGVsZW0gPT09IHNhZmVBY3RpdmVFbGVtZW50KCkpID09PSAodHlwZSA9PT0gXCJmb2N1c1wiKTtcbiAgICB9XG5cbiAgICAvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuICAgIC8vIEFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiB0aHJvdyB1bmV4cGVjdGVkbHlcbiAgICAvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzOTNcbiAgICBmdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uKGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSkge1xuICAgICAgICB2YXIgb3JpZ0ZuLCB0eXBlO1xuXG4gICAgICAgIC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuICAgICAgICBpZiAodHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiKSB7XG5cbiAgICAgICAgICAgIC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiKSB7XG5cbiAgICAgICAgICAgICAgICAvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHR5cGUgaW4gdHlwZXMpIHtcbiAgICAgICAgICAgICAgICBvbihlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbdHlwZV0sIG9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCkge1xuXG4gICAgICAgICAgICAvLyAoIHR5cGVzLCBmbiApXG4gICAgICAgICAgICBmbiA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2UgaWYgKGZuID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblxuICAgICAgICAgICAgICAgIC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG4gICAgICAgICAgICAgICAgZm4gPSBkYXRhO1xuICAgICAgICAgICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gKCB0eXBlcywgZGF0YSwgZm4gKVxuICAgICAgICAgICAgICAgIGZuID0gZGF0YTtcbiAgICAgICAgICAgICAgICBkYXRhID0gc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZuID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZm4gPSByZXR1cm5GYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICghZm4pIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9uZSA9PT0gMSkge1xuICAgICAgICAgICAgb3JpZ0ZuID0gZm47XG4gICAgICAgICAgICBmbiA9IGZ1bmN0aW9uIChldmVudCkge1xuXG4gICAgICAgICAgICAgICAgLy8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG4gICAgICAgICAgICAgICAgalF1ZXJ5KCkub2ZmKGV2ZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ0ZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuICAgICAgICAgICAgZm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8IChvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKyspO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LmFkZCh0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAgICAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gICAgKi9cbiAgICBqUXVlcnkuZXZlbnQgPSB7XG5cbiAgICAgICAgZ2xvYmFsOiB7fSxcblxuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IpIHtcblxuICAgICAgICAgICAgdmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuICAgICAgICAgICAgICAgIGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuICAgICAgICAgICAgICAgIHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcbiAgICAgICAgICAgICAgICBlbGVtRGF0YSA9IGRhdGFQcml2LmdldChlbGVtKTtcblxuICAgICAgICAgICAgLy8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcbiAgICAgICAgICAgIGlmICghZWxlbURhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuICAgICAgICAgICAgaWYgKGhhbmRsZXIuaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGhhbmRsZU9iakluID0gaGFuZGxlcjtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCBpbnZhbGlkIHNlbGVjdG9ycyB0aHJvdyBleGNlcHRpb25zIGF0IGF0dGFjaCB0aW1lXG4gICAgICAgICAgICAvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcbiAgICAgICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3Rvcihkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuZ3VpZCkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3RcbiAgICAgICAgICAgIGlmICghKGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cykpIHtcbiAgICAgICAgICAgICAgICBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlKSkge1xuICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24gKGUpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoZWxlbSwgYXJndW1lbnRzKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG4gICAgICAgICAgICB0eXBlcyA9ICh0eXBlcyB8fCBcIlwiKS5tYXRjaChybm90aHRtbHdoaXRlKSB8fCBbXCJcIl07XG4gICAgICAgICAgICB0ID0gdHlwZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKHQtLSkge1xuICAgICAgICAgICAgICAgIHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWModHlwZXNbdF0pIHx8IFtdO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsxXTtcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VzID0gKHRtcFsyXSB8fCBcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuICAgICAgICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFt0eXBlXSB8fCB7fTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuICAgICAgICAgICAgICAgIHR5cGUgPSAoc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUpIHx8IHR5cGU7XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG4gICAgICAgICAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsW3R5cGVdIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgICAgICAgICBoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ1R5cGU6IG9yaWdUeXBlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICBndWlkOiBoYW5kbGVyLmd1aWQsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICAgICAgICAgICAgICAgICAgbmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdChzZWxlY3RvciksXG4gICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKFwiLlwiKVxuICAgICAgICAgICAgICAgIH0sIGhhbmRsZU9iakluKTtcblxuICAgICAgICAgICAgICAgIC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgaWYgKCEoaGFuZGxlcnMgPSBldmVudHNbdHlwZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzID0gZXZlbnRzW3R5cGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNwZWNpYWwuc2V0dXAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpYWwuc2V0dXAuY2FsbChlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSkgPT09IGZhbHNlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZXZlbnRIYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNwZWNpYWwuYWRkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwZWNpYWwuYWRkLmNhbGwoZWxlbSwgaGFuZGxlT2JqKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmopO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLnB1c2goaGFuZGxlT2JqKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50Lmdsb2JhbFt0eXBlXSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcykge1xuXG4gICAgICAgICAgICB2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG4gICAgICAgICAgICAgICAgZXZlbnRzLCB0LCBoYW5kbGVPYmosXG4gICAgICAgICAgICAgICAgc3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuICAgICAgICAgICAgICAgIGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YShlbGVtKSAmJiBkYXRhUHJpdi5nZXQoZWxlbSk7XG5cbiAgICAgICAgICAgIGlmICghZWxlbURhdGEgfHwgIShldmVudHMgPSBlbGVtRGF0YS5ldmVudHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG4gICAgICAgICAgICB0eXBlcyA9ICh0eXBlcyB8fCBcIlwiKS5tYXRjaChybm90aHRtbHdoaXRlKSB8fCBbXCJcIl07XG4gICAgICAgICAgICB0ID0gdHlwZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKHQtLSkge1xuICAgICAgICAgICAgICAgIHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWModHlwZXNbdF0pIHx8IFtdO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsxXTtcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VzID0gKHRtcFsyXSB8fCBcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodHlwZSBpbiBldmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5yZW1vdmUoZWxlbSwgdHlwZSArIHR5cGVzW3RdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsW3R5cGVdIHx8IHt9O1xuICAgICAgICAgICAgICAgIHR5cGUgPSAoc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUpIHx8IHR5cGU7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnMgPSBldmVudHNbdHlwZV0gfHwgW107XG4gICAgICAgICAgICAgICAgdG1wID0gdG1wWzJdICYmXG4gICAgICAgICAgICAgICAgICAgIG5ldyBSZWdFeHAoXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpICsgXCIoXFxcXC58JClcIik7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG4gICAgICAgICAgICAgICAgb3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iaiA9IGhhbmRsZXJzW2pdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgobWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICghaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCF0bXAgfHwgdG1wLnRlc3QoaGFuZGxlT2JqLm5hbWVzcGFjZSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShqLCAxKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZU9iai5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGVjaWFsLnJlbW92ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpYWwucmVtb3ZlLmNhbGwoZWxlbSwgaGFuZGxlT2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3RcbiAgICAgICAgICAgICAgICAvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcbiAgICAgICAgICAgICAgICBpZiAob3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzcGVjaWFsLnRlYXJkb3duIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWFsLnRlYXJkb3duLmNhbGwoZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlKSA9PT0gZmFsc2UpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZUV2ZW50KGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcbiAgICAgICAgICAgIGlmIChqUXVlcnkuaXNFbXB0eU9iamVjdChldmVudHMpKSB7XG4gICAgICAgICAgICAgICAgZGF0YVByaXYucmVtb3ZlKGVsZW0sIFwiaGFuZGxlIGV2ZW50c1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkaXNwYXRjaDogZnVuY3Rpb24gKG5hdGl2ZUV2ZW50KSB7XG5cbiAgICAgICAgICAgIC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuICAgICAgICAgICAgdmFyIGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeChuYXRpdmVFdmVudCk7XG5cbiAgICAgICAgICAgIHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgaGFuZGxlcnMgPSAoZGF0YVByaXYuZ2V0KHRoaXMsIFwiZXZlbnRzXCIpIHx8IHt9KVtldmVudC50eXBlXSB8fCBbXSxcbiAgICAgICAgICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbZXZlbnQudHlwZV0gfHwge307XG5cbiAgICAgICAgICAgIC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG4gICAgICAgICAgICBhcmdzWzBdID0gZXZlbnQ7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcbiAgICAgICAgICAgIGlmIChzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCh0aGlzLCBldmVudCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgaGFuZGxlcnNcbiAgICAgICAgICAgIGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKHRoaXMsIGV2ZW50LCBoYW5kbGVycyk7XG5cbiAgICAgICAgICAgIC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlICgobWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVtpKytdKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cbiAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbaisrXSkgJiZcbiAgICAgICAgICAgICAgICAhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBldmVudCBpcyBuYW1lc3BhY2VkLCB0aGVuIGVhY2ggaGFuZGxlciBpcyBvbmx5IGludm9rZWQgaWYgaXQgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lhbGx5IHVuaXZlcnNhbCBvciBpdHMgbmFtZXNwYWNlcyBhcmUgYSBzdXBlcnNldCBvZiB0aGUgZXZlbnQncy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudC5ybmFtZXNwYWNlIHx8IGhhbmRsZU9iai5uYW1lc3BhY2UgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5ybmFtZXNwYWNlLnRlc3QoaGFuZGxlT2JqLm5hbWVzcGFjZSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSAoKGpRdWVyeS5ldmVudC5zcGVjaWFsW2hhbmRsZU9iai5vcmlnVHlwZV0gfHwge30pLmhhbmRsZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iai5oYW5kbGVyKS5hcHBseShtYXRjaGVkLmVsZW0sIGFyZ3MpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGV2ZW50LnJlc3VsdCA9IHJldCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuICAgICAgICAgICAgaWYgKHNwZWNpYWwucG9zdERpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgc3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBldmVudC5yZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcnM6IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuICAgICAgICAgICAgICAgIGhhbmRsZXJRdWV1ZSA9IFtdLFxuICAgICAgICAgICAgICAgIGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuICAgICAgICAgICAgICAgIGN1ciA9IGV2ZW50LnRhcmdldDtcblxuICAgICAgICAgICAgLy8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlQ291bnQgJiZcblxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OVxuICAgICAgICAgICAgICAgIC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICh0cmFjLTEzMTgwKVxuICAgICAgICAgICAgICAgIGN1ci5ub2RlVHlwZSAmJlxuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogRmlyZWZveCA8PTQyXG4gICAgICAgICAgICAgICAgLy8gU3VwcHJlc3Mgc3BlYy12aW9sYXRpbmcgY2xpY2tzIGluZGljYXRpbmcgYSBub24tcHJpbWFyeSBwb2ludGVyIGJ1dHRvbiAodHJhYy0zODYxKVxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG4gICAgICAgICAgICAgICAgLy8gLi4uYnV0IG5vdCBhcnJvdyBrZXkgXCJjbGlja3NcIiBvZiByYWRpbyBpbnB1dHMsIHdoaWNoIGNhbiBoYXZlIGBidXR0b25gIC0xIChnaC0yMzQzKVxuICAgICAgICAgICAgICAgICEoZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbiA+PSAxKSkge1xuXG4gICAgICAgICAgICAgICAgZm9yICg7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcykge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAoIzEzMjA4KVxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAhKGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkSGFuZGxlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRTZWxlY3RvcnMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYmogPSBoYW5kbGVyc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZFNlbGVjdG9yc1tzZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFNlbGVjdG9yc1tzZWxdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkoc2VsLCB0aGlzKS5pbmRleChjdXIpID4gLTEgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmZpbmQoc2VsLCB0aGlzLCBudWxsLCBbY3VyXSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZFNlbGVjdG9yc1tzZWxdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRIYW5kbGVycy5wdXNoKGhhbmRsZU9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZWRIYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyUXVldWUucHVzaCh7ZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcbiAgICAgICAgICAgIGN1ciA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJRdWV1ZS5wdXNoKHtlbGVtOiBjdXIsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZShkZWxlZ2F0ZUNvdW50KX0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlclF1ZXVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZFByb3A6IGZ1bmN0aW9uIChuYW1lLCBob29rKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXG4gICAgICAgICAgICAgICAgZ2V0OiBpc0Z1bmN0aW9uKGhvb2spID9cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3JpZ2luYWxFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBob29rKHRoaXMub3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gOlxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZml4OiBmdW5jdGlvbiAob3JpZ2luYWxFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsRXZlbnRbalF1ZXJ5LmV4cGFuZG9dID9cbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50IDpcbiAgICAgICAgICAgICAgICBuZXcgalF1ZXJ5LkV2ZW50KG9yaWdpbmFsRXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNwZWNpYWw6IHtcbiAgICAgICAgICAgIGxvYWQ6IHtcblxuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcbiAgICAgICAgICAgICAgICBub0J1YmJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsaWNrOiB7XG5cbiAgICAgICAgICAgICAgICAvLyBVdGlsaXplIG5hdGl2ZSBldmVudCB0byBlbnN1cmUgY29ycmVjdCBzdGF0ZSBmb3IgY2hlY2thYmxlIGlucHV0c1xuICAgICAgICAgICAgICAgIHNldHVwOiBmdW5jdGlvbiAoZGF0YSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuICAgICAgICAgICAgICAgICAgICAvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJjaGVja2FibGVUeXBlLnRlc3QoZWwudHlwZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmNsaWNrICYmIG5vZGVOYW1lKGVsLCBcImlucHV0XCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJpdi5nZXQoZWwsIFwiY2xpY2tcIikgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkYXRhUHJpdi5zZXQoIGVsLCBcImNsaWNrXCIsIC4uLiApXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlcmFnZU5hdGl2ZShlbCwgXCJjbGlja1wiLCByZXR1cm5UcnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBmYWxzZSB0byBhbGxvdyBub3JtYWwgcHJvY2Vzc2luZyBpbiB0aGUgY2FsbGVyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uIChkYXRhKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG4gICAgICAgICAgICAgICAgICAgIC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IHRoaXMgfHwgZGF0YTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlcmluZyBhIGNsaWNrXG4gICAgICAgICAgICAgICAgICAgIGlmIChyY2hlY2thYmxlVHlwZS50ZXN0KGVsLnR5cGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5jbGljayAmJiBub2RlTmFtZShlbCwgXCJpbnB1dFwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByaXYuZ2V0KGVsLCBcImNsaWNrXCIpID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZXJhZ2VOYXRpdmUoZWwsIFwiY2xpY2tcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgc3VwcHJlc3MgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG4gICAgICAgICAgICAgICAgLy8gQWxzbyBwcmV2ZW50IGl0IGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYSBsZXZlcmFnZWQgbmF0aXZlLWV2ZW50IHN0YWNrXG4gICAgICAgICAgICAgICAgX2RlZmF1bHQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmNoZWNrYWJsZVR5cGUudGVzdCh0YXJnZXQudHlwZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5jbGljayAmJiBub2RlTmFtZSh0YXJnZXQsIFwiaW5wdXRcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQcml2LmdldCh0YXJnZXQsIFwiY2xpY2tcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVOYW1lKHRhcmdldCwgXCJhXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGJlZm9yZXVubG9hZDoge1xuICAgICAgICAgICAgICAgIHBvc3REaXNwYXRjaDogZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogRmlyZWZveCAyMCtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBFbnN1cmUgdGhlIHByZXNlbmNlIG9mIGFuIGV2ZW50IGxpc3RlbmVyIHRoYXQgaGFuZGxlcyBtYW51YWxseS10cmlnZ2VyZWRcbiAgICAvLyBzeW50aGV0aWMgZXZlbnRzIGJ5IGludGVycnVwdGluZyBwcm9ncmVzcyB1bnRpbCByZWludm9rZWQgaW4gcmVzcG9uc2UgdG9cbiAgICAvLyAqbmF0aXZlKiBldmVudHMgdGhhdCBpdCBmaXJlcyBkaXJlY3RseSwgZW5zdXJpbmcgdGhhdCBzdGF0ZSBjaGFuZ2VzIGhhdmVcbiAgICAvLyBhbHJlYWR5IG9jY3VycmVkIGJlZm9yZSBvdGhlciBsaXN0ZW5lcnMgYXJlIGludm9rZWQuXG4gICAgZnVuY3Rpb24gbGV2ZXJhZ2VOYXRpdmUoZWwsIHR5cGUsIGV4cGVjdFN5bmMpIHtcblxuICAgICAgICAvLyBNaXNzaW5nIGV4cGVjdFN5bmMgaW5kaWNhdGVzIGEgdHJpZ2dlciBjYWxsLCB3aGljaCBtdXN0IGZvcmNlIHNldHVwIHRocm91Z2ggalF1ZXJ5LmV2ZW50LmFkZFxuICAgICAgICBpZiAoIWV4cGVjdFN5bmMpIHtcbiAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQoZWwsIHR5cGUsIHJldHVyblRydWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIGNvbnRyb2xsZXIgYXMgYSBzcGVjaWFsIHVuaXZlcnNhbCBoYW5kbGVyIGZvciBhbGwgZXZlbnQgbmFtZXNwYWNlc1xuICAgICAgICBkYXRhUHJpdi5zZXQoZWwsIHR5cGUsIGZhbHNlKTtcbiAgICAgICAgalF1ZXJ5LmV2ZW50LmFkZChlbCwgdHlwZSwge1xuICAgICAgICAgICAgbmFtZXNwYWNlOiBmYWxzZSxcbiAgICAgICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBub3RBc3luYywgcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBzYXZlZCA9IGRhdGFQcml2LmdldCh0aGlzLCB0eXBlKTtcblxuICAgICAgICAgICAgICAgIGlmICgoZXZlbnQuaXNUcmlnZ2VyICYgMSkgJiYgdGhpc1t0eXBlXSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEludGVycnVwdCBwcm9jZXNzaW5nIG9mIHRoZSBvdXRlciBzeW50aGV0aWMgLnRyaWdnZXIoKWVkIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2F2ZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgYXJndW1lbnRzIGZvciB1c2Ugd2hlbiBoYW5kbGluZyB0aGUgaW5uZXIgbmF0aXZlIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBzYXZlZCA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQcml2LnNldCh0aGlzLCB0eXBlLCBzYXZlZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgdGhlIG5hdGl2ZSBldmVudCBhbmQgY2FwdHVyZSBpdHMgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzXG4gICAgICAgICAgICAgICAgICAgICAgICBub3RBc3luYyA9IGV4cGVjdFN5bmModGhpcywgdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3R5cGVdKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkYXRhUHJpdi5nZXQodGhpcywgdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2F2ZWQgIT09IHJlc3VsdCB8fCBub3RBc3luYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQcml2LnNldCh0aGlzLCB0eXBlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzYXZlZCAhPT0gcmVzdWx0KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYW5jZWwgdGhlIG91dGVyIHN5bnRoZXRpYyBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgZm9yIGFuIGV2ZW50IHdpdGggYSBidWJibGluZyBzdXJyb2dhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIChmb2N1cyBvciBibHVyKSwgYXNzdW1lIHRoYXQgdGhlIHN1cnJvZ2F0ZSBhbHJlYWR5IHByb3BhZ2F0ZWQgZnJvbSB0cmlnZ2VyaW5nIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmF0aXZlIGV2ZW50IGFuZCBwcmV2ZW50IHRoYXQgZnJvbSBoYXBwZW5pbmcgYWdhaW4gaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgdGVjaG5pY2FsbHkgZ2V0cyB0aGUgb3JkZXJpbmcgd3Jvbmcgdy5yLnQuIHRvIGAudHJpZ2dlcigpYCAoaW4gd2hpY2ggdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBidWJibGluZyBzdXJyb2dhdGUgcHJvcGFnYXRlcyAqYWZ0ZXIqIHRoZSBub24tYnViYmxpbmcgYmFzZSksIGJ1dCB0aGF0IHNlZW1zXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXNzIGJhZCB0aGFuIGR1cGxpY2F0aW9uLlxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChqUXVlcnkuZXZlbnQuc3BlY2lhbFt0eXBlXSB8fCB7fSkuZGVsZWdhdGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBuYXRpdmUgZXZlbnQgdHJpZ2dlcmVkIGFib3ZlLCBldmVyeXRoaW5nIGlzIG5vdyBpbiBvcmRlclxuICAgICAgICAgICAgICAgICAgICAvLyBGaXJlIGFuIGlubmVyIHN5bnRoZXRpYyBldmVudCB3aXRoIHRoZSBvcmlnaW5hbCBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNhdmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gLi4uYW5kIGNhcHR1cmUgdGhlIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICBkYXRhUHJpdi5zZXQodGhpcywgdHlwZSwgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dGVuZCB3aXRoIHRoZSBwcm90b3R5cGUgdG8gcmVzZXQgdGhlIGFib3ZlIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKHNhdmVkLnNoaWZ0KCksIGpRdWVyeS5FdmVudC5wcm90b3R5cGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFib3J0IGhhbmRsaW5nIG9mIHRoZSBuYXRpdmUgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBqUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiAoZWxlbSwgdHlwZSwgaGFuZGxlKSB7XG5cbiAgICAgICAgLy8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG4gICAgICAgIGlmIChlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uIChzcmMsIHByb3BzKSB7XG5cbiAgICAgICAgLy8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGpRdWVyeS5FdmVudChzcmMsIHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV2ZW50IG9iamVjdFxuICAgICAgICBpZiAoc3JjICYmIHNyYy50eXBlKSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuICAgICAgICAgICAgLy8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcbiAgICAgICAgICAgIC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgICAgICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuICAgICAgICAgICAgc3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcbiAgICAgICAgICAgIHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuICAgICAgICAgICAgICAgIHJldHVyblRydWUgOlxuICAgICAgICAgICAgICAgIHJldHVybkZhbHNlO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGFyZ2V0IHByb3BlcnRpZXNcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcbiAgICAgICAgICAgIC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IChzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMpID9cbiAgICAgICAgICAgICAgICBzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxuICAgICAgICAgICAgICAgIHNyYy50YXJnZXQ7XG5cbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cbiAgICAgICAgICAgIC8vIEV2ZW50IHR5cGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHNyYztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG4gICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCh0aGlzLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuICAgICAgICB0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG5cbiAgICAgICAgLy8gTWFyayBpdCBhcyBmaXhlZFxuICAgICAgICB0aGlzW2pRdWVyeS5leHBhbmRvXSA9IHRydWU7XG4gICAgfTtcblxuICAgIC8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbiAgICBqUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuICAgICAgICBpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuICAgICAgICBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG4gICAgICAgIGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcbiAgICAgICAgaXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG4gICAgICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuICAgICAgICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG4gICAgICAgICAgICBpZiAoZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuICAgICAgICAgICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cbiAgICAgICAgICAgIGlmIChlICYmICF0aGlzLmlzU2ltdWxhdGVkKSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuICAgICAgICAgICAgdGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cbiAgICAgICAgICAgIGlmIChlICYmICF0aGlzLmlzU2ltdWxhdGVkKSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xuICAgIGpRdWVyeS5lYWNoKHtcbiAgICAgICAgYWx0S2V5OiB0cnVlLFxuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICBjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcbiAgICAgICAgY3RybEtleTogdHJ1ZSxcbiAgICAgICAgZGV0YWlsOiB0cnVlLFxuICAgICAgICBldmVudFBoYXNlOiB0cnVlLFxuICAgICAgICBtZXRhS2V5OiB0cnVlLFxuICAgICAgICBwYWdlWDogdHJ1ZSxcbiAgICAgICAgcGFnZVk6IHRydWUsXG4gICAgICAgIHNoaWZ0S2V5OiB0cnVlLFxuICAgICAgICB2aWV3OiB0cnVlLFxuICAgICAgICBcImNoYXJcIjogdHJ1ZSxcbiAgICAgICAgY29kZTogdHJ1ZSxcbiAgICAgICAgY2hhckNvZGU6IHRydWUsXG4gICAgICAgIGtleTogdHJ1ZSxcbiAgICAgICAga2V5Q29kZTogdHJ1ZSxcbiAgICAgICAgYnV0dG9uOiB0cnVlLFxuICAgICAgICBidXR0b25zOiB0cnVlLFxuICAgICAgICBjbGllbnRYOiB0cnVlLFxuICAgICAgICBjbGllbnRZOiB0cnVlLFxuICAgICAgICBvZmZzZXRYOiB0cnVlLFxuICAgICAgICBvZmZzZXRZOiB0cnVlLFxuICAgICAgICBwb2ludGVySWQ6IHRydWUsXG4gICAgICAgIHBvaW50ZXJUeXBlOiB0cnVlLFxuICAgICAgICBzY3JlZW5YOiB0cnVlLFxuICAgICAgICBzY3JlZW5ZOiB0cnVlLFxuICAgICAgICB0YXJnZXRUb3VjaGVzOiB0cnVlLFxuICAgICAgICB0b0VsZW1lbnQ6IHRydWUsXG4gICAgICAgIHRvdWNoZXM6IHRydWUsXG5cbiAgICAgICAgd2hpY2g6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcblxuICAgICAgICAgICAgLy8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG4gICAgICAgICAgICBpZiAoZXZlbnQud2hpY2ggPT0gbnVsbCAmJiBya2V5RXZlbnQudGVzdChldmVudC50eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG4gICAgICAgICAgICBpZiAoIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIHJtb3VzZUV2ZW50LnRlc3QoZXZlbnQudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnV0dG9uICYgMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYnV0dG9uICYgMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYnV0dG9uICYgNCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LndoaWNoO1xuICAgICAgICB9XG4gICAgfSwgalF1ZXJ5LmV2ZW50LmFkZFByb3ApO1xuXG4gICAgalF1ZXJ5LmVhY2goe2ZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwifSwgZnVuY3Rpb24gKHR5cGUsIGRlbGVnYXRlVHlwZSkge1xuICAgICAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbFt0eXBlXSA9IHtcblxuICAgICAgICAgICAgLy8gVXRpbGl6ZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG4gICAgICAgICAgICBzZXR1cDogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgLy8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcbiAgICAgICAgICAgICAgICAvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiZm9jdXNcIiwgLi4uIClcbiAgICAgICAgICAgICAgICAvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiYmx1clwiLCAuLi4gKVxuICAgICAgICAgICAgICAgIGxldmVyYWdlTmF0aXZlKHRoaXMsIHR5cGUsIGV4cGVjdFN5bmMpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGZhbHNlIHRvIGFsbG93IG5vcm1hbCBwcm9jZXNzaW5nIGluIHRoZSBjYWxsZXJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgLy8gRm9yY2Ugc2V0dXAgYmVmb3JlIHRyaWdnZXJcbiAgICAgICAgICAgICAgICBsZXZlcmFnZU5hdGl2ZSh0aGlzLCB0eXBlKTtcblxuICAgICAgICAgICAgICAgIC8vIFJldHVybiBub24tZmFsc2UgdG8gYWxsb3cgbm9ybWFsIGV2ZW50LXBhdGggcHJvcGFnYXRpb25cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGRlbGVnYXRlVHlwZTogZGVsZWdhdGVUeXBlXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3NcbiAgICAvLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuICAgIC8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4gICAgLy9cbiAgICAvLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4gICAgLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4gICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4gICAgLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbiAgICBqUXVlcnkuZWFjaCh7XG4gICAgICAgIG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG4gICAgICAgIG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcbiAgICAgICAgcG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG4gICAgICAgIHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbiAgICB9LCBmdW5jdGlvbiAob3JpZywgZml4KSB7XG4gICAgICAgIGpRdWVyeS5ldmVudC5zcGVjaWFsW29yaWddID0ge1xuICAgICAgICAgICAgZGVsZWdhdGVUeXBlOiBmaXgsXG4gICAgICAgICAgICBiaW5kVHlwZTogZml4LFxuXG4gICAgICAgICAgICBoYW5kbGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciByZXQsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuICAgICAgICAgICAgICAgIC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG4gICAgICAgICAgICAgICAgaWYgKCFyZWxhdGVkIHx8IChyZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyh0YXJnZXQsIHJlbGF0ZWQpKSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuICAgICAgICAgICAgICAgICAgICByZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC50eXBlID0gZml4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG5cbiAgICAgICAgb246IGZ1bmN0aW9uICh0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gb24odGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbik7XG4gICAgICAgIH0sXG4gICAgICAgIG9uZTogZnVuY3Rpb24gKHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4pIHtcbiAgICAgICAgICAgIHJldHVybiBvbih0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgb2ZmOiBmdW5jdGlvbiAodHlwZXMsIHNlbGVjdG9yLCBmbikge1xuICAgICAgICAgICAgdmFyIGhhbmRsZU9iaiwgdHlwZTtcbiAgICAgICAgICAgIGlmICh0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmopIHtcblxuICAgICAgICAgICAgICAgIC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcbiAgICAgICAgICAgICAgICBoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG4gICAgICAgICAgICAgICAgalF1ZXJ5KHR5cGVzLmRlbGVnYXRlVGFyZ2V0KS5vZmYoXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iai5vcmlnVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqLnNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYmouaGFuZGxlclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiKSB7XG5cbiAgICAgICAgICAgICAgICAvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuICAgICAgICAgICAgICAgIGZvciAodHlwZSBpbiB0eXBlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZih0eXBlLCBzZWxlY3RvciwgdHlwZXNbdHlwZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcblxuICAgICAgICAgICAgICAgIC8vICggdHlwZXMgWywgZm5dIClcbiAgICAgICAgICAgICAgICBmbiA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZuID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGZuID0gcmV0dXJuRmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQucmVtb3ZlKHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgdmFyXG5cbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvMzIyOVxuICAgICAgICByeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopW14+XSopXFwvPi9naSxcblxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTMgb25seVxuICAgICAgICAvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuICAgICAgICBybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuICAgICAgICAvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcbiAgICAgICAgcmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuICAgICAgICByY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7XG5cbiAgICAvLyBQcmVmZXIgYSB0Ym9keSBvdmVyIGl0cyBwYXJlbnQgdGFibGUgZm9yIGNvbnRhaW5pbmcgbmV3IHJvd3NcbiAgICBmdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoZWxlbSwgY29udGVudCkge1xuICAgICAgICBpZiAobm9kZU5hbWUoZWxlbSwgXCJ0YWJsZVwiKSAmJlxuICAgICAgICAgICAgbm9kZU5hbWUoY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIpKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkoZWxlbSkuY2hpbGRyZW4oXCJ0Ym9keVwiKVswXSB8fCBlbGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuXG4gICAgLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuICAgIGZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoZWxlbSkge1xuICAgICAgICBlbGVtLnR5cGUgPSAoZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpICE9PSBudWxsKSArIFwiL1wiICsgZWxlbS50eXBlO1xuICAgICAgICByZXR1cm4gZWxlbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXN0b3JlU2NyaXB0KGVsZW0pIHtcbiAgICAgICAgaWYgKChlbGVtLnR5cGUgfHwgXCJcIikuc2xpY2UoMCwgNSkgPT09IFwidHJ1ZS9cIikge1xuICAgICAgICAgICAgZWxlbS50eXBlID0gZWxlbS50eXBlLnNsaWNlKDUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoc3JjLCBkZXN0KSB7XG4gICAgICAgIHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgcGRhdGFDdXIsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG4gICAgICAgIGlmIChkZXN0Lm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuICAgICAgICBpZiAoZGF0YVByaXYuaGFzRGF0YShzcmMpKSB7XG4gICAgICAgICAgICBwZGF0YU9sZCA9IGRhdGFQcml2LmFjY2VzcyhzcmMpO1xuICAgICAgICAgICAgcGRhdGFDdXIgPSBkYXRhUHJpdi5zZXQoZGVzdCwgcGRhdGFPbGQpO1xuICAgICAgICAgICAgZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG4gICAgICAgICAgICBpZiAoZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcbiAgICAgICAgICAgICAgICBwZGF0YUN1ci5ldmVudHMgPSB7fTtcblxuICAgICAgICAgICAgICAgIGZvciAodHlwZSBpbiBldmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGV2ZW50c1t0eXBlXS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQoZGVzdCwgdHlwZSwgZXZlbnRzW3R5cGVdW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDIuIENvcHkgdXNlciBkYXRhXG4gICAgICAgIGlmIChkYXRhVXNlci5oYXNEYXRhKHNyYykpIHtcbiAgICAgICAgICAgIHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKHNyYyk7XG4gICAgICAgICAgICB1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoe30sIHVkYXRhT2xkKTtcblxuICAgICAgICAgICAgZGF0YVVzZXIuc2V0KGRlc3QsIHVkYXRhQ3VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuICAgIGZ1bmN0aW9uIGZpeElucHV0KHNyYywgZGVzdCkge1xuICAgICAgICB2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgLy8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG4gICAgICAgIGlmIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3Qoc3JjLnR5cGUpKSB7XG4gICAgICAgICAgICBkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuICAgICAgICAgICAgLy8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcbiAgICAgICAgfSBlbHNlIGlmIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIpIHtcbiAgICAgICAgICAgIGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvbU1hbmlwKGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkKSB7XG5cbiAgICAgICAgLy8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuICAgICAgICBhcmdzID0gY29uY2F0LmFwcGx5KFtdLCBhcmdzKTtcblxuICAgICAgICB2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgICAgIGlOb0Nsb25lID0gbCAtIDEsXG4gICAgICAgICAgICB2YWx1ZSA9IGFyZ3NbMF0sXG4gICAgICAgICAgICB2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKHZhbHVlKTtcblxuICAgICAgICAvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcbiAgICAgICAgaWYgKHZhbHVlSXNGdW5jdGlvbiB8fFxuICAgICAgICAgICAgKGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgICFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCh2YWx1ZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbi5lYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gY29sbGVjdGlvbi5lcShpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlSXNGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBhcmdzWzBdID0gdmFsdWUuY2FsbCh0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb21NYW5pcChzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsKSB7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoYXJncywgY29sbGVjdGlvblswXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCk7XG4gICAgICAgICAgICBmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgICAgIGlmIChmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gZmlyc3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgaWYgKGZpcnN0IHx8IGlnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICBzY3JpcHRzID0galF1ZXJ5Lm1hcChnZXRBbGwoZnJhZ21lbnQsIFwic2NyaXB0XCIpLCBkaXNhYmxlU2NyaXB0KTtcbiAgICAgICAgICAgICAgICBoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG4gICAgICAgICAgICAgICAgLy8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG4gICAgICAgICAgICAgICAgLy8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gZnJhZ21lbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IGlOb0Nsb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0galF1ZXJ5LmNsb25lKG5vZGUsIHRydWUsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzU2NyaXB0cykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZShzY3JpcHRzLCBnZXRBbGwobm9kZSwgXCJzY3JpcHRcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChjb2xsZWN0aW9uW2ldLCBub2RlLCBpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzU2NyaXB0cykge1xuICAgICAgICAgICAgICAgICAgICBkb2MgPSBzY3JpcHRzW3NjcmlwdHMubGVuZ3RoIC0gMV0ub3duZXJEb2N1bWVudDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZWVuYWJsZSBzY3JpcHRzXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tYXAoc2NyaXB0cywgcmVzdG9yZVNjcmlwdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gc2NyaXB0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyc2NyaXB0VHlwZS50ZXN0KG5vZGUudHlwZSB8fCBcIlwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFkYXRhUHJpdi5hY2Nlc3Mobm9kZSwgXCJnbG9iYWxFdmFsXCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNvbnRhaW5zKGRvYywgbm9kZSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnNyYyAmJiAobm9kZS50eXBlIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgIT09IFwibW9kdWxlXCIpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5Ll9ldmFsVXJsICYmICFub2RlLm5vTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuX2V2YWxVcmwobm9kZS5zcmMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub25jZTogbm9kZS5ub25jZSB8fCBub2RlLmdldEF0dHJpYnV0ZShcIm5vbmNlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERPTUV2YWwobm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKHJjbGVhblNjcmlwdCwgXCJcIiksIG5vZGUsIGRvYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlKGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSkge1xuICAgICAgICB2YXIgbm9kZSxcbiAgICAgICAgICAgIG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKHNlbGVjdG9yLCBlbGVtKSA6IGVsZW0sXG4gICAgICAgICAgICBpID0gMDtcblxuICAgICAgICBmb3IgKDsgKG5vZGUgPSBub2Rlc1tpXSkgIT0gbnVsbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuY2xlYW5EYXRhKGdldEFsbChub2RlKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2VlcERhdGEgJiYgaXNBdHRhY2hlZChub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRHbG9iYWxFdmFsKGdldEFsbChub2RlLCBcInNjcmlwdFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVtO1xuICAgIH1cblxuICAgIGpRdWVyeS5leHRlbmQoe1xuICAgICAgICBodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZShyeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMpIHtcbiAgICAgICAgICAgIHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuICAgICAgICAgICAgICAgIGNsb25lID0gZWxlbS5jbG9uZU5vZGUodHJ1ZSksXG4gICAgICAgICAgICAgICAgaW5QYWdlID0gaXNBdHRhY2hlZChlbGVtKTtcblxuICAgICAgICAgICAgLy8gRml4IElFIGNsb25pbmcgaXNzdWVzXG4gICAgICAgICAgICBpZiAoIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEpICYmXG4gICAgICAgICAgICAgICAgIWpRdWVyeS5pc1hNTERvYyhlbGVtKSkge1xuXG4gICAgICAgICAgICAgICAgLy8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG4gICAgICAgICAgICAgICAgZGVzdEVsZW1lbnRzID0gZ2V0QWxsKGNsb25lKTtcbiAgICAgICAgICAgICAgICBzcmNFbGVtZW50cyA9IGdldEFsbChlbGVtKTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZml4SW5wdXQoc3JjRWxlbWVudHNbaV0sIGRlc3RFbGVtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG4gICAgICAgICAgICBpZiAoZGF0YUFuZEV2ZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChkZWVwRGF0YUFuZEV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICBzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbChlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbChjbG9uZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVDb3B5RXZlbnQoc3JjRWxlbWVudHNbaV0sIGRlc3RFbGVtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjbG9uZUNvcHlFdmVudChlbGVtLCBjbG9uZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG4gICAgICAgICAgICBkZXN0RWxlbWVudHMgPSBnZXRBbGwoY2xvbmUsIFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgaWYgKGRlc3RFbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgc2V0R2xvYmFsRXZhbChkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKGVsZW0sIFwic2NyaXB0XCIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYW5EYXRhOiBmdW5jdGlvbiAoZWxlbXMpIHtcbiAgICAgICAgICAgIHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuICAgICAgICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcbiAgICAgICAgICAgICAgICBpID0gMDtcblxuICAgICAgICAgICAgZm9yICg7IChlbGVtID0gZWxlbXNbaV0pICE9PSB1bmRlZmluZWQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChhY2NlcHREYXRhKGVsZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoZGF0YSA9IGVsZW1bZGF0YVByaXYuZXhwYW5kb10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5ldmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHR5cGUgaW4gZGF0YS5ldmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWNpYWxbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5yZW1vdmUoZWxlbSwgdHlwZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVFdmVudChlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bZGF0YVByaXYuZXhwYW5kb10gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1bZGF0YVVzZXIuZXhwYW5kb10pIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVtkYXRhVXNlci5leHBhbmRvXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICAgIGRldGFjaDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlKHRoaXMsIHNlbGVjdG9yLCB0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZSh0aGlzLCBzZWxlY3Rvcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdGV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjZXNzKHRoaXMsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnRleHQodGhpcykgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtcHR5KCkuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhcHBlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkb21NYW5pcCh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KHRoaXMsIGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoZWxlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJlcGVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvbU1hbmlwKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQodGhpcywgZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUoZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJlZm9yZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvbU1hbmlwKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkb21NYW5pcCh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW0sIHRoaXMubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZWxlbSxcbiAgICAgICAgICAgICAgICBpID0gMDtcblxuICAgICAgICAgICAgZm9yICg7IChlbGVtID0gdGhpc1tpXSkgIT0gbnVsbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY2xlYW5EYXRhKGdldEFsbChlbGVtLCBmYWxzZSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG4gICAgICAgICAgICAgICAgICAgIGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uIChkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cykge1xuICAgICAgICAgICAgZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcbiAgICAgICAgICAgIGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LmNsb25lKHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGh0bWw6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFjY2Vzcyh0aGlzLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXNbMF0gfHwge30sXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgICAgICBsID0gdGhpcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmlubmVySFRNTDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QodmFsdWUpICYmXG4gICAgICAgICAgICAgICAgICAgICF3cmFwTWFwWyhydGFnTmFtZS5leGVjKHZhbHVlKSB8fCBbXCJcIiwgXCJcIl0pWzFdLnRvTG93ZXJDYXNlKCldKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlcih2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IHRoaXNbaV0gfHwge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY2xlYW5EYXRhKGdldEFsbChlbGVtLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtcHR5KCkuYXBwZW5kKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVwbGFjZVdpdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpZ25vcmVkID0gW107XG5cbiAgICAgICAgICAgIC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIG5vbi1pZ25vcmVkIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuICAgICAgICAgICAgcmV0dXJuIGRvbU1hbmlwKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5pbkFycmF5KHRoaXMsIGlnbm9yZWQpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY2xlYW5EYXRhKGdldEFsbCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQoZWxlbSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG4gICAgICAgICAgICB9LCBpZ25vcmVkKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmVhY2goe1xuICAgICAgICBhcHBlbmRUbzogXCJhcHBlbmRcIixcbiAgICAgICAgcHJlcGVuZFRvOiBcInByZXBlbmRcIixcbiAgICAgICAgaW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuICAgICAgICBpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuICAgICAgICByZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbiAgICB9LCBmdW5jdGlvbiAobmFtZSwgb3JpZ2luYWwpIHtcbiAgICAgICAgalF1ZXJ5LmZuW25hbWVdID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgZWxlbXMsXG4gICAgICAgICAgICAgICAgcmV0ID0gW10sXG4gICAgICAgICAgICAgICAgaW5zZXJ0ID0galF1ZXJ5KHNlbGVjdG9yKSxcbiAgICAgICAgICAgICAgICBsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDw9IGxhc3Q7IGkrKykge1xuICAgICAgICAgICAgICAgIGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKHRydWUpO1xuICAgICAgICAgICAgICAgIGpRdWVyeShpbnNlcnRbaV0pW29yaWdpbmFsXShlbGVtcyk7XG5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcbiAgICAgICAgICAgICAgICAvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG4gICAgICAgICAgICAgICAgcHVzaC5hcHBseShyZXQsIGVsZW1zLmdldCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHJldCk7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgdmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiKTtcblxuICAgIHZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiAoZWxlbSkge1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcbiAgICAgICAgLy8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG4gICAgICAgIC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuICAgICAgICB2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuICAgICAgICBpZiAoIXZpZXcgfHwgIXZpZXcub3BlbmVyKSB7XG4gICAgICAgICAgICB2aWV3ID0gd2luZG93O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcbiAgICB9O1xuXG4gICAgdmFyIHJib3hTdHlsZSA9IG5ldyBSZWdFeHAoY3NzRXhwYW5kLmpvaW4oXCJ8XCIpLCBcImlcIik7XG5cblxuICAgIChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLy8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG4gICAgICAgIC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXG4gICAgICAgICAgICBpZiAoIWRpdikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7d2lkdGg6NjBweDtcIiArXG4gICAgICAgICAgICAgICAgXCJtYXJnaW4tdG9wOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjBcIjtcbiAgICAgICAgICAgIGRpdi5zdHlsZS5jc3NUZXh0ID1cbiAgICAgICAgICAgICAgICBcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OnNjcm9sbDtcIiArXG4gICAgICAgICAgICAgICAgXCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcbiAgICAgICAgICAgICAgICBcIndpZHRoOjYwJTt0b3A6MSVcIjtcbiAgICAgICAgICAgIGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChjb250YWluZXIpLmFwcGVuZENoaWxkKGRpdik7XG5cbiAgICAgICAgICAgIHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRpdik7XG4gICAgICAgICAgICBwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcbiAgICAgICAgICAgIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyhkaXZTdHlsZS5tYXJnaW5MZWZ0KSA9PT0gMTI7XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIFNhZmFyaSA8PTkuMSAtIDEwLjEsIGlPUyA8PTcuMCAtIDkuM1xuICAgICAgICAgICAgLy8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG4gICAgICAgICAgICBkaXYuc3R5bGUucmlnaHQgPSBcIjYwJVwiO1xuICAgICAgICAgICAgcGl4ZWxCb3hTdHlsZXNWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoZGl2U3R5bGUucmlnaHQpID09PSAzNjtcblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcbiAgICAgICAgICAgIC8vIERldGVjdCBtaXNyZXBvcnRpbmcgb2YgY29udGVudCBkaW1lbnNpb25zIGZvciBib3gtc2l6aW5nOmJvcmRlci1ib3ggZWxlbWVudHNcbiAgICAgICAgICAgIGJveFNpemluZ1JlbGlhYmxlVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKGRpdlN0eWxlLndpZHRoKSA9PT0gMzY7XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgb25seVxuICAgICAgICAgICAgLy8gRGV0ZWN0IG92ZXJmbG93OnNjcm9sbCBzY3Jld2luZXNzIChnaC0zNjk5KVxuICAgICAgICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9NjRcbiAgICAgICAgICAgIC8vIERvbid0IGdldCB0cmlja2VkIHdoZW4gem9vbSBhZmZlY3RzIG9mZnNldFdpZHRoIChnaC00MDI5KVxuICAgICAgICAgICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICAgICAgc2Nyb2xsYm94U2l6ZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyhkaXYub2Zmc2V0V2lkdGggLyAzKSA9PT0gMTI7XG5cbiAgICAgICAgICAgIGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZChjb250YWluZXIpO1xuXG4gICAgICAgICAgICAvLyBOdWxsaWZ5IHRoZSBkaXYgc28gaXQgd291bGRuJ3QgYmUgc3RvcmVkIGluIHRoZSBtZW1vcnkgYW5kXG4gICAgICAgICAgICAvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG4gICAgICAgICAgICBkaXYgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcm91bmRQaXhlbE1lYXN1cmVzKG1lYXN1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHBhcnNlRmxvYXQobWVhc3VyZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBzY3JvbGxib3hTaXplVmFsLCBwaXhlbEJveFN0eWxlc1ZhbCxcbiAgICAgICAgICAgIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgICAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgICAgIC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG4gICAgICAgIGlmICghZGl2LnN0eWxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG4gICAgICAgIC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcbiAgICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuICAgICAgICBkaXYuY2xvbmVOb2RlKHRydWUpLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcbiAgICAgICAgc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuICAgICAgICBqUXVlcnkuZXh0ZW5kKHN1cHBvcnQsIHtcbiAgICAgICAgICAgIGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVN0eWxlVGVzdHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGl4ZWxCb3hTdHlsZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlU3R5bGVUZXN0cygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwaXhlbEJveFN0eWxlc1ZhbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVN0eWxlVGVzdHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlU3R5bGVUZXN0cygpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2Nyb2xsYm94U2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVTdHlsZVRlc3RzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjcm9sbGJveFNpemVWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pKCk7XG5cblxuICAgIGZ1bmN0aW9uIGN1ckNTUyhlbGVtLCBuYW1lLCBjb21wdXRlZCkge1xuICAgICAgICB2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBGaXJlZm94IDUxK1xuICAgICAgICAgICAgLy8gUmV0cmlldmluZyBzdHlsZSBiZWZvcmUgY29tcHV0ZWQgc29tZWhvd1xuICAgICAgICAgICAgLy8gZml4ZXMgYW4gaXNzdWUgd2l0aCBnZXR0aW5nIHdyb25nIHZhbHVlc1xuICAgICAgICAgICAgLy8gb24gZGV0YWNoZWQgZWxlbWVudHNcbiAgICAgICAgICAgIHN0eWxlID0gZWxlbS5zdHlsZTtcblxuICAgICAgICBjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyhlbGVtKTtcblxuICAgICAgICAvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG5lZWRlZCBmb3I6XG4gICAgICAgIC8vICAgLmNzcygnZmlsdGVyJykgKElFIDkgb25seSwgIzEyNTM3KVxuICAgICAgICAvLyAgIC5jc3MoJy0tY3VzdG9tUHJvcGVydHkpICgjMzE0NClcbiAgICAgICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICAgICAgICByZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpIHx8IGNvbXB1dGVkW25hbWVdO1xuXG4gICAgICAgICAgICBpZiAocmV0ID09PSBcIlwiICYmICFpc0F0dGFjaGVkKGVsZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0galF1ZXJ5LnN0eWxlKGVsZW0sIG5hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG4gICAgICAgICAgICAvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcbiAgICAgICAgICAgIC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG4gICAgICAgICAgICAvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuICAgICAgICAgICAgaWYgKCFzdXBwb3J0LnBpeGVsQm94U3R5bGVzKCkgJiYgcm51bW5vbnB4LnRlc3QocmV0KSAmJiByYm94U3R5bGUudGVzdChuYW1lKSkge1xuXG4gICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuICAgICAgICAgICAgICAgIHdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgICAgICAgICAgICAgbWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcbiAgICAgICAgICAgICAgICBtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG4gICAgICAgICAgICAgICAgLy8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuICAgICAgICAgICAgICAgIHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcbiAgICAgICAgICAgICAgICByZXQgPSBjb21wdXRlZC53aWR0aDtcblxuICAgICAgICAgICAgICAgIC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICBzdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG4gICAgICAgICAgICAgICAgc3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcbiAgICAgICAgICAgIC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG4gICAgICAgICAgICByZXQgKyBcIlwiIDpcbiAgICAgICAgICAgIHJldDtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGFkZEdldEhvb2tJZihjb25kaXRpb25GbiwgaG9va0ZuKSB7XG5cbiAgICAgICAgLy8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChjb25kaXRpb25GbigpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZ2V0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmdldCA9IGhvb2tGbikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cblxuICAgIHZhciBjc3NQcmVmaXhlcyA9IFtcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCJdLFxuICAgICAgICBlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKS5zdHlsZSxcbiAgICAgICAgdmVuZG9yUHJvcHMgPSB7fTtcblxuICAgIC8vIFJldHVybiBhIHZlbmRvci1wcmVmaXhlZCBwcm9wZXJ0eSBvciB1bmRlZmluZWRcbiAgICBmdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZShuYW1lKSB7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuICAgICAgICB2YXIgY2FwTmFtZSA9IG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksXG4gICAgICAgICAgICBpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIG5hbWUgPSBjc3NQcmVmaXhlc1tpXSArIGNhcE5hbWU7XG4gICAgICAgICAgICBpZiAobmFtZSBpbiBlbXB0eVN0eWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSBwb3RlbnRpYWxseS1tYXBwZWQgalF1ZXJ5LmNzc1Byb3BzIG9yIHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuICAgIGZ1bmN0aW9uIGZpbmFsUHJvcE5hbWUobmFtZSkge1xuICAgICAgICB2YXIgZmluYWwgPSBqUXVlcnkuY3NzUHJvcHNbbmFtZV0gfHwgdmVuZG9yUHJvcHNbbmFtZV07XG5cbiAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmluYWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZlbmRvclByb3BzW25hbWVdID0gdmVuZG9yUHJvcE5hbWUobmFtZSkgfHwgbmFtZTtcbiAgICB9XG5cblxuICAgIHZhclxuXG4gICAgICAgIC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcbiAgICAgICAgLy8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG4gICAgICAgIC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuICAgICAgICByZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG4gICAgICAgIHJjdXN0b21Qcm9wID0gL14tLS8sXG4gICAgICAgIGNzc1Nob3cgPSB7cG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wifSxcbiAgICAgICAgY3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuICAgICAgICAgICAgbGV0dGVyU3BhY2luZzogXCIwXCIsXG4gICAgICAgICAgICBmb250V2VpZ2h0OiBcIjQwMFwiXG4gICAgICAgIH07XG5cbiAgICBmdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlcihlbGVtLCB2YWx1ZSwgc3VidHJhY3QpIHtcblxuICAgICAgICAvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG4gICAgICAgIC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuICAgICAgICB2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtYXRjaGVzID9cblxuICAgICAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3NcbiAgICAgICAgICAgIE1hdGgubWF4KDAsIG1hdGNoZXNbMl0gLSAoc3VidHJhY3QgfHwgMCkpICsgKG1hdGNoZXNbM10gfHwgXCJweFwiKSA6XG4gICAgICAgICAgICB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBib3hNb2RlbEFkanVzdG1lbnQoZWxlbSwgZGltZW5zaW9uLCBib3gsIGlzQm9yZGVyQm94LCBzdHlsZXMsIGNvbXB1dGVkVmFsKSB7XG4gICAgICAgIHZhciBpID0gZGltZW5zaW9uID09PSBcIndpZHRoXCIgPyAxIDogMCxcbiAgICAgICAgICAgIGV4dHJhID0gMCxcbiAgICAgICAgICAgIGRlbHRhID0gMDtcblxuICAgICAgICAvLyBBZGp1c3RtZW50IG1heSBub3QgYmUgbmVjZXNzYXJ5XG4gICAgICAgIGlmIChib3ggPT09IChpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIikpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPCA0OyBpICs9IDIpIHtcblxuICAgICAgICAgICAgLy8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luXG4gICAgICAgICAgICBpZiAoYm94ID09PSBcIm1hcmdpblwiKSB7XG4gICAgICAgICAgICAgICAgZGVsdGEgKz0galF1ZXJ5LmNzcyhlbGVtLCBib3ggKyBjc3NFeHBhbmRbaV0sIHRydWUsIHN0eWxlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBjb250ZW50LWJveCwgd2UncmUgc2Vla2luZyBcInBhZGRpbmdcIiBvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCJcbiAgICAgICAgICAgIGlmICghaXNCb3JkZXJCb3gpIHtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG4gICAgICAgICAgICAgICAgZGVsdGEgKz0galF1ZXJ5LmNzcyhlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFtpXSwgdHJ1ZSwgc3R5bGVzKTtcblxuICAgICAgICAgICAgICAgIC8vIEZvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCIsIGFkZCBib3JkZXJcbiAgICAgICAgICAgICAgICBpZiAoYm94ICE9PSBcInBhZGRpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YSArPSBqUXVlcnkuY3NzKGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbaV0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQnV0IHN0aWxsIGtlZXAgdHJhY2sgb2YgaXQgb3RoZXJ3aXNlXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmEgKz0galF1ZXJ5LmNzcyhlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kW2ldICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBib3JkZXItYm94IChjb250ZW50ICsgcGFkZGluZyArIGJvcmRlciksIHdlJ3JlIHNlZWtpbmcgXCJjb250ZW50XCIgb3JcbiAgICAgICAgICAgICAgICAvLyBcInBhZGRpbmdcIiBvciBcIm1hcmdpblwiXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gRm9yIFwiY29udGVudFwiLCBzdWJ0cmFjdCBwYWRkaW5nXG4gICAgICAgICAgICAgICAgaWYgKGJveCA9PT0gXCJjb250ZW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgLT0galF1ZXJ5LmNzcyhlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFtpXSwgdHJ1ZSwgc3R5bGVzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgXCJjb250ZW50XCIgb3IgXCJwYWRkaW5nXCIsIHN1YnRyYWN0IGJvcmRlclxuICAgICAgICAgICAgICAgIGlmIChib3ggIT09IFwibWFyZ2luXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgLT0galF1ZXJ5LmNzcyhlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kW2ldICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXG4gICAgICAgIGlmICghaXNCb3JkZXJCb3ggJiYgY29tcHV0ZWRWYWwgPj0gMCkge1xuXG4gICAgICAgICAgICAvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgYSByb3VuZGVkIHN1bSBvZiBjb250ZW50LCBwYWRkaW5nLCBzY3JvbGwgZ3V0dGVyLCBhbmQgYm9yZGVyXG4gICAgICAgICAgICAvLyBBc3N1bWluZyBpbnRlZ2VyIHNjcm9sbCBndXR0ZXIsIHN1YnRyYWN0IHRoZSByZXN0IGFuZCByb3VuZCBkb3duXG4gICAgICAgICAgICBkZWx0YSArPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoXG4gICAgICAgICAgICAgICAgZWxlbVtcIm9mZnNldFwiICsgZGltZW5zaW9uWzBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoMSldIC1cbiAgICAgICAgICAgICAgICBjb21wdXRlZFZhbCAtXG4gICAgICAgICAgICAgICAgZGVsdGEgLVxuICAgICAgICAgICAgICAgIGV4dHJhIC1cbiAgICAgICAgICAgICAgICAwLjVcblxuICAgICAgICAgICAgICAgIC8vIElmIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyB1bmtub3duLCB0aGVuIHdlIGNhbid0IGRldGVybWluZSBjb250ZW50LWJveCBzY3JvbGwgZ3V0dGVyXG4gICAgICAgICAgICAgICAgLy8gVXNlIGFuIGV4cGxpY2l0IHplcm8gdG8gYXZvaWQgTmFOIChnaC0zOTY0KVxuICAgICAgICAgICAgKSkgfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWx0YTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEpIHtcblxuICAgICAgICAvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXG4gICAgICAgIHZhciBzdHlsZXMgPSBnZXRTdHlsZXMoZWxlbSksXG5cbiAgICAgICAgICAgIC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTQzMjIpLlxuICAgICAgICAgICAgLy8gRmFrZSBjb250ZW50LWJveCB1bnRpbCB3ZSBrbm93IGl0J3MgbmVlZGVkIHRvIGtub3cgdGhlIHRydWUgdmFsdWUuXG4gICAgICAgICAgICBib3hTaXppbmdOZWVkZWQgPSAhc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IGV4dHJhLFxuICAgICAgICAgICAgaXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcbiAgICAgICAgICAgICAgICBqUXVlcnkuY3NzKGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMpID09PSBcImJvcmRlci1ib3hcIixcbiAgICAgICAgICAgIHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCxcblxuICAgICAgICAgICAgdmFsID0gY3VyQ1NTKGVsZW0sIGRpbWVuc2lvbiwgc3R5bGVzKSxcbiAgICAgICAgICAgIG9mZnNldFByb3AgPSBcIm9mZnNldFwiICsgZGltZW5zaW9uWzBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoMSk7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG4gICAgICAgIC8vIFJldHVybiBhIGNvbmZvdW5kaW5nIG5vbi1waXhlbCB2YWx1ZSBvciBmZWlnbiBpZ25vcmFuY2UsIGFzIGFwcHJvcHJpYXRlLlxuICAgICAgICBpZiAocm51bW5vbnB4LnRlc3QodmFsKSkge1xuICAgICAgICAgICAgaWYgKCFleHRyYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWwgPSBcImF1dG9cIjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCB3aGVuIHZhbHVlIGlzIFwiYXV0b1wiXG4gICAgICAgIC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcbiAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSAtIDQuMyBvbmx5XG4gICAgICAgIC8vIEFsc28gdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3IgbWlzcmVwb3J0ZWQgaW5saW5lIGRpbWVuc2lvbnMgKGdoLTM2MDIpXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDktMTEgb25seVxuICAgICAgICAvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIHdoZW4gYm94IHNpemluZyBpcyB1bnJlbGlhYmxlXG4gICAgICAgIC8vIFdlIHVzZSBnZXRDbGllbnRSZWN0cygpIHRvIGNoZWNrIGZvciBoaWRkZW4vZGlzY29ubmVjdGVkLlxuICAgICAgICAvLyBJbiB0aG9zZSBjYXNlcywgdGhlIGNvbXB1dGVkIHZhbHVlIGNhbiBiZSB0cnVzdGVkIHRvIGJlIGJvcmRlci1ib3hcbiAgICAgICAgaWYgKCghc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpICYmIGlzQm9yZGVyQm94IHx8XG4gICAgICAgICAgICB2YWwgPT09IFwiYXV0b1wiIHx8XG4gICAgICAgICAgICAhcGFyc2VGbG9hdCh2YWwpICYmIGpRdWVyeS5jc3MoZWxlbSwgXCJkaXNwbGF5XCIsIGZhbHNlLCBzdHlsZXMpID09PSBcImlubGluZVwiKSAmJlxuICAgICAgICAgICAgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCkge1xuXG4gICAgICAgICAgICBpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcykgPT09IFwiYm9yZGVyLWJveFwiO1xuXG4gICAgICAgICAgICAvLyBXaGVyZSBhdmFpbGFibGUsIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBhcHByb3hpbWF0ZSBib3JkZXIgYm94IGRpbWVuc2lvbnMuXG4gICAgICAgICAgICAvLyBXaGVyZSBub3QgYXZhaWxhYmxlIChlLmcuLCBTVkcpLCBhc3N1bWUgdW5yZWxpYWJsZSBib3gtc2l6aW5nIGFuZCBpbnRlcnByZXQgdGhlXG4gICAgICAgICAgICAvLyByZXRyaWV2ZWQgdmFsdWUgYXMgYSBjb250ZW50IGJveCBkaW1lbnNpb24uXG4gICAgICAgICAgICB2YWx1ZUlzQm9yZGVyQm94ID0gb2Zmc2V0UHJvcCBpbiBlbGVtO1xuICAgICAgICAgICAgaWYgKHZhbHVlSXNCb3JkZXJCb3gpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBlbGVtW29mZnNldFByb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIFwiXCIgYW5kIGF1dG9cbiAgICAgICAgdmFsID0gcGFyc2VGbG9hdCh2YWwpIHx8IDA7XG5cbiAgICAgICAgLy8gQWRqdXN0IGZvciB0aGUgZWxlbWVudCdzIGJveCBtb2RlbFxuICAgICAgICByZXR1cm4gKHZhbCArXG4gICAgICAgICAgICBib3hNb2RlbEFkanVzdG1lbnQoXG4gICAgICAgICAgICAgICAgZWxlbSxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb24sXG4gICAgICAgICAgICAgICAgZXh0cmEgfHwgKGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiKSxcbiAgICAgICAgICAgICAgICB2YWx1ZUlzQm9yZGVyQm94LFxuICAgICAgICAgICAgICAgIHN0eWxlcyxcblxuICAgICAgICAgICAgICAgIC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgY29tcHV0ZWQgc2l6ZSB0byByZXF1ZXN0IHNjcm9sbCBndXR0ZXIgY2FsY3VsYXRpb24gKGdoLTM1ODkpXG4gICAgICAgICAgICAgICAgdmFsXG4gICAgICAgICAgICApXG4gICAgICAgICkgKyBcInB4XCI7XG4gICAgfVxuXG4gICAgalF1ZXJ5LmV4dGVuZCh7XG5cbiAgICAgICAgLy8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG4gICAgICAgIC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuICAgICAgICBjc3NIb29rczoge1xuICAgICAgICAgICAgb3BhY2l0eToge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKGVsZW0sIGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wdXRlZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IGN1ckNTUyhlbGVtLCBcIm9wYWNpdHlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcbiAgICAgICAgY3NzTnVtYmVyOiB7XG4gICAgICAgICAgICBcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCI6IHRydWUsXG4gICAgICAgICAgICBcImNvbHVtbkNvdW50XCI6IHRydWUsXG4gICAgICAgICAgICBcImZpbGxPcGFjaXR5XCI6IHRydWUsXG4gICAgICAgICAgICBcImZsZXhHcm93XCI6IHRydWUsXG4gICAgICAgICAgICBcImZsZXhTaHJpbmtcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiZm9udFdlaWdodFwiOiB0cnVlLFxuICAgICAgICAgICAgXCJncmlkQXJlYVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJncmlkQ29sdW1uXCI6IHRydWUsXG4gICAgICAgICAgICBcImdyaWRDb2x1bW5FbmRcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiZ3JpZENvbHVtblN0YXJ0XCI6IHRydWUsXG4gICAgICAgICAgICBcImdyaWRSb3dcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiZ3JpZFJvd0VuZFwiOiB0cnVlLFxuICAgICAgICAgICAgXCJncmlkUm93U3RhcnRcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwibGluZUhlaWdodFwiOiB0cnVlLFxuICAgICAgICAgICAgXCJvcGFjaXR5XCI6IHRydWUsXG4gICAgICAgICAgICBcIm9yZGVyXCI6IHRydWUsXG4gICAgICAgICAgICBcIm9ycGhhbnNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwid2lkb3dzXCI6IHRydWUsXG4gICAgICAgICAgICBcInpJbmRleFwiOiB0cnVlLFxuICAgICAgICAgICAgXCJ6b29tXCI6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG4gICAgICAgIC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcbiAgICAgICAgY3NzUHJvcHM6IHt9LFxuXG4gICAgICAgIC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG4gICAgICAgIHN0eWxlOiBmdW5jdGlvbiAoZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhKSB7XG5cbiAgICAgICAgICAgIC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuICAgICAgICAgICAgaWYgKCFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG4gICAgICAgICAgICB2YXIgcmV0LCB0eXBlLCBob29rcyxcbiAgICAgICAgICAgICAgICBvcmlnTmFtZSA9IGNhbWVsQ2FzZShuYW1lKSxcbiAgICAgICAgICAgICAgICBpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KG5hbWUpLFxuICAgICAgICAgICAgICAgIHN0eWxlID0gZWxlbS5zdHlsZTtcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuICAgICAgICAgICAgLy8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG4gICAgICAgICAgICAvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG4gICAgICAgICAgICBpZiAoIWlzQ3VzdG9tUHJvcCkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBmaW5hbFByb3BOYW1lKG9yaWdOYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cbiAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzW25hbWVdIHx8IGpRdWVyeS5jc3NIb29rc1tvcmlnTmFtZV07XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiICYmIChyZXQgPSByY3NzTnVtLmV4ZWModmFsdWUpKSAmJiByZXRbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhZGp1c3RDU1MoZWxlbSwgbmFtZSwgcmV0KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGaXhlcyBidWcgIzkyMzdcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IFwibnVtYmVyXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIC8vIFRoZSBpc0N1c3RvbVByb3AgY2hlY2sgY2FuIGJlIHJlbW92ZWQgaW4galF1ZXJ5IDQuMCB3aGVuIHdlIG9ubHkgYXV0by1hcHBlbmRcbiAgICAgICAgICAgICAgICAvLyBcInB4XCIgdG8gYSBmZXcgaGFyZGNvZGVkIHZhbHVlcy5cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJudW1iZXJcIiAmJiAhaXNDdXN0b21Qcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHJldCAmJiByZXRbM10gfHwgKGpRdWVyeS5jc3NOdW1iZXJbb3JpZ05hbWVdID8gXCJcIiA6IFwicHhcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xuICAgICAgICAgICAgICAgIGlmICghc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKFwiYmFja2dyb3VuZFwiKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVtuYW1lXSA9IFwiaW5oZXJpdFwiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuICAgICAgICAgICAgICAgIGlmICghaG9va3MgfHwgIShcInNldFwiIGluIGhvb2tzKSB8fFxuICAgICAgICAgICAgICAgICAgICAodmFsdWUgPSBob29rcy5zZXQoZWxlbSwgdmFsdWUsIGV4dHJhKSkgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0N1c3RvbVByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcbiAgICAgICAgICAgICAgICBpZiAoaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuICAgICAgICAgICAgICAgICAgICAocmV0ID0gaG9va3MuZ2V0KGVsZW0sIGZhbHNlLCBleHRyYSkpICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNzczogZnVuY3Rpb24gKGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMpIHtcbiAgICAgICAgICAgIHZhciB2YWwsIG51bSwgaG9va3MsXG4gICAgICAgICAgICAgICAgb3JpZ05hbWUgPSBjYW1lbENhc2UobmFtZSksXG4gICAgICAgICAgICAgICAgaXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdChuYW1lKTtcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuICAgICAgICAgICAgLy8gd2FudCB0byBtb2RpZnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuICAgICAgICAgICAgLy8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuICAgICAgICAgICAgaWYgKCFpc0N1c3RvbVByb3ApIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gZmluYWxQcm9wTmFtZShvcmlnTmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcbiAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzW25hbWVdIHx8IGpRdWVyeS5jc3NIb29rc1tvcmlnTmFtZV07XG5cbiAgICAgICAgICAgIC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG4gICAgICAgICAgICBpZiAoaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcykge1xuICAgICAgICAgICAgICAgIHZhbCA9IGhvb2tzLmdldChlbGVtLCB0cnVlLCBleHRyYSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG4gICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBjdXJDU1MoZWxlbSwgbmFtZSwgc3R5bGVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG4gICAgICAgICAgICBpZiAodmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtW25hbWVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcbiAgICAgICAgICAgIGlmIChleHRyYSA9PT0gXCJcIiB8fCBleHRyYSkge1xuICAgICAgICAgICAgICAgIG51bSA9IHBhcnNlRmxvYXQodmFsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUobnVtKSA/IG51bSB8fCAwIDogdmFsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBqUXVlcnkuZWFjaChbXCJoZWlnaHRcIiwgXCJ3aWR0aFwiXSwgZnVuY3Rpb24gKGksIGRpbWVuc2lvbikge1xuICAgICAgICBqUXVlcnkuY3NzSG9va3NbZGltZW5zaW9uXSA9IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKGVsZW0sIGNvbXB1dGVkLCBleHRyYSkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wdXRlZCkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoalF1ZXJ5LmNzcyhlbGVtLCBcImRpc3BsYXlcIikpICYmXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogU2FmYXJpIDgrXG4gICAgICAgICAgICAgICAgICAgIC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG4gICAgICAgICAgICAgICAgICAgIC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuICAgICAgICAgICAgICAgICAgICAvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgKCFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2FwKGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0V2lkdGhPckhlaWdodChlbGVtLCBkaW1lbnNpb24sIGV4dHJhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFdpZHRoT3JIZWlnaHQoZWxlbSwgZGltZW5zaW9uLCBleHRyYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoZWxlbSwgdmFsdWUsIGV4dHJhKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcyA9IGdldFN0eWxlcyhlbGVtKSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHJlYWQgc3R5bGVzLnBvc2l0aW9uIGlmIHRoZSB0ZXN0IGhhcyBhIGNoYW5jZSB0byBmYWlsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3cuXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGJveFNpemVCdWdneSA9ICFzdXBwb3J0LnNjcm9sbGJveFNpemUoKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnBvc2l0aW9uID09PSBcImFic29sdXRlXCIsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdywgb25seSBmZXRjaCBib3hTaXppbmcgaWYgd2UgbmVlZCBpdCAoZ2gtMzk5MSlcbiAgICAgICAgICAgICAgICAgICAgYm94U2l6aW5nTmVlZGVkID0gc2Nyb2xsYm94U2l6ZUJ1Z2d5IHx8IGV4dHJhLFxuICAgICAgICAgICAgICAgICAgICBpc0JvcmRlckJveCA9IGJveFNpemluZ05lZWRlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNzcyhlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzKSA9PT0gXCJib3JkZXItYm94XCIsXG4gICAgICAgICAgICAgICAgICAgIHN1YnRyYWN0ID0gZXh0cmEgP1xuICAgICAgICAgICAgICAgICAgICAgICAgYm94TW9kZWxBZGp1c3RtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQm9yZGVyQm94LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAwO1xuXG4gICAgICAgICAgICAgICAgLy8gQWNjb3VudCBmb3IgdW5yZWxpYWJsZSBib3JkZXItYm94IGRpbWVuc2lvbnMgYnkgY29tcGFyaW5nIG9mZnNldCogdG8gY29tcHV0ZWQgYW5kXG4gICAgICAgICAgICAgICAgLy8gZmFraW5nIGEgY29udGVudC1ib3ggdG8gZ2V0IGJvcmRlciBhbmQgcGFkZGluZyAoZ2gtMzY5OSlcbiAgICAgICAgICAgICAgICBpZiAoaXNCb3JkZXJCb3ggJiYgc2Nyb2xsYm94U2l6ZUJ1Z2d5KSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnRyYWN0IC09IE1hdGguY2VpbChcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bXCJvZmZzZXRcIiArIGRpbWVuc2lvblswXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKDEpXSAtXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHN0eWxlc1tkaW1lbnNpb25dKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICBib3hNb2RlbEFkanVzdG1lbnQoZWxlbSwgZGltZW5zaW9uLCBcImJvcmRlclwiLCBmYWxzZSwgc3R5bGVzKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuICAgICAgICAgICAgICAgIGlmIChzdWJ0cmFjdCAmJiAobWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyh2YWx1ZSkpICYmXG4gICAgICAgICAgICAgICAgICAgIChtYXRjaGVzWzNdIHx8IFwicHhcIikgIT09IFwicHhcIikge1xuXG4gICAgICAgICAgICAgICAgICAgIGVsZW0uc3R5bGVbZGltZW5zaW9uXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGpRdWVyeS5jc3MoZWxlbSwgZGltZW5zaW9uKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoZWxlbSwgdmFsdWUsIHN1YnRyYWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuICAgICAgICBmdW5jdGlvbiAoZWxlbSwgY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAocGFyc2VGbG9hdChjdXJDU1MoZWxlbSwgXCJtYXJnaW5MZWZ0XCIpKSB8fFxuICAgICAgICAgICAgICAgICAgICBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuICAgICAgICAgICAgICAgICAgICBzd2FwKGVsZW0sIHttYXJnaW5MZWZ0OiAwfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbiAgICBqUXVlcnkuZWFjaCh7XG4gICAgICAgIG1hcmdpbjogXCJcIixcbiAgICAgICAgcGFkZGluZzogXCJcIixcbiAgICAgICAgYm9yZGVyOiBcIldpZHRoXCJcbiAgICB9LCBmdW5jdGlvbiAocHJlZml4LCBzdWZmaXgpIHtcbiAgICAgICAgalF1ZXJ5LmNzc0hvb2tzW3ByZWZpeCArIHN1ZmZpeF0gPSB7XG4gICAgICAgICAgICBleHBhbmQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQgPSB7fSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgcGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdChcIiBcIikgOiBbdmFsdWVdO1xuXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWRbcHJlZml4ICsgY3NzRXhwYW5kW2ldICsgc3VmZml4XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0c1tpXSB8fCBwYXJ0c1tpIC0gMl0gfHwgcGFydHNbMF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cGFuZGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChwcmVmaXggIT09IFwibWFyZ2luXCIpIHtcbiAgICAgICAgICAgIGpRdWVyeS5jc3NIb29rc1twcmVmaXggKyBzdWZmaXhdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgICAgY3NzOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3ModGhpcywgZnVuY3Rpb24gKGVsZW0sIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlcywgbGVuLFxuICAgICAgICAgICAgICAgICAgICBtYXAgPSB7fSxcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXMgPSBnZXRTdHlsZXMoZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IG5hbWUubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcFtuYW1lW2ldXSA9IGpRdWVyeS5jc3MoZWxlbSwgbmFtZVtpXSwgZmFsc2UsIHN0eWxlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnN0eWxlKGVsZW0sIG5hbWUsIHZhbHVlKSA6XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jc3MoZWxlbSwgbmFtZSk7XG4gICAgICAgICAgICB9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEpO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuICAgIGZ1bmN0aW9uIFR3ZWVuKGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcpO1xuICAgIH1cblxuICAgIGpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG4gICAgVHdlZW4ucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogVHdlZW4sXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICAgICAgICAgIHRoaXMucHJvcCA9IHByb3A7XG4gICAgICAgICAgICB0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgICAgIHRoaXMudW5pdCA9IHVuaXQgfHwgKGpRdWVyeS5jc3NOdW1iZXJbcHJvcF0gPyBcIlwiIDogXCJweFwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgY3VyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbdGhpcy5wcm9wXTtcblxuICAgICAgICAgICAgcmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG4gICAgICAgICAgICAgICAgaG9va3MuZ2V0KHRoaXMpIDpcbiAgICAgICAgICAgICAgICBUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBydW46IGZ1bmN0aW9uIChwZXJjZW50KSB7XG4gICAgICAgICAgICB2YXIgZWFzZWQsXG4gICAgICAgICAgICAgICAgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbdGhpcy5wcm9wXTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nW3RoaXMuZWFzaW5nXShcbiAgICAgICAgICAgICAgICAgICAgcGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5vdyA9ICh0aGlzLmVuZCAtIHRoaXMuc3RhcnQpICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0ZXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaG9va3MgJiYgaG9va3Muc2V0KSB7XG4gICAgICAgICAgICAgICAgaG9va3Muc2V0KHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG4gICAgVHdlZW4ucHJvcEhvb2tzID0ge1xuICAgICAgICBfZGVmYXVsdDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAodHdlZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgLy8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcbiAgICAgICAgICAgICAgICAvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuICAgICAgICAgICAgICAgIGlmICh0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG4gICAgICAgICAgICAgICAgICAgIHR3ZWVuLmVsZW1bdHdlZW4ucHJvcF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlW3R3ZWVuLnByb3BdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR3ZWVuLmVsZW1bdHdlZW4ucHJvcF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG4gICAgICAgICAgICAgICAgLy8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcbiAgICAgICAgICAgICAgICAvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpRdWVyeS5jc3ModHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIik7XG5cbiAgICAgICAgICAgICAgICAvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cbiAgICAgICAgICAgICAgICByZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0d2Vlbikge1xuXG4gICAgICAgICAgICAgICAgLy8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG4gICAgICAgICAgICAgICAgLy8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuICAgICAgICAgICAgICAgIC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5meC5zdGVwW3R3ZWVuLnByb3BdKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5meC5zdGVwW3R3ZWVuLnByb3BdKHR3ZWVuKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKFxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY3NzSG9va3NbdHdlZW4ucHJvcF0gfHxcbiAgICAgICAgICAgICAgICAgICAgdHdlZW4uZWxlbS5zdHlsZVtmaW5hbFByb3BOYW1lKHR3ZWVuLnByb3ApXSAhPSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuc3R5bGUodHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHdlZW4uZWxlbVt0d2Vlbi5wcm9wXSA9IHR3ZWVuLm5vdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbiAgICAvLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcbiAgICBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHR3ZWVuKSB7XG4gICAgICAgICAgICBpZiAodHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0d2Vlbi5lbGVtW3R3ZWVuLnByb3BdID0gdHdlZW4ubm93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGpRdWVyeS5lYXNpbmcgPSB7XG4gICAgICAgIGxpbmVhcjogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LFxuICAgICAgICBzd2luZzogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHJldHVybiAwLjUgLSBNYXRoLmNvcyhwICogTWF0aC5QSSkgLyAyO1xuICAgICAgICB9LFxuICAgICAgICBfZGVmYXVsdDogXCJzd2luZ1wiXG4gICAgfTtcblxuICAgIGpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4gICAgLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbiAgICBqUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cbiAgICB2YXJcbiAgICAgICAgZnhOb3csIGluUHJvZ3Jlc3MsXG4gICAgICAgIHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuICAgICAgICBycnVuID0gL3F1ZXVlSG9va3MkLztcblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlKCkge1xuICAgICAgICBpZiAoaW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmhpZGRlbiA9PT0gZmFsc2UgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2NoZWR1bGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChzY2hlZHVsZSwgalF1ZXJ5LmZ4LmludGVydmFsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgalF1ZXJ5LmZ4LnRpY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbiAgICBmdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnhOb3cgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKGZ4Tm93ID0gRGF0ZS5ub3coKSk7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbiAgICBmdW5jdGlvbiBnZW5GeCh0eXBlLCBpbmNsdWRlV2lkdGgpIHtcbiAgICAgICAgdmFyIHdoaWNoLFxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBhdHRycyA9IHtoZWlnaHQ6IHR5cGV9O1xuXG4gICAgICAgIC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcbiAgICAgICAgaW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG4gICAgICAgIGZvciAoOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoKSB7XG4gICAgICAgICAgICB3aGljaCA9IGNzc0V4cGFuZFtpXTtcbiAgICAgICAgICAgIGF0dHJzW1wibWFyZ2luXCIgKyB3aGljaF0gPSBhdHRyc1tcInBhZGRpbmdcIiArIHdoaWNoXSA9IHR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5jbHVkZVdpZHRoKSB7XG4gICAgICAgICAgICBhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKHZhbHVlLCBwcm9wLCBhbmltYXRpb24pIHtcbiAgICAgICAgdmFyIHR3ZWVuLFxuICAgICAgICAgICAgY29sbGVjdGlvbiA9IChBbmltYXRpb24udHdlZW5lcnNbcHJvcF0gfHwgW10pLmNvbmNhdChBbmltYXRpb24udHdlZW5lcnNbXCIqXCJdKSxcbiAgICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmICgodHdlZW4gPSBjb2xsZWN0aW9uW2luZGV4XS5jYWxsKGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUpKSkge1xuXG4gICAgICAgICAgICAgICAgLy8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHdlZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKGVsZW0sIHByb3BzLCBvcHRzKSB7XG4gICAgICAgIHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCBob29rcywgb2xkZmlyZSwgcHJvcFR3ZWVuLCByZXN0b3JlRGlzcGxheSwgZGlzcGxheSxcbiAgICAgICAgICAgIGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG4gICAgICAgICAgICBhbmltID0gdGhpcyxcbiAgICAgICAgICAgIG9yaWcgPSB7fSxcbiAgICAgICAgICAgIHN0eWxlID0gZWxlbS5zdHlsZSxcbiAgICAgICAgICAgIGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKGVsZW0pLFxuICAgICAgICAgICAgZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoZWxlbSwgXCJmeHNob3dcIik7XG5cbiAgICAgICAgLy8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXG4gICAgICAgIGlmICghb3B0cy5xdWV1ZSkge1xuICAgICAgICAgICAgaG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoZWxlbSwgXCJmeFwiKTtcbiAgICAgICAgICAgIGlmIChob29rcy51bnF1ZXVlZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaG9va3MudW5xdWV1ZWQgPSAwO1xuICAgICAgICAgICAgICAgIG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuICAgICAgICAgICAgICAgIGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaG9va3MudW5xdWV1ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZGZpcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBob29rcy51bnF1ZXVlZCsrO1xuXG4gICAgICAgICAgICBhbmltLmFsd2F5cyhmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuICAgICAgICAgICAgICAgIGFuaW0uYWx3YXlzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9va3MudW5xdWV1ZWQtLTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFqUXVlcnkucXVldWUoZWxlbSwgXCJmeFwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvb2tzLmVtcHR5LmZpcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlY3Qgc2hvdy9oaWRlIGFuaW1hdGlvbnNcbiAgICAgICAgZm9yIChwcm9wIGluIHByb3BzKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHByb3BzW3Byb3BdO1xuICAgICAgICAgICAgaWYgKHJmeHR5cGVzLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHByb3BzW3Byb3BdO1xuICAgICAgICAgICAgICAgIHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IChoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcInNob3dcIiBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1twcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW4gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcmlnW3Byb3BdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbcHJvcF0gfHwgalF1ZXJ5LnN0eWxlKGVsZW0sIHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcbiAgICAgICAgcHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KHByb3BzKTtcbiAgICAgICAgaWYgKCFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3Qob3JpZykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc3RyaWN0IFwib3ZlcmZsb3dcIiBhbmQgXCJkaXNwbGF5XCIgc3R5bGVzIGR1cmluZyBib3ggYW5pbWF0aW9uc1xuICAgICAgICBpZiAoaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xuXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG4gICAgICAgICAgICAvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcbiAgICAgICAgICAgIC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZIGFuZCBFZGdlIGp1c3QgbWlycm9yc1xuICAgICAgICAgICAgLy8gdGhlIG92ZXJmbG93WCB2YWx1ZSB0aGVyZS5cbiAgICAgICAgICAgIG9wdHMub3ZlcmZsb3cgPSBbc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZXTtcblxuICAgICAgICAgICAgLy8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG4gICAgICAgICAgICByZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG4gICAgICAgICAgICBpZiAocmVzdG9yZURpc3BsYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KGVsZW0sIFwiZGlzcGxheVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3BsYXkgPSBqUXVlcnkuY3NzKGVsZW0sIFwiZGlzcGxheVwiKTtcbiAgICAgICAgICAgIGlmIChkaXNwbGF5ID09PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgICAgIGlmIChyZXN0b3JlRGlzcGxheSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XG4gICAgICAgICAgICAgICAgICAgIHNob3dIaWRlKFtlbGVtXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5ID0galF1ZXJ5LmNzcyhlbGVtLCBcImRpc3BsYXlcIik7XG4gICAgICAgICAgICAgICAgICAgIHNob3dIaWRlKFtlbGVtXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBbmltYXRlIGlubGluZSBlbGVtZW50cyBhcyBpbmxpbmUtYmxvY2tcbiAgICAgICAgICAgIGlmIChkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuY3NzKGVsZW0sIFwiZmxvYXRcIikgPT09IFwibm9uZVwiKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZSBhdCB0aGUgZW5kIG9mIHB1cmUgc2hvdy9oaWRlIGFuaW1hdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wVHdlZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW0uZG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdG9yZURpc3BsYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5vdmVyZmxvdykge1xuICAgICAgICAgICAgc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgICAgICAgICAgYW5pbS5hbHdheXMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1swXTtcbiAgICAgICAgICAgICAgICBzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WzFdO1xuICAgICAgICAgICAgICAgIHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbMl07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEltcGxlbWVudCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuICAgICAgICBwcm9wVHdlZW4gPSBmYWxzZTtcbiAgICAgICAgZm9yIChwcm9wIGluIG9yaWcpIHtcblxuICAgICAgICAgICAgLy8gR2VuZXJhbCBzaG93L2hpZGUgc2V0dXAgZm9yIHRoaXMgZWxlbWVudCBhbmltYXRpb25cbiAgICAgICAgICAgIGlmICghcHJvcFR3ZWVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFTaG93KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImhpZGRlblwiIGluIGRhdGFTaG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyhlbGVtLCBcImZ4c2hvd1wiLCB7ZGlzcGxheTogcmVzdG9yZURpc3BsYXl9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcbiAgICAgICAgICAgICAgICBpZiAodG9nZ2xlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cbiAgICAgICAgICAgICAgICBpZiAoaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3dIaWRlKFtlbGVtXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG5cbiAgICAgICAgICAgICAgICBhbmltLmRvbmUoZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZpbmFsIHN0ZXAgb2YgYSBcImhpZGVcIiBhbmltYXRpb24gaXMgYWN0dWFsbHkgaGlkaW5nIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93SGlkZShbZWxlbV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcml2LnJlbW92ZShlbGVtLCBcImZ4c2hvd1wiKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChwcm9wIGluIG9yaWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5zdHlsZShlbGVtLCBwcm9wLCBvcmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQZXItcHJvcGVydHkgc2V0dXBcbiAgICAgICAgICAgIHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKGhpZGRlbiA/IGRhdGFTaG93W3Byb3BdIDogMCwgcHJvcCwgYW5pbSk7XG4gICAgICAgICAgICBpZiAoIShwcm9wIGluIGRhdGFTaG93KSkge1xuICAgICAgICAgICAgICAgIGRhdGFTaG93W3Byb3BdID0gcHJvcFR3ZWVuLnN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChoaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgcHJvcFR3ZWVuLnN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9wRmlsdGVyKHByb3BzLCBzcGVjaWFsRWFzaW5nKSB7XG4gICAgICAgIHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cbiAgICAgICAgLy8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG4gICAgICAgIGZvciAoaW5kZXggaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbENhc2UoaW5kZXgpO1xuICAgICAgICAgICAgZWFzaW5nID0gc3BlY2lhbEVhc2luZ1tuYW1lXTtcbiAgICAgICAgICAgIHZhbHVlID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZWFzaW5nID0gdmFsdWVbMV07XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwcm9wc1tpbmRleF0gPSB2YWx1ZVswXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcHJvcHNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcHJvcHNbaW5kZXhdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBob29rcyA9IGpRdWVyeS5jc3NIb29rc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBob29rcy5leHBhbmQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwcm9wc1tuYW1lXTtcblxuICAgICAgICAgICAgICAgIC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cbiAgICAgICAgICAgICAgICAvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG4gICAgICAgICAgICAgICAgZm9yIChpbmRleCBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShpbmRleCBpbiBwcm9wcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzW2luZGV4XSA9IHZhbHVlW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpYWxFYXNpbmdbaW5kZXhdID0gZWFzaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzcGVjaWFsRWFzaW5nW25hbWVdID0gZWFzaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uKGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICAgIHN0b3BwZWQsXG4gICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICBsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG4gICAgICAgICAgICBkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyhmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICBkZWxldGUgdGljay5lbGVtO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0aWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChzdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nID0gTWF0aC5tYXgoMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lKSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMyBvbmx5XG4gICAgICAgICAgICAgICAgICAgIC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5NylcbiAgICAgICAgICAgICAgICAgICAgdGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuICAgICAgICAgICAgICAgICAgICBwZXJjZW50ID0gMSAtIHRlbXAsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLnR3ZWVuc1tpbmRleF0ucnVuKHBlcmNlbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeVdpdGgoZWxlbSwgW2FuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nXSk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG1vcmUgdG8gZG8sIHlpZWxkXG4gICAgICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAxICYmIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVtYWluaW5nO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuICAgICAgICAgICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeVdpdGgoZWxlbSwgW2FuaW1hdGlvbiwgMSwgMF0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZVdpdGgoZWxlbSwgW2FuaW1hdGlvbl0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKHtcbiAgICAgICAgICAgICAgICBlbGVtOiBlbGVtLFxuICAgICAgICAgICAgICAgIHByb3BzOiBqUXVlcnkuZXh0ZW5kKHt9LCBwcm9wZXJ0aWVzKSxcbiAgICAgICAgICAgICAgICBvcHRzOiBqUXVlcnkuZXh0ZW5kKHRydWUsIHtcbiAgICAgICAgICAgICAgICAgICAgc3BlY2lhbEVhc2luZzoge30sXG4gICAgICAgICAgICAgICAgICAgIGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIHR3ZWVuczogW10sXG4gICAgICAgICAgICAgICAgY3JlYXRlVHdlZW46IGZ1bmN0aW9uIChwcm9wLCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nW3Byb3BdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyk7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi50d2VlbnMucHVzaCh0d2Vlbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0d2VlbjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uIChnb3RvRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IDAsXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLnR3ZWVuc1tpbmRleF0ucnVuKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdvdG9FbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeVdpdGgoZWxlbSwgW2FuaW1hdGlvbiwgMSwgMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZVdpdGgoZWxlbSwgW2FuaW1hdGlvbiwgZ290b0VuZF0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0V2l0aChlbGVtLCBbYW5pbWF0aW9uLCBnb3RvRW5kXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuICAgICAgICBwcm9wRmlsdGVyKHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nKTtcblxuICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzW2luZGV4XS5jYWxsKGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihyZXN1bHQuc3RvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Ll9xdWV1ZUhvb2tzKGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSkuc3RvcCA9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RvcC5iaW5kKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBqUXVlcnkubWFwKHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uKTtcblxuICAgICAgICBpZiAoaXNGdW5jdGlvbihhbmltYXRpb24ub3B0cy5zdGFydCkpIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoZWxlbSwgYW5pbWF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG4gICAgICAgIGFuaW1hdGlvblxuICAgICAgICAgICAgLnByb2dyZXNzKGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzKVxuICAgICAgICAgICAgLmRvbmUoYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUpXG4gICAgICAgICAgICAuZmFpbChhbmltYXRpb24ub3B0cy5mYWlsKVxuICAgICAgICAgICAgLmFsd2F5cyhhbmltYXRpb24ub3B0cy5hbHdheXMpO1xuXG4gICAgICAgIGpRdWVyeS5meC50aW1lcihcbiAgICAgICAgICAgIGpRdWVyeS5leHRlbmQodGljaywge1xuICAgICAgICAgICAgICAgIGVsZW06IGVsZW0sXG4gICAgICAgICAgICAgICAgYW5pbTogYW5pbWF0aW9uLFxuICAgICAgICAgICAgICAgIHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gYW5pbWF0aW9uO1xuICAgIH1cblxuICAgIGpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKEFuaW1hdGlvbiwge1xuXG4gICAgICAgIHR3ZWVuZXJzOiB7XG4gICAgICAgICAgICBcIipcIjogW2Z1bmN0aW9uIChwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4ocHJvcCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGFkanVzdENTUyh0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWModmFsdWUpLCB0d2Vlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR3ZWVuO1xuICAgICAgICAgICAgfV1cbiAgICAgICAgfSxcblxuICAgICAgICB0d2VlbmVyOiBmdW5jdGlvbiAocHJvcHMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wcykpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHByb3BzO1xuICAgICAgICAgICAgICAgIHByb3BzID0gW1wiKlwiXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvcHMgPSBwcm9wcy5tYXRjaChybm90aHRtbHdoaXRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHByb3AsXG4gICAgICAgICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBBbmltYXRpb24udHdlZW5lcnNbcHJvcF0gPSBBbmltYXRpb24udHdlZW5lcnNbcHJvcF0gfHwgW107XG4gICAgICAgICAgICAgICAgQW5pbWF0aW9uLnR3ZWVuZXJzW3Byb3BdLnVuc2hpZnQoY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHByZWZpbHRlcnM6IFtkZWZhdWx0UHJlZmlsdGVyXSxcblxuICAgICAgICBwcmVmaWx0ZXI6IGZ1bmN0aW9uIChjYWxsYmFjaywgcHJlcGVuZCkge1xuICAgICAgICAgICAgaWYgKHByZXBlbmQpIHtcbiAgICAgICAgICAgICAgICBBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgQW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uIChzcGVlZCwgZWFzaW5nLCBmbikge1xuICAgICAgICB2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCh7fSwgc3BlZWQpIDoge1xuICAgICAgICAgICAgY29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcbiAgICAgICAgICAgICAgICBpc0Z1bmN0aW9uKHNwZWVkKSAmJiBzcGVlZCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBzcGVlZCxcbiAgICAgICAgICAgIGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhaXNGdW5jdGlvbihlYXNpbmcpICYmIGVhc2luZ1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZlxuICAgICAgICBpZiAoalF1ZXJ5LmZ4Lm9mZikge1xuICAgICAgICAgICAgb3B0LmR1cmF0aW9uID0gMDtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHQuZHVyYXRpb24gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkc1tvcHQuZHVyYXRpb25dO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcbiAgICAgICAgaWYgKG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgb3B0LnF1ZXVlID0gXCJmeFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUXVldWVpbmdcbiAgICAgICAgb3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuICAgICAgICBvcHQuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihvcHQub2xkKSkge1xuICAgICAgICAgICAgICAgIG9wdC5vbGQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdC5xdWV1ZSkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKHRoaXMsIG9wdC5xdWV1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG9wdDtcbiAgICB9O1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICAgIGZhZGVUbzogZnVuY3Rpb24gKHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjaykge1xuXG4gICAgICAgICAgICAvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihpc0hpZGRlbldpdGhpblRyZWUpLmNzcyhcIm9wYWNpdHlcIiwgMCkuc2hvdygpXG5cbiAgICAgICAgICAgIC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuICAgICAgICAgICAgICAgIC5lbmQoKS5hbmltYXRlKHtvcGFjaXR5OiB0b30sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgYW5pbWF0ZTogZnVuY3Rpb24gKHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdChwcm9wKSxcbiAgICAgICAgICAgICAgICBvcHRhbGwgPSBqUXVlcnkuc3BlZWQoc3BlZWQsIGVhc2luZywgY2FsbGJhY2spLFxuICAgICAgICAgICAgICAgIGRvQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltID0gQW5pbWF0aW9uKHRoaXMsIGpRdWVyeS5leHRlbmQoe30sIHByb3ApLCBvcHRhbGwpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW1wdHkgfHwgZGF0YVByaXYuZ2V0KHRoaXMsIFwiZmluaXNoXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltLnN0b3AodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cbiAgICAgICAgICAgIHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cbiAgICAgICAgICAgICAgICB0aGlzLmVhY2goZG9BbmltYXRpb24pIDpcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlKG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24pO1xuICAgICAgICB9LFxuICAgICAgICBzdG9wOiBmdW5jdGlvbiAodHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCkge1xuICAgICAgICAgICAgdmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uIChob29rcykge1xuICAgICAgICAgICAgICAgIHZhciBzdG9wID0gaG9va3Muc3RvcDtcbiAgICAgICAgICAgICAgICBkZWxldGUgaG9va3Muc3RvcDtcbiAgICAgICAgICAgICAgICBzdG9wKGdvdG9FbmQpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgZ290b0VuZCA9IGNsZWFyUXVldWU7XG4gICAgICAgICAgICAgICAgY2xlYXJRdWV1ZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZSh0eXBlIHx8IFwiZnhcIiwgW10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVxdWV1ZSA9IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcbiAgICAgICAgICAgICAgICAgICAgdGltZXJzID0galF1ZXJ5LnRpbWVycyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFQcml2LmdldCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpbmRleF0gJiYgZGF0YVtpbmRleF0uc3RvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcFF1ZXVlKGRhdGFbaW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW5kZXggaW4gZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaW5kZXhdICYmIGRhdGFbaW5kZXhdLnN0b3AgJiYgcnJ1bi50ZXN0KGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BRdWV1ZShkYXRhW2luZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyc1tpbmRleF0uZWxlbSA9PT0gdGhpcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbaW5kZXhdLnF1ZXVlID09PSB0eXBlKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lcnNbaW5kZXhdLmFuaW0uc3RvcChnb3RvRW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcXVldWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cbiAgICAgICAgICAgICAgICAvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxuICAgICAgICAgICAgICAgIGlmIChkZXF1ZXVlIHx8ICFnb3RvRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKHRoaXMsIHR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBmaW5pc2g6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhUHJpdi5nZXQodGhpcyksXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlID0gZGF0YVt0eXBlICsgXCJxdWV1ZVwiXSxcbiAgICAgICAgICAgICAgICAgICAgaG9va3MgPSBkYXRhW3R5cGUgKyBcInF1ZXVlSG9va3NcIl0sXG4gICAgICAgICAgICAgICAgICAgIHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuICAgICAgICAgICAgICAgIC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcbiAgICAgICAgICAgICAgICBkYXRhLmZpbmlzaCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3RcbiAgICAgICAgICAgICAgICBqUXVlcnkucXVldWUodGhpcywgdHlwZSwgW10pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGhvb2tzICYmIGhvb2tzLnN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgaG9va3Muc3RvcC5jYWxsKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG4gICAgICAgICAgICAgICAgZm9yIChpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lcnNbaW5kZXhdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzW2luZGV4XS5xdWV1ZSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXJzW2luZGV4XS5hbmltLnN0b3AodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG4gICAgICAgICAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWV1ZVtpbmRleF0gJiYgcXVldWVbaW5kZXhdLmZpbmlzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVbaW5kZXhdLmZpbmlzaC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcbiAgICAgICAgICAgICAgICBkZWxldGUgZGF0YS5maW5pc2g7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmVhY2goW1widG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIl0sIGZ1bmN0aW9uIChpLCBuYW1lKSB7XG4gICAgICAgIHZhciBjc3NGbiA9IGpRdWVyeS5mbltuYW1lXTtcbiAgICAgICAgalF1ZXJ5LmZuW25hbWVdID0gZnVuY3Rpb24gKHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cbiAgICAgICAgICAgICAgICBjc3NGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDpcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGUoZ2VuRngobmFtZSwgdHJ1ZSksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbiAgICBqUXVlcnkuZWFjaCh7XG4gICAgICAgIHNsaWRlRG93bjogZ2VuRngoXCJzaG93XCIpLFxuICAgICAgICBzbGlkZVVwOiBnZW5GeChcImhpZGVcIiksXG4gICAgICAgIHNsaWRlVG9nZ2xlOiBnZW5GeChcInRvZ2dsZVwiKSxcbiAgICAgICAgZmFkZUluOiB7b3BhY2l0eTogXCJzaG93XCJ9LFxuICAgICAgICBmYWRlT3V0OiB7b3BhY2l0eTogXCJoaWRlXCJ9LFxuICAgICAgICBmYWRlVG9nZ2xlOiB7b3BhY2l0eTogXCJ0b2dnbGVcIn1cbiAgICB9LCBmdW5jdGlvbiAobmFtZSwgcHJvcHMpIHtcbiAgICAgICAgalF1ZXJ5LmZuW25hbWVdID0gZnVuY3Rpb24gKHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlKHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBqUXVlcnkudGltZXJzID0gW107XG4gICAgalF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aW1lcixcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgdGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuICAgICAgICBmeE5vdyA9IERhdGUubm93KCk7XG5cbiAgICAgICAgZm9yICg7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRpbWVyID0gdGltZXJzW2ldO1xuXG4gICAgICAgICAgICAvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXG4gICAgICAgICAgICBpZiAoIXRpbWVyKCkgJiYgdGltZXJzW2ldID09PSB0aW1lcikge1xuICAgICAgICAgICAgICAgIHRpbWVycy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGltZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgalF1ZXJ5LmZ4LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBmeE5vdyA9IHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgalF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24gKHRpbWVyKSB7XG4gICAgICAgIGpRdWVyeS50aW1lcnMucHVzaCh0aW1lcik7XG4gICAgICAgIGpRdWVyeS5meC5zdGFydCgpO1xuICAgIH07XG5cbiAgICBqUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbiAgICBqUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpblByb2dyZXNzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgc2NoZWR1bGUoKTtcbiAgICB9O1xuXG4gICAgalF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluUHJvZ3Jlc3MgPSBudWxsO1xuICAgIH07XG5cbiAgICBqUXVlcnkuZnguc3BlZWRzID0ge1xuICAgICAgICBzbG93OiA2MDAsXG4gICAgICAgIGZhc3Q6IDIwMCxcblxuICAgICAgICAvLyBEZWZhdWx0IHNwZWVkXG4gICAgICAgIF9kZWZhdWx0OiA0MDBcbiAgICB9O1xuXG5cbiAgICAvLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4gICAgLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbiAgICBqUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiAodGltZSwgdHlwZSkge1xuICAgICAgICB0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1t0aW1lXSB8fCB0aW1lIDogdGltZTtcbiAgICAgICAgdHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlKHR5cGUsIGZ1bmN0aW9uIChuZXh0LCBob29rcykge1xuICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChuZXh0LCB0aW1lKTtcbiAgICAgICAgICAgIGhvb2tzLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG5cblxuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSxcbiAgICAgICAgICAgIHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIiksXG4gICAgICAgICAgICBvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKSk7XG5cbiAgICAgICAgaW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcbiAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG4gICAgICAgIHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuICAgICAgICAvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuICAgICAgICBzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuICAgICAgICAvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuICAgICAgICBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgaW5wdXQudmFsdWUgPSBcInRcIjtcbiAgICAgICAgaW5wdXQudHlwZSA9IFwicmFkaW9cIjtcbiAgICAgICAgc3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xuICAgIH0pKCk7XG5cblxuICAgIHZhciBib29sSG9vayxcbiAgICAgICAgYXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgICAgYXR0cjogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjZXNzKHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZUF0dHI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkucmVtb3ZlQXR0cih0aGlzLCBuYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBqUXVlcnkuZXh0ZW5kKHtcbiAgICAgICAgYXR0cjogZnVuY3Rpb24gKGVsZW0sIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcmV0LCBob29rcyxcbiAgICAgICAgICAgICAgICBuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cbiAgICAgICAgICAgIC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcbiAgICAgICAgICAgIGlmIChuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LnByb3AoZWxlbSwgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG4gICAgICAgICAgICAvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG4gICAgICAgICAgICBpZiAoblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyhlbGVtKSkge1xuICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1tuYW1lLnRvTG93ZXJDYXNlKCldIHx8XG4gICAgICAgICAgICAgICAgICAgIChqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QobmFtZSkgPyBib29sSG9vayA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVBdHRyKGVsZW0sIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcbiAgICAgICAgICAgICAgICAgICAgKHJldCA9IGhvb2tzLnNldChlbGVtLCB2YWx1ZSwgbmFtZSkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSArIFwiXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldChlbGVtLCBuYW1lKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXQgPSBqUXVlcnkuZmluZC5hdHRyKGVsZW0sIG5hbWUpO1xuXG4gICAgICAgICAgICAvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuICAgICAgICAgICAgcmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGF0dHJIb29rczoge1xuICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGVsZW0sIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVOYW1lKGVsZW0sIFwiaW5wdXRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZUF0dHI6IGZ1bmN0aW9uIChlbGVtLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIG5hbWUsXG4gICAgICAgICAgICAgICAgaSA9IDAsXG5cbiAgICAgICAgICAgICAgICAvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG4gICAgICAgICAgICAgICAgYXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2gocm5vdGh0bWx3aGl0ZSk7XG5cbiAgICAgICAgICAgIGlmIChhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgobmFtZSA9IGF0dHJOYW1lc1tpKytdKSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbiAgICBib29sSG9vayA9IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZWxlbSwgdmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2VcbiAgICAgICAgICAgICAgICBqUXVlcnkucmVtb3ZlQXR0cihlbGVtLCBuYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUobmFtZSwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBqUXVlcnkuZWFjaChqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCgvXFx3Ky9nKSwgZnVuY3Rpb24gKGksIG5hbWUpIHtcbiAgICAgICAgdmFyIGdldHRlciA9IGF0dHJIYW5kbGVbbmFtZV0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuICAgICAgICBhdHRySGFuZGxlW25hbWVdID0gZnVuY3Rpb24gKGVsZW0sIG5hbWUsIGlzWE1MKSB7XG4gICAgICAgICAgICB2YXIgcmV0LCBoYW5kbGUsXG4gICAgICAgICAgICAgICAgbG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKCFpc1hNTCkge1xuXG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuICAgICAgICAgICAgICAgIGhhbmRsZSA9IGF0dHJIYW5kbGVbbG93ZXJjYXNlTmFtZV07XG4gICAgICAgICAgICAgICAgYXR0ckhhbmRsZVtsb3dlcmNhc2VOYW1lXSA9IHJldDtcbiAgICAgICAgICAgICAgICByZXQgPSBnZXR0ZXIoZWxlbSwgbmFtZSwgaXNYTUwpICE9IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICBsb3dlcmNhc2VOYW1lIDpcbiAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgICAgICBhdHRySGFuZGxlW2xvd2VyY2FzZU5hbWVdID0gaGFuZGxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuXG4gICAgdmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuICAgICAgICByY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICAgIHByb3A6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFjY2Vzcyh0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVQcm9wOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbalF1ZXJ5LnByb3BGaXhbbmFtZV0gfHwgbmFtZV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmV4dGVuZCh7XG4gICAgICAgIHByb3A6IGZ1bmN0aW9uIChlbGVtLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHJldCwgaG9va3MsXG4gICAgICAgICAgICAgICAgblR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG4gICAgICAgICAgICAvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG4gICAgICAgICAgICBpZiAoblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKGVsZW0pKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG4gICAgICAgICAgICAgICAgbmFtZSA9IGpRdWVyeS5wcm9wRml4W25hbWVdIHx8IG5hbWU7XG4gICAgICAgICAgICAgICAgaG9va3MgPSBqUXVlcnkucHJvcEhvb2tzW25hbWVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG4gICAgICAgICAgICAgICAgICAgIChyZXQgPSBob29rcy5zZXQoZWxlbSwgdmFsdWUsIG5hbWUpKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIChlbGVtW25hbWVdID0gdmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KGVsZW0sIG5hbWUpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbGVtW25hbWVdO1xuICAgICAgICB9LFxuXG4gICAgICAgIHByb3BIb29rczoge1xuICAgICAgICAgICAgdGFiSW5kZXg6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIChlbGVtKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuICAgICAgICAgICAgICAgICAgICAvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE0MTExNjIzMzM0Ny9odHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKGVsZW0sIFwidGFiaW5kZXhcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhYmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodGFiaW5kZXgsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHJmb2N1c2FibGUudGVzdChlbGVtLm5vZGVOYW1lKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcmNsaWNrYWJsZS50ZXN0KGVsZW0ubm9kZU5hbWUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmhyZWZcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJvcEZpeDoge1xuICAgICAgICAgICAgXCJmb3JcIjogXCJodG1sRm9yXCIsXG4gICAgICAgICAgICBcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4gICAgLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4gICAgLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuICAgIC8vIG9uIHRoZSBvcHRpb25cbiAgICAvLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuICAgIC8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbiAgICAvLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbiAgICAvLyBzaW5jZSBpdCBjb25zaWRlcnMgc3VjaCBhY2Nlc3Npb25zIG5vb3BcbiAgICBpZiAoIXN1cHBvcnQub3B0U2VsZWN0ZWQpIHtcbiAgICAgICAgalF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKGVsZW0pIHtcblxuICAgICAgICAgICAgICAgIC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChlbGVtKSB7XG5cbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGpRdWVyeS5lYWNoKFtcbiAgICAgICAgXCJ0YWJJbmRleFwiLFxuICAgICAgICBcInJlYWRPbmx5XCIsXG4gICAgICAgIFwibWF4TGVuZ3RoXCIsXG4gICAgICAgIFwiY2VsbFNwYWNpbmdcIixcbiAgICAgICAgXCJjZWxsUGFkZGluZ1wiLFxuICAgICAgICBcInJvd1NwYW5cIixcbiAgICAgICAgXCJjb2xTcGFuXCIsXG4gICAgICAgIFwidXNlTWFwXCIsXG4gICAgICAgIFwiZnJhbWVCb3JkZXJcIixcbiAgICAgICAgXCJjb250ZW50RWRpdGFibGVcIlxuICAgIF0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgalF1ZXJ5LnByb3BGaXhbdGhpcy50b0xvd2VyQ2FzZSgpXSA9IHRoaXM7XG4gICAgfSk7XG5cblxuICAgIC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlIGFjY29yZGluZyB0byBIVE1MIHNwZWNcbiAgICAvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2VcbiAgICBmdW5jdGlvbiBzdHJpcEFuZENvbGxhcHNlKHZhbHVlKSB7XG4gICAgICAgIHZhciB0b2tlbnMgPSB2YWx1ZS5tYXRjaChybm90aHRtbHdoaXRlKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIHRva2Vucy5qb2luKFwiIFwiKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGdldENsYXNzKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGFzc2VzVG9BcnJheSh2YWx1ZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWF0Y2gocm5vdGh0bWx3aGl0ZSkgfHwgW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgICAgICBhZGRDbGFzczogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG4gICAgICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGopIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLmFkZENsYXNzKHZhbHVlLmNhbGwodGhpcywgaiwgZ2V0Q2xhc3ModGhpcykpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KHZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKGNsYXNzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChlbGVtID0gdGhpc1tpKytdKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJWYWx1ZSA9IGdldENsYXNzKGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmIChcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoY3VyVmFsdWUpICsgXCIgXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjbGF6eiA9IGNsYXNzZXNbaisrXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyLmluZGV4T2YoXCIgXCIgKyBjbGF6eiArIFwiIFwiKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyICs9IGNsYXp6ICsgXCIgXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoY3VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZmluYWxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcbiAgICAgICAgICAgICAgICBpID0gMDtcblxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaikge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkodGhpcykucmVtb3ZlQ2xhc3ModmFsdWUuY2FsbCh0aGlzLCBqLCBnZXRDbGFzcyh0aGlzKSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyKFwiY2xhc3NcIiwgXCJcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSh2YWx1ZSk7XG5cbiAgICAgICAgICAgIGlmIChjbGFzc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgoZWxlbSA9IHRoaXNbaSsrXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyVmFsdWUgPSBnZXRDbGFzcyhlbGVtKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuICAgICAgICAgICAgICAgICAgICBjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmIChcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoY3VyVmFsdWUpICsgXCIgXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjbGF6eiA9IGNsYXNzZXNbaisrXSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY3VyLmluZGV4T2YoXCIgXCIgKyBjbGF6eiArIFwiIFwiKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKGN1cik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGZpbmFsVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICB0b2dnbGVDbGFzczogZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZVZhbCkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUsXG4gICAgICAgICAgICAgICAgaXNWYWxpZFZhbHVlID0gdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KHZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgaXNWYWxpZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyh2YWx1ZSkgOiB0aGlzLnJlbW92ZUNsYXNzKHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkodGhpcykudG9nZ2xlQ2xhc3MoXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5jYWxsKHRoaXMsIGksIGdldENsYXNzKHRoaXMpLCBzdGF0ZVZhbCksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZVZhbFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRWYWx1ZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBzZWxmID0galF1ZXJ5KHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzID0gY2xhc3Nlc1RvQXJyYXkodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY2xhc3NOYW1lID0gY2xhc3NOYW1lc1tpKytdKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmhhc0NsYXNzKGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZUNsYXNzKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYWRkQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQcml2LnNldCh0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG4gICAgICAgICAgICAgICAgICAgIC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0QXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJpdi5nZXQodGhpcywgXCJfX2NsYXNzTmFtZV9fXCIpIHx8IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYXNDbGFzczogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lLCBlbGVtLFxuICAgICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG4gICAgICAgICAgICB3aGlsZSAoKGVsZW0gPSB0aGlzW2krK10pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgKFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZShnZXRDbGFzcyhlbGVtKSkgKyBcIiBcIikuaW5kZXhPZihjbGFzc05hbWUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgdmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgICAgdmFsOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBob29rcywgcmV0LCB2YWx1ZUlzRnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgZWxlbSA9IHRoaXNbMF07XG5cbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzW2VsZW0udHlwZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS52YWxIb29rc1tlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChob29rcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgXCJnZXRcIiBpbiBob29rcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHJldCA9IGhvb2tzLmdldChlbGVtLCBcInZhbHVlXCIpKSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGVsZW0udmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldC5yZXBsYWNlKHJyZXR1cm4sIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKHZhbHVlKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWw7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlSXNGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWx1ZS5jYWxsKHRoaXMsIGksIGpRdWVyeSh0aGlzKS52YWwoKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuICAgICAgICAgICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCArPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0galF1ZXJ5Lm1hcCh2YWwsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBob29rcyA9IGpRdWVyeS52YWxIb29rc1t0aGlzLnR5cGVdIHx8IGpRdWVyeS52YWxIb29rc1t0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcbiAgICAgICAgICAgICAgICBpZiAoIWhvb2tzIHx8ICEoXCJzZXRcIiBpbiBob29rcykgfHwgaG9va3Muc2V0KHRoaXMsIHZhbCwgXCJ2YWx1ZVwiKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGpRdWVyeS5leHRlbmQoe1xuICAgICAgICB2YWxIb29rczoge1xuICAgICAgICAgICAgb3B0aW9uOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoZWxlbSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKGVsZW0sIFwidmFsdWVcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwgIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpcEFuZENvbGxhcHNlKGpRdWVyeS50ZXh0KGVsZW0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUsIG9wdGlvbiwgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gbWF4O1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gb25lID8gaW5kZXggOiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24gPSBvcHRpb25zW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCkgJiZcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhb3B0aW9uLmRpc2FibGVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhbm9kZU5hbWUob3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIikpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBqUXVlcnkob3B0aW9uKS52YWwoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChlbGVtLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSh2YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gb3B0aW9ucy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uID0gb3B0aW9uc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmluQXJyYXkoalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQob3B0aW9uKSwgdmFsdWVzKSA+IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25TZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvblNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG4gICAgalF1ZXJ5LmVhY2goW1wicmFkaW9cIiwgXCJjaGVja2JveFwiXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBqUXVlcnkudmFsSG9va3NbdGhpc10gPSB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChlbGVtLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KGpRdWVyeShlbGVtKS52YWwoKSwgdmFsdWUpID4gLTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFzdXBwb3J0LmNoZWNrT24pIHtcbiAgICAgICAgICAgIGpRdWVyeS52YWxIb29rc1t0aGlzXS5nZXQgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbiAgICBzdXBwb3J0LmZvY3VzaW4gPSBcIm9uZm9jdXNpblwiIGluIHdpbmRvdztcblxuXG4gICAgdmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuICAgICAgICBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9O1xuXG4gICAgalF1ZXJ5LmV4dGVuZChqUXVlcnkuZXZlbnQsIHtcblxuICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbiAoZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycykge1xuXG4gICAgICAgICAgICB2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLCBsYXN0RWxlbWVudCxcbiAgICAgICAgICAgICAgICBldmVudFBhdGggPSBbZWxlbSB8fCBkb2N1bWVudF0sXG4gICAgICAgICAgICAgICAgdHlwZSA9IGhhc093bi5jYWxsKGV2ZW50LCBcInR5cGVcIikgPyBldmVudC50eXBlIDogZXZlbnQsXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKGV2ZW50LCBcIm5hbWVzcGFjZVwiKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdChcIi5cIikgOiBbXTtcblxuICAgICAgICAgICAgY3VyID0gbGFzdEVsZW1lbnQgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuICAgICAgICAgICAgLy8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcbiAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuICAgICAgICAgICAgaWYgKHJmb2N1c01vcnBoLnRlc3QodHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZS5pbmRleE9mKFwiLlwiKSA+IC0xKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlcy5zb3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbnR5cGUgPSB0eXBlLmluZGV4T2YoXCI6XCIpIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG4gICAgICAgICAgICAvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcbiAgICAgICAgICAgIGV2ZW50ID0gZXZlbnRbalF1ZXJ5LmV4cGFuZG9dID9cbiAgICAgICAgICAgICAgICBldmVudCA6XG4gICAgICAgICAgICAgICAgbmV3IGpRdWVyeS5FdmVudCh0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG4gICAgICAgICAgICBldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcbiAgICAgICAgICAgIGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbihcIi5cIik7XG4gICAgICAgICAgICBldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlID9cbiAgICAgICAgICAgICAgICBuZXcgUmVnRXhwKFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKSArIFwiKFxcXFwufCQpXCIpIDpcbiAgICAgICAgICAgICAgICBudWxsO1xuXG4gICAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcbiAgICAgICAgICAgIGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICghZXZlbnQudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID0gZWxlbTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuICAgICAgICAgICAgZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgW2V2ZW50XSA6XG4gICAgICAgICAgICAgICAgalF1ZXJ5Lm1ha2VBcnJheShkYXRhLCBbZXZlbnRdKTtcblxuICAgICAgICAgICAgLy8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuICAgICAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsW3R5cGVdIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseShlbGVtLCBkYXRhKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuICAgICAgICAgICAgLy8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcbiAgICAgICAgICAgIGlmICghb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFpc1dpbmRvdyhlbGVtKSkge1xuXG4gICAgICAgICAgICAgICAgYnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKCFyZm9jdXNNb3JwaC50ZXN0KGJ1YmJsZVR5cGUgKyB0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICg7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRQYXRoLnB1c2goY3VyKTtcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gY3VyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuICAgICAgICAgICAgICAgIGlmICh0bXAgPT09IChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50UGF0aC5wdXNoKHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlICgoY3VyID0gZXZlbnRQYXRoW2krK10pICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgICAgICAgICAgbGFzdEVsZW1lbnQgPSBjdXI7XG4gICAgICAgICAgICAgICAgZXZlbnQudHlwZSA9IGkgPiAxID9cbiAgICAgICAgICAgICAgICAgICAgYnViYmxlVHlwZSA6XG4gICAgICAgICAgICAgICAgICAgIHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuICAgICAgICAgICAgICAgIC8vIGpRdWVyeSBoYW5kbGVyXG4gICAgICAgICAgICAgICAgaGFuZGxlID0gKGRhdGFQcml2LmdldChjdXIsIFwiZXZlbnRzXCIpIHx8IHt9KVtldmVudC50eXBlXSAmJlxuICAgICAgICAgICAgICAgICAgICBkYXRhUHJpdi5nZXQoY3VyLCBcImhhbmRsZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZS5hcHBseShjdXIsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE5hdGl2ZSBoYW5kbGVyXG4gICAgICAgICAgICAgICAgaGFuZGxlID0gb250eXBlICYmIGN1cltvbnR5cGVdO1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGFjY2VwdERhdGEoY3VyKSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoY3VyLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudC50eXBlID0gdHlwZTtcblxuICAgICAgICAgICAgLy8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuICAgICAgICAgICAgaWYgKCFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoKCFzcGVjaWFsLl9kZWZhdWx0IHx8XG4gICAgICAgICAgICAgICAgICAgIHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoZXZlbnRQYXRoLnBvcCgpLCBkYXRhKSA9PT0gZmFsc2UpICYmXG4gICAgICAgICAgICAgICAgICAgIGFjY2VwdERhdGEoZWxlbSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbnR5cGUgJiYgaXNGdW5jdGlvbihlbGVtW3R5cGVdKSAmJiAhaXNXaW5kb3coZWxlbSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gZWxlbVtvbnR5cGVdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG1wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVtvbnR5cGVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtW3R5cGVdKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0bXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtW29udHlwZV0gPSB0bXA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBldmVudC5yZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG4gICAgICAgIC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXG4gICAgICAgIHNpbXVsYXRlOiBmdW5jdGlvbiAodHlwZSwgZWxlbSwgZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0galF1ZXJ5LmV4dGVuZChcbiAgICAgICAgICAgICAgICBuZXcgalF1ZXJ5LkV2ZW50KCksXG4gICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICBpc1NpbXVsYXRlZDogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKGUsIG51bGwsIGVsZW0pO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uICh0eXBlLCBkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcih0eXBlLCBkYXRhLCB0aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24gKHR5cGUsIGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBlbGVtID0gdGhpc1swXTtcbiAgICAgICAgICAgIGlmIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKHR5cGUsIGRhdGEsIGVsZW0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cblxuICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuICAgIC8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbiAgICAvLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xuICAgIC8vXG4gICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG4gICAgLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG4gICAgLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4gICAgLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbiAgICBpZiAoIXN1cHBvcnQuZm9jdXNpbikge1xuICAgICAgICBqUXVlcnkuZWFjaCh7Zm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCJ9LCBmdW5jdGlvbiAob3JpZywgZml4KSB7XG5cbiAgICAgICAgICAgIC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5zaW11bGF0ZShmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeChldmVudCkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnNwZWNpYWxbZml4XSA9IHtcbiAgICAgICAgICAgICAgICBzZXR1cDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2Vzcyhkb2MsIGZpeCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhdHRhY2hlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIob3JpZywgaGFuZGxlciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0YVByaXYuYWNjZXNzKGRvYywgZml4LCAoYXR0YWNoZXMgfHwgMCkgKyAxKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRlYXJkb3duOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKGRvYywgZml4KSAtIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhdHRhY2hlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIob3JpZywgaGFuZGxlciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJpdi5yZW1vdmUoZG9jLCBmaXgpO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJpdi5hY2Nlc3MoZG9jLCBmaXgsIGF0dGFjaGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cbiAgICB2YXIgbm9uY2UgPSBEYXRlLm5vdygpO1xuXG4gICAgdmFyIHJxdWVyeSA9ICgvXFw/Lyk7XG5cblxuICAgIC8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbiAgICBqUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgeG1sO1xuICAgICAgICBpZiAoIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcbiAgICAgICAgLy8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB4bWwgPSAobmV3IHdpbmRvdy5ET01QYXJzZXIoKSkucGFyc2VGcm9tU3RyaW5nKGRhdGEsIFwidGV4dC94bWxcIik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHhtbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInBhcnNlcmVycm9yXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgalF1ZXJ5LmVycm9yKFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHhtbDtcbiAgICB9O1xuXG5cbiAgICB2YXJcbiAgICAgICAgcmJyYWNrZXQgPSAvXFxbXFxdJC8sXG4gICAgICAgIHJDUkxGID0gL1xccj9cXG4vZyxcbiAgICAgICAgcnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuICAgICAgICByc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbiAgICBmdW5jdGlvbiBidWlsZFBhcmFtcyhwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCkge1xuICAgICAgICB2YXIgbmFtZTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG5cbiAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuICAgICAgICAgICAgalF1ZXJ5LmVhY2gob2JqLCBmdW5jdGlvbiAoaSwgdikge1xuICAgICAgICAgICAgICAgIGlmICh0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KHByZWZpeCkpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG4gICAgICAgICAgICAgICAgICAgIGFkZChwcmVmaXgsIHYpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cbiAgICAgICAgICAgICAgICAgICAgYnVpbGRQYXJhbXMoXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXggKyBcIltcIiArICh0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIikgKyBcIl1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHYsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFkaXRpb25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoIXRyYWRpdGlvbmFsICYmIHRvVHlwZShvYmopID09PSBcIm9iamVjdFwiKSB7XG5cbiAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cbiAgICAgICAgICAgIGZvciAobmFtZSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBidWlsZFBhcmFtcyhwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqW25hbWVdLCB0cmFkaXRpb25hbCwgYWRkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG4gICAgICAgICAgICBhZGQocHJlZml4LCBvYmopO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2ZcbiAgICAvLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbiAgICBqUXVlcnkucGFyYW0gPSBmdW5jdGlvbiAoYSwgdHJhZGl0aW9uYWwpIHtcbiAgICAgICAgdmFyIHByZWZpeCxcbiAgICAgICAgICAgIHMgPSBbXSxcbiAgICAgICAgICAgIGFkZCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlT3JGdW5jdGlvbikge1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGlzRnVuY3Rpb24odmFsdWVPckZ1bmN0aW9uKSA/XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlT3JGdW5jdGlvbigpIDpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVPckZ1bmN0aW9uO1xuXG4gICAgICAgICAgICAgICAgc1tzLmxlbmd0aF0gPSBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArIFwiPVwiICtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICBpZiAoYSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGEpIHx8IChhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoYSkpKSB7XG5cbiAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuICAgICAgICAgICAgalF1ZXJ5LmVhY2goYSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGFkZCh0aGlzLm5hbWUsIHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcbiAgICAgICAgICAgIC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuICAgICAgICAgICAgZm9yIChwcmVmaXggaW4gYSkge1xuICAgICAgICAgICAgICAgIGJ1aWxkUGFyYW1zKHByZWZpeCwgYVtwcmVmaXhdLCB0cmFkaXRpb25hbCwgYWRkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cbiAgICAgICAgcmV0dXJuIHMuam9pbihcIiZcIik7XG4gICAgfTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgICAgICBzZXJpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkucGFyYW0odGhpcy5zZXJpYWxpemVBcnJheSgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AodGhpcywgXCJlbGVtZW50c1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KGVsZW1lbnRzKSA6IHRoaXM7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3NcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KHRoaXMpLmlzKFwiOmRpc2FibGVkXCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICByc3VibWl0dGFibGUudGVzdCh0aGlzLm5vZGVOYW1lKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QodHlwZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QodHlwZSkpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaSwgZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0galF1ZXJ5KHRoaXMpLnZhbCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5Lm1hcCh2YWwsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge25hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKHJDUkxGLCBcIlxcclxcblwiKX07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7bmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UockNSTEYsIFwiXFxyXFxuXCIpfTtcbiAgICAgICAgICAgICAgICB9KS5nZXQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICB2YXJcbiAgICAgICAgcjIwID0gLyUyMC9nLFxuICAgICAgICByaGFzaCA9IC8jLiokLyxcbiAgICAgICAgcmFudGlDYWNoZSA9IC8oWz8mXSlfPVteJl0qLyxcbiAgICAgICAgcmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXG4gICAgICAgIC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuICAgICAgICBybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuICAgICAgICBybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcbiAgICAgICAgcnByb3RvY29sID0gL15cXC9cXC8vLFxuXG4gICAgICAgIC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cbiAgICAgICAgcHJlZmlsdGVycyA9IHt9LFxuXG4gICAgICAgIC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cbiAgICAgICAgdHJhbnNwb3J0cyA9IHt9LFxuXG4gICAgICAgIC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuICAgICAgICBhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoXCIqXCIpLFxuXG4gICAgICAgIC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuICAgICAgICBvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICBvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbiAgICAvLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG4gICAgZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKHN0cnVjdHVyZSkge1xuXG4gICAgICAgIC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMpIHtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuICAgICAgICAgICAgICAgIGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGF0YVR5cGUsXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2gocm5vdGh0bWx3aGl0ZSkgfHwgW107XG5cbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGZ1bmMpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG4gICAgICAgICAgICAgICAgd2hpbGUgKChkYXRhVHlwZSA9IGRhdGFUeXBlc1tpKytdKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhVHlwZVswXSA9PT0gXCIrXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoMSkgfHwgXCIqXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAoc3RydWN0dXJlW2RhdGFUeXBlXSA9IHN0cnVjdHVyZVtkYXRhVHlwZV0gfHwgW10pLnVuc2hpZnQoZnVuYyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBhcHBlbmRcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzdHJ1Y3R1cmVbZGF0YVR5cGVdID0gc3RydWN0dXJlW2RhdGFUeXBlXSB8fCBbXSkucHVzaChmdW5jKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbiAgICBmdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyhzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIpIHtcblxuICAgICAgICB2YXIgaW5zcGVjdGVkID0ge30sXG4gICAgICAgICAgICBzZWVraW5nVHJhbnNwb3J0ID0gKHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyk7XG5cbiAgICAgICAgZnVuY3Rpb24gaW5zcGVjdChkYXRhVHlwZSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkO1xuICAgICAgICAgICAgaW5zcGVjdGVkW2RhdGFUeXBlXSA9IHRydWU7XG4gICAgICAgICAgICBqUXVlcnkuZWFjaChzdHJ1Y3R1cmVbZGF0YVR5cGVdIHx8IFtdLCBmdW5jdGlvbiAoXywgcHJlZmlsdGVyT3JGYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3Rvcnkob3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgICAgICFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbZGF0YVR5cGVPclRyYW5zcG9ydF0pIHtcblxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KGRhdGFUeXBlT3JUcmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgICAgICBpbnNwZWN0KGRhdGFUeXBlT3JUcmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWVraW5nVHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhKHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5zcGVjdChvcHRpb25zLmRhdGFUeXBlc1swXSkgfHwgIWluc3BlY3RlZFtcIipcIl0gJiYgaW5zcGVjdChcIipcIik7XG4gICAgfVxuXG4gICAgLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4gICAgLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbiAgICAvLyBGaXhlcyAjOTg4N1xuICAgIGZ1bmN0aW9uIGFqYXhFeHRlbmQodGFyZ2V0LCBzcmMpIHtcbiAgICAgICAgdmFyIGtleSwgZGVlcCxcbiAgICAgICAgICAgIGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBmb3IgKGtleSBpbiBzcmMpIHtcbiAgICAgICAgICAgIGlmIChzcmNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgKGZsYXRPcHRpb25zW2tleV0gPyB0YXJnZXQgOiAoZGVlcCB8fCAoZGVlcCA9IHt9KSkpW2tleV0gPSBzcmNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVlcCkge1xuICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCh0cnVlLCB0YXJnZXQsIGRlZXApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICAvKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gICAgKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICAgICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gICAgKi9cbiAgICBmdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKHMsIGpxWEhSLCByZXNwb25zZXMpIHtcblxuICAgICAgICB2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG4gICAgICAgICAgICBjb250ZW50cyA9IHMuY29udGVudHMsXG4gICAgICAgICAgICBkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuICAgICAgICAvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuICAgICAgICB3aGlsZSAoZGF0YVR5cGVzWzBdID09PSBcIipcIikge1xuICAgICAgICAgICAgZGF0YVR5cGVzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuICAgICAgICBpZiAoY3QpIHtcbiAgICAgICAgICAgIGZvciAodHlwZSBpbiBjb250ZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50c1t0eXBlXSAmJiBjb250ZW50c1t0eXBlXS50ZXN0KGN0KSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZXMudW5zaGlmdCh0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG4gICAgICAgIGlmIChkYXRhVHlwZXNbMF0gaW4gcmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG4gICAgICAgICAgICBmb3IgKHR5cGUgaW4gcmVzcG9uc2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhVHlwZXNbMF0gfHwgcy5jb252ZXJ0ZXJzW3R5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1swXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxEYXRhVHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0RGF0YVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3REYXRhVHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcbiAgICAgICAgICAgIGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG4gICAgICAgIC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG4gICAgICAgIC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAgICAgICAgaWYgKGZpbmFsRGF0YVR5cGUpIHtcbiAgICAgICAgICAgIGlmIChmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbMF0pIHtcbiAgICAgICAgICAgICAgICBkYXRhVHlwZXMudW5zaGlmdChmaW5hbERhdGFUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZXNbZmluYWxEYXRhVHlwZV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gICAgKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAgICAqL1xuICAgIGZ1bmN0aW9uIGFqYXhDb252ZXJ0KHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzKSB7XG4gICAgICAgIHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuICAgICAgICAgICAgY29udmVydGVycyA9IHt9LFxuXG4gICAgICAgICAgICAvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG4gICAgICAgICAgICBkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuICAgICAgICBpZiAoZGF0YVR5cGVzWzFdKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnYgaW4gcy5jb252ZXJ0ZXJzKSB7XG4gICAgICAgICAgICAgICAgY29udmVydGVyc1tjb252LnRvTG93ZXJDYXNlKCldID0gcy5jb252ZXJ0ZXJzW2NvbnZdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG4gICAgICAgIC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG5cbiAgICAgICAgICAgIGlmIChzLnJlc3BvbnNlRmllbGRzW2N1cnJlbnRdKSB7XG4gICAgICAgICAgICAgICAganFYSFJbcy5yZXNwb25zZUZpZWxkc1tjdXJyZW50XV0gPSByZXNwb25zZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcbiAgICAgICAgICAgIGlmICghcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIocmVzcG9uc2UsIHMuZGF0YVR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmV2ID0gY3VycmVudDtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcblxuICAgICAgICAgICAgICAgIC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gXCIqXCIpIHtcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gcHJldjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcbiAgICAgICAgICAgICAgICAgICAgY29udiA9IGNvbnZlcnRlcnNbcHJldiArIFwiIFwiICsgY3VycmVudF0gfHwgY29udmVydGVyc1tcIiogXCIgKyBjdXJyZW50XTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29udjIgaW4gY29udmVydGVycykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gY29udjIuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0bXBbMV0gPT09IGN1cnJlbnQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udiA9IGNvbnZlcnRlcnNbcHJldiArIFwiIFwiICsgdG1wWzBdXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydGVyc1tcIiogXCIgKyB0bXBbMF1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udikge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnYgPSBjb252ZXJ0ZXJzW2NvbnYyXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udmVydGVyc1tjb252Ml0gIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gdG1wWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlcy51bnNoaWZ0KHRtcFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udiAhPT0gdHJ1ZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udiAmJiBzLnRocm93cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gY29udihyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gY29udihyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IFwicGFyc2VyZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7c3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZX07XG4gICAgfVxuXG4gICAgalF1ZXJ5LmV4dGVuZCh7XG5cbiAgICAgICAgLy8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG4gICAgICAgIGFjdGl2ZTogMCxcblxuICAgICAgICAvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG4gICAgICAgIGxhc3RNb2RpZmllZDoge30sXG4gICAgICAgIGV0YWc6IHt9LFxuXG4gICAgICAgIGFqYXhTZXR0aW5nczoge1xuICAgICAgICAgICAgdXJsOiBsb2NhdGlvbi5ocmVmLFxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcbiAgICAgICAgICAgIGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QobG9jYXRpb24ucHJvdG9jb2wpLFxuICAgICAgICAgICAgZ2xvYmFsOiB0cnVlLFxuICAgICAgICAgICAgcHJvY2Vzc0RhdGE6IHRydWUsXG4gICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXG4gICAgICAgICAgICAvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG4gICAgICAgICAgICBhY2NlcHRzOiB7XG4gICAgICAgICAgICAgICAgXCIqXCI6IGFsbFR5cGVzLFxuICAgICAgICAgICAgICAgIHRleHQ6IFwidGV4dC9wbGFpblwiLFxuICAgICAgICAgICAgICAgIGh0bWw6IFwidGV4dC9odG1sXCIsXG4gICAgICAgICAgICAgICAgeG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcbiAgICAgICAgICAgICAgICBqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjb250ZW50czoge1xuICAgICAgICAgICAgICAgIHhtbDogL1xcYnhtbFxcYi8sXG4gICAgICAgICAgICAgICAgaHRtbDogL1xcYmh0bWwvLFxuICAgICAgICAgICAgICAgIGpzb246IC9cXGJqc29uXFxiL1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVzcG9uc2VGaWVsZHM6IHtcbiAgICAgICAgICAgICAgICB4bWw6IFwicmVzcG9uc2VYTUxcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuICAgICAgICAgICAgICAgIGpzb246IFwicmVzcG9uc2VKU09OXCJcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIERhdGEgY29udmVydGVyc1xuICAgICAgICAgICAgLy8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICAgICAgICAgICAgY29udmVydGVyczoge1xuXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG4gICAgICAgICAgICAgICAgXCIqIHRleHRcIjogU3RyaW5nLFxuXG4gICAgICAgICAgICAgICAgLy8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG4gICAgICAgICAgICAgICAgXCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuICAgICAgICAgICAgICAgIC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICBcInRleHQganNvblwiOiBKU09OLnBhcnNlLFxuXG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgdGV4dCBhcyB4bWxcbiAgICAgICAgICAgICAgICBcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcbiAgICAgICAgICAgIC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcbiAgICAgICAgICAgIC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG4gICAgICAgICAgICAvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcbiAgICAgICAgICAgIGZsYXRPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdXJsOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuICAgICAgICAvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG4gICAgICAgIC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG4gICAgICAgIGFqYXhTZXR1cDogZnVuY3Rpb24gKHRhcmdldCwgc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncyA/XG5cbiAgICAgICAgICAgICAgICAvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgICAgICAgIGFqYXhFeHRlbmQoYWpheEV4dGVuZCh0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MpLCBzZXR0aW5ncykgOlxuXG4gICAgICAgICAgICAgICAgLy8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuICAgICAgICAgICAgICAgIGFqYXhFeHRlbmQoalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMocHJlZmlsdGVycyksXG4gICAgICAgIGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyh0cmFuc3BvcnRzKSxcblxuICAgICAgICAvLyBNYWluIG1ldGhvZFxuICAgICAgICBhamF4OiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG4gICAgICAgICAgICBpZiAodHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB1cmw7XG4gICAgICAgICAgICAgICAgdXJsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgICAgIHZhciB0cmFuc3BvcnQsXG5cbiAgICAgICAgICAgICAgICAvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG4gICAgICAgICAgICAgICAgY2FjaGVVUkwsXG5cbiAgICAgICAgICAgICAgICAvLyBSZXNwb25zZSBoZWFkZXJzXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVycyxcblxuICAgICAgICAgICAgICAgIC8vIHRpbWVvdXQgaGFuZGxlXG4gICAgICAgICAgICAgICAgdGltZW91dFRpbWVyLFxuXG4gICAgICAgICAgICAgICAgLy8gVXJsIGNsZWFudXAgdmFyXG4gICAgICAgICAgICAgICAgdXJsQW5jaG9yLFxuXG4gICAgICAgICAgICAgICAgLy8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuICAgICAgICAgICAgICAgIGNvbXBsZXRlZCxcblxuICAgICAgICAgICAgICAgIC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuICAgICAgICAgICAgICAgIGZpcmVHbG9iYWxzLFxuXG4gICAgICAgICAgICAgICAgLy8gTG9vcCB2YXJpYWJsZVxuICAgICAgICAgICAgICAgIGksXG5cbiAgICAgICAgICAgICAgICAvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcbiAgICAgICAgICAgICAgICB1bmNhY2hlZCxcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3RcbiAgICAgICAgICAgICAgICBzID0galF1ZXJ5LmFqYXhTZXR1cCh7fSwgb3B0aW9ucyksXG5cbiAgICAgICAgICAgICAgICAvLyBDYWxsYmFja3MgY29udGV4dFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG4gICAgICAgICAgICAgICAgLy8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJlxuICAgICAgICAgICAgICAgIChjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSkgP1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoY2FsbGJhY2tDb250ZXh0KSA6XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudCxcblxuICAgICAgICAgICAgICAgIC8vIERlZmVycmVkc1xuICAgICAgICAgICAgICAgIGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG4gICAgICAgICAgICAgICAgY29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxcblxuICAgICAgICAgICAgICAgIC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblxuICAgICAgICAgICAgICAgIC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG4gICAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnMgPSB7fSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICBzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuICAgICAgICAgICAgICAgIC8vIEZha2UgeGhyXG4gICAgICAgICAgICAgICAganFYSFIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWR5U3RhdGU6IDAsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICBnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2VIZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gcmhlYWRlcnMuZXhlYyhyZXNwb25zZUhlYWRlcnNTdHJpbmcpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzW21hdGNoWzFdLnRvTG93ZXJDYXNlKCkgKyBcIiBcIl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZXNwb25zZUhlYWRlcnNbbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSArIFwiIFwiXSB8fCBbXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChtYXRjaFsyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSByZXNwb25zZUhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCkgKyBcIiBcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaC5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmF3IHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICBnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlcyB0aGUgaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgIHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzTmFtZXNbbmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICBvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5taW1lVHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpxWEhSLmFsd2F5cyhtYXBbanFYSFIuc3RhdHVzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvZGUgaW4gbWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlW2NvZGVdID0gW3N0YXR1c0NvZGVbY29kZV0sIG1hcFtjb2RlXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBDYW5jZWwgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uIChzdGF0dXNUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuYWJvcnQoZmluYWxUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoMCwgZmluYWxUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gQXR0YWNoIGRlZmVycmVkc1xuICAgICAgICAgICAgZGVmZXJyZWQucHJvbWlzZShqcVhIUik7XG5cbiAgICAgICAgICAgIC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuICAgICAgICAgICAgLy8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcbiAgICAgICAgICAgIC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgcy51cmwgPSAoKHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmKSArIFwiXCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UocnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIik7XG5cbiAgICAgICAgICAgIC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuICAgICAgICAgICAgcy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuICAgICAgICAgICAgLy8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuICAgICAgICAgICAgcy5kYXRhVHlwZXMgPSAocy5kYXRhVHlwZSB8fCBcIipcIikudG9Mb3dlckNhc2UoKS5tYXRjaChybm90aHRtbHdoaXRlKSB8fCBbXCJcIl07XG5cbiAgICAgICAgICAgIC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxuICAgICAgICAgICAgaWYgKHMuY3Jvc3NEb21haW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD04IC0gMTEsIEVkZ2UgMTIgLSAxNVxuICAgICAgICAgICAgICAgIC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG4gICAgICAgICAgICAgICAgLy8gZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD04IC0gMTEgb25seVxuICAgICAgICAgICAgICAgICAgICAvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxuICAgICAgICAgICAgICAgICAgICB1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuICAgICAgICAgICAgICAgICAgICBzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmxBbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxBbmNob3IuaG9zdDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcbiAgICAgICAgICAgICAgICAgICAgcy5jcm9zc0RvbWFpbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcbiAgICAgICAgICAgIGlmIChzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcy5kYXRhID0galF1ZXJ5LnBhcmFtKHMuZGF0YSwgcy50cmFkaXRpb25hbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IHByZWZpbHRlcnNcbiAgICAgICAgICAgIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSKTtcblxuICAgICAgICAgICAgLy8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcbiAgICAgICAgICAgIGlmIChjb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ganFYSFI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG4gICAgICAgICAgICAvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxuICAgICAgICAgICAgZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cbiAgICAgICAgICAgIC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcbiAgICAgICAgICAgIGlmIChmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDApIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcihcImFqYXhTdGFydFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBwZXJjYXNlIHRoZSB0eXBlXG4gICAgICAgICAgICBzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcbiAgICAgICAgICAgIHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3Qocy50eXBlKTtcblxuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG4gICAgICAgICAgICAvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cbiAgICAgICAgICAgIC8vIFJlbW92ZSBoYXNoIHRvIHNpbXBsaWZ5IHVybCBtYW5pcHVsYXRpb25cbiAgICAgICAgICAgIGNhY2hlVVJMID0gcy51cmwucmVwbGFjZShyaGFzaCwgXCJcIik7XG5cbiAgICAgICAgICAgIC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG4gICAgICAgICAgICBpZiAoIXMuaGFzQ29udGVudCkge1xuXG4gICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhlIGhhc2ggc28gd2UgY2FuIHB1dCBpdCBiYWNrXG4gICAgICAgICAgICAgICAgdW5jYWNoZWQgPSBzLnVybC5zbGljZShjYWNoZVVSTC5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgZGF0YSBpcyBhdmFpbGFibGUgYW5kIHNob3VsZCBiZSBwcm9jZXNzZWQsIGFwcGVuZCBkYXRhIHRvIHVybFxuICAgICAgICAgICAgICAgIGlmIChzLmRhdGEgJiYgKHMucHJvY2Vzc0RhdGEgfHwgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVVUkwgKz0gKHJxdWVyeS50ZXN0KGNhY2hlVVJMKSA/IFwiJlwiIDogXCI/XCIpICsgcy5kYXRhO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHMuZGF0YTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgb3IgdXBkYXRlIGFudGktY2FjaGUgcGFyYW0gaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgaWYgKHMuY2FjaGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZShyYW50aUNhY2hlLCBcIiQxXCIpO1xuICAgICAgICAgICAgICAgICAgICB1bmNhY2hlZCA9IChycXVlcnkudGVzdChjYWNoZVVSTCkgPyBcIiZcIiA6IFwiP1wiKSArIFwiXz1cIiArIChub25jZSsrKSArIHVuY2FjaGVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcbiAgICAgICAgICAgICAgICBzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcbiAgICAgICAgICAgICAgICAocy5jb250ZW50VHlwZSB8fCBcIlwiKS5pbmRleE9mKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcy5kYXRhID0gcy5kYXRhLnJlcGxhY2UocjIwLCBcIitcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG4gICAgICAgICAgICBpZiAocy5pZk1vZGlmaWVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5sYXN0TW9kaWZpZWRbY2FjaGVVUkxdKSB7XG4gICAgICAgICAgICAgICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkW2NhY2hlVVJMXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuZXRhZ1tjYWNoZVVSTF0pIHtcbiAgICAgICAgICAgICAgICAgICAganFYSFIuc2V0UmVxdWVzdEhlYWRlcihcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbY2FjaGVVUkxdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuICAgICAgICAgICAgaWYgKHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcbiAgICAgICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG4gICAgICAgICAgICAgICAgXCJBY2NlcHRcIixcbiAgICAgICAgICAgICAgICBzLmRhdGFUeXBlc1swXSAmJiBzLmFjY2VwdHNbcy5kYXRhVHlwZXNbMF1dID9cbiAgICAgICAgICAgICAgICAgICAgcy5hY2NlcHRzW3MuZGF0YVR5cGVzWzBdXSArXG4gICAgICAgICAgICAgICAgICAgIChzLmRhdGFUeXBlc1swXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIpIDpcbiAgICAgICAgICAgICAgICAgICAgcy5hY2NlcHRzW1wiKlwiXVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG4gICAgICAgICAgICBmb3IgKGkgaW4gcy5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAganFYSFIuc2V0UmVxdWVzdEhlYWRlcihpLCBzLmhlYWRlcnNbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG4gICAgICAgICAgICBpZiAocy5iZWZvcmVTZW5kICYmXG4gICAgICAgICAgICAgICAgKHMuYmVmb3JlU2VuZC5jYWxsKGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMpID09PSBmYWxzZSB8fCBjb21wbGV0ZWQpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cbiAgICAgICAgICAgICAgICByZXR1cm4ganFYSFIuYWJvcnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG4gICAgICAgICAgICBzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuICAgICAgICAgICAgLy8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG4gICAgICAgICAgICBjb21wbGV0ZURlZmVycmVkLmFkZChzLmNvbXBsZXRlKTtcbiAgICAgICAgICAgIGpxWEhSLmRvbmUocy5zdWNjZXNzKTtcbiAgICAgICAgICAgIGpxWEhSLmZhaWwocy5lcnJvcik7XG5cbiAgICAgICAgICAgIC8vIEdldCB0cmFuc3BvcnRcbiAgICAgICAgICAgIHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSKTtcblxuICAgICAgICAgICAgLy8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG4gICAgICAgICAgICBpZiAoIXRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgIGRvbmUoLTEsIFwiTm8gVHJhbnNwb3J0XCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuICAgICAgICAgICAgICAgIC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG4gICAgICAgICAgICAgICAgaWYgKGZpcmVHbG9iYWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKFwiYWpheFNlbmRcIiwgW2pxWEhSLCBzXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBqcVhIUjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUaW1lb3V0XG4gICAgICAgICAgICAgICAgaWYgKHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqcVhIUi5hYm9ydChcInRpbWVvdXRcIik7XG4gICAgICAgICAgICAgICAgICAgIH0sIHMudGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKHJlcXVlc3RIZWFkZXJzLCBkb25lKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXG4gICAgICAgICAgICAgICAgICAgIGRvbmUoLTEsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG4gICAgICAgICAgICBmdW5jdGlvbiBkb25lKHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29tcGxldGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXRUaW1lcikge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRUaW1lcik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICAvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcbiAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgcmVhZHlTdGF0ZVxuICAgICAgICAgICAgICAgIGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuICAgICAgICAgICAgICAgIGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHJlc3BvbnNlIGRhdGFcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyhzLCBqcVhIUiwgcmVzcG9uc2VzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhamF4Q29udmVydChzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2Vzcyk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuICAgICAgICAgICAgICAgIGlmIChpc1N1Y2Nlc3MpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuICAgICAgICAgICAgICAgICAgICBpZiAocy5pZk1vZGlmaWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiTGFzdC1Nb2RpZmllZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5sYXN0TW9kaWZpZWRbY2FjaGVVUkxdID0gbW9kaWZpZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiZXRhZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldGFnW2NhY2hlVVJMXSA9IG1vZGlmaWVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm8gY29udGVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vdCBtb2RpZmllZFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gMzA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3VjY2VzcyA9ICFlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHN0YXR1c1RleHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgfHwgIXN0YXR1c1RleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuICAgICAgICAgICAgICAgIGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgICAgICBqcVhIUi5zdGF0dXNUZXh0ID0gKG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCkgKyBcIlwiO1xuXG4gICAgICAgICAgICAgICAgLy8gU3VjY2Vzcy9FcnJvclxuICAgICAgICAgICAgICAgIGlmIChpc1N1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZVdpdGgoY2FsbGJhY2tDb250ZXh0LCBbc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFJdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3RXaXRoKGNhbGxiYWNrQ29udGV4dCwgW2pxWEhSLCBzdGF0dXNUZXh0LCBlcnJvcl0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG4gICAgICAgICAgICAgICAganFYSFIuc3RhdHVzQ29kZShzdGF0dXNDb2RlKTtcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZpcmVHbG9iYWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBbanFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvcl0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENvbXBsZXRlXG4gICAgICAgICAgICAgICAgY29tcGxldGVEZWZlcnJlZC5maXJlV2l0aChjYWxsYmFja0NvbnRleHQsIFtqcVhIUiwgc3RhdHVzVGV4dF0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZpcmVHbG9iYWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKFwiYWpheENvbXBsZXRlXCIsIFtqcVhIUiwgc10pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuICAgICAgICAgICAgICAgICAgICBpZiAoISgtLWpRdWVyeS5hY3RpdmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcihcImFqYXhTdG9wXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ganFYSFI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0SlNPTjogZnVuY3Rpb24gKHVybCwgZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZ2V0KHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRTY3JpcHQ6IGZ1bmN0aW9uICh1cmwsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmdldCh1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBqUXVlcnkuZWFjaChbXCJnZXRcIiwgXCJwb3N0XCJdLCBmdW5jdGlvbiAoaSwgbWV0aG9kKSB7XG4gICAgICAgIGpRdWVyeVttZXRob2RdID0gZnVuY3Rpb24gKHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUpIHtcblxuICAgICAgICAgICAgLy8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5hamF4KGpRdWVyeS5leHRlbmQoe1xuICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgIHR5cGU6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGNhbGxiYWNrXG4gICAgICAgICAgICB9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCh1cmwpICYmIHVybCkpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG5cbiAgICBqUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBqUXVlcnkuYWpheCh7XG4gICAgICAgICAgICB1cmw6IHVybCxcblxuICAgICAgICAgICAgLy8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICAgICAgZGF0YVR5cGU6IFwic2NyaXB0XCIsXG4gICAgICAgICAgICBjYWNoZTogdHJ1ZSxcbiAgICAgICAgICAgIGFzeW5jOiBmYWxzZSxcbiAgICAgICAgICAgIGdsb2JhbDogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIE9ubHkgZXZhbHVhdGUgdGhlIHJlc3BvbnNlIGlmIGl0IGlzIHN1Y2Nlc3NmdWwgKGdoLTQxMjYpXG4gICAgICAgICAgICAvLyBkYXRhRmlsdGVyIGlzIG5vdCBpbnZva2VkIGZvciBmYWlsdXJlIHJlc3BvbnNlcywgc28gdXNpbmcgaXQgaW5zdGVhZFxuICAgICAgICAgICAgLy8gb2YgdGhlIGRlZmF1bHQgY29udmVydGVyIGlzIGtsdWRneSBidXQgaXQgd29ya3MuXG4gICAgICAgICAgICBjb252ZXJ0ZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGFGaWx0ZXI6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5nbG9iYWxFdmFsKHJlc3BvbnNlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICAgIHdyYXBBbGw6IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICAgICAgICB2YXIgd3JhcDtcblxuICAgICAgICAgICAgaWYgKHRoaXNbMF0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihodG1sKSkge1xuICAgICAgICAgICAgICAgICAgICBodG1sID0gaHRtbC5jYWxsKHRoaXNbMF0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG4gICAgICAgICAgICAgICAgd3JhcCA9IGpRdWVyeShodG1sLCB0aGlzWzBdLm93bmVyRG9jdW1lbnQpLmVxKDApLmNsb25lKHRydWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbMF0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB3cmFwLmluc2VydEJlZm9yZSh0aGlzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3cmFwLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtID0gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZWxlbS5maXJzdEVsZW1lbnRDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgICAgICAgICB9KS5hcHBlbmQodGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdyYXBJbm5lcjogZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGh0bWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkodGhpcykud3JhcElubmVyKGh0bWwuY2FsbCh0aGlzLCBpKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0galF1ZXJ5KHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHMud3JhcEFsbChodG1sKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYXBwZW5kKGh0bWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdyYXA6IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICAgICAgICB2YXIgaHRtbElzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKGh0bWwpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLndyYXBBbGwoaHRtbElzRnVuY3Rpb24gPyBodG1sLmNhbGwodGhpcywgaSkgOiBodG1sKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVud3JhcDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudChzZWxlY3Rvcikubm90KFwiYm9keVwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkodGhpcykucmVwbGFjZVdpdGgodGhpcy5jaGlsZE5vZGVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgalF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICByZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZShlbGVtKTtcbiAgICB9O1xuICAgIGpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHJldHVybiAhIShlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgpO1xuICAgIH07XG5cblxuICAgIGpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciB4aHJTdWNjZXNzU3RhdHVzID0ge1xuXG4gICAgICAgICAgICAvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuICAgICAgICAgICAgMDogMjAwLFxuXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuICAgICAgICAgICAgLy8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG4gICAgICAgICAgICAxMjIzOiAyMDRcbiAgICAgICAgfSxcbiAgICAgICAgeGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuICAgIHN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmIChcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCk7XG4gICAgc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbiAgICBqUXVlcnkuYWpheFRyYW5zcG9ydChmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cbiAgICAgICAgLy8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuICAgICAgICBpZiAoc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzZW5kOiBmdW5jdGlvbiAoaGVhZGVycywgY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIgPSBvcHRpb25zLnhocigpO1xuXG4gICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmFzeW5jLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGFzc3dvcmRcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnhockZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpIGluIG9wdGlvbnMueGhyRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyW2ldID0gb3B0aW9ucy54aHJGaWVsZHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZShvcHRpb25zLm1pbWVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihpLCBoZWFkZXJzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnRpbWVvdXQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFib3J0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZXJyb3JcIikge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSgwLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1c1RleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyU3VjY2Vzc1N0YXR1c1t4aHIuc3RhdHVzXSB8fCB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXNUZXh0LFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIikgIT09IFwidGV4dFwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7YmluYXJ5OiB4aHIucmVzcG9uc2V9IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3RleHQ6IHhoci5yZXNwb25zZVRleHR9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTGlzdGVuIHRvIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICB4aHIub25sb2FkID0gY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0geGhyLm9udGltZW91dCA9IGNhbGxiYWNrKFwiZXJyb3JcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgOSBvbmx5XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2soXCJhYm9ydFwiKTtcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2VuZChvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcbiAgICBqUXVlcnkuYWpheFByZWZpbHRlcihmdW5jdGlvbiAocykge1xuICAgICAgICBpZiAocy5jcm9zc0RvbWFpbikge1xuICAgICAgICAgICAgcy5jb250ZW50cy5zY3JpcHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbiAgICBqUXVlcnkuYWpheFNldHVwKHtcbiAgICAgICAgYWNjZXB0czoge1xuICAgICAgICAgICAgc2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXCIgK1xuICAgICAgICAgICAgICAgIFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcbiAgICAgICAgfSxcbiAgICAgICAgY29udGVudHM6IHtcbiAgICAgICAgICAgIHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnZlcnRlcnM6IHtcbiAgICAgICAgICAgIFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZ2xvYmFsRXZhbCh0ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxuICAgIGpRdWVyeS5hamF4UHJlZmlsdGVyKFwic2NyaXB0XCIsIGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIGlmIChzLmNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHMuY2FjaGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocy5jcm9zc0RvbWFpbikge1xuICAgICAgICAgICAgcy50eXBlID0gXCJHRVRcIjtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG4gICAgalF1ZXJ5LmFqYXhUcmFuc3BvcnQoXCJzY3JpcHRcIiwgZnVuY3Rpb24gKHMpIHtcblxuICAgICAgICAvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIG9yIGZvcmNlZC1ieS1hdHRycyByZXF1ZXN0c1xuICAgICAgICBpZiAocy5jcm9zc0RvbWFpbiB8fCBzLnNjcmlwdEF0dHJzKSB7XG4gICAgICAgICAgICB2YXIgc2NyaXB0LCBjYWxsYmFjaztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2VuZDogZnVuY3Rpb24gKF8sIGNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdCA9IGpRdWVyeShcIjxzY3JpcHQ+XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihzLnNjcmlwdEF0dHJzIHx8IHt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnByb3Aoe2NoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCwgc3JjOiBzLnVybH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oXCJsb2FkIGVycm9yXCIsIGNhbGxiYWNrID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZShldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0WzBdKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgdmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuICAgICAgICByanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4gICAgLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xuICAgIGpRdWVyeS5hamF4U2V0dXAoe1xuICAgICAgICBqc29ucDogXCJjYWxsYmFja1wiLFxuICAgICAgICBqc29ucENhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAobm9uY2UrKykpO1xuICAgICAgICAgICAgdGhpc1tjYWxsYmFja10gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbiAgICBqUXVlcnkuYWpheFByZWZpbHRlcihcImpzb24ganNvbnBcIiwgZnVuY3Rpb24gKHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSKSB7XG5cbiAgICAgICAgdmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuICAgICAgICAgICAganNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAocmpzb25wLnRlc3Qocy51cmwpID9cbiAgICAgICAgICAgICAgICAgICAgXCJ1cmxcIiA6XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgKHMuY29udGVudFR5cGUgfHwgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pbmRleE9mKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIHJqc29ucC50ZXN0KHMuZGF0YSkgJiYgXCJkYXRhXCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgLy8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuICAgICAgICBpZiAoanNvblByb3AgfHwgcy5kYXRhVHlwZXNbMF0gPT09IFwianNvbnBcIikge1xuXG4gICAgICAgICAgICAvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG4gICAgICAgICAgICBjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKHMuanNvbnBDYWxsYmFjaykgP1xuICAgICAgICAgICAgICAgIHMuanNvbnBDYWxsYmFjaygpIDpcbiAgICAgICAgICAgICAgICBzLmpzb25wQ2FsbGJhY2s7XG5cbiAgICAgICAgICAgIC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcbiAgICAgICAgICAgIGlmIChqc29uUHJvcCkge1xuICAgICAgICAgICAgICAgIHNbanNvblByb3BdID0gc1tqc29uUHJvcF0ucmVwbGFjZShyanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHMuanNvbnAgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcy51cmwgKz0gKHJxdWVyeS50ZXN0KHMudXJsKSA/IFwiJlwiIDogXCI/XCIpICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG4gICAgICAgICAgICBzLmNvbnZlcnRlcnNbXCJzY3JpcHQganNvblwiXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5lcnJvcihjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWzBdO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gRm9yY2UganNvbiBkYXRhVHlwZVxuICAgICAgICAgICAgcy5kYXRhVHlwZXNbMF0gPSBcImpzb25cIjtcblxuICAgICAgICAgICAgLy8gSW5zdGFsbCBjYWxsYmFja1xuICAgICAgICAgICAgb3ZlcndyaXR0ZW4gPSB3aW5kb3dbY2FsbGJhY2tOYW1lXTtcbiAgICAgICAgICAgIHdpbmRvd1tjYWxsYmFja05hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG4gICAgICAgICAgICBqcVhIUi5hbHdheXMoZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHdpbmRvdykucmVtb3ZlUHJvcChjYWxsYmFja05hbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93W2NhbGxiYWNrTmFtZV0gPSBvdmVyd3JpdHRlbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTYXZlIGJhY2sgYXMgZnJlZVxuICAgICAgICAgICAgICAgIGlmIChzW2NhbGxiYWNrTmFtZV0pIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcbiAgICAgICAgICAgICAgICAgICAgcy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2VcbiAgICAgICAgICAgICAgICAgICAgb2xkQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2tOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VDb250YWluZXIgJiYgaXNGdW5jdGlvbihvdmVyd3JpdHRlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcndyaXR0ZW4ocmVzcG9uc2VDb250YWluZXJbMF0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gRGVsZWdhdGUgdG8gc2NyaXB0XG4gICAgICAgICAgICByZXR1cm4gXCJzY3JpcHRcIjtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICAvLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG4gICAgLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuICAgIC8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxuICAgIC8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cbiAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG4gICAgc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYm9keSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcIlwiKS5ib2R5O1xuICAgICAgICBib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcbiAgICAgICAgcmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG4gICAgfSkoKTtcblxuXG4gICAgLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4gICAgLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuICAgIC8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4gICAgLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xuICAgIGpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiAoZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAga2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuICAgICAgICAgICAgY29udGV4dCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuICAgICAgICBpZiAoIWNvbnRleHQpIHtcblxuICAgICAgICAgICAgLy8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgaWYgKHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcIlwiKTtcblxuICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgYmFzZSBocmVmIGZvciB0aGUgY3JlYXRlZCBkb2N1bWVudFxuICAgICAgICAgICAgICAgIC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG4gICAgICAgICAgICAgICAgLy8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTCAoZ2gtMjk2NSlcbiAgICAgICAgICAgICAgICBiYXNlID0gY29udGV4dC5jcmVhdGVFbGVtZW50KFwiYmFzZVwiKTtcbiAgICAgICAgICAgICAgICBiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuaGVhZC5hcHBlbmRDaGlsZChiYXNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKGRhdGEpO1xuICAgICAgICBzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG4gICAgICAgIC8vIFNpbmdsZSB0YWdcbiAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtjb250ZXh0LmNyZWF0ZUVsZW1lbnQocGFyc2VkWzFdKV07XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZWQgPSBidWlsZEZyYWdtZW50KFtkYXRhXSwgY29udGV4dCwgc2NyaXB0cyk7XG5cbiAgICAgICAgaWYgKHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGpRdWVyeShzY3JpcHRzKS5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqUXVlcnkubWVyZ2UoW10sIHBhcnNlZC5jaGlsZE5vZGVzKTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gICAgICovXG4gICAgalF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiAodXJsLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG4gICAgICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIG9mZiA9IHVybC5pbmRleE9mKFwiIFwiKTtcblxuICAgICAgICBpZiAob2ZmID4gLTEpIHtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSh1cmwuc2xpY2Uob2ZmKSk7XG4gICAgICAgICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgb2ZmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0J3MgYSBmdW5jdGlvblxuICAgICAgICBpZiAoaXNGdW5jdGlvbihwYXJhbXMpKSB7XG5cbiAgICAgICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICAgICAgICAgIHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0eXBlID0gXCJQT1NUXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuICAgICAgICBpZiAoc2VsZi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBqUXVlcnkuYWpheCh7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG5cbiAgICAgICAgICAgICAgICAvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuICAgICAgICAgICAgICAgIC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuICAgICAgICAgICAgICAgIC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJodG1sXCIsXG4gICAgICAgICAgICAgICAgZGF0YTogcGFyYW1zXG4gICAgICAgICAgICB9KS5kb25lKGZ1bmN0aW9uIChyZXNwb25zZVRleHQpIHtcblxuICAgICAgICAgICAgICAgIC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5odG1sKHNlbGVjdG9yID9cblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeShcIjxkaXY+XCIpLmFwcGVuZChqUXVlcnkucGFyc2VIVE1MKHJlc3BvbnNlVGV4dCkpLmZpbmQoc2VsZWN0b3IpIDpcblxuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVRleHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxuICAgICAgICAgICAgICAgIC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcbiAgICAgICAgICAgIH0pLmFsd2F5cyhjYWxsYmFjayAmJiBmdW5jdGlvbiAoanFYSFIsIHN0YXR1cykge1xuICAgICAgICAgICAgICAgIHNlbGYuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIHJlc3BvbnNlIHx8IFtqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFJdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuXG4gICAgLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcbiAgICBqUXVlcnkuZWFjaChbXG4gICAgICAgIFwiYWpheFN0YXJ0XCIsXG4gICAgICAgIFwiYWpheFN0b3BcIixcbiAgICAgICAgXCJhamF4Q29tcGxldGVcIixcbiAgICAgICAgXCJhamF4RXJyb3JcIixcbiAgICAgICAgXCJhamF4U3VjY2Vzc1wiLFxuICAgICAgICBcImFqYXhTZW5kXCJcbiAgICBdLCBmdW5jdGlvbiAoaSwgdHlwZSkge1xuICAgICAgICBqUXVlcnkuZm5bdHlwZV0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uKHR5cGUsIGZuKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuXG4gICAgalF1ZXJ5LmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHJldHVybiBqUXVlcnkuZ3JlcChqUXVlcnkudGltZXJzLCBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuICAgICAgICB9KS5sZW5ndGg7XG4gICAgfTtcblxuXG4gICAgalF1ZXJ5Lm9mZnNldCA9IHtcbiAgICAgICAgc2V0T2Zmc2V0OiBmdW5jdGlvbiAoZWxlbSwgb3B0aW9ucywgaSkge1xuICAgICAgICAgICAgdmFyIGN1clBvc2l0aW9uLCBjdXJMZWZ0LCBjdXJDU1NUb3AsIGN1clRvcCwgY3VyT2Zmc2V0LCBjdXJDU1NMZWZ0LCBjYWxjdWxhdGVQb3NpdGlvbixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGpRdWVyeS5jc3MoZWxlbSwgXCJwb3NpdGlvblwiKSxcbiAgICAgICAgICAgICAgICBjdXJFbGVtID0galF1ZXJ5KGVsZW0pLFxuICAgICAgICAgICAgICAgIHByb3BzID0ge307XG5cbiAgICAgICAgICAgIC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIikge1xuICAgICAgICAgICAgICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XG4gICAgICAgICAgICBjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKGVsZW0sIFwidG9wXCIpO1xuICAgICAgICAgICAgY3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoZWxlbSwgXCJsZWZ0XCIpO1xuICAgICAgICAgICAgY2FsY3VsYXRlUG9zaXRpb24gPSAocG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiKSAmJlxuICAgICAgICAgICAgICAgIChjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0KS5pbmRleE9mKFwiYXV0b1wiKSA+IC0xO1xuXG4gICAgICAgICAgICAvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuICAgICAgICAgICAgLy8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG4gICAgICAgICAgICBpZiAoY2FsY3VsYXRlUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICBjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG4gICAgICAgICAgICAgICAgY3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VyVG9wID0gcGFyc2VGbG9hdChjdXJDU1NUb3ApIHx8IDA7XG4gICAgICAgICAgICAgICAgY3VyTGVmdCA9IHBhcnNlRmxvYXQoY3VyQ1NTTGVmdCkgfHwgMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucykpIHtcblxuICAgICAgICAgICAgICAgIC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCh7fSwgY3VyT2Zmc2V0KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRvcCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMudG9wID0gKG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCkgKyBjdXJUb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5sZWZ0ID0gKG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0KSArIGN1ckxlZnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcInVzaW5nXCIgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudXNpbmcuY2FsbChlbGVtLCBwcm9wcyk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VyRWxlbS5jc3MocHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuXG4gICAgICAgIC8vIG9mZnNldCgpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIGJvcmRlciBib3ggdG8gdGhlIGRvY3VtZW50IG9yaWdpblxuICAgICAgICBvZmZzZXQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KHRoaXMsIG9wdGlvbnMsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlY3QsIHdpbixcbiAgICAgICAgICAgICAgICBlbGVtID0gdGhpc1swXTtcblxuICAgICAgICAgICAgaWYgKCFlbGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuICAgICAgICAgICAgLy8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYVxuICAgICAgICAgICAgLy8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG4gICAgICAgICAgICBpZiAoIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge3RvcDogMCwgbGVmdDogMH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdldCBkb2N1bWVudC1yZWxhdGl2ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmlld3BvcnQgc2Nyb2xsIHRvIHZpZXdwb3J0LXJlbGF0aXZlIGdCQ1JcbiAgICAgICAgICAgIHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgd2luID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3A6IHJlY3QudG9wICsgd2luLnBhZ2VZT2Zmc2V0LFxuICAgICAgICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBwb3NpdGlvbigpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIG1hcmdpbiBib3ggdG8gaXRzIG9mZnNldCBwYXJlbnQncyBwYWRkaW5nIGJveFxuICAgICAgICAvLyBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBiZWhhdmlvciBvZiBDU1MgYWJzb2x1dGUgcG9zaXRpb25pbmdcbiAgICAgICAgcG9zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpc1swXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LCBkb2MsXG4gICAgICAgICAgICAgICAgZWxlbSA9IHRoaXNbMF0sXG4gICAgICAgICAgICAgICAgcGFyZW50T2Zmc2V0ID0ge3RvcDogMCwgbGVmdDogMH07XG5cbiAgICAgICAgICAgIC8vIHBvc2l0aW9uOmZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB0aGUgdmlld3BvcnQsIHdoaWNoIGl0c2VsZiBhbHdheXMgaGFzIHplcm8gb2Zmc2V0XG4gICAgICAgICAgICBpZiAoalF1ZXJ5LmNzcyhlbGVtLCBcInBvc2l0aW9uXCIpID09PSBcImZpeGVkXCIpIHtcblxuICAgICAgICAgICAgICAgIC8vIEFzc3VtZSBwb3NpdGlvbjpmaXhlZCBpbXBsaWVzIGF2YWlsYWJpbGl0eSBvZiBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cbiAgICAgICAgICAgICAgICAvLyBBY2NvdW50IGZvciB0aGUgKnJlYWwqIG9mZnNldCBwYXJlbnQsIHdoaWNoIGNhbiBiZSB0aGUgZG9jdW1lbnQgb3IgaXRzIHJvb3QgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIHdoZW4gYSBzdGF0aWNhbGx5IHBvc2l0aW9uZWQgZWxlbWVudCBpcyBpZGVudGlmaWVkXG4gICAgICAgICAgICAgICAgZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuICAgICAgICAgICAgICAgIG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG9mZnNldFBhcmVudCAmJlxuICAgICAgICAgICAgICAgIChvZmZzZXRQYXJlbnQgPT09IGRvYy5ib2R5IHx8IG9mZnNldFBhcmVudCA9PT0gZG9jLmRvY3VtZW50RWxlbWVudCkgJiZcbiAgICAgICAgICAgICAgICBqUXVlcnkuY3NzKG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiKSA9PT0gXCJzdGF0aWNcIikge1xuXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZWxlbSAmJiBvZmZzZXRQYXJlbnQubm9kZVR5cGUgPT09IDEpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJbmNvcnBvcmF0ZSBib3JkZXJzIGludG8gaXRzIG9mZnNldCwgc2luY2UgdGhleSBhcmUgb3V0c2lkZSBpdHMgY29udGVudCBvcmlnaW5cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50T2Zmc2V0ID0galF1ZXJ5KG9mZnNldFBhcmVudCkub2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyhvZmZzZXRQYXJlbnQsIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3Mob2Zmc2V0UGFyZW50LCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgbGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgICAgICAvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG4gICAgICAgIC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuICAgICAgICAvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG4gICAgICAgIC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcbiAgICAgICAgLy9cbiAgICAgICAgLy8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG4gICAgICAgIC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuICAgICAgICBvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiKSA9PT0gXCJzdGF0aWNcIikge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xuICAgIGpRdWVyeS5lYWNoKHtzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwifSwgZnVuY3Rpb24gKG1ldGhvZCwgcHJvcCkge1xuICAgICAgICB2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG4gICAgICAgIGpRdWVyeS5mblttZXRob2RdID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGFjY2Vzcyh0aGlzLCBmdW5jdGlvbiAoZWxlbSwgbWV0aG9kLCB2YWwpIHtcblxuICAgICAgICAgICAgICAgIC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuICAgICAgICAgICAgICAgIHZhciB3aW47XG4gICAgICAgICAgICAgICAgaWYgKGlzV2luZG93KGVsZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbiA9IGVsZW07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtLm5vZGVUeXBlID09PSA5KSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW4gPyB3aW5bcHJvcF0gOiBlbGVtW21ldGhvZF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHdpbikge1xuICAgICAgICAgICAgICAgICAgICB3aW4uc2Nyb2xsVG8oXG4gICAgICAgICAgICAgICAgICAgICAgICAhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbGVtW21ldGhvZF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxuICAgIC8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4gICAgLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4gICAgLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcbiAgICAvLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuICAgIC8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG4gICAgalF1ZXJ5LmVhY2goW1widG9wXCIsIFwibGVmdFwiXSwgZnVuY3Rpb24gKGksIHByb3ApIHtcbiAgICAgICAgalF1ZXJ5LmNzc0hvb2tzW3Byb3BdID0gYWRkR2V0SG9va0lmKHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbGVtLCBjb21wdXRlZCkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wdXRlZCA9IGN1ckNTUyhlbGVtLCBwcm9wKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJudW1ub25weC50ZXN0KGNvbXB1dGVkKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkoZWxlbSkucG9zaXRpb24oKVtwcm9wXSArIFwicHhcIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfSk7XG5cblxuICAgIC8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xuICAgIGpRdWVyeS5lYWNoKHtIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCJ9LCBmdW5jdGlvbiAobmFtZSwgdHlwZSkge1xuICAgICAgICBqUXVlcnkuZWFjaCh7cGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZX0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSkge1xuXG4gICAgICAgICAgICAgICAgLy8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmZuW2Z1bmNOYW1lXSA9IGZ1bmN0aW9uIChtYXJnaW4sIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmIChkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjZXNzKHRoaXMsIGZ1bmN0aW9uIChlbGVtLCB0eXBlLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvYztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2luZG93KGVsZW0pKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jTmFtZS5pbmRleE9mKFwib3V0ZXJcIikgPT09IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtW1wiaW5uZXJcIiArIG5hbWVdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbXCJjbGllbnRcIiArIG5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5ib2R5W1wic2Nyb2xsXCIgKyBuYW1lXSwgZG9jW1wic2Nyb2xsXCIgKyBuYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5ib2R5W1wib2Zmc2V0XCIgKyBuYW1lXSwgZG9jW1wib2Zmc2V0XCIgKyBuYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jW1wiY2xpZW50XCIgKyBuYW1lXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY3NzKGVsZW0sIHR5cGUsIGV4dHJhKSA6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnN0eWxlKGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgfSk7XG5cblxuICAgIGpRdWVyeS5lYWNoKChcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIFwiICtcbiAgICAgICAgXCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG4gICAgICAgIFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiKS5zcGxpdChcIiBcIiksXG4gICAgICAgIGZ1bmN0aW9uIChpLCBuYW1lKSB7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG4gICAgICAgICAgICBqUXVlcnkuZm5bbmFtZV0gPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uKG5hbWUsIG51bGwsIGRhdGEsIGZuKSA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihuYW1lKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICAgIGhvdmVyOiBmdW5jdGlvbiAoZm5PdmVyLCBmbk91dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW91c2VlbnRlcihmbk92ZXIpLm1vdXNlbGVhdmUoZm5PdXQgfHwgZm5PdmVyKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcblxuICAgICAgICBiaW5kOiBmdW5jdGlvbiAodHlwZXMsIGRhdGEsIGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbih0eXBlcywgbnVsbCwgZGF0YSwgZm4pO1xuICAgICAgICB9LFxuICAgICAgICB1bmJpbmQ6IGZ1bmN0aW9uICh0eXBlcywgZm4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9mZih0eXBlcywgbnVsbCwgZm4pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlbGVnYXRlOiBmdW5jdGlvbiAoc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub24odHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbik7XG4gICAgICAgIH0sXG4gICAgICAgIHVuZGVsZWdhdGU6IGZ1bmN0aW9uIChzZWxlY3RvciwgdHlwZXMsIGZuKSB7XG5cbiAgICAgICAgICAgIC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cbiAgICAgICAgICAgICAgICB0aGlzLm9mZihzZWxlY3RvciwgXCIqKlwiKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYodHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcbiAgICAvLyBhcmd1bWVudHMuXG4gICAgLy8galF1ZXJ5LnByb3h5IGlzIGRlcHJlY2F0ZWQgdG8gcHJvbW90ZSBzdGFuZGFyZHMgKHNwZWNpZmljYWxseSBGdW5jdGlvbiNiaW5kKVxuICAgIC8vIEhvd2V2ZXIsIGl0IGlzIG5vdCBzbGF0ZWQgZm9yIHJlbW92YWwgYW55IHRpbWUgc29vblxuICAgIGpRdWVyeS5wcm94eSA9IGZ1bmN0aW9uIChmbiwgY29udGV4dCkge1xuICAgICAgICB2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRtcCA9IGZuW2NvbnRleHRdO1xuICAgICAgICAgICAgY29udGV4dCA9IGZuO1xuICAgICAgICAgICAgZm4gPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuICAgICAgICAvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZm4pKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2ltdWxhdGVkIGJpbmRcbiAgICAgICAgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgcHJveHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcbiAgICAgICAgcHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cbiAgICAgICAgcmV0dXJuIHByb3h5O1xuICAgIH07XG5cbiAgICBqUXVlcnkuaG9sZFJlYWR5ID0gZnVuY3Rpb24gKGhvbGQpIHtcbiAgICAgICAgaWYgKGhvbGQpIHtcbiAgICAgICAgICAgIGpRdWVyeS5yZWFkeVdhaXQrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGpRdWVyeS5yZWFkeSh0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgalF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuICAgIGpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xuICAgIGpRdWVyeS5ub2RlTmFtZSA9IG5vZGVOYW1lO1xuICAgIGpRdWVyeS5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgICBqUXVlcnkuaXNXaW5kb3cgPSBpc1dpbmRvdztcbiAgICBqUXVlcnkuY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xuICAgIGpRdWVyeS50eXBlID0gdG9UeXBlO1xuXG4gICAgalF1ZXJ5Lm5vdyA9IERhdGUubm93O1xuXG4gICAgalF1ZXJ5LmlzTnVtZXJpYyA9IGZ1bmN0aW9uIChvYmopIHtcblxuICAgICAgICAvLyBBcyBvZiBqUXVlcnkgMy4wLCBpc051bWVyaWMgaXMgbGltaXRlZCB0b1xuICAgICAgICAvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG4gICAgICAgIC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG4gICAgICAgIHZhciB0eXBlID0galF1ZXJ5LnR5cGUob2JqKTtcbiAgICAgICAgcmV0dXJuICh0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIpICYmXG5cbiAgICAgICAgICAgIC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChcIlwiKVxuICAgICAgICAgICAgLy8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuICAgICAgICAgICAgLy8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG4gICAgICAgICAgICAhaXNOYU4ob2JqIC0gcGFyc2VGbG9hdChvYmopKTtcbiAgICB9O1xuXG5cbiAgICAvLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbiAgICAvLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4gICAgLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4gICAgLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuICAgIC8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuICAgIC8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuICAgIC8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuICAgIC8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4gICAgLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuICAgIC8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICB2YXJcblxuICAgICAgICAvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcbiAgICAgICAgX2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cbiAgICAgICAgLy8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcbiAgICAgICAgXyQgPSB3aW5kb3cuJDtcblxuICAgIGpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKGRlZXApIHtcbiAgICAgICAgaWYgKHdpbmRvdy4kID09PSBqUXVlcnkpIHtcbiAgICAgICAgICAgIHdpbmRvdy4kID0gXyQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkpIHtcbiAgICAgICAgICAgIHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpRdWVyeTtcbiAgICB9O1xuXG4gICAgLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbiAgICAvLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4gICAgLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuICAgIGlmICghbm9HbG9iYWwpIHtcbiAgICAgICAgd2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xuICAgIH1cblxuXG4gICAgcmV0dXJuIGpRdWVyeTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbGliL2pxdWVyeS0zLjQuMC5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCwgcGFyZW50KSB7XG4gIGlmIChwYXJlbnQpe1xuICAgIHJldHVybiBwYXJlbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICB9XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG59O1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBwYXNzaW5nIGZ1bmN0aW9uIGluIG9wdGlvbnMsIHRoZW4gdXNlIGl0IGZvciByZXNvbHZlIFwiaGVhZFwiIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gVXNlZnVsIGZvciBTaGFkb3cgUm9vdCBzdHlsZSBpLmVcbiAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAgICAgLy8gICBpbnNlcnRJbnRvOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Zvb1wiKS5zaGFkb3dSb290IH1cbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdHZhciBzdHlsZVRhcmdldCA9IGdldFRhcmdldC5jYWxsKHRoaXMsIHRhcmdldCwgcGFyZW50KTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3RhcmdldF1cblx0fTtcbn0pKCk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG4gICAgICAgIGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUsIHRhcmdldCk7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cblx0aWYob3B0aW9ucy5hdHRycy5ub25jZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dmFyIG5vbmNlID0gZ2V0Tm9uY2UoKTtcblx0XHRpZiAobm9uY2UpIHtcblx0XHRcdG9wdGlvbnMuYXR0cnMubm9uY2UgPSBub25jZTtcblx0XHR9XG5cdH1cblxuXHRhZGRBdHRycyhzdHlsZSwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XG5cblx0cmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBnZXROb25jZSgpIHtcblx0aWYgKHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHJldHVybiBfX3dlYnBhY2tfbm9uY2VfXztcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSB0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbidcblx0XHQgPyBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKSBcblx0XHQgOiBvcHRpb25zLnRyYW5zZm9ybS5kZWZhdWx0KG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEV2ZW50Q2VudGVyID0gKGZ1bmN0aW9uKCl7XG5cblx0dmFyIGV2ZW50cyA9IHt9XG5cblx0ZnVuY3Rpb24gb24oZXZ0LGhhbmRsZXIpe1xuXHRcdGV2ZW50c1tldnRdID0gZXZlbnRzW2V2dF0gfHwgW11cblxuXHRcdGV2ZW50c1tldnRdLnB1c2goe1xuXHRcdFx0aGFuZGxlcjpoYW5kbGVyXG5cdFx0fSlcblx0fVxuXG5cdGZ1bmN0aW9uIGZpcmUoZXZ0LGFyZ3Mpe1xuXHRcdGlmKCFldmVudHNbZXZ0XSl7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0Zm9yKHZhciBpPTA7IGk8ZXZlbnRzW2V2dF0ubGVuZ3RoOyBpKyspe1xuXHRcdFx0ZXZlbnRzW2V2dF1baV0uaGFuZGxlcihhcmdzKVxuXHRcdH1cblx0fVxuXG5cdHJldHVybntcblx0XHRvbjogb24sXG5cdFx0ZmlyZTogZmlyZVxuXHR9XG5cbn0pKClcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudENlbnRlclxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL21vZC9ldmVudC5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCdsZXNzL3RvYXN0Lmxlc3MnKVxuXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpXG5cbmZ1bmN0aW9uIHRvYXN0KG1zZyx0aW1lKSB7XG5cdHRoaXMubXNnID0gbXNnXG5cdHRoaXMuZGlzbWlzc1RpbWUgPSB0aW1lfHwxMDAwXG5cdHRoaXMuY3JlYXRlVG9hc3QoKVxuXHR0aGlzLnNob3dUb2FzdCgpXG59XG5cbnRvYXN0LnByb3RvdHlwZS5jcmVhdGVUb2FzdCA9IGZ1bmN0aW9uKCl7XG5cdHZhciB0cGwgPSAnPGRpdiBjbGFzcz1cInRvYXN0XCI+Jyt0aGlzLm1zZysnPC9kaXY+J1xuXHR0aGlzLiR0b2FzdCA9ICQodHBsKVxuXHQkKCdib2R5JykuYXBwZW5kKHRoaXMuJHRvYXN0KVxufVxuXG50b2FzdC5wcm90b3R5cGUuc2hvd1RvYXN0ID0gZnVuY3Rpb24oKXtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdHNlbGYuJHRvYXN0LmZhZGVJbigzMDAsZnVuY3Rpb24oKXtcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdFx0XHRzZWxmLiR0b2FzdC5mYWRlT3V0KDMwMCxmdW5jdGlvbigpe1xuXHRcdFx0XHRzZWxmLiR0b2FzdC5yZW1vdmUoKVxuXHRcdFx0fSlcblx0XHR9LHNlbGYuZGlzbWlzc1RpbWUpXG5cdH0pXG59XG5cbmZ1bmN0aW9uIFRvYXN0KG1zZyx0aW1lKXtcblx0cmV0dXJuIG5ldyB0b2FzdChtc2csdGltZSlcbn1cbm1vZHVsZS5leHBvcnRzLlRvYXN0ID0gVG9hc3RcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9tb2QvdG9hc3QuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICQgPSByZXF1aXJlKCdqcXVlcnknKVxucmVxdWlyZSgnbGVzcy9pbmRleC5sZXNzJyk7XG5cbnZhciBOb3RlTWFuYWdlciA9IHJlcXVpcmUoJ21vZC9ub3RlLW1hbmFnZXIuanMnKS5Ob3RlTWFuYWdlcjtcbnZhciBFdmVudCA9IHJlcXVpcmUoJ21vZC9ldmVudC5qcycpO1xudmFyIFdhdGVyRmFsbCA9IHJlcXVpcmUoJ21vZC93YXRlcmZhbGwuanMnKTtcblxuTm90ZU1hbmFnZXIubG9hZCgpO1xuXG4kKCcuYWRkLW5vdGUnKS5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICBOb3RlTWFuYWdlci5hZGQoKTtcbn0pXG5cbkV2ZW50Lm9uKCd3YXRlcmZhbGwnLCBmdW5jdGlvbigpe1xuICAgIFdhdGVyRmFsbC5pbml0KCQoJyNjb250ZW50JykpO1xufSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9hcHAvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2luZGV4Lmxlc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2luZGV4Lmxlc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvZGlzdC9janMuanMhLi9pbmRleC5sZXNzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGVzcy9pbmRleC5sZXNzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiaHRtbCxcXG5ib2R5IHtcXG4gIG1hcmdpbjogMDtcXG59XFxuYm9keSB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBwYWRkaW5nLXRvcDogMXB4O1xcbn1cXG51bCxcXG5saSB7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG59XFxuYm9keSB7XFxuICBmb250OiAxNHB4LzEuNCAnQXJpYWwnO1xcbn1cXG5hIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gIGNvbG9yOiAjZmZmO1xcbn1cXG4jaGVhZGVyIHtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHotaW5kZXg6IDEwMDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAzMHB4O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbn1cXG4jaGVhZGVyIGEge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBtYXJnaW4tdG9wOiA2cHg7XFxufVxcbiNoZWFkZXIgLnVzZXItYXJlYSB7XFxuICBwYWRkaW5nLXJpZ2h0OiAxNnB4O1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbn1cXG4jaGVhZGVyIC51c2VyLWFyZWEgbGkge1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBtYXJnaW4tbGVmdDogNXB4O1xcbn1cXG4jaGVhZGVyIC51c2VyLWFyZWEgbGkgc3BhbiB7XFxuICBjb2xvcjogI2ZmZjtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgbWFyZ2luLXRvcDogNnB4O1xcbn1cXG4jaGVhZGVyIC51c2VyLWFyZWEgaW1nIHtcXG4gIGhlaWdodDogMThweDtcXG4gIG1hcmdpbi10b3A6IDVweDtcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXG59XFxuI2hlYWRlciAuc2V0dGluZyB7XFxuICBmbG9hdDogcmlnaHQ7XFxuICBtYXJnaW4tbGVmdDogOXB4O1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuI2hlYWRlciAuYWRkLW5vdGUge1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBtYXJnaW4tbGVmdDogMTZweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNmZmY7XFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICBwYWRkaW5nOiAycHggNHB4O1xcbn1cXG4jaGVhZGVyIC5sb2dpbiB7XFxuICBmbG9hdDogcmlnaHQ7XFxuICBtYXJnaW4tbGVmdDogMTZweDtcXG59XFxuI2NvbnRlbnQge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbWFyZ2luLXRvcDogMzBweDtcXG4gIGhlaWdodDogLXdlYmtpdC1jYWxjKDcwJSk7XFxuICBoZWlnaHQ6IGNhbGMoNzAlKTtcXG59XFxuQGtleWZyYW1lcyBtb3ZlLXR3aW5rLWJhY2sge1xcbiAgZnJvbSB7XFxuICAgIGJhY2tncm91bmQtcG9zaXRpb246IDAgMDtcXG4gIH1cXG4gIHRvIHtcXG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogLTEwMDAwcHggNTAwMHB4O1xcbiAgfVxcbn1cXG4uc3RhcnMge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIHJpZ2h0OiAwO1xcbiAgYm90dG9tOiAwO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuLnN0YXJzIHtcXG4gIGJhY2tncm91bmQ6ICMwMDAgdXJsKCdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUFBQVFBQkFBRC8yd0JEQUFnR0JnY0dCUWdIQndjSkNRZ0tEQlVPREFzTERCa1NFdzhWSGhzZ0h4NGJIUjBoSlRBcElTTXRKQjBkS2prcUxURXpOalkySUNnN1B6bzBQakExTmpQLzJ3QkRBUWtKQ1F3TERCZ09EaGd6SWgwaU16TXpNek16TXpNek16TXpNek16TXpNek16TXpNek16TXpNek16TXpNek16TXpNek16TXpNek16TXpNek16TXpNelAvd2dBUkNBY0lDMEFEQVJFQUFoRUJBeEVCLzhRQUd3QUJBUUVCQVFFQkFRQUFBQUFBQUFBQUFRSUFBd1FGQmdmL3hBQVlBUUVCQVFFQkFBQUFBQUFBQUFBQUFBQUFBUUlEQlAvYUFBd0RBUUFDRUFNUUFBQUEvbGloaVRITTZBWW9CS01VQk1OaUJKbG9nUkVrb3lTSWd0QVlSQkV4Z01kS2lFa29RS01CUUNZVENCZ01JTGRaTkZFRG94b3Nta3M2SEV4UnpLSk1VU0ltS0pBeFF4STB3QVkxSWtsa21qR0VhQUVRRXdrbUVZd3FKSUNBRkZBQmpDWXhnS01Ba21FVEVnU1VKSkpZcUxtUXhpVEdLTUJKWWxHQVJBZ295NUV3R0V3RkdNWUFFUU1CSWdCbFRHVEFBZ1VTQllBVUJaSkIxTVNZeGhKTVl3RkdNQkFpWlJNSmlnQXhpVENTWW9wWkZNWVZBS0NUVWtpY3hpYXBjQUNWRUZsQUFnWTZpU1NZeHdBRHFTS1phV0VrZ2dSTVNJQVVTQWtnSlFHRWtvVXkwU0JoSkxNb1l5WXhpaVZvZ0FFQk90bUlBa1JLTVl4aWpHQTBOa21NWlVUR0V4QmtURkdVTUJSakdUR0xNUldpZ0FSRVFFb2tvVEZnU1l3Z3VLczBTSnRHTkNhcUtPcDV3S0pNWVFNWVJBa29DZ2hDdEdNWUtSTUJqUW1NTlNJaVNKZ0tBUmpBcW1NSkFpVVNZd2lTV0JKUUdFQkpLQURHTUFHTVl4SWdKakFKaEVCS0FSTVlCTW9pWWtDakdFeGpFbUpLTUJnQXhoVUF5SmhKRUFKRVRGQ0JqRkFCakNCSmpDV1FKaEpLT1FxbGdZVWtrd0dFQUVWRENDSXJSZ0NRcWdBa0liWk1VR1JTVVl3bU9nR09wSUFRY3dJRVNoU21rODZZNW5RNGdJZ0pKaUNoV1JRT2hKZ01Ka1ZWa3hhU0FtWEFaRXdtVUF4SUNZb3F4SkF3aVl3Z0JSakFBaVl3Z1lRRk1DZ2tsR1RDWmJNbUFwY1FZUVRHRXdtS01Zb1FGVkFRTVlBRVNpVENOQmlqSFE2bm1NSUZFMW9TUk1BZ1NVSmpBSlFRazBpYUF3R01KVkFGR01ZMEZJRmtnSWtpSWt5MEprUU1JQ0FGa21NWWtUR01KaWhJTUFDQWdZa3dGR0F3Z1dJQUpJcW1KU2hBU1NqQVdZeEFDQUFTVUFyaE9hVUFsZ1NJZ0Fya3hBaUJaSWtsRXJrd0tnbVZGTVlDekVtWEdSQW94ekVvZ3hnTWFWTlppUkV5NHdGRW9nQWtDQlpKaGxzZ3dGaUowT1FnUUFDQlpLU1d0bklra2dERUNCMEpNQUdCVXlBaUlHQVFXa0FFU1JNSklsRUZBS2hpRENVUWRyS0lBeGhNWW9nc2t4aEpLTVk2RUVtTVlVRExpaUJGRW9sY0tZeGpLR0xCTVlzd0ZDWXgwT1lIUlJKS01TdVNTZ09wekVRQ2t3aVk3SElTUkFZUXJBSUdNQlJqR0VUQkdKcEE2UkFHTElFYVRHRURHakdyR0VnVEFJZ1laVXBNWVNSQXdtTVl4aE1BaUlBWUJKTUFraVlCQW9rb3hqR0tFQ0NpVlRHUkF3bU1KZ0tNU0pnRXhnTVF0RWdtTVl4akFJa2dxbUV4WUVtTVlRV1VCVUZCVXBFa2s2a2lVc29HQVRBSmlER0tNRXFGbEVpQmpLaUFJR0pBeFJKWmdOS2dKQWlVQkpoSUFUQ0lKUUxaQUhNa2d4akFZeGdNSkpKUUNJbUpFQlhJbU1VQmdNWUNpU2lVeXBLZ2xFbUtzNkVKakdGYk9ZbUF3Z0lIUk1RWXdGS0ppaVJCYUFUQ1lEQ21LQVFFeGl3RUJNSUNZU0N3QW93QVl4aHJDTVl3RFZsRUZFbUV3aEZFVm9URW1yQ1lRTVVhQXdEV0VvNWt3aUZXU1VBZ1lvZ1lEQ0lBYXFBeGpSaE1BZ1lSTUlpU1lRTUJRZ1l3bU1CZ01ZRENTWXdnQmpHTEFDQ2lsREdUR0FSQVFFd2txQ2lZU1JXUkV3SkoxQUJNS3lWRWlBR0Vtd01ZeFJnRWt5NHhKaFJKRW9rU3hBa3dtTVNZa1JKS0JhSVRBZEJNQUFRSWtMaklpV0J6RTB1TVl3bGlTY1NSU1NsUktFeUlyMEpPQnhKTVVRVVNKaVFXVW93Q29sQ1lBS0FwY2tpWXlxVVNZa3hsRW9TUkJVREdBYktFUU1ZeEltTWtxbGlTbEVtTXVSQXdyUktKaEFwWU1ZVEZBbGdKbGxLQVRFbUVvUU1Zd0NVUUpRQ0pnclFnSVVtTE1kQ1NpVEdBeFFDYzREb1FWUUJSZ0tBSXkxWk1ZeGk2NW1oSkxBd2dOVWFKQVRDQWtnWXhqR01KUWttRURLb0NKaEV5Z2ltRXhKZ0pNWXhKUUVnWW94SlJqR0F4MElNVVNJQVVZZ1RHQXdGR0FvQUtBUUpFeGdFb0FLQVJFMFV1SkZLV2pXU1lnREZFR0pNdGtvbU1ZeGlSTVVKaWhBZ29nREZITW9vczVtQUNoSk1CWUVrclJCa3haaVNWNlJKUlJkTWFnNGtFakdGQlFDaVNpazlDK1lUaUJpUk1CakNjekFCaXpFbGdZeGpHRVFNQXJrUk1RQXJrVEFLaGhBQ2pXWXhaZ0FER0VFcFFRS1RBUXFKaFJGUW9sTUlGTElsR0VRRk1ZbFFVd2lRSlJoS0U1aUJaaVJNWUNpYW9ZUk5XTUlGRmtpUVVBR01ZUWlCTVhRWXdIUlpURXloVmdNQmpwWE1Jd0ZFbEdKS3BDQUNnRXdrbEF1TW1Bc2tUQ1l3S2lnZEJBQkJjQmt3Q0JJbUFva3dBU0poSktNWVRBVVVZQUtNU0lpY3hLSk1JZ0JoQUJNQUZFaUJnRWtUR01ZeEpSUmdLWEZJaUJSQWlKSktnSlJ6RVRGQUJnS01VWW9DUU1CZ0tFa3hKUW1NWXdGSE1WeEpKU1NVV1NkWmZUTHlzNXh6MEtyTG5RWWt4Y0lnQkJnRXdpUVFVQkpnRVNURWtJcUNJZ1VCUmhKSkVUQVlWRW9ERWlkbDVKaVNqTEppd0VEV1FkUkpBUkF3Q21YQUpaSUdFREZKaW1oTUJrd0ZxbU1aRURDWXhpVENKbGtVVEZFbGtDQllraVNJMENBeFpqVmhqQWRLRENTSmdFa3hSTUFGZ05JQWFOV1hRRFpqUmdMSUFUR0V3R01ZeGpHRUNpem1LaGlVQ2x4U0FyaWtCRURHQXhnTUpqQ1N0cEppREdNSmpHQVFBUk1JQVlSS01CWmdKS0FrQk1TSWdKSllFbUV3Q0JqQVVBR01ZeGlUQ1pSRVRDVVNVWXdIWTVtRXdrcmdTVEdFeGlnTVlSS0FBQWtsYUZFd0NZQkVrVEVndGtKSmpFeFJpclVCZzByS1FRRUxRSXdraVVCakVsR0VneHhFQ3lCTUJBSmxERmdZU2hLQTVpQW1NQmhMSVZTRXkwcWttVk1BQ1NXWTFtRVRtZEJKRXdDZ3VNU1VJR0Fvd29ndUV4a293TGpDQ0lraUpnTVNJaXNsSmlqQUFtRVRHQTZFR3FnRVlER3JCRkNOWW9rd0dLSkV3a1JnRXdWWWtoR3JMVUJOaWFNVUpKSWdZb0JBeFFHTVlUQVVCbG9BUk1xU21NdUZBVENZZ1FNSWdZeGpMaklBSUdFREdNSkpnRXhpU2dFUk1Zd0ZDU1lrUUFDd01BaVlnb0RHRWtUQVlRTEFCTVNXU1pjbUV4Z0VCTUpqQ1lUR1VNbUtBQkpNQlpSQlFrZ1lSSlZRTVdRWW94aVJNU1lGQVRFbWhFVFc0RHBCWFNPSUlpYzdRcU1KQmhFQ2dLQUFJQWtRRURBU1lrd25jNGdVU1dVWXhpQU1ZUktJTW9ZREZKaktnQmhJT2hCZGlKSUZDSWdTWUFFb3dGQUFtQXBNSzBTVUJSQmpDWk1BRmdZbzVpdUVTU2t4UUdNSW1FRlNVVENZQUVUR3JCTGloc0NvQnBLQWt3eEpqQVVJR0JhQ3hKTktHUk1Vb1duTWtSTVlDd0pWRUNreUtpaDBNWVNTU1N5U2dFeVlreFFra2lZb2tveGlRRlF5U0pqQVlreFlnWVNERkdFd0NJR0pLQXhSUkFDQW1KTUFsZ0JqQVl3Q1NVU0pqR0FSQlFVVEdNSmdWUUtKQXdrbEdBcFF4aEtNQmtUTGdSQXgwSUFCTUppaEFTUlVBeUpCU3laSk90dktKa1ZUR01BbEZFaVFZUUF5RFFnSWdZd2xBQ3dnSkJaQmhNUUJpU2lWVElDaXFKakhRa0NqR01jVXBaWEFKWmpFRkVsR0F4Z0tzd21BeFlHQTBhcEVTakdBUU1JbEpnWEFZd2dZd0NaTUpoRXh6TXRDSmdSRXhqQ1l4UmxreVlTU2dNSlFHQ21VS0ZNWVFwR0NrRFJoSU1VWXhoV1V1c2N3bFRJZ0s0VXhJZ0poQXhsU3l4UUpYRWxrb3J6RWd4UmlSTUtBaVl3QVlDd0FEQ0JoQUJBVEFTSWlJQUpoRURBVUJqR01Za3Nrc1NRQURHTUlnWVJKRWt4aVRHTUpnRXhqS21UQUFtTUJRR0tKTUpnQVFYR0V3bUFwQXRSQXN4aElBd21FU1JFUkZhQWhNUVVzR1FDTVNVb2RDU2lERkZHSklBd2tDS2lCaXdNU2RTVEF2Tk1BQVVCakVtQURHWEdUR1hJbEdKTE1TSWtGRUpTaWhqRklyaVRHRUNVb0ZUWEtDMFlCTUJJNU5OQlFraVNJbENnWWt3bU1JTGdLRXdHS01VbUFrVndtRURGSWdCakhRZ1Z4S0lBSWxBVVNZdzI0WXlVQlJKYWhnTlpvUU1BaUlBQmlqRXJpVW94bGtzU0V3aVlvc2hhTUJSaVNTU3lVb2tEQVlUR0JVeUFncVpNU0poTVl4akdNQmdVRkV3Q0JoTVlrUkF4akNKakdNUVVKaE1RSmpFbEFVWXlnQ1l5QUZBQUdNWVNSQVRLZ2lZd2dvVWdXUVl3Q0pJa21FUklGY2lZd0NaYUE2SlJ6TVl3R01ZRm9RRk1XdVJJTXFrZ0JpWlpwT2hoaVNCS0pBQkU1bUxRYUVCTUlnWVY2SEU1cGlSQ2txVUpCTUFGa3FDZ0ppakVpWXdHTEpFaE11WEdGSktYQUpoSkJFRjZFM0tDb0dHU3F4QzZOV0tBVEdLRWtva3hTQUdNSmlsa0NnRVFMQXhRQUlrcGloTE9RbUF4UzRrb3dKaEFGdEViU1FNVVl4aWhNSVVnYUFhcUlFa3F0RkFTWXhxWXhpUU1ZVngxT1lsSlpJSFJaU0RHWEZBa3JKa1FNQUdLSk1Zd2dZVEdFd2tsQUpKUmdBQk1JR0lFeFFFbUVCTVlRTVlza1FBQ2dFVEFXUVlvQUFURkdKTVFkQ1FKT2dDU0txQkpoTUJoTUlLSlJJbVVUb1NZeGhBNG5ReGhBeGpDSkpoRXhKWUZBWXdnQlFyQ1dZQ2pGQ1NaY0NCakFBSFFoWUxpeURHSUFUR3JtVU1ZQk1CSlJSSTI0aUpURWxDQmhBZ3hpUk1BbUVrb1JBUUJNVXNGRWlzcGpDU1VZeGxDeUNrbGFKRzVzbGNBcG9hd0xRR0V3RkNZREZrR0JNWXdpV1pRa3dpV1lrd0NVUVVDWXdGR0V3R01LMlFVWUVSSlZLVEYyeEpoQXdtRVRHQ2dzSUJwaVJKR3NhTVlER3JSaEtNUVdLMFVRWXBBQUJVbE1tYXhoU1ZrRXdnQUdNSmdMQVRHTUlBSUZBWXhSSWttRVRFZ1l4akdBd2lZa29rb3draVl4akNZQk1KekxFQ3pITVJNVVFCaWlUbUlsa2lLaUpCakdBeGhBdFpSQTZuSlZBUU1KZ0pFVEdNU0lHRXdnSWttTUpqR01JaVN1U2dFUUxNSUtpbUpNY3dLRTVyZ2lCTEFTakhNS0REV2pRbUpBNkdNcldJZ1RrSlJJbUZKVUF4aEpKS01Zd2lKSmpBbUZjWmNBSmt5NHhSQmFacEpFQ2lUR3VhTXVORUZtRW1xQXdGbEFVWWd4aEFER0xNVVFVQW1NWUJNQWlCUkJpZ01LWW9WREdLQUNpZ0FUQVdBcGlUQ1lvQ2pHQXFpTVlDZ0F4SnFvbUJVd0ZpSlJJaUJpVHNTUWRDU0JLSkpBeGdGQmNTVUNZeWhqSWlLeVl4akdGSkVDbEFMVEdBbFVESmhBeGpDQWdvSUNaRVFNc3BRR0JWRXhqQ0lHQUNqQ1VjeFVGTUJoSkFwY2dZeTBTbGttTVNZUU1ZRlV4bG9rVEFpQWdvZ1dZU0RDWWhhSkxrQnJDU3FCakpKaWdFVExpd1RBWW9Wb0RxQUVoVWdFVVRDY3ptV1lrVDBIQWcyZ1ZERmtpWWtrb3NSQTRVUmpGR0F3ckFJa2xrS3BKakdqVWlVU1lDZ0VCWEVnbUZRd29nSzRBS01ZZzZYT0JhSWpGQ1lLU0NpaXpFR01VWWt4Z0xBUkpFeFpBR0FSRW9rQkVER0tNV3FTWkVCTUlDVUFGQVlRTFRFbU1ZeHEwWVRFMTBpU1NqRWdVU05NQmxTekdFVEdFeFJBRmtnVWN6QUFnWVRHSlFLV1RKUUF1RXBBa0JVS0FEQ2dCMElYQ1VnU1dTdU1aTUJqR0VER0JVeGpDaVl4bEJURWdxbUV3bUpFVEFZd2lZRnlZeGhJTVVDNUpFRm9sRVZDZ0JNQmhGUk1aY0FnS1NKaFdVVENBQVlES21LU1kxWVRBcVVrQ1lrd0ZHWHFRWkxBU1JYRkdLQVRSQkowckV4am1jeWlUQ1NKSnEwWVRHRVNURkNVQnFnbU1CakNJRW1KTVlva3hsd3dXWVN5Q2lSTUFDQ3Bra3kwQmtCRlpLU2ptcVl3V1VCUkVWV05DSkJkWW9CTUJoSUtFREdLTUFGRW1NbUZVeGdNSllnQjBBb0RBSmt3bU11TUpSZ01CZ0V5QzR5SVZpalFCVkFhTVlTUk1xWW9TaVRvU1VCaVJPaHpNWXhaam1JRUNnWUJXUkpPcHlURkdFUU1zb0dBQU1JQ0psd2dZUUtFRElHWEFKSW9DWUJBUlhHRXhCUmhFa1RBVUNZRnhqR0V3SUN1Uk1ZeGpLQ0tRU1dDaVVZZ1RDWVJVTVlreFJpVEZJQ0M0RVRHQXdnWXhnQmNaQVNpUlhHTWdZd0FVQllFbU1KaWlpakxCaWtnc3BjUUFpQlp5eW1zU1l3R0pNQTFpb0FFU1JKRVREUkdKS0FrVEdKQW9CQWxNQzVLVlVGRUJNWXhKaEF5NUVoVk1ZVEtrbEpSS3lZVFdZQ3lTaElPcGdNVVNaS01zaVNJa2xDSkpqQUtCUUNaY1l4UmlpaWpITW9vd0FVU0lBSmhBb1RBS1paQkV3cUFCa3hSaEFUQUpSUklIUmNCMEFvNkFjQkZPWmhWRUNCQTdISTFZRTBZeTREQVNXYzBRRW9EQVl4Z011S0JFeGlsREdNSlJJb0NvSUlHWEFLQmhNWXlxQUNZVkRDWVFNU2RDU1VwWk1ZcEFUS0NTbEFBQ2RDVnhDQWlTdVJNdVJKRUJLTUFrQ1pjWVFSQmNnWXdtQVFNQW1Fa3hJaUlDQ2dvQUlBWXhqQ1dTWXdsQVdKQmpDQW1BeXlTVWRNdlBRVVlTREFZQjB4c3FNWXdHSk1JRHBPU0FtckRBb2tpQlFDUWlaY2d0QUpoQW9BU1ZSQURvbk5Rd2lBaVl5b0ZFR0pzU2hLSU1Zb1RFbEdNbU1vZEFJTE1TVVNZd0ZKakFVSXFpVVVZd0dFeEJqQ1l4aEV3QUJpakFZRVZESWtDcVNXWXlZUk1KakZtS0tJTXRFbEVsRUVsQUNZU2xDaVFBeFJpYUVCZ010RUNTWW9oRUJNSmpHRUFGVXhrUkFGeGhFRENXbklwWkxCQXk0eGtEQ0pLNHlKZ01aVUJNWVJKRVFTVlFBeUltWEFaRUNpRENLcEtTVUJsbEtNc21UR0V3R0tFeGpFcWlDSks1RWtveEFtQXhoQVRBSmdNSWdaY2dZd0dKQXhpaWpHTVNKaXl6bVlCRWtzUVdRTVJsTkFoVlVFd3hnR3BpeWlUQUlFQ2REa2F0R0UwVHBxY2xKVk1VU1l4Q0pTaGhNWXhpU2dNWW9rU1JBeGhFa3NneGtTV3JBQnNRS01ZQkV4aEpNWTZtVG11RVJJRXdGRWlZU2pDVUpoTVNVSmhBVUNsUU1jekFZQUZFeTBBQ0NKZ0tKTXVGRWxWTUlpcWRFQkV5NEVDbGdRS1NSQlVsS01UTFlJVUtFbHBKTmFFd21MSlVRTUlHTUs0UVRGRWlRSWlZQ2lTUlhHRXdtRVRKSlN5WVRDa0NTVVpjbG5NUUV3cUdUR1ZBVVRBQWdBQ0poVU1ZeGhKUkpGVVV3S0VpVUFHTVl3a29GR01Ba3FnSW1NZ1pVU1V4SmpDWXdBSlN5bUVUQVl4Z01CakVnQzJLWmFJUkFveDNPSWttRWtvb2tsUVlnQUVTVXlnbUFRS01Zb2tVZ0FXa3k0QkFCTVl4aEpFRlNVd0NZRnhRcGdBb2tvbEZvUkpFeGxDbVJVQUJWTUMwSWtXZENDeUNoQXhRRWlZUk1ndEZDY3dFd21Fa3NTakNZd0ZraVlSTVNLU1paRXhqR01Ca3dHVkV3Q21LQXdHQlZFeTBtRW9WeVVRSlJDcEtKbHdtVEdFVmt5WUFyTGtrSmNZNkpJVm9RRXhZS0pqQUlDS3BKUktZUklBVEFKaWpFS2xrbGtHRXhrQ2xTUkpLUkpBNkVxcEppaEpBd0twaktHTWxFZ1lva29rUk1LaGpHRWdVU0NnVVNpbHh6S01KakNTSUZKSUNZeElMakNjam9DWXBVa1VrVEdBd2dTVVpSTUpqQ0JqRWxBQmdNSzRVZ3BWSk1KaWpGRW1NWVNqbUN5VkVnWXdna0ttTVl3bUFDeEpVSk1VekswQWlRSWtpU0FpWlpNeUxqR01xWVV3bUFURXBscEFrVkRMam96elZFQVVSQmJKRTFuUWhNSW1VS0pFa3NBTEtRQlU1bEpKUzR4UlJaaWdFd0dNVVlBRktJSk1ZRkJNVVNndUJNWW94aEtNS2lRSWdZb1RHS0Vrb0RHTVlza3hqR1dnc1RHQWxRQkpGTUlBRVk2VkJSb0N3RTZuTWdEQ0pnRlVCR3dFWWd4Z01JbU1RVVpReVVJcmlVeFN5QWdDSmpGRWlZd2dCbHlZU2lUQUlHTUpqQVl4aE1Ba2dVWUFFb0JXU3pva0VMUklGSlJCUWlvQlJKWnpSQXdBWWtvRndnU2lTWXhqQ0JSbGxFVEVsQUJqRkFTQWdaY0pLWW94QW1LTVVZeGlpVEFRcVFKb3hZTFRQRlVnU2dFQkFza2tBS1ZaVmtEQVlUQUFpWWtSQkpYR01TVVVCUUdFQU1ndUtBU1FWU2lURkVGTEpqQ1VjeXJPaEtXWTVsTGhNQWdCMU1DUXFJZ21MWENkRW9rcGNCaVRDWXdHQXlKZ0FETGpHQVVCSkVUb1FTZEJBRlV3RmtpSlFFbUVDekFZUk1KSWlaUUxNTVRRQ2hRUUowb0FER2hLcVRSUUdNSjFPSkpoRUNqRkVpYW1xSWhoSU1ZRENZd0NZVnlZeGxSVENZeElDSUFKaEpLS0lFbGNpVUpKaVNpUUU2bk13QUlDSUFCZ0tNQmhBeFFHTWRTU1NTakNTVVpRbEtWRXhhUVdZNWttS0F4SmhKTVNZQk1ZUVdSUkVrQ2dFd25NUU1JZ0M1RUFNV1NZNkdNQlpJa2dTb1NZbzBCUUpDNGtza3BKS1hHRWt5U0FMU1VTc29ySlFtSk1KaXptWVFKQVJBeGhFeGpDQmpFbEFXU1FVWVFNbVVWU1JNVXVDenNjeXlFeTJBQ1VRSW1FeFJKakNtTFd5aVVza1ZRQXgzUE9BR0F4a0FFd0dYR01ZVXdDdUtUR0VDZ01xZ1VJZ1lrc2dCRVRHTUltTWFzWWlVR3pHaldoakJDbUUybUhJclJqcFVERUZHRUZ4aklDSUZMSmtDakZVQ2FFNWdJZ1lzQk1BcmhJRVRKUUVsZ1FLMG1KS0Vrd0dFQk1ZeGlSRXdDSWtsRUZFQ0lHSkVER01CakZHTUlDSW1BQktKTUNxSXFDSkNZQ3dNWURHSktBQU11TVpNU1l5Z2xJQUJJbUVEQUFpQlFHTUNvQ2xGR0pLQUFNVVFTb0JRaEdNU1NZa294UWdZeUM0a0NRTFRvYzJza2xBV1FJQUpqRW5ZNGtpQmlnTUltQVRvY3hVVEdBd0FKMk9JZ0psRVRHT2k0NTNQVXlwQmhNSW1BeWFJVnFoTkZWam9JbUtBc2treEpKajBISWtDUk1TSW1UQVpVa29USWd1QVRDWVNnS0ZKTVVRSUdLSk1OQlFtTUVha3dBWTBBQ1l5NFVCTVlWbW1RS0pyTDNUaVZHR2lMSlVOV0pHTWtGaVlDVnBPZ0ZFaFVEQVpjSmt4UklyZ1NqRkxnS0lMVEVnWmJRTUlra0ZnV29nWXhseUFIUWd4akNZQ2lBV2lrbFpTQ3lSSUtYSmdFc3hoSkVRV2tTQ2lTU3dBeGhLTUJsd0ppaURvY3dFVkVDakFRZFNBTXRHUk1TWUFNV1NRWUZ0TVNCWmlWb294a1FBd0NTQkpSZ0JTSnBMS2lUbVlTQ2toYVVGS011U1JTREVuUlpFbFFVeGdFVmxLSk1KSmdyQkdBc3hqQ0tBS2xyQXBpUklNSW1NdEVDWkpGY1VVRnowSldnQXNrazZGSE1VakxXNnFMTGpwV01KakNCSUFZa3hqQUFHS0FDZ0V5WXlnaUlJckFsR01CUjBNU0FJaUFraUpnTVZXTVlvazBiVFFHTUJveGhFRlNVQ2dFcFFFQ3liYUtRSWhLcUl3TGhyQU1XYzBvQkF5cVVTWXh0Q0tnRlFUSlpKaVZTa1NSVk1KakppUk11UkFSQURDVXNDZ2RDRkRKaE1CaVNqQVlBWG9veUtFb2dCaFdSVEFCUmlqQUFxaWxGSEl3Q0JpU2pHTXVKRVVrd21FREtKWkltRXdFbVdra293RWxDWXNnZ3hscEVrb3dMSlJRQWdBZ1dRWWd3a21MV1lRcE5BUUNxU0taVlVoRXkwa2tyaEJFQlFCUlZBUk1zSjBKQW9DQm9DRUZ4aEZFbE1LMkNDNVZBQU1ZcFpMTUNaTXNsTEJRUldzMlphSk1CaWhFQ0NTekhZNkNXWWtnVEFZeEppUUpFRENZVURLa2lKaWdNWXlVb0pnS01VQXBKYXlaQUJLRUJFREdBQ2dFMUFnU1VCUk1CbEMwbTJpWXdGSWxBQmpHdHhwQXhRMU1TS2hhU1VTcVdRWUJLTVVrQ1ZiSmtJeGx3bVJNWXdGR01DcGpKSlM0REhSQ2tnbzBRSWtpQWlZREFkQUlBb0NnRXhKaEpLV0JRTVFvS1VKZ01CWmdBd21NQWxDU0FMa3hoTUs0RXdrZ0Nvb0F1U3dFREFBZ3FnSzRCTWdKbHhLWUZza1JBVEFZb3lZa3hLOUFJUU1XWlFDVEZWSUV4VVpKYXlJR0F4WkJSQmpDQkpRbUFDU3pDUVl3Z0JxREFldVBJSzVFeTVNU1dZUldURm5NU1RJaVN0QW1SV2xrQ1N3RzVzeTBTWWtvd21NU1dKME94Z0F4SnpNSlJJQVlDVEdFQ2hNbU1vSmhNWUJFVVZBTE1BQVdaRWxVRWtSTEtKTVlrd2tGRkVpRkpqR0F3R2pHRURWUzZKTVdrZ1lSTVpacnJKSkoxcm1FWVZ3b0VpdlFreGlUQ1dnWVF0eGtJQzF4WkNZQkFURkZBWmNDWUZSSlNncnFCemdDcWdNWW9vQ1FFQ2lTUk1BaUpJQ0pKSmdLSkpXQ2tTakFKZ0tBVEdNWUJNWXNGa3lZd2lDaGtRTVlEQ1NaY21Fd0NTWVZUSkpsb2t5SmpBcWdCbFRFbU1BbEFXQjBTU0JVRVVBRXk4eEpFWVNCTUNMVW9vTGdNWXdBWVFCQVJNb0lHTUJJbUFRQ2tCTGlCVVNSRXdtRXdHWENBa3BrUUZwU1NqR1dSQUJLdWVoam9jVEZySW1NQlpSWlFpU0FFQ0JqQUFDQmdLQUJNWW94UkpTSmx3RkFZb1FKTVlDZ01ZUkFVRENKakFBaVFVWTFZUUV4alFrQ3VGTVRia1JJR1hJRktDZ0psQ3lUdFp5SlhSaE1LWXdnWmNKSmkwQk1vVUJrREZMZ0ZLQXhqQ1VTWk0xa3hqc3ZFRVJHZzZSaUsxWEhPQW9nNkVrbG5NQUVCQXdGaUFHQVFKTVFDMkJqQ21YR1RDSmdNSUdBc2t4UUdXa2tUR0xXQ2treTVBeGpBU3VLTWxBWUJYQVpBRm9FRENvWkVnb0FsUk9ZVlFtRVFLTW1Fd0x6TUpRbktLQXhpaVFLSlJhcE9hQXFBWXhKUUNBQVlva1FFb0NRTVVTbU1vWXdHTVpRd3BqQWl1Vk1sQ3NnWUVDaEJhQkUwdXBKaVJwTHNvd0FZeFJqRkNkQkFreFJKZ0FrQzBneTBRSUZDWUJNVVFkQ1RBS0ltVkVrb3lZeEpsREZBVVlUQUNZQktNWXdBSWlBMEZ4RkJSalJqQWF0R05SV0tPUldiYVNkQ0FLQXdsR0xPSmpLa2xKa3l5S3FBRmdJR0tBVENCZ1ZBVXdtRVNSTUlHRUNnTUJpZ29HS0lHaUFSQTZFa0dFQ2dBa3hRR09wQUVpWUZ5QmdCZXB5TUtBZ0pSSmpDQUNZeGpHTVl3aUFxcElnQzJRU2xGSE15NU1VSkltQXhoTXVUb2NqR0VERWdJRkVnc25NbzdFcFJSQW1FNXJSUkFnbUtVZ2hHZ0RBV1NCUkpRR0pBa3dtSktPWW1FeElpWUt4Z2hBa1RHQkV5NGdWRDFwNVJNZFRtdUZCYU1rbExBSFJFZzZBQ2drbWdFMWRiT2h5TElNU1dXWXNza3hqQVVKSnpBQ2pJQXVBb3hoRVRHTVlUQUJTSmhCUVNnUU1CbFRHS0F4Z01DSmpDWXdtQURDSTBEQlFZb21NQTBGUUdyQkNZRnlKNlR6R01VQlFsbkV3R1dqR01LSkswQ1lURkVsR0F4akVpc2xHQkV4aWdNVVNZREdLSk1ZeGhOUUVKUWdBbU1kVGlZd2dVUVlrU2lqQUFBWVFYRXBqQ3NsQVpBd21NQWdVU0FtS0pFeGpHRVJGWlRBQXJnRk1TQmxVUUtBQkF3aUNxV1FCaEFrUU1BZ1pZT1JaWlNBaUJpU1ZSTVlVeEtwWkFEQVl3bUtFU3lDREdJT1pSaUJNU0poQURDYWdUUmdNU0lna0N1S0pCYVFFQkZVQk1LQmx3QWxnVVNsTkJJaEFZYTdXWWc2RUFZc1N6Q1NJa2lVSkJ6TVlRQVJBU2dFd0ZGQVpNWVZ4a3hoSlhBVUNKbHhrd2dLZ0NZeVFVWW94Z0V4Z0V3bXFTNGt4akFZREdNSWdKaElLTVdRVXNDbEtIZXprRVlCTVlUb3NvRFFhQURHTVlvUUVrS3hpZ0EwWXNBS01Zd0dFeGpBWVFNSUdNWW9BRVM2NVFrbERXZ01CaWhKTVlrd0ZuTVNUQ1l4Z0V3R01VU0lnQWdJbU1BbU1ZeFFLb2dTVUlDU0JpaEFBTUJoSk1ZVnlVQzRBUU1XUVl3a0NzbUJNVUlDQUVpb0tCUUFNdW9NaUJoTXRsblFpQWtLUzQ1Z2NqQVNJQUpSQmdHc1l4b0RHTVVRQmhNU0ppbHlRWkZjSW1FZ3NreTR4a1JBcEJyR1RtVVVUSzEwc3dGRW1FU2l4Sk1TQW1Fd0dBREFVSlJJRkFJbENTWVVvQkJjaUJpVndtTWlBTGtRRXlnZ0tZd2dJR0VUQUJoTENwR0F4akFZd21FUUF3RkFKUWdRcWxDdG5XemdURmtnSUdCYlNUVWpFQ0JqRkFJbUFLNkdNVVFZWVJNU1lCQVFLSkVTRENZQkVrc0FNSUhhdU1Zb0NhdUFrQkVTUUVDUUFTem1ZeGhNWVFNWXhZR0FTUkVrUUVva1RHTUFMYUlBQWdZeGpBV0pnQXhnQVNUTFNVWlF3SUdFa3hqRkhOVWt5VUJqR01CaFdFd2dBakxxa3BFU2dGVXNRZ0E1MTBDQVRrUVNTSmlSRVNSQ3NZVFJqR0tKQVRBQUNTWlZCTUFyUUdNWUJBeXBreGlpekVtSkVBbDFkYm5FcW1FeFppZ0F5WWxhTUppUUVDZ0V4aWlVb3lvQ1ZSQ1pBVEdBVEdKWEZHVEFCaE1ZREdFQkFUR1dSQkVvQnJHQVJBd3hKWTZSTHBNWVRWWkVBZ0pnTEpNV1lxaGVwazVHRTdubkFtTUJWWURHaE5XTWFLR2dRTUJSakFVWXdDYUxPcHlBa2tvd0NTVlRFMGhHQVNqSE1STVhVUUdFMWFNQUZHS09aakdBRENTSmdNQWdKZ0tFeGpFbUF3Q3RHUkpFUUtFZ1ZVQ1RHS0FTU2lTakZrQVVBQVVJRWlXWWtrd21NUVVZd0VxQ2xFQ1lSSktNU0lITVFBc1RDQmlpbHBFVEF2TXdGREFkRG1lY0NSQW94SlpKWklEUVRBWUJNU2F0RmtDWUJNQWdtRlFSTVl4SmlWVXdtTE1KQWltYUpKczYyOVU1cUNVWVFRWEdFeUM0d21BUkF3aVlTaVRJTGkwYlFJeGt4akdNSlFFcWlDQmpBWVJBQUFUR0tNQmpHTVVTSW1FQk1KUnpMQ3RDQUdFUUFzZ1RDV1NJZ2FyVU5KSklWakNhQW94Z01ZUk1JaVNOSVJKalVoRFFVU0l3Q1k2bU9ZQUlDQTBRRkFCUmhBd0ZHckdnTVlCRWtTU3dKTVlCSU1KZ01JQUJTMGdZd0ZnQmdNSUNBaVNVQWxFZ3RHQk1ZeFJpVENTSW1NSmpBQmhBa29UQVlCSkF4aEFreTRFU1NoakJSR3JGR0pNQVJxeG9hb2lLRzNyRmhaUktweUpFeGNkQ3p6bkVrQ0JFREFZRG9jNnhnaEF4akVWcXJMR0F3Z1VZQkJCY0lpQUdKQXdsRmxFR01CZ1hJcGR0a2dKUmlFb3loaEFva1JLQXhoTVlvQUxBd2dLQVd6Q1lvRENKaWs1Z3VNSmhCTVpjS1lES0NCU0JqQ1lreFJJZ2RBTUpJbEFaUXlZNkVxSFJKTlRDQzR5WXdnSUJYWmVKY2traWFzWUlSRlpBeGhFVURVakdvTkFkVG5XQ0tHc0FSUkpZa25jNGttTUlBWXhscEpFb3dHTUJWVUJNQWdZVEFCUlJBQVl3Z1lrUk1ZRENaVk1CbHhpMENWeFNTWVRBSmlpRndpQmhBeGpBbGttTUlIUWd4Z0ZjSUNRS1NkVG1xQ0t5S0lBV2NseEpSZ01hVEdDbUdra1NaY1djWTJqRlFhV1RsVlRYZUxBS29rNUVuUXhvVHFlWTVFQUFnWXdnQTBDQm9TU1N5REdyUmlpUkFES29GR0FUR0dXYkUwdVNhNkVHT3BLZ3hObU11RkZOYlpSQmpHTVlUQ1lUR01CU3FKZ0V3bUVRTVlERW1Bd2xBS1lERkVrcmlqSUtnVVNZQ2dFd0poRURGRWlTWVRDVW9CYVNZdzBMakdpaFRBVWFrREFJZ01ZeTVMSXJGRUFWQXBaaGlpQkFERkFZYVRBVVRBV0JnRXhockRHQXhoTVdTSnpNSmdFUU1KaEFvQU1YU0FSakdKTVl3Rm1JTVNZd2xFQUlDWVFFb0FFeWdwSlJKUUdFRENCUzlEbVpFQ1RLaUFGR1RHTUFtRURDSzRESWdZa2tzaGFCQlpFb2tFUVdSRUNvMFJxSUxaQXBqU3lOVVRBQml3T3BKTldkWWdLQklKRXhoeUJDemtzR0pNQmhFREZBQWdTQW1KRXhrQlhBWVNDd01JRWxLaEdNbUZTd1RMaTFDMEkxU1pRUlJyb1lreGpBSW1FeGpDQmkxVXdHS0FUQUpqQUFnQmhNSmdRTEFCTW9Ka2tWd21BU1JFeGt3Z1l3bUFSTUFncVlFeGlxeGxTUmhNaVlDcnFtY0JoRWtZeGxzVTVVblE1a2xFeTRXY3NsRUdNSWdJMWpDQm94akFZQ2dOU01KSmhBc3hKUmptSmdFc2tCRURHRURDYlJpWVFNSUdNSUZFZ1lCTUJRR0Fva1RDWUJFVlFRTUJoQW93R0VwWk1ZeGtDbHhqQWRDRUJVTWlCakNBS21Na2lKSmlpVndvTGdMT1prQ1Z4WmlDaEJBVm9DVXhWc1JaQlVKUnlKTVVTZEtSaWF4UjBJT1FGR0pFd1NTdkl3RWdJZ1VTSUNZa3hqRkVHQXlZeW9HTVlDZ0tKTVNxZEk1SFpPU0xXc0VWeTBVU2hEVW1YQ1VhU3RPaHpLQVRDWXhKaWdNSUZDSmpGa0FZeElpWVRBWVRxSjJQS1FnZGptWUJYQ0NXU0NoaE9oekV5U1VKSUNKaE1CakNRS3BRb2tpVUJaSklyVm1Fd3hxRENBZ0ltRWdDaWlBQVFnQW9rcXNJREdFMVlrcUFtcWdFeGpHb01VSm94SUZBSUNZQkFDakdFQ3pFaVVRVVRXRW1NTll4b3dBZENTUUFTZ0FERkdNQlJJbUpMQXhoQVNnRWtvQUtNSmdKV2lVRENxWkVsY1VVUVpLTVl3R0VRQUFFeEpZcUdTVm9sQVRBQ2hveHF4SlJJbVN5VnhJbUtxY3BFa0JFOTU4OGJLT3dBb1FDWXl5Smt4MGxrOHBnQTZITW9CSUV3a21NWXdHRWt5WXk0eGhKRXhqRkVtS0JaTUROTkNaTXF0Q21KaHRrUUVUcWwxWnhNSUVsQ0pKakZFZ1VVVUJKZ01JbUFDeWpBWXdtT29ISTZtVEdPWUxpaVNra3NGeEpaQUNDSW1BeGpDSWdZeGdGVUMweGhKRUJFcFN6QUpWa3lwSmdMQVRBQW1Bc2tURW1BMFVRYWt3RlFHTlFVTVNOVkFZa3dtcWdFQmlpQUtNVVNBaVNTSWlZVEcwME1JbUpOWFE1a1JqVWlZSUFLSkFEQ0lrbU1Ja0NZd21NU1VKZ01VWVFBb2dSTUFnWXk1QVJNdEpJTGpGSUdFa1JBa3hqR01VWWt4ME1vZ1pjQ0pqbVl3ck1tdHhpZ0VDVVRMaVFPb1V4em9BWkdLSk9xd2pXTVplaGptZ0N3ZENFc1ZJOHdBV1lrd2ttTUpJQ0JnRURFaWdVcVFVQlJKZ0tKTUpoSkpMVEtGSktvbUVBRXdMaWoyWE5GSGpCYUF4aWdNQW1FRENXQmdBUkVER1JBb2xReDBFQUtNQUZrRkFJQ21BeW9HRkF4aWpBU0toa1JNWXdnSmlnSk1kREZCVUNZVENJRmtrbU1ZVEdNWUNnQW93RWdZVEdNQUZBV1NZUkVtRUtSQTBZdzBqQ1FXWWd3bU1BQ2REbUJRQ1VWUWNoS05BTllrczVoR0VUVmpCQUlHcGlDd01CZ0VzNWlZUkVreFFHTVlUVmdNTVNKaEF4aWlRRVFNQlpJbU1VU0pJaVNZd0NZd21KRTZFbUpYb3ZKbE1TQlJJQ0pwWnFnQVRKakxBZ0taUVVneGlqcVFURlZTMUlGVWdTU2MxRENKUnN1RlFZeElnVUFDVVFCaE1TWXM1VkphWVpRVEFKSWdZREZKTFNnVUJKWmhKS01ZQUtRTTBIVTlkenhPcHdKV2pDU1lSQXhqQ2tGSFJaS0FCS0pBd0NaTEJjSWxFaVlsQUZva3N4UUNtQWxiQkFRQXdpQWtpWWF5a2lZdzFoQXdGUnFSTUJoTVlzQ1NpVENBd0NGVVNZUU1VU0JnQVNnQ0tNYWdvREdFb0lEVmpDRVdBQVlvazZuT3RDSUdJTVk2RUNGYU1ZdWdCTUpSSUVsbk9NWWFveEpnZ0tDdFRCQ0lBU1VTSUdwR01ZRENZeGpDQmdNSW1FQUVzeEpKUUZDWURGQUlGR0pBeGlUQVlva1JJRVFFczVya0JBRENKQmpDSUdNQmxFQklPaElBWUJFVEFkaFhKSUdBVGdyU0JjSmpaY2Fra3haQUNZQkF3Q1NVU1lBQ2t1TVl4SUZFaVlBTEpRYXBBREN1RXBBd0FLNUF4WkphK3E1NW5VNGtyWklnWXdtRUFNa2xsTGpDU1lzZ3hKaExTZ1dSQW9BS0pUR1dqR0tFb2hNWXlvSUZFaVlSSU1ZVERwcFdURW1Hc1lvQXFzaWtvd0FZeGhBeGpHS0EwYU5UV0VrVEFKSW1BUk1FU1V1SnNzd0dFVEJHTldFeG9CRVFKTU5ZWURBSklpWURWaW9UR29NQUhVeElBVkVFbERXS01TRUJqR0FUQ1lDU3F4b0RWcWNxSk1JR0FzQ1NqQVVCam9CakdFa2tSTUlrZ0poTVNVWWt3RkVpQlpBR01BaUFDQkltTUJqQ2N4TUpRZ0FBdHBqRWlZa0RBWVJFNkdCWVRGR01DZ25PS0pxd0p5NTFKaVNoSUtNQUFKaVJBd2dTWWFjaXNCakdNWXdHRUV6V1JBeVlTbFZ4SUlHUlhHRVNqMDBITXhRR01KSUdMVEF1QUN3S0F3R01Zd2lJb0NTWmNXU0FrbUxJS1NpaEtPWUdMVG0wbEdUQXVUQ0FHTU5BbFFEV0tKTVpjVVlsRXhqR1daRVRhUkZDVVlGVUlvS0JKWElsRWxSSmdOU1l4SXk1RTFJMW9UQVl4akNZNlpjYW9BQTFNWVRHTUtpWWdCTEtKSU9oZ0VEVWdZd0dFczV3Z0pScWtER0NNSUNJVUJCV0VRZ0V4aEVCS0FrUkV4ZFNCaG95b0FDdFJrZ1lzZ3hRQ0JaakZFQ1NBRkdNWUFFREZrQVlEQ0JJQ3VKUk1BQ0lGa0F1UkF3bUFrVExab2tUcFFBaVVrbUJVaWlHQW1xTkhFZ3dnQml6RWdZQkFrUkVrQUtNQWttRXdBSUdNWXhseVl5VVpVeWlZeGdSVVRLaVdkYURHRWtzeEJnRXlKU2hJbUVTRENJRkdFQUZLTUJsQ2hKSU1KUlJrUU1XQWdCSzRwQXdxSmlqQVl4cXdER05TWXhoQmFMVG1ZU2lSVWtTVFVpSUdCZEZJQlFJcmdTeVM0Z0JHc0ppSVZ5WXFpRVFyQUlGZ1lUUUdwaWptRmRZNWxFbUFGNkp6QXhqb1lrd25VNUdNYWtRTVNVQlVjeE1JaFVtSk1hRXhqR0dwTkdyQ1lJVEdFeGlpU2dFa29ERlZKZ2loSkF3MEdoSkV3Z1lSTUpqR0F4akNZQU1VU1dZU0JJTWREa1NZU1FYR1RHTVVKSlFFbVZRRWt4Z0F3cWxVbEZ4ekVnb1VTUVhIT0pNU2F1a1djaURBQlJJZ1lCQXhKUkpnTVl4akFXU1VCSUZFaUFpQUNCa3dyUmpFbUVwZVpUT1ZBcGUxaVNKaEVDVEFJQ1dZa0JBc2tSS0pBd2dCWmdNWkFUS0dNSWdVVWxHQUNSQmNVZ0pSbGt4WUdTQkJVREpocWlsbVRDQWxrRFNTV0pNQUZHb0VJd0ttTWdJQXRHUnBMam1ZeEltTUJseVlTaEVBcVJFUkpNSktsamtnQmhxaVRSakdFa0NpcW9pQW9BTVlhUkF3UW1FNWlZMVkwWURGRWdVQWdBR0FDekdBb0RBSWdZVEZCU0paQVFDWVFNQmdFRENZVndJaUs0eVNha1FnRURFbEFZb1FJVkFBRkpNU0MwZ1l5eWxnS2dtUUV3RUNaY0tJbVdURkNXYU9kSktZRG9zbk01bUtUR2p1Y2prWUZ4Z0xKUU10RW1Fa0RHTVlER0pLQVNpamtVU0FGQUJoTUJSWkJqb1FBZ3VUQVlwYU85Z0JSZ0ZNc2dZeGlpZ0pFUk1Zd0dNWWtRS0tBa1VUQW9CaEtLQXduVkpNQUNJR01XVFFLa1VtTUppQldSUkV3aVNKSWxrMVJnTEdPUmlqR3BNRUJnWEdRQW93bUxJQUFFU3lSTVVZQUtLRWtneFZZVEVoR0VhazBKZ3F3Q0pBUU1ZeFkwa3dtRWtURFZBQmlSakZuSVFFd0NBR0F3aUFHQXhqQ1lEQ0FHQXhSZ0VSS0pMMEltVVJFQU1VQmdFQ2pBVUNxSkJRbUpNWXhnTUlDWWtzREdXU2lBRkVnd2dZQlhJR0pWaG9URkFJQ0pBa0ZBdG5RREpKSW1BU2dVQTRtVENYR0pPWUF0QUJoQk1xSUVnSlJCZ0Vrd1dNdU1ZU1JBQ2pFbUtNWURHS01BZ0pCUmdLS1dUMFdZeGpDaUNnQVl4aXdBb1JKRXhpVEdFU0NoQXdKUks0b3hKakFXVWRDZ1RFR05XaWlSS3FUR1hESUdNQW1KWFdVRVVCaEpFeFJOWXhTcHBKTUFqU0pNSnpMTXVRRmFKVEFXU1V2SXNURFpqUWlOSVJSTmFKRXhkQWdBeGpHdERBWUVzaUpBZ1N5aEFTelZ6aWpHTlNZb2t4SUdBUkNOVWpHTUZZeElpWTBCSWdJR0VWcEpNWURGQUJqRkFJbUtxSXk1RW9ra3NEQVpWTVlvd2tyU1lRRWtrb2t4aEZjQUFpWXlnZ1lrQlFNQWdZd0dWSUtORFNtaHFUTElHU2lERkFkRnBZWm1LcE1CaEZaQURtQ0JTOW9neHhCTXFTSUZrbUpFeGlSRWt3a21BTEtDWEdFQkFrb1FNWXhnVlNTekFBbUtJRlFzREhhNXNsVVFRTXVNQW1LS0lBUU1XQW1KRURHTUpqR0tKQURxQUlrbVhHU2k2WXlpWWF4WnpsVERXRWswbUJXekJHQVJBeFpKakFZc2t4UVZnakdFRFVsQkdBc0NSTVlhSUJGVWdUQ05nVVlRQ0tMR2lKQ3JBVEdJRUNnSldrQ1N5am1ZSWt4WnF4aWl4T1JpZ0tNWXhpVEFZazZ4SkFnWUJKQXdqV0FJQkV3a2pXTktJa2xHSkVRTUlnSlpqQUJqQVlTUk1JR0V3S2dLWVRGQUFtQXdBS2dvQ0lnU0ltSUpFeGdNWUJWQVJOUmtXSklDU29ZeVlWa29SRkFGd2tGa2xHUlVKSUlNV2xnVkx4SVRLZ1lURWlZd0FCUUFKSWtsR3E0NUZBWWdwQmFFd0NDa0JyS01ZREFJZ3VFSXhZVjF1YUJVeGtCVkF3RmlTU0JnS0tFREFBbUFvQ2pBVVFZa3NvbEtJTXFaTExvbFFTVFZSZ2x4akRTQXlZbGFzQWhNSkpSaEF3Z1lva1FLb0ppaUJFcXNJUml5REdNSUdyQkdXZ0FrUkd6SFVrQnJaVnBvVEUweGdLTVFZQkVTVlVrUk1TSk1TV2Frd2lVZERnSmdFQklLSk1ZeGk0Z0NnTVl3a21FYURCQUFpWWthc21VUkFvREdKS01KaWpBQldrUXhnQVRHTUppVENLNHhpMGdURkdNU1VTU1VCUktpSmpBSUdFQklKS01TU1VZeW9HQTFiTXFrd2trTElpaVNxWW83SEpBbFVER0VRUktXQU9aa1RxY3pTaHlUQ29ZeGpGQVFZQk1JQVlERkU2YUdNQmhKUlVLRWtCVWpHc3dnSUFZUVhKU1JDdlJacTdLRVJFd21BREVsQ0FHQXBNWW9GQUVCTUpoTW1KV1Nqc2NqSmlUTFprNm5VNW1KQWF3bWpBcW1Bd0NZRkdhVkpLVzZFd0RHQURWUUVpSUFNU1dBVllrd2xrQUIwQXdIUTlwMHQrVVZKSUdLS3BBeGpHRXdDQW1BeHEwSW1BSVFvTUlFbUFzVEdLSUU2R09RZ1dVQkFnWUFBMVVUR0tNSUdBd0NKakVpQmlvbWtxbktRRWFBakFZU2pEV0FZQ3FBakdNQmpGQ1NCaWdMSkV3RkFxVW5Na293R0tBQU1BQ1lCRUNDeVNSQTZFZ1FxWk1CaWpHTUpJQ1lTQkVzU0NpQkF4bEJKRk1KZ0lKT2dLR01jaGdNQnF3eGpBSklnVUJJa2ltSnRvWXhCUUdBQkVER0VBT2hBRmdTWXhoSlhJblJTT21vaVNJaUpnSk1XWXdBU1lwRXdxQ1lUQUFtRk1VUXNpZGlTRVNCVktTaXdNQUYwQ01CbFVRTUpCUWdXU0pWUUpqR0ppUk5TQmpHTUJRUmlqVW1JaEtKQXdoVlFEVlFWaTRnQ3dOV01BRkdFQkVSQVNEUnFTZ0F4TUEwbEhNU0RDZENSTVVTZERFZ0JpakhFUk1ZU1l4SmlxeFJSSmlqRW1FQ1FNQlJvMUpxY2dUQUZhTUJoS01OSk1CUnFZNW1Fd21Bd2lCakZFaUlEUkdYcVduQUFBb3haQlJJbk14MEFnQ2dKSkFTaVFFRExTQUFJZ0poTUJJR01JbUVCSkVva3dySmpJbU94d0lBb1ZUQVNjNERFaldOR0VDZ0Vrd2drcmlVb0xkQ1k2RUFZa3hpaVRDWUNpVENBZ1lva2tWUVNscUhVeFFGQ1l4aEFveGlSTVNZb0RGRkVnQmhFUVFFd0tGbGdTaXNtS01uWWF5ckxMaVFKRXhKaVJFS29UR0pLTVVBR0UwU1lTS1JFb0lEVXdDQjY2NEZFd0dKQVNnb2hEU29rd3h6TEF1Z29vUUNIVFFnVUFrR0Fvb3Nna3dHTkVsR0FTUXFqQ1VJQ1VVY3pBSUFTWTVuVXVKSkpBeGRJa2lCaE1ZSVFvQW9DaVJBcUpBQkF3Q0lDSUZBWXhnTXVFRW9TUkVzQk1CSWdhcXJaU3RGSkJpU1JNWVNDeVFLRWxReFJDWWdvd2dZeGpDZFY0b2txQ21FU1FNQmpDQlFtSkVRQmVpY2dWRk1ZQUFrcFV4a1NKZVpKSmhOU2FFb0FBd0FLU0s1RURDcVNxZ0lBWXdGQVNKakNZRENVQnpFeTRSaXFyVUM0Q2hBb29ra29UQUJpUk1KakdFa3dtTW1LQXhoTVdXSnpwaUFVRkxPMW9TbVdZYXhScElHZ3hNSnFUQUlTMVpnQ3RrZ0pJRkFZcXNZMEpSSlZSSFF4aXFneG9DNkJBMEExSmpSWklsalZFZ0lnSUdFeFJ5RVRGRkVnWWdUQkNGWEhNeFFDTldKSlpSSnF1T1JqR0F4ekV4VUFVSFU1QVVCaWdNYWlNVEZHcVRDQmhNWXFPY1ZVR0tBMVlZVFZVU0JoR21NUUlDWUtxQVRHTUlHTlZRRTFjUWRpVEFZQ1Z5WVFBQk1Ja0FCakdBU2lSQUFNVWR6a1FvV2xFa2dLNGtwQWxleGNjckpBd0xSanFubktBeDFPUmhKQW9rVFJRcjVnTUFraldpeEFreUpLNEFNSmhJS0Vva2tDeUN5QkJNdUV4SlJnTUJRQUlMaWk0bXV5VFdFQkFvb3dtSk1ZeFJKSW1FeGhBU1N6SUZpQkFnSlJqVXhJTFFwUjF0Q1JBVENjcEVhd0V4UnF4Z01FdUtza21FeGpGbk1DakZVR0dNSWpVd2dVWFVtTVlRQUl3bGhURkdKTEpMcXprWUNnQXdGR0pFREdNVVNZeFJoQ0FxaUlBVEZGVlFDVWN5YW9Zc2t4Z0lKRXhVSkZVVVNBQ1l3Q01GQk1XTlNCaWlSS0F4Sk1kVG1ZVGFhSmlqVlJva1RWaW9rREdNSnEwSWdZVEVtR2dZeGpIUUFBa2d5MlVuTWdvd21NU0JnRXdnSUZuTUJBUkE3SEpReVlURWlvQW9rcjFqbVhaek1XWllFNnA1eE1ZUkVnREZrQ2FLTFh6SE13R0FhcU1aY21BUUVTQU1CUkppaEFEQVlEQ0NLeVVTSmpHRWt3a2laVVNvMWRVd0xqV1VZQkVva0lvbXNCaWpBWXdGbUpLQXhqR0FvNWlkRDFISTVwbHdHTEVxaUFCRUNSRUVRQmFKVENCakdFZ1RDSkpsREhWSUpFUzZEUmpGQVVJMEFhTUJqTFNBbERXaEtvS01Cam1kREdBeGdKRW9ER01kQU1Zd0JBRllUSE1hMlFYb3hJbENTQml5aURHSkpBVEdnTEVBSnJDSUdHcGdqRmtsR3JHZ0tDa1FKSmlpREZGR0F4akdFa1ZCUU1ZQ2pDQmlqQldpakNTVVFJR081NXhNWWtrc0Z5QkppaVJBa3kwU0FpbUpWQVFBcklvc285SzhDa2tGa0JBVElsMjNsNTZVQmxva0tLN3h3S2dNTlVFU0ZCaW9CQXNVOFpnTXVFUkJWQkpXMWxFa0JYSkFsZ1lDZ0pFQkFGUkpNemx4Z0V5NUZFSUdnc2s2VnpQUWlTWW1rVEZDWUJpVFVtTUpKUmhBeFFnQUdNWWdTU3hPNWtnaFVza3gxQ3RBSlJqbUlnQ0lFcWltQXdFbGlBQ0JnS1hBS1VZeEpWQXhZa21NVVZYcFBNYUpBUVhJbUtOUVhWUkFDWXNDaWlCT1ppaE1XUVlnc1FBa3dsUWhVZ1VRQlVhc0poTEpKQW94SjBKQWtrb0FBMGRSQW1neGpGR01TYUFUb0FWaGdNRlk2bkEyV3JBSWdXQUdBb3hKaktvQVl3RmxuTVRDYWlBUUVUR0pLT3B5SU1XUVl4bHlRWXhZa0FBcmpBSlNTS2hoQURyRUJZRnJSeFRBcVlTRENnV3VJS0JOTFFDQjBybUVRZERWQmNTVFFJeFFtTVdlVWtrd21FVEFZeGlUQVlSSUtFREVpSklIUXh6TXRwSmlVcFFCRWtSVU5HTUltckhwU0ZsQXFxQUJLQXdtTUpSaEpFa0FBNkNCSkJRbUpUQXRHS1RxQ3dJZ1VpdDFva2JLQW1YQlFNa2dLb0VwakdFb0swSVZoaUNseUlsSE1veHFvVEdnamFZb1RGR0pNWWt1RWd4cVNqb2NSTVlUQVdZeGpHRW94eUpFd2lCUUNBQ1lnUUFveDFJRVNUR01VWUJMSUlNQUVpSml4QWdva3hSaVJNU1ZGRTBpWWt3R0tBWWtER0V4aVRDQUNKaEpVRkFRRURGMHhSQlJKakFZd2dCNkRtQnpLQURHQURDSmdKWEdRQVNpU2hVU0N5UlVNWXhpanFjRXNEbVpjSW9IWmVaSmloaUJNYXJBNXdEUVVDQkM0b3FBc3hpam1jU1N6bVlWVEpoQWtUQ1FBaVl4aEF4SmhUTElnSUNZd0FJQ0psd0RFZ0pyS1gwSUxrQnFERkdLS0FTakFZZ3hoTVVBQ0JqRkVKbEFSQlVTazZrcWdCaTBvdXNBeHE1bEtFUlZTZ2FCUWtUSmhFVEFZUkxJSkdxZ0dzYUVhQkFZeHFTeEF3QVlEQVVhRUJyb1djUk1ZNkZITVRtSmpHTWRERkhNVEdOV2pBU1lveEJCMEdwaWhLSk9nbk13Z0lGQVNTU1VSR0F1a3gwSk5FbXFZU2dNQmdLb2pDQkpRMUppaUJqRUFXSUFJR01ZQkFRVUF5VVlDaEVTaURHSkVCQXdLcDBJTVNVSkpnTVlrVEZFR01CaVRHTVphSVJNQXFGQUltQktKSU1KbHhrc1FVTVNYRmtFazE2Q1RuQUJOVWREbWhLMFNVb0lDV1NjQ0NpU2dKTEV4SW1KS0pNQWdkQ1FKTVl4a0ZRTUpSQW1RQVZ3aVF0QVNZVEpwS3Q2blJjWWl6RWxtTVlnN0FXSUVDVUlFbUpPeHhFQlNSV1RKMEJReFNlazVySkltTFJMcWdKaVRXeVVhSkN3SUdYQUpoU2dLQXdGRW5RNW5RS0lvMmpCRW1xakdBc0NpakFZVEFCakNKSTFVZGlUR0pNVUJqRUNVUVVGWVFqR01YUVhDSklnU1FTV0ZFWW82R01TSklpSUdKTVlUbVRBVUpkU2REbWFNRkdSVkVnVVNKVklRSU5Zek90a3hnQ0tBQ2pHSkxKTUFrbEdFbFFESWxHRXhpakFZZ1JLQVNWQVRxU0FHQUJKTVlRS01Zd0dYRWdKSmpvU2ttRXk0Q2dLSUZLSk1TWXdMU1dXV2NWa1R2RW5JeFZVZFR6UkpqclhNZ1RRR1FYR0VvNkVIRWdRTE9aaWdFeGpBSkJSZ0VRQWt5cUpLSzJ2TXlZeTR3b0FTVVlRWEFJQVdFbDJxSjFqYWd1QUN5Qk1VVUlpSUdBa0NUQ1FZeGhMSktNU1l4Mk9wQnlLT3BCa29xbU9aSzRDUkpNQ1l5cEpoRXlBbGd1czBCanFZbXRHTUdsd1FsMUlnQWlKUWhVaENZa1RGR01KUWhTRVk2RWdZQ1Jxb0FyUW1Fa29DaEVpa3dHR0Frd1ZpNG9URWxtSUVUQVNKQW5RNUVuUURHTWRUbkFGVVFFSkloV0VtS0tKSk1Za2F3UWdVWUJBQ3pHSVhHVEFJbk5jSmtDaEVCS01BRWpWRXdsRWdKWkJnTVNVQUFaYVFNWW9CRTVDWmNCaFNSTVlUREtWakpqRkFTc2dZQ2pxUWtHVk1sQVVCYXAzanpHcEppTkdKTGlFbW1YQWJUUXhpVEVBVWdxQmpHRURHQ3RXQ0xpVEVwakxqR1RLS21STVlEQUpJbUtKRURTaHFDaEtSQTYyVW9BbU9oek1kQ1NqRkdFQ0RITUJKRXhSSW5VQUlNSmlqMWtFMFZXWE1wTVZWeHlNb0FFR0V5WlpNSWlZeVlzNWxMcktDRVJKcGhFTkdKaXlLb0RHTEE2RW5Tb0pHQXhRR0FTU2pvQVZaeml4SU1ZUUtxWVJyUmdBQ3pHTUJxUkpNTUJoQ2dxS0tBU1RBWVJPWmdBUkVrVEVtRXNJa2FDQWlqRTBDSVJSSmpBQlJnb2pHS01Za3hSZ0FGUVRDWUNWVEdURkNZb0RHQVFOU1RGQ1FZeDFJRWd3QVlURXFwakZHT2drbk1ETGdBeUpnRW9UU2xZbEVDU3lWa0RGbUFsTVpWTUFtS011UFRIa0dzTUZKam5BaFRMZ05vd1FHTVNZb1NRQXhoQXdtQVFFREVsQW1GUkJSY1VtQXdpU21VTVVZQVJXWmNhckFUSlFVbGlVYUV1cEVrd21NVUJCSUFZUUVvd0FkREhNREdLS1BRUU5nVEtHU2h0QUppVENJa21UR1dTd0VDRTZGS2lGZ2FFeFpKaWpCb3dEazZZd21NSW1LQURBWXhpU2dNTVhTUVVhcmlTVENCUW1KTUpoS0lNQnFvQ29CT1ppZ0FvQUVSS01Zb0NDaUFKTEpBMEpxd1FHT2xKQmpSaVRFZ05ZVERHQWtCWEdUR0xNU0JoTVlRQVJVTUlBbU1ZbFZFU1NpeEpLQVNUVURBQklpZENCRWd4SUNZb2dvQktKRWtDaVZreGhRQXN4aEJjSlNTU29CSlJoS01RQ1VTSkppZ1hvQkowT1JoaExJSk9ZZ1VBR0FRTUJqQ1l3QVlrc3dDU21YTG1WY1pjU0tTVUNaUWtzRENCakpDMEppZ2lUTHFEUmlxc0VEVlFnZFJpeWFzNUdBVEFCaVNqRWlKUUZFaUIxT1pCakVsSFE2RWxKUkt3aVdzVmdKakdLQUVDaVJWQW94SlNVS2dBbFV4aWpGRUNWUUFoR05TWVNpd0pFQ2ptSlJKZ0VUREYxSklqUkNZeEpaWklGR0FUQ1NCWk5BakNTUUpnRVNRS01XRU5TSmhBa29ERUhTSUtBU1RDV1JXQVlBQWt4cW94UVFHSk1VdVFBc3dHSktBVEdBUk1JZ29kRVR6bUJSS0F4MEFEcUpKZ0pNQlFGRkVGa0FZb2drQ2pHTVl4UUNCZ0pNdEVraWdZb1FFd0ttUUJVa0JNWWs3SElVQkpNQllLR01VQVJoTUFFQVpGUW93R0FUQUNXU0JsREFVSkJpU2hCTXFKSmpHQWtwY21KTldreGhYSUtDbEtrcVNaU2tBTEVFeDBvTVlZc3hWWVNqRW5Fd0dMQVFDTlZHRW94akdBa2tUREhjNlZ6U1FBRmtvUUFUSmlUQ0pnRVJKRmFRQlF4U1VKaEVzNTBpWXdBYUVhU3dNU1VhTlFZUUVDUktNSUdFc1NRRVFBc0RDUVdBRkFZd0ZnWUNUR01BbU1ZVENNTkFBWW81bEFZd3dFbU94ek1Lc2M5Rk1SSFFra0RGVmlpQk1FQW1NQmhBeGdNSmdKRVFFb2d4bEU2R09Za3Jpa3hRQ1VVUUJnTUppaTZBZ0pKRVRHSk1Zd0ttUk1JbUFvbFpNQW9BSmpMaFRLa0dCTUlGbHJKSUltSkVrREZFclFKam9jb2s2TElpY3dNaVN0RW1NWXhqR29OQ2tqYVZvSVJKSkV4UkppakdKRXhKZ0V3VmhpeVFBUUVGVEFhTldBUk1aTVVZdFZBd21WRXF6bUVraXVBc1NUQldMR05aU3BoTWN3Sk1ZeDBMSlFFQ1Z4UmdBVElHRVFNSWxFckJSSjBKTVlTeklpQWhXTGdOUVVJZ1lBRVRDQmx5VVFZQkVvQkdNVFZDU1lvQU1JaVlrU1NqRkFKSmpFQ1lxTlVqR05WUVVDdEdURW1NU1lRaEJSRUFNWTdITTFKQlJBUmpFaUJxb3dHTVlJb0JOV2dBVEdCVk1aUkFSRUFNSkJSWkpJQ2RBRUNqRmtLSUdFeTBtQVNqa1paUktNb21KQXN4akNJZ1dTWXk0bEpMSU1Zc2hVRUFNSUNZVEZFa21FREhNVEdFeElnZFRqQVVBR3R4TVpBVm9EQUpqQUZBaENiVERFd21BREFZQ2hBS1NZb2t3Q0Jxb21NSjFPUUNDMlFDWXk0UWlxb3dKWkpabHlVWWtGd2pZR2dFeGl5UU5RWW9xTWphZ1dKd0pFb2t4am9DSUFDMkpBQUpreFFrbUtLTUJDcFFDQWlVWXlJR01kS2dZUnFUQUppeVJNWVFFRnlZeGlpUkV4aGdOV01JRkVtRW9vd21BQkVTU2dBeEppaUlhb25Kb29ocWpHQXhJa0NZeG93TGdUQVl4Ulp6cWdBcUpBU0RHTlZGQUJqRXhoQTFhRUFNWXk1TEJReUJRRkVtQXhoRWt4aE1KZ0tBVkRKaWhVRklNWVNWd0lxa3BpRHNRWW94UWtDZFRtVUN5WkpPb0hNd2d1S1FNQWdZQkV4aVJFa0JJQXdtQXdIUTVRQUloYmpSS1l5NFNSTElNWWFBTkNZMUJVU0JJRmdZeGpDUldORmtnWXhncEdKTVdTQW1TbW9GSVRvUXFyRWpTVWdDMklwUkZTSWpDWlpzVFJKME1CcURJRkdXakZDQ1NRWUJVS0E2RW1NQmhBeGdBVXBVRENDSUZtVkpTZ0VUR0pLTUpKMHBBSXdoU0pSaVFHRUtSTVNZd21KRW9JbzFWR0NzQlFHaEF3MVpSSjBBZ3hSUXdBSkJGZENUR01ZeEpoRXhnTVNCUklnVVlSQWtDakVsRm5PaklFU1FNQWsxWUFVWW9pQW9CcVl3Z1l3Q0FGR01CSllHQVRBV1FZeFJRVm9rb1RHSk9sTVFKSkpRSFFEbVlrc2hZTE1tTUowQUNSTVl3TEpTQWdCaEF3Q3RFb2dKakdFeEpRQUJpZ0pMSUNHM21sa0FaY0IwQUFDTldLb01NRUZBZ2FFd2tpQmlnSUFUQUlJcUJvaGtrbU1VQWdJQ2t0Wk1KSW1YSmhKVWpGMEdSTEVTeVNhREdPa0NVVGFEQ1FXWTFRS0ppbEN4RUVra0NUS2lJbUVrREVpSUdBcEZjSUdLUUVvRkJSTVVTWW93bUtJcWhLSWpGaFFZVENKb2cwYXVsWTVtTUlDVVVSRkdyREdxVENKb0FMb0tFeFFDV2RDQ2F4SUdJakNZa29Dd0xBZ1NSTUJpakNZd21KQUJJTUluVTVrd0dLTUJKaE1OY2l6R0FJU2dOVXhSSW1KRXdGQ0FHTUJRQUpJblk1R01KUnFJU2dBUUtwaVNURWdXSlJCSUZBdkl4YVlvb2tCTVlUQVN1QkFza3NUbUJKUktnSW1FUUV3aVlTam1BQ0Frakd0RVRtQlNnSFVDQ1RSVlNWR01KQTBHQ0VRTVVBVk1VU1lEQ0pnSk1hc2FNWWtUR01ZREZJTEltTUpLNUtKWERHb0VwRVRGRlVCRWlZc3hKZFFNSmlSQXhxVENKanFRQ1NaWkFva3hSUmdBREdLQURHRk10QVVJSkpSaFhGR1JBd2lZMUlraVVKQmhLSkVSTUlFakZtcUNTd0F4akZBQWxMUkJqU1VWUUFtS0xBc2tvZ3hSaXF4ek1RQmloSktnRWtTQ2hBQUVhY3JPbGN5VkRJQ1lrQ2dFb1lnZ1JBQUVCR2treDBpQU1JRlZNQmdFd0NTWXdHRXhqQUlDVUpCU2dwaG9oTVlRS0tJSkFzRnhTU2RDVG1CME9aQWlBZ1VVS2drbU1CZ1NSWEpnQVNUS0dNbUFRTUlDSmpDQmpDU3VBb3hNbU9WSmxvd21JQk1hVU1XU2FrSXdtQURGR0pwb2dnRXdGR0FwSlVBVENRQUZnSmdNV2N6Q1lTUVhDU1VKSmpGSmloVEwwQ29qR0U2RUdTcmNZa3N3bk9LSnFnT3B6RW94SmptWXdnVUlGRW1NWURDWXdtRVRBVVNKU0pnQW9ERm1BVEZFMG1qVW1Bc0FFd2lTSUdNZENRTVl4aGlDalVGQ1lrb1NnQVNnTVlEb0JpUnFoSklLakdFc0JPSUNJaUVVYXVZRkZHTGlRcVFLSmwxZ1lRRUtxT2hFVWNnS0UxQUFKUWtHakFTQlJqRWtpQlJnQVRFZ1VZU2lRTVlTaWptQllGR29paVJNWW9DVEZDQW1NSkpCaWlER0FCRTZnWmNXQklJTGhJUUVGa3dnU0FtUkJRd29raVpVd0pqQ0JnTW9ZWk1GU0t5WVRHZ05RWVl3QUpoTUlHQVRFR3JRZ1VRWXhZaWN5VkVveElnWXdnQmpGbk1veFpKSlJKbEJNQWxnaUtyT1dsektzR05XcHl3MGtrbEdLQ0tKckNZVEZFRW1NU1VZeGl4Sk1ZU1FFeGdFUkV3Q0FtUktBU2lSRVFPNXlNVGJwS0NwT2hnS01KZ01ZeGpHRXhSekVRZ0VRckZDQkpqQ0FtRVFNSW1LR3JBczVFZ0ltaEVra3NEQVl1SkpxU3pzUU1BR0NwRWlXeldTWXhnTE1FSUNTYWt4QUNKaURRbUF3aUJKaWdKTUpqR0VERkdBa3hRa2xHTVl3bEJSQ0lrQVdRV1l4Z0FzZ3dFRkNZZ3dnSW1BVlNUcUJrVmtBS1NRV0NnQUFLQk1aWk1LQmlUcUpJR0V3RW1CVXNpVEdxUldTeVRHZ0Nnd3dnWXM1blk1aVNJSFU1RUNKakdJS01XVVFjMVRJR01CWklHRUFNZERtQW1FUUF5aFFGa2lLQmx3bElsSkNvMUZNYVVzUkF4UlFSaXFreGpIVWtrZ1RHTVl4UWlnc2dVWWt4akNKaklnSmdLQW9CRlVrb0JTUnBLS2lCSXBMS01TSlJpVlVUQUFRaldLSkUwRklITW9SRXdDQlJoQVJFRG9Zb3hoS09WU1dCQXdrbWhvTU1TVUFBV1lheFVRWXhxVEJBRkpKUkpvVEdxQmtWNW1FYVFnRXhCaWpBWVFBd21XU2tTUUFRRXdsckFnbUtBb3hKaE1VWUNTaEVreGhLTVNZeGF3S1NTWVFKRXhnRXdtV2dPZ0VpUVNsQ29rZ0FnU1pRdEFER0FUQ0lnV0JLaUJJQ0JLMGlhTVpacENLSkVpcUtnSkV3S0ZrSUNZQklLTVlBTUltT2h6SUtBUUpNSlJKSWlBR0xKSlMxRnlZeGpMZ0Vvd2tJbHJBbElpWWtrc2t0WXNTZ01KaTRrbWtUQ2RDam1TQmlTaEV4U0FMSlFBQmdNVUpqSW1BVEdLTUppVm93RkpnS3BFSXhob01kQU1XY3pHWElsQUJNV05TWUFLaWFSTUJqR0V4aEtFb3dGZ0IyQVRFbGtCU0FnRVlEUVVnYU1TWW9va1JDcGpvUWFwTUpvazFVQUdOSFE1bW9KaWpHS0NxSWdBREFKZ0F3QVNkU1ZTa3hJR0V4UWdDNENVb29RQVFFeFFnSmhNQmdLTUJqRmtyakpKQUZnQWdJbUtNdEFZU1JJQXBNU3NvQ1lER01DaVlCQVRDWW9rc1FKVVRFbUV4QzVFSXhsS0NZVERXS05FZ1VZRndwakNjd01BaUJpUkFvb1RrSUNJR0pBQkpMQXdrbGtDb1VTbUVveTRreGhNQ1l4aXpvUUt5S0taWmgwd0ZHTVlvb2dUQUluUXdGbklreFJCWXBnTXNpQUdFQk1VQW1Fd0pSaEVDU2pHTlNhQXcwbWdGV3pHS09oSkJqRENGU0lsR01VTVFKQlZTQmhNV1NTVUlsbUV3bUpxeEF4Y1NVWVNDeVNUQUlBSmdORUFXTkFsUnowMEFtQVNpWXhnTVNORWRUa0FnSTFvd1VnRVlRTVVCSUNJRWlVQWdZeEpoS0F4Z01ZeGlqR0JSRXhaUkJoTUpKUnhMS1hDaUlBWWtCTVNZQUVWc29vbzVwekV3cklBblFoWVJKTVlER01Zd21Fc2t3bUpFd0dYSUFVSkFLR0dqTEJVbWlER3BLaE1ZeGpHS0lNQmlRTUs1TUNMUWluWmVoNVFBeGpDU1FVWXdGcmt3QVVTSklMWktVaTBSM3M4NHFDSkNJQ1pLRmFVTWdpckpHaW9KMElMS0F3a0FXQjZEb2NBT1lDSkpSa1RFcmhBREdNVVNJbUVSTWxFaUFHRVRHS0V4Z0dtS01wWlJFVlNWSE9nb1kxWWtDaEFveEVCSlJxREJGVlFnWXNUc2NoQVNERkZHTWFpTEtBZ1JBa29BSk1KSlJKaGlqVlJKbzFKSmdDRTFFQUZrbU5XaWptZFFBQnFqUUFBR0F4UUVtTVNVVVNVU0FtTVNCUmloQWtSSkVER0VWVWdzeGdPaGpFbk1TaXpLQW1MSU1VQkpqQ1lBQXNwUXdDaVlrRkNSUUpYR1JKSktNQW1FVEFKaEtBeElDVW9rQ0JnQlpNYW5JTlFhSklLS3FvREdFRURxdklRQUNpQkVrb2xGY1lzVG1CQlFGRUFKaUJPcEpSSUFXZFRrU29VQ1pCclJyTVpjWXM1Q1l4U1dBcmpKa2xXSFNSS2hyQ1l3R0VERm5RU0NTeUNCQXNVd3JqRUdNU0pnRW9CTUpqSlppUUZRVVRFbG1BUVdoc1FYV2JKaDAwWEhYVGlJRUZHTUFtQVNZb2tCb01hRWF3RmlCakNKWUdMSktJQ21LS0lFQk1TWVFNQUZBYU1CUmgwSVl3MEVtakdYR0pNaUJnRmFTU2lER0dxQUlCTVlrQkF4aE1XQkpqbXRuUTVFblZNU0poSkVBTUlFbENTdElsRWxrblFCSkV4Z0ZhRXhJSlFrbUJjQ1lEQ1NXWmNZeUFpUXNrbU1JRWdpU0lnSUNZeGhLRURHcVNJb1FNWUFNU29ZYWpMRVdVZEplWmdFa3duUW9sQXBZRUFGVUJURWdTSmdLV1VSQXdHTVNaY1lURkpBTFJKMFNBVUVvVWdGVEpnVUtFbE1Lb2xKSWxBRllZd1ZoS0tKTUlnWWtST29Gbk1ra1FMQXF6RkV5Z0FZd2dCYUFDb1VVUVdZeGdLSlRHRW9EQ0JocEtpUk1UVkNXVWN3RWtTQ3pDWXhnQ0tDa3dSaEdzVVl3Z0lHS01kQUpJTEtMSUFTakNTUlFFWUNvQXFvd0dLSnE0bXNhS0lBd0dNWXhnR2c2QUJaQm9UVUdFSUFHcGpHTUpqR0Vra1NTZ01ZeEoxS0FEQUFnWXdtS0lWVEZHTElMQW9TUktNYzE2Q0FnSkpLVWN4S0Vnb0NRTFhDQklnU1NsR0F4SmpHQW94SmpHRXNLb0RHTUJCb3hBRkdBU2lTUkFna3lvUW1FQ1FLcWdoTUFGRWlaY0tVQklBSklDWUJNWXhqRW1LTXVUQW1YQVNVWWtSS1dVa3hhd2laUVFCS0JLQXBjTkpvS29tS0lxaEVUR0tFZ3hnS09nZ2NqR0FvVERZZ0VvQWttTVl4YUlDb0lrbUVBS0V5UVVCWmdNVVlhMElHTUdsUUZnVWNqR01JbU1JbUtOQVRWRkV4UW5LcU1Zb2tSSkxPZ0FZeGhNVVFVWXhqRUdBREFNV1RVeGlqRkFTYXJHQXhqbVl4akdLTVRTZHppQlFCRkdwTVNZbU5XTGlBQVJNWXhJR0F4akFKWUdLTUFDU0JZRkFZRnlXWXhSakdBeGlTekdWTEFTQ3prVUtBbUFnVENBTGpFaUlHQkVCSkFreFJpVENBZ0pRMGdCaEpBMFlDUk1ZeGpFaUlFRkx4Q0E2Q0p6QUtvcUF3RWxraUs0eUpKUkJnQXhqS2daTUpsQlFFVmxBVXdyQlFnWURGTEpDV1N1UUZjVUJrUU1XYXBNSlJJbEVtTEpFVG9BRm5Jd21FOUJCamlBbUtKRTZXVVFwSW1JQVRLQ0tZa1Z3Z0lBSmlqQ2dZeFJqQUppeVNqRWxWSlowQTVpWURGUmhNYWdUR0pFb281Z0lpVUVJVUFKMElFd0dMRXdnQUNKSUdDTUJWSXhJbU1JQlNhTHJCR0VnZ3hoQUNoSXJIUWt4Z01ZdUtKQUNUR0F3aUFDU2RBS0FEQ1NBbUVBRmNDSklsQVlvQ2lSTVVZd0FVQWxFZ1lvVnlVY1ZvVElnQlJSek1KbFFNbUF4aVFKQVJKckFhRUNpQUpFU3FvREdLRW9DQ1NpWUFLQXdnQmdBa3hKVXRFa2lZNWxHQk9peEJSVmtGUkpRbUpBQ0JMSk1XU0pKUUFaVVV4SWttS0F4aWlCTVNLcENKakVya3hTcENVSkpacVNERkRXakNKaEVUVlVZQ1JFa282Z0J6TVlvQ1JOWlpsaVRBQW1XZ01aTUFLaUppZ0FvQlRDWVFMSU1KUUNTSmdySFFUbUlBSmhnTVkxVVdZb2t4aWlTVENKaVlSb01JbEdNVVFCaEVCQ05XRXdCRW1MTHJuQVdZQUVhc1l4Tk1TQkpKakNKaElOU2REa0pRR0dNSWtpU0JnRVRFZ1lrNkVIUWtvd2tDQWlTWW9sUkVvb0RBSlJnTWRBQVNSS0pNWUNpUUZVVWxjWVVDQk1CakNDcEprUU1kQUpBd0ZoVWtreGdKT2hJRkFOSlFBV0JnRWtTWW9rd21BU1FFbzVBV2EyQU5GUkp6S01aQzJScENBcUxBeGlBTVl4aVRDZFRtWUJBeXFJa0ZFbUVBS0tBZ3dtTWN5eVRLZ2xBcVFpSmhxZ0NWR3dyWlhVQ1VKMFNDdFZ5d0dKTUIxRTVsbEhNU3prQUZsZ1NrbVZBd21NVVNZd2dJbUF4akpRR0tJV2hSTUM0YWtvVUM0d0VtS3FUUmlxWVFNTlVZeEFpU0ZVTUFRR0V4akhTdEFTSTFnS0pLaERUUTVOVHBVVVNUR0V3Q0ppUk1ZYVNZa3dnSUFVQUNZS3hVWWEwQTFSb1FFQ2FRaEVTU1RHb0tOR0FTVEdNQlJJQ1lUQ0lBWW9Ub1NZb2dEQ0pZQUpBbEFBQ0MwS0ptdWFDU0lDU1lEQUlrRm1FUUFvZ3hRVkVTSkpSWWtHSU1YV0F4UmhMSkE1aVRFbUtLTUlrckJhY3dNVUN5S1NhSVdnQUUxdUVCRWdZc2tRSkVrREdFeDJPZFlJUU1vaUJSaUJFUUV3RUZFaUFrbVd5QUxNWWhPaEpSTmF1a1FZVEZHQXN3aUlhR1hRQ1RHTWRUR0tPUkpSaVFLTVdaQUZER1FVS0pNbUZjSmpFbG1NQmhBVVRHRWtvbFV0Q2tCR0tLT1lVUmlURkZHTldLalVrRmlVUUFtakJXSUNFUk1hc01BbXF6RWxSSVVqQ2F1eEJKUk1JR05RWWt4VUkwR0FUUmpBSUFBaVVBVlluT0xHc0lFbFFFVmpDWTBBR0VveEppU2hDbUFEQUpqRW1LSUtNVWRDU2pBVVNKSmpIUURHT1owSkF4Z0xCUkFGeVlEQVlvbzVHRVFNSkpSWUVnU05WQUJKakFCUmlRTVVKZ3F3TWRUbUpJaEVraVVCUUdKQWtRS1dTUVFBWlVsSkcxSkxBQkEwSmdFeEpoSkF4UjBOVUVtakdMTUJoQW9ra1JKQXhqRXFnSmdNWXNRSlFNWTFWUkZHQVN3S0V4Z0tEVFpZU1JNWTdGa2dTU1dTU1lEQ1dtWEFCS1lWQk1tQlV4SlJqMEhJa1NURkdTaUJLQXhseDBTVFVtSmpGSFN1Um93bU1BbXBMalVHS0Fva3dHb2hJS0NNWW9rS3NJa28xWURxTWN6YU1ZMFVGWUNqREVITXVzVUpoZ0dzSUNhSk1ZeFJBTFprZ1Jxd0dBMVNVQmhnSnBFa1RSSW1MSU1Zd2xBYXBPa1NCSlFnSmdNWW9vd2dKZ0pFREdNVVVTUUpoSUtKS0FBTVNZeFJqR0FEQVVKUkpSQlltSU1hazBTUUFBWW9TVEFZeGk2eFFpUVVCanBISWd3aWRUbUFITW9reTRrVEpJR2xreVNOcVlvU1JJR01Ja2dKZ01KakdLb0VpS0pBU2dBc2t4aVNpVEFZeEtZeGxWUUVzQUpSRllSTlNZVFNwVktZUUFveGpDWURDWW9zQ1RDY3hNWWdzeGFaUUNUSlpLNFRKZ1hBWXduWTVpU0pRa0FKaFFBb3dXcVlZQ2x4enM3QVRFaUltcEdFREdLTU5kU0NZeEpxYUlrMEkxakFZWW9CcVNoQXdFbEZuTW9veFJ6TktvR0RUUlFHaWpHTEF3R0FCQW9sY0JLVVk3a0NZS1NhME1CakdDMFJLQXhjWWdURmdCalVEQWF0QUpnS0FEQVVCakZMU1lrREVnWVRHTUJoQVRDQWtnSklnb1VpVVNCaWhBQk1VWW9BSU1TU0JoTVl3R0F4aEtNVWFna0l4Z0xFZ3haZ0pXU0RJZ3FCQUZBSVJCZ01uUmNXUVlEdWNBTUpSSW1KMDBhSVNoQmVwekFER0Vva29ERkFRZENBQXdHQXhhU3VGVW93SE5LRllzYVlEb1NhV3FSUUVTU3pBWVRHRUNqRm5JZ1N4SkFreDBKT2lLNGd4U1NvVVlVbFVreGdMTzV3QXhqQ0pJbVNpUU1XYTBSQ0V5cVRTSm9CQVRWUmNZQ1RGQWFzSm9BTUpxc0lnMVlSTVRDQUZWaWlRS0VCTVlvU1FOS0lsQm9Ra2pHTUFnSWlZb0NEQ3RrQ2xHS0F4UVVrMW8wWW9nNm5PMVRFZ1l1QUNqR01BbXFEUnFvWUNSRXhKUWttTUFGTFNCQUdLQURDQmpHTUIwSUtBa2tCTVl3cmtSQUN4TVlreGpvVUpSeU9aZ0FCTVNZeFpqQ0FpUVk3Vkp6SWdFQkVEQ1lvNXJ5TVpFbFVSSU9oeExJZ0VTVVZ4MUpFa2t4aWlUQ1lEYWFORUxSaFRIUTVBSUdFeDBJRWdDVHFTWWtRQVRBVW9VSWlKNW1VcHJJNkVZUklLS0V4QjBFVEVsbUFUSUZMMUlJTUJJQVdVWWs3Z1VRQmdBdXBrQVdnb2pHTUoxVG1TSUNVU3VCQTZHQXhpN1pGQ0FveGlpeElBUkNzTUlHQXdtQTFhTU5BUlFsVnlFd0ZHSmpvY3loRVNhd21FREZHQXdEQWREblFZMEpKaE1BbUtFVEdJQTZMek1XaVlUVUNVQmdNVUl4SWtsVWdNUUppUkFvS3dGSE1vc0lCSkFTVENTQWlCUUZITXdDWW9rREdNVUJoSk1ZU1JBeEswbU1CbFV4aWpDWmNJcFpKSW5FVEdBc1NER0tKQVJWU2dMS3JrUkFCaVNsd2tKaXpISlF3QVVZa1NzcHJuV2l3RWdDakNBaVNTSllHQXhRRW1NQzJDQmFxU1NZeGpDQUNCSlpKUUFTSW1YQVVBSFVZSzRNNHlwMEVLQU1Zb0NqQ1VCUkJRZ1l4a3BlaEp5RWtER09wSkpSaWtWd0lnclFUSWdaY0JoUUtPcHpBd0NBbUFvb2t3a0ZHcGdLTUJqSFF4Z0V4Z01BbUtBVEVtRVNxQ1l4UnFrMGFnc0NveEpSakFBMENZQkVrb1RFd0dyQWRJeGlCRXdoUkNCWmhBc1RrVVVjanFBVUNVU01TYXFDSktBMUJSWUJEUVZHRXhpUW9LTUJvU0JBeGdNSUNCaWpDY3lnSk1JR0VrU2hKTUpKUklrR0lFd2dBcW9DVVVZeGloSk1KaUJFZ1RHSkVEQ0poVVRIUW81a0NCaktJRmtDU0pLNG1DZ3draU1CUWtnSW5Jd2dVUVVCaE1ZUUFhWWd4aFJXUUVUcWNER0tNQUpqRnJBaVFKaUJLTVNVdUV4aWpvY3prbUpLTEJjbXJBVUFpb2xGRkFBQ1l3Rm5NN0VFbUpNZEFKTVdBSFJDMU5KZ3R4Z2pBaVpaTUtVU2RqbUJqQVVZeGdMSkFTQ2l3QVRDWWF4TVlSS0pMQURHTVVRSmhHa1NSSmlqVkpvd1ZpZ2l3cGxDeUFTcW9reFJqQUFsSE9BMU5HVm1KTVl4UURSR0VDakFVU1lURW5RQzZrd0NUR3JCRkdMSXFnTVVhakxWakZRR01KT2s1Rk5FVkdKTUJoQURBWXdGbGttRTVpWURGQVFKaXhBeGdKQVFBUk9aUklya3dpWVRDZHptU1lRTVVaWlJBQVdUSWdVWXlpTlVXUkFCUW1XRWtzRG9vU0FuT0pyQVNXWTBBSTJ3YUxKSU1TZEFBb3drbUtKTUlhVmxJa21NU1l3Z2VvOHdnVWN6RkFZU1RHRUJNU1VLUzFSSllIUWs3UjQ3TVlveTJTaFFhR2xhaEpTanBVbEdKRWtzQ1Npd0FCTVNKSmpDV1VGaU1TS3lBRWxHSk1VU21NdlVnU1FNbEZBWUNnQlF3cGpMa1RGQXRFZ1dXZ0M1RUFLSkJhUU1Zb3dDQmhKWG9tSk1TV0lpVFRGa0xJbVNxSXdqUWFNYXNUQ0lFbEFBZ0pRZ1lTVENLeVVRSUNsRmtuWmVWZ2FNdW9TeUl5OUVCcE1UVGxCWmdyRENLd21KTUpJaXNsSklMa1RDUVVTWXgwQUZ5QkFtSkV3a2dXSkJSZ1hHQXhnTEZPWmlTZ0tBd2lBZ1VKbERFRkFTV1l4UkJJbUZFeXFWVEVtclJJaUNxSlFuTllKSU1tV293RTBsUjJPSnpvQ3RrR01CWkMybEVJZ1N0aVlvaXBLbEVTUk1JSUFLNnJPVUlBWmFFRURGQWdRVUpRRXFMam9FSnE2Ukp4c3hoTXVNalFFZEF0cUtPYVVWVkFTVUFpU1NkQ3lSQWtnU1JFc1FLQ3pvVEFDZ0dNWWt4Z01rbHIxSkFreFJrUU1Zb3lnR01tRlJNSWxLbUF4a3hTeWlXUVNDOUNVeGpvWXdBSkJhMENTWXdDVVl4cTBZeWdqWW1nTUJkYU1OU1RHQXhKUlpCaWl5U1NSQW93aXNpQmhGRTZBS3pZRXk0YXlZMHFaRTFkUk5YUElLRWlzYU1Xb2lTWUJBRlNVd0xrd2tHTUJpam9CelVSQVNSRXhJa2xtSkVETGdBQk1XUWdXUVVTWUNqR0VEQ1VaWU1KaVJFb0NERW1LQk9ncXBxcU1ha1l4Skt5Q1VVU3NFaWdOcGxKUVVSZ0FLeG9DUUVvUVhJRkdNSklpWUt4cFF4a0JBVEVBZE5FTWd4Smx3Z2lZU0ZSUkVBSk95OGhpakdPZ0htc3hRR0tvTVlaVWFFcklDem90MUpKUlFHSkFTam9Cam1RWXdtTVVZb3hRSUVySWdVU0FraVl4UjJTQ0RDb1dCaklGS2tnWXhrVEttS0ZFa1NSTVhVRkRFZ1l3aVlvQ1JKRVNTaWlTUktFQUtNS3laSkJZczZsd2xMa0tURXhnSkF4aWhKRVNTakFZUkF3TFlnbUExSWlXU0FDSmpSSlpxVENXVEVnVWQ2NFJpU1RLcGpHTUFFcUVpVVpBa29CQXhSUmdYSkpaQUxrd2dTdUtSSktBa294bENDaWtnNWxtRWtva29za2xjaUoxT2FpU1lzeElDV1FBS29nSW5VbzdMeFNSQWxZS1RHVlRDWTRLaUFuSW9BUUtnSXRDb2trVEdNV1NJSWlvaXVWS1FJRmNnWXdraVlrREZDZEJQS3RtTWdaTE1VMUJoSkVRQXdSMEF4Wmp6V1dBa21vS0tKaXF3bHk4cktLalZqQ1lUQUpqcVVRZERnUVl4WkpJblFTUU1tRlFEQUFDWW93Q2RFZ0JCVUNqR1JNcVFBaWF6VVMxQ1VtTEpBQUtJcGlxWXhKUUFJR01TVVVKUnpFREVtRVRDSWdLaUFya3dGQXVSckdKaE1TQmhMTUJnS01JR01CUUNzbGxKSlJkSmdNWWtEQ2FFa1JyQ0paeGhFNkJXaVFJcldNcEZHTzV3SkFGQ3dJUUtNQmlTaWhJS1hKWkJnVzA0bEFDaFNJR0VUR01jMW95Y3hFQkpNSUZGQ1F1VEZtSVhJR09nQUpqQUFLb2tsblk2SG1PaXdsQVlGeFNCS3lpWTZFTElBU1lveEtTVEFhMGdNQlFrRkFCUW9xZ1VTVXNJbU1JZ0JKUUFVU0JqSGNnNUZBWUJXeVNpREZDWWtEQUl3bG1KT0ZsRW1OV0tMSkFvd2xMQ0psVUJLQVFBc1N5REpSek1RdlFrU1NnRWtvU1RJQXRHSk1ZNkpKZ0ZlcVNZd0xqRkNRQlJTQmxreUkweWdvbUtJS0FERkdoMGd3Uml4TWF0R01JQVVRQlltSk1KaFhHTWdZeGpVZ1VUR0F4aHJHTkVpWXV0RWlBRkNZd21NV0N5aVVKTlVJRkhRNWdFQmpHS3RrWVNVb1NTaXpFVk1KaWlhMFVRQWdKek1KZ01Za3NBSktLRXdyQ0pJRkdFa0JVTFRBWUJXa2t4UUFRQklraVlRRXNDbHlTVlNSR0F4UUFKUUdBeGhNWTZHQW9BRURMSXBRRWxIQW82a0VtVU1pQXJCelRFeTRTUUtFQU1VSmdPeEJLWmNJR0JFVlNRU3dVSlFWTVNXQkpZR1ZKS0lMSUxJS0pNQlJpd09rWW94NWJKQVJMcVN5QkF4MEJSRXdnQWlZVEdPZ2tpWXlTUXFZVUNTUktWTUFDSUVpVVFVaUlEWGNGNVJRQUpTWWxlZ0poV1FGTVVCakZBQUZDYW9LakRTU01Zb0RCVWxpUVdSR0tKb2hOV01VV2M0d2dJZ2Fnb0JDRUFBVFVnWXhqRndFZ0pSaEVCSkVWbEtNWUZVb1FMRWtnUVVSTEpNWW9TaUNUQ0pqQ2N6QVVZa29TUU1CZ0F4UUVtRVRDc2xuTkFveFlrbUpBRG9RWXdsQ1NLNUxBQ1NRRWtvREFVQlFrbGFWSE9NQlJqRWxGa0VMaEtBb29ESkpaVlNXVVRHTlVnVEdPUlI2Qk9aelVJRXhpU0NTb2t4Z0tJRUVEb3VNVWREa1lvREdNQW1FeEIwT1pnQWFJVEdNSW1XQkZBVlNRVENvWVFFVHBFRkVuQ3pHRW9LeFFrZ0pSbEVrUkFSTUlHTWRTVEZBS1FTdUtNa2dCaWx4MEpNWXhJaVlCVENVYXJNcEFBbU1tQlV5VXFKSlNTWXdtS0F4SlpJMGtqRzBZa1lDUk1kS2dzeGdNYU5RRVVhZ3NTampIUXhnT1lqV0FUR2pDQUZFRjFKakZIUUlrd0VsbU1BbGtnQ3FBaUMrdE9CakdMT1JJR1hHUkVCTUlnWXdGa0dLQXdDSkJRR0pNWXhpUk1BR01VZENGZ29Fb2tDekdNQkJpakNTV1lrd3JSU2N5akhNREZHTVNVVVVBbk1vczVFaVVBR01VUUMwQUZGRmttU2p0VWxBVUVTVlFCRVNKeU9oM0lPS3dRQllFZ1ltSktKTEpBeGtUYXRRUmhFeGl5VnlVU1NZb2c3bkFnb3hxRFJnTVdDS3F5V1NnS0Fpc2tLblU1Q1lTWTZIVUR5V0lHS0V5TnVFNWxGbk5WQW9rb1NqR0lMQTduRXhZbUpPUUZHQVNSSkxPaUFGa0ttTWdLb2dJblVDemtCZ0VvbEtBVEVpQ3FBcmpKUVVGa3dGQWF1aEpqRXhqQ0JxeDBNWUlBR2dJb3FwRW9zNHhnQVFFTFZMQ0V3a2dKWkpnTVl4WmdCWktUb1NZb2xGckNTU0pqQ1djaWtURkVrbGtBQlFtQUFFUUVUQUFMWkprb3hCMFdVd0ZBUVpaTVdTWXlJaUN5WXlCUUZHSlVBREFsRkF1S1FKTVdZZ3hoS0U1aW9DSWxGQUJaME9BQ0FIWTVBZGFnaU1VdUxPcHlNWk1kQ1N6Rm1KRVRtU1VRUVVlalRoRXl3WXdDUWFKSkVDQktBd0lGYXJGUUdBVENJZ0JoQTVsSFE1bUpGQUZTUUxCTVpwU3ptWXlTVVpRcVhBQlFWUXhaek94NHJFeFJpbERXQWtpVVNKQjBJT2hpaEtPSjBNU0pSMEpBRG1TWW9BRUNqb1VnQWtyUUdSQmNZUk1XWXhCZ0VzU2t4QW1BQlhJaVF0SUdyQ01TWVRVR0V4b2ltZ1lnc3NrQWhLR2swSVZaSmowSG1qQVlCQTFxbUdNSUdMS0lNQlFHT2haQnpBeXFXU1lUR1ZBd2tnVVl3aWdKZ09ZQ1VTVUpnRXhKSjFBREFZRlFNaVl4bEFSTUFrS0NTVVNLWW94SzJCS1lTVHFRQzRTUzBneGhVTWlRV0JJRkNZNkNTSktpVVk2R0U1bTA2UXh3TEpLTE9aWjJyZ2NvVEtGQ2RBS1Nqb2NpemlKWklnU2RDU0NRTytuS05MWUVuRXhpNDVHSktPUlJpVG9TZ0s0b3hqQ0FsRWtnWXhqRUZIVTRDWUFFQkF5NG9sTElPcHpXUlNpUzVZSkxKTHF3aWpvU2VMVXhjSUdMV2JNWURGRW1NV0lnVUFBVW5RNHJaSlpSUlJ5T1ltTVNKaXlpck1FQUNCaEpWUk1xU2R4SUpNaUltSkhUUzlwT1FGQUpqRW1wTUFEQ1lCQVJyQ1NKakJFbDFRR0VrVEdFUklBNkV4QURXS2dNTkpVWUFLTVkxQmpFUWlkU1FNSkpSaEF4Z1ZTUk1Xc2lXbUpNQlp4QXhLcGpJZ1VZa1FNSWxHS0pFbFlTekVDb1NKakFTWURGa2xKaWpBb1NtTVVCaEVnVEdNU1lRTXVBNklrR0U2QVdXSnlNU1dXU1lGa2JLTE5EVXFwb0RyYXB6T1VVUW9CMVNpU2pGVkJoRXVXQzBDQUJaVEVyMUpFeGprWXlKb2dGa3hqRUp6T2l3SlJpaElNS0MyWTVnWW9rQ1RGR0xPYXltQkVvZ3RZVk1aRUMxa1V4QkphNDBVWVRrVlhVWWs4Mm9sUmloTldBUUFRS0F3SFFrNkFTWkxJTXRBZEJNZ0JDK3c4aElpSlpTZDY0RXhqQVlCRVRHVUFzdEpFa3drbUUxdG1ra3hqQ1l3R3JHaEVUR0FRS05TQUdFQWpwV01BbU1CSW1MTVFZQzQ1RmswakdLQWFtS0lLTEpBUU1CSWxsbUlFREdLQVNpQU1CMEVoWk9pZFRtWUNDaE9ZbUlFREFkQUpFd21BVEFXU1NxbU1CaEF5MFFZREVvTFFvR09oQUtHU3lBS0tFREZBQUFJZ0Jsb3RPWktxSlFFRmxtSU1VWW94aVRvVlNURlZRUmkxN0lublBRZVVsWkVVc0NoTlhNWXhpU0JFVEtuRk9pNDZIQTdra2tBQ1lvMGMxa2trU0VWQkpFVENKSUpTNHhKaFNRTXNWb29veFJ3S0pSQW9GcFpNSktLZ3BqRUZwYlhLR3pGcUFkREhTSlBIcVNkSmJNVWsxUUZITVRHQXM1bU9xcUppVEowSU1xQjZqa0NXU2REZ3FZNW1LTHM2RkVCQ1ZVeEpnTUlnb0phZGE1eEFrbGl0R0FRUkFTUUtKcEtBWVRCV0dLQ3FpVFZnRXhnRUN5S1lrUUV3a2xHTVNKMk9KSlFGUUZDYlF5REZBVlVqRWdxWVVSTVNZU1JNWXhpU2dNSmpMam9tTWN5akVtSUF4aXlRQW9CQUJJVzBveGlUQXFrbENCaUNsQUV4a0FsUnNDanFRWlpBVXhpUk1CaE1BQ0lHQVZERWtpbEZsQVVZb3hJRmlKakNzbENabVZSV1VzN2xIbUpMV0JMS0pLUkxybVRFbVZRQVJWRTVuY3M5UndKT1J5SU1TbUVjb3RDUUpKQW9rVEFVU1dCa3l5WURHb05Vd2t4aWpBV2NnRXdJcXFDZERrWVJTUVhKUm9VTFpNcVlveDZZNW5oMWxxczFLWElWWkJSSmlpU2x3a2xuUkF4SlJpRENCMk9aUmlUMW5rTUlDSmRXYUF3b0FKS3lZb0RKSjBNZWl1RWNUTDBMTVVaRWt4cUNnZ05TSmNRQWhicExDcWdFMUJSSmhDc0VVSkpqQVhSQ1NVVVNWVUFkam1FSUdpeE1GSklRaldLTVRFbUUxQXdnQmlDakVpWUNnQW9zZ3hRR05hSm9DUUtBd0NCUUZFa2dXWURGRWdCS29pQmt4WkFHWEdRRXdBVVVDMEFrbUVBTFRFbk5laEtVSmlSSUVSSVVqSVVpV0lnZENURWxuUWt3bG1Nc21CQVNTajBsbmxXU3lUQ2REcVNsa21NWTZMSklJSE5laVNVZGpIcFBJWWtrNWtLQUowSmprUVlrU1JKTUpJVWdFSmhJcW9BcENpQ01VQW5Nc281Q1lnb1ZESFk1RUNVbUpscXNLSkNLbHVqb0pRRVJ5MUlsVVJYV0pSSmVVMU5ZU2xva0N6SWlTWWtTZ0tLSktKUFNlUURGaUppNlRRQ1pBQkJVREdCTVk2VjZUeVJ3TFd6b1l4a1FLb0lFWVFwQTBJR3BYU1dhc01GWXhCUmpCV0dNSUdNVFNYQ1NVWUFyQ0p6Q0tLTkNVUlNZRFFCU0pqRVFpYW9PMEJpUk1JRW1FREdFeDBPSmpxY3hNcUNCQmpHTUpoQXdrRkFVSUdFZ0RBdUtPaHhMUU9SMUpCY2xFRkVHQXM3RUxBbUFEQVdXaVFRdUZFd2dZa3Nva2hka1djNlRIWVJKS0tNQWlCWkluUWxhUG9ueTBER0U3bEhuVUtBUUxPcGs2blVvRENxU1Fsa3FKNXhNSjZEeWtDY2dMV1RtV2RDSXh6SkFra29ERWlGQmhnRURVUkowaUt3RWdKWnpFZ3hSQlJnTXVMTUFGQWxrU2xBcElpckJWRmtDWEhuc2xhRkFvcEMzR2xBclNkRG5TSUZMU1lRTVNBbEFkZ0VTanpnV0lpQlFtS0pLSk1JQ0pJQWlaYXJzY0lrVVFWTEpRTFhWaklERWl1TVlveVRWR2dPbFlRSUFveGhBd2dZb2tzaXJDTVlvQ1N3S09aZ0VSTVRMck1JQVlDaVRScUNZU2pGQ1VjeWpFbEVBWXhoTVdTSllrQVVKSkFHVktKTWlZQk1BRmtFR0tYRUltVUxUb0JCakFZd0FVc29uTVRDV0JKMU9ZQXRFSlpRRUdNWW93bUpFbzZISWdRVUUwVVZaaFVUQUlpVUlGRkVyajBubFFNWXg2VHNlTlpNVUprNkZIcE81Slp4SUFSQW5TWUplWlJSenM5a2Vja2trQVhvZWM2Z2N3Q0FvNGdBRUdPZ1ZRRlJKSlFnWktYbVNZRENCaE9WSlVTQWdLeVVkRURFcVFnTmdaYUpNS0VxYWtzSTgxbmNGd0ppd3JCR3JCRFpLb0ZDSjBKRWdUR0VEMUhJazlaNUNpU2pBU2RURmlVY3pHTVl3Q1NRS1l5MmRLNXhLVUNvQ1pLTXBRaVlZRlRFaVVaTlFFZFNxa3hKQlpKUmhNVVlDaUtSSk1NWXNrRENVQkppVEdNWUpTeWlDaEFrU2lJS28wU1VTVWRST1lpVVNCaVNTakZrbEFkQ0RDSmlDVEFxQmtvQ2lUQ0JSSUNZeWdGRW1Nblk1bU1Za3hpVEdWUUpNVVk2SE1vQUpFRkU2QVVDd1lVREZHTVFkQU9ZRkdYQVdhVFYwTXNpWWtVNkFVQW1PYW9rcFJnTWR6cWVkWUVzU2tvNm5VNkNVSjVST1lnRlNFSzhpazlOZERsQ0J6T0Jsb1NTd0pDSkU1RWdKekFSSkppcURIUWc2bkVzZ0RFbEZBUVlBclJqRWlLaGhTQ3pLeHFDRXgwVUV3Sk1xYXFFcVBOWWxyMU9aak0yc2FYRUdDSFNZVEdFc1N6RUNjanFZRDFHQTZuaUVCT3BCSml6RklDWXk0a2tvd0FVWVNxUzVPSWxMSWdaRUYxbEdNYVZFYkFWQk5JRVcwS0pCakVsQVlRS3E0b3NnNWwwRkV4aVNoTUZkRGtNWUJKS0lOS1dZREdLSWdLQ2dZUUFEcXRvbklSS0VnREVsQ1lza3hSakZDY3dBeXlKZ0tSTVpRcEpyc2M0a1NUS21Bd3A2Rjh4a3M1aVFZVEFLZ0FZUlNpRm9reGpKaEtBUVdSSVJBNkVFbG5VODVRS0dKQTZKQloxTUpsd0hVb0V4QUNCaUFNVVFLMm5ZNXJ3RVN6SlozT2gxV1VnN0tITkVreHpNSmhycWR6elJKYThTVTVtWG1ZNm9nb1hISVRtU2MwdGNZd2tFa2dkVEFTVUFHQWtzQUFRTVFKaVRLb2tsQVphQXlKaUJXam5JcUdSTmJSY0o1ckVWVFdJR0VJdWdZblRRZ0luUk1kRjVuTW94SlJqMW5JOUJ5UE1ZNm1PaElBS1dVQlpCSzVBd0ZrcmpDWkdzRVlUTGt4ZEVzb21LQWt3aldBMEpKSnFZQ3F3TGtEQ1lTaWhwSWpGaWNxc3dRZ0paRk5XUkdqRWdZREVnVVFZb3hKZ01ZMFVBbEhSZXB6U0RBVWREa0JnRW9rNkFXQkpSaURBVVNKSmdNSW1NSmlxVGtCb2tUR1hIcVRrY3hFREdKTVl4bHhKaEJLS0pNU3FZRVJBa29nUkJhTWFPbGMwRG9RQW1KSldEcWxnSWlZd2l0SW1KTVlBSkpLTVFTV2RpRGtCaXdLS09oWWxIZXZTZUl1RTVMa29UbUo2d1BPQkFITVRtQ2gyTE1rTGpSekpPUmRuTmNWQVlnczVsRUhRQ0RvUXFTa2lVWWtCTlJBRmVrOHNTdXNSaEFCTXVURWlDcGswU3JaYWVocmdJSEpLTXVTYVNqVldVbDFJUnROQ0FIVXBBNkx5TElBQktQVVk2bm5JSUxKT2dBQjBUb1NKZ0pYSW1LQXl5WXdwWkZFQWlzbzFZU3lLSmdKTE1OWWdJVEJXTkNGWVVWQ1NnTE9oQjByR2lRTEpwTWFPaDBPUmlDVHFTQkpBbUtKQXdrR0tKTVl4Ukl3a2lCYTlFRG1BbEZFZ1l3Q0JSUlJSQW1Ba1RDQkpRR0V3QVl4cTZtT2RSa21FcGNRZ1lCQVFBQkVsY1VCakowRWdTVlFLVEdNQUZBQUxaZ2pWS1lzQklBeFFxb0VGbEZnU0lMMFRDSUVrR0lLQVNERm5ZNW5Jd0dFb29Dd0V1dXhSRVVDaVVkRHFBbkk1QVFCUnlKRlpNZHlFb2xZakhNa216c3NFeGhLT3g1VEdFUUlNbUJiS09KME9aSmlhcUVqUWdMa20zREFZREZya0NSQk1DcU1Gb1dscjFYemtKYXFaQmRTU1VFbXFsSlpHeEtJTEtTaWw1Z0lHTUo3REhRODV5UUxVRXdpSllBQ1NVc3BqR01KSmxTckV3a0dsQ3pKUk5zbFNjeE1VVG9rbXlCTVZXSk5GRTFSUmlRRWtvb2tzUkdzVVFZRHBGbU9Rbk1rVENVU1lTVEFTSVZXUUJSSWtsQUs0Q1FTeWdBb29va1NDaVJFNkdLQUJVQkpNWW9rUUlLRUNpYTFhQTBCMzBBT2VWbk13Q1VCakFCaE1JR0pNQml6RkVDcUNZeGpGSE02R0pNWVJYQWtsQ1FTWUFNdEpSanFTdEdCTUtvZ2xFcUdBd3BKZ0pPaFJ6SkFGeEpaYVNVWXduUUs3UmdNVXZjNW5FVEpJRXFGcGptYzFvVTdtSk10SG5BZ2xNdUxxOHVRV0JsUmpBU1lva1FNSmlFa0YxWXFJT2k4ck1WWTUxQ1VndU11TVpPWlNaY0tvbklzN0VsSE01SW5RbEtXUnFTalMwYXpTeUZtRXgwTFhvaWVjREZFbU9wMU9aWnpJU2xTaWhBZ3N3aVpBcGVhWWtUR0tNdUd3RVNSbGd4U0pyU0tUaUlsZ1lrQkVUVW1HQUt3bUF3Q1k2a2dKWVV4QlowSnJuRkVDQUFkREdNQW1KRWtER0NNVVlrd0dBVkRHTWxDU0ppaEVreFlFbUFvNkVBQUxTWXdBSmdBb0RDVUFqUkFZQUFveEpSUmlUR0FSSkE2RWtpU1lrU3pBVW9tQW94SUhRQ1JBU2dNc3BpakFKQkltVVRGbGxMQllwSlMwQW9Db0FBUWdJbGdKSkFITmNVSjJTUUVnNkZFMW9zUU1zaVlSU1NqS0ZKSUhOY2RVNkhNVExpQ1NDRXdxVk9TYXhCWUtoTVVRSlJ5THFLVEd6T2ROckVqR0ZTeVNyS3plWUphOHpMWmlVZ3BGUVJXUk9vRWxFQ25NeFlLbnJQS2lUYWpHSktRSnFpcGVsbEZIQXhpU2hQUVFVVWN6bVl4UlFtSUVvUk1nWlpNQmlnVEF0RkpKU2dHTUNVWVZDVEppakdXUlNnRXNta3h6aWdyUmpDYWdrUktVT2lCem9pekNCUmdBb0NDaWhFZzZBU1lBaURWUkVKaEExU2FGY0tTVVlRRXdtTldOQUpaSWlkVGtZeGloQTVsQUpKSW1FVEZVR0NKSkVRb0VZb0JBa3hnRW9DU2lDd0VERkdBUk1CakFVU0pCUktoa29US0ZvQVNTWXNCWEZKUmxvZzV5VVhYcE9ZR0FzNXJhWTRxbVJFZzZISmNTWWd4anFRaXFZVXhsc2toRTVyYUpoTEFvbGVwQ0JKSzlEc25Nb0RLRWtFQWttTmIxam1TQlFBWWxLTUM0UUF5QWtIUllqQVliY2tGMFpJRWlaUXhreDFRWG1CUXJCaEVxTVRaSmpDcWlZb2hiQXlSV2pxSklxczJWYnlNWWdzb1NvN2sxSnpBb0RGQ2N5aWhSQWE1cXhKUUdBcEpWRWtzZ1Nrd0dLSUpFb1RGRWlZZ3dtckNFYXNZUWlTcXdnVUlDSWtWaGlDem9KSkJaSmpGbUpMTVlra2d4b0FxakJBSUdNQWlZeElpV1NZQkdzTVlrVENXZFRpQmdNSmlDaVNpVEdFUkUxQWtSakNBa21waE1CakFZQk1JQ1NDcVlCQVFFb3hoRXdHTUFHQW94SmhNSmdKS01ZRjZDa21WS09LWWc5QlpqRmdDNUFsZWhCYUp4TVN1Z0NvTE1Zd0FKa1NxaGNhU3ptWVNTd0VSS01ZeFpKUlJLaGlDUklKU0NqTGpBQmpDQklvbVdSUkF3QVlrVndGa0NTVVNWQUlManNTY2tWRTZrZ1FkVnhCSmpvQkNCaWlVdGNOdUNBczFrRlFrbEZya3MxUWN6QVk2bFM5aXp0WndPWUFRV0JqQ1lVeHFvbFNBb3hpQ2lDakVuVUtEU1NZS3MwQkpaaExKTWEwa0JwRVlEV2dwaEpFRG9RSmhNQmlhUmpGZ2RpRGtKUmlUb0J6TE1CMk9KQmdoQ3NTRVdKQktvSWlVQUZDSW1BazZWeUtqQ0JRbUtNY2pDV1FCakFKUklGQUJZRFdDTUFDWWdveGlpam1CaWdFeGdNWlVFa29EQ1NKWmhKRWdDd3JRQ1lSRUJFa2tveEJCWmxTMFJYRW5uVGtKM081aWlTaUZVUVhDQUFZeE9SVTBrbEZsQUJKaWttc3NGeWNoRXdtQVFFc3hnTE1ZN2dzQWN5U3dPS1l4SzBZeEFtTUpKUWtGR1RITVZ4Z0NSdERBQWxrbU5LbEVKU2RXcE1RY2lrRVZ3S0ZtQXhpV1FvQ1Zvc21xQ1ZHenFjMTVvZ1hHWHRaSlp6SVRHTXRIV0xxeFRtY3dWSkVDaFJXUlNpUk11TUpBSXFBWXhpaHMxT2FHS29DTW1Bc3FzUkNOWUJYSlJBZ1VBa3hoR2dUR01ZeFlBWW9SS0pMSklxUkdNQlJoT2h4QWcwS2xrbWpEV0V3QkNJRmtGRW1PaElDZWl2T2FNSUdLS0FvZ0RFaVlEQVlSQXdsa21JcWdnTVl3a2lJMVVZeEpJbU1JQUlHTVlRRUJHc1kwQlJBR0tBUUFvRENZd0dXZ01pSUxnVG9ZbzVua0lFU2oxbU1XUXFJa0FtRWxjWXhSQUFKaE9nRUNVWkpYRWtGQUpLSUtsZ21NQlJRQ2RCTW9jeVRvU2VjcEpOYUNZRFFGa2xScXhSSmt4eEtXaVJKVEFLcEJqb3BGSFl4OVk4U2VaSWE1bk95NGhjbVRLR0lXekZFeGliTEFCS0pDc1hMa0s2bkpSTVVYQ3BaWmlVZ1RHWG9hT3RZeUlFcWdZNW1MUlhHU2hJTXNtTUJrRm94SmpGQ21CVVRWSlVBcGhLb0dNTllSV0VvQ1JFQUNNQTFqRkZITVJLSUVvQ3dFQ2dJckZtZ0xJRWs3bkk2bkVpSlc3Sk5BTkJSakV4UklraUpqR0VBS0d0QUJpakZBWVRtWXhqb2NqQVlRTUlsQ1NOU0VZd0NZUUUxVkZGbkVneFFtTVNVWTVpSWlTQmhxakdoQUJBU1JBb2t3Z1l4U3lVWWxFQlhvWktNWTVuaEFCTWVnN2lKbEJKTEJLTWMxZ1NUb1NTSjFPWlpnQXdsSmxvZ0NUR0pURkx5S01tRWdEb1k2Q2REcWVkY1l4MGp4UmtTclpKQXNnWTZFVmhxeVNCUkpKV2lDaVVvd3JJQ0M5STdudVBNZVlrNW9yQ2F0QW9rb3FBV29kRG1URkdzQ3lUV3NKUUFTbFZaQXJCUmpxY3pveXJ6SkV4UUZIUVFNY2hPZ2tnSmpvVWN5aVRFZ1VKSUNCaEpNVVVZd0ZKSzlBSk1sVWlKb21HdFlOQW9Fd3JyQW1FMVlURmdJR0VDeWdFNWxGR0VEQVNkQklLTUppekFjRlFDUU1TVlRFalFCY1FaVUVUQUltQVJNQmdLTVVTSmlUQVlza0RDSUVxbEdTakJWRXhqVkpjQUNTVUlHQWtSTVlRQXdGQVl4aEpFeFJJbUpFVEdNUVlSckNRVkNCaWlSTVl4MEpNZEZENTV6TE1TVW5jN0dKTVVTdEdURkVxQW1LSUF0WktFeEppekFuUUNTREdXZ0xOSE1hZ2t3Q0FpV2xBZDE1bENCNWtBSU9oSlFMSml3TkNZb2tRc0ZEQVlBTWRDVEdNZTVlUk1jaUFFdW9TSWt5bGdNc2xDWVNRaG9TeVVTcm9oQktBS3hqQ29RaWRTREZnWUJNSUZIWW81SElTakhReEJCMUtKTEpNWUN3U1FCYU1KS1VzcFpqRWlTdUxFRVRWUWdURkdyQXVTVFJLdGlFRklsRUdMQXN3R0tKRXhpaWdBb3dHS0FreFJRR0pBNWxsQVJGRVVtakJXTU1KSmhNU0pqR0VER01ZQ2l6b2N6RUFZa1NqQVl4UUF0QVpMRTFBeEpxbUxBREFKUklrZ1lveGdBUkpNQmhNWUJNWW9reGdKS0F4aWlTeWFDb29CRXdpUUFsbU9wZ1BJZVVWa3hhVWVnUU1ZaGFLU1N3QlpURkZrQ29CUW1Ba3hTV1NZa2s2SE5hS01scmptWWtzU0RFZ2xHS1VPd25JNHBBbUtJRXUyQUdORmtpWXhSektvQ0txQU9oekF4akdMS2prQUNJVWtRa2dKSzBJRWlZMFZYTkFzUVZBeVdSVkVsa0ZMQ0JSWkJSUmlCRVNST3gxTVFTWXdnU1NKWlFDSUdCTVlBRmNVQmtDNnNnU1FOS0ZGQWFxRkVRQURHQW1LcUNqR0pBb1RSaXFUR01VWWtSRVRBQjFKSklFc3hxc1R6eDNJTVNTSkFtS0VtTElFa1JKS0xJSkV4akdLQXdGS29IWWdrd0VtQUNoSU1VWXhRcUdMR3pFREFGWVlrUUFvcFpDekJHRVRHSkFCTVlvd2tGR01CZ05XQ0FTakFKaEpFUXJSWklHTE1JblNvTkZrRW5sT0toaWtEcWVneTBRQUNRbEdKQTZBVUJSaEpPeEtoSmpKakdJRVRFckIxU1Rvc0lpU1lTQ0RxQUVGaUt5Y1RDYUVoS3ExNWxoRkdBb2tTaUFOV3kxSkpSek5XTUlERURXTVVTSW5NSUJYQ0JpVEdLQ0tybXlxTFpLSUNVU05RZEFQb3IxVDR4UmpHTE1RZENDZ0U2R0V4QjBFU1RFaWlkQUF5eVVZd0pnTVNkQUxBS29vb2d4QWhGR0tvRVFKTVl3Q1RLMlltRVNURlVnRVdkYTVGR0FveEppakNXUUppUU1KME1UV0NBQkxKQUFFQkppekFCaEpNWXNEb0pCekxFZ0JFU1R1UXNwQkpoTUpZbk1DekNBZ1dBbFZnTVNRTUFsRWxDU0FnU1VKakVtTVl4UkpqR0ZSQUtZd0FKakdMRVRtSmlqQVlza3Nnb2tURFNVTVlrNUhNNUVrbG5kYkVna3lVU1FXSlN3U1dCQjBSRW9zQ0NqRWlKbDVtRVNFc0NTeVRHSUtFa1RGQ1NRSlJ4RW1XakZHSW9LaVRxSlJ5TUZWRm5JbXV0UmtGbk0xWUREbGdKMERDVkJXTktJSkZ0RUdORmdTQXFpQU1xeXRrSWdJbU1UVmlVdjJVK0FKaWpDQWdZVG9RVVlTUk9oSlFGRUNnVVVCbHhSSlFKakdKS01Zd1ZsU2tvc2dnaU9oSlZKSmpBWXhqR1Vnc1NZc3dBVlNVQlVhc1VBZ1NCUWxHTVlzVGtZNkVpQWlBbUFza2tDU2lURXhSWkpqbVVKQWxrR0VEQUJRQ1lESFpZSlRFbU1KaWpFa2lXU1VKakFkRFVrbEhNeG9rRG9ZeFJpREdBd21KS01CakFZUU1xV2dGYUpBQkpFb3hRbk14UmhFd21NUVk2a2xCYlNKRVVZQ2p6SE14Mk95NGd4eU9hVVl3Q3FKQWlKa2tURkNTV1NKWUFxSklHU2ptSWlBQVdTSUVuUW94eklLTUJNb1VBQlVsd2lXUWN5amFkTW9NYXFxc3BBZ0tCTVlCQWdTaGlLeTFFR1FPWmNSUVVZd0ZLQ1FabWx4SWtsQ0FpQmtTN2JPQmpGa21LTXFnQWxGRUNVU2RDaWlBRUNSRUNoRUNRT2dwQmpFbExJbUtBeVZYYzVFUmhOV0NNSmhvTWFVS0JFa1RHQWxhRVVxZ29DaWlCT2NKZElraVlBTEVza0FPb0FTVUFHQURHaVJ0bzZKd0pqRW5vSUpFa1RFbU11TEJBb0NsdEFnQU1Zb0N3Sk1ZUk1VU1lDam9RWXhBbU1iVEY1UUlrZ0JpbHlCamFURnhnQURvQnFEckVqWE9NQUZBQmloTVNZd0dFdFJNU0lIUlVCT1phSzBaTEpPaEpDOUJPUmprSkNZU1ZTRXdTNnNaS01xQUZDZ1VRZERpdGxKaWlCTUJSQlFBQlFMa0RLblVrU1VDU3hsNW1DcExpQktVSlNoT1lnZENpYVJpakFUVUFBa0dLQVNTem5BQzRTVEVnQ1VDMEFHS0FDR1ZjWUJNSUNJZ1dSWmlsa3dtT2hBZ0JRRmxFbENZQU9vQ1FBQ1l4UW1KTElFeUJoTVN0RWxpQkpkbEhZNFJBbGhVeGhNVFNVYVVBeUlHTVl3Z3RGSnF4Nmp6aVVRV2M0RFZZRkdNWUN6Q2RGVURpVUFuTXN4SUdFMFFZcTBTWW9rQ2pzY1NpUUxBNWxyUWdnSmowcms4NEVsQUJnTEpNQlFrbUVvZ1JBUUtJTEFBMG9Nc1VCSmdNVXVRR3BFMFl3Z1VRWFFYQUZFWUFLTUpSQW5RQ1FNQmhYSUVpWTZMSlFFblZJVk1saUJSQzlTU3prU2NpakFVQlNKd2wxWVVreTlEbVVKU1FVU0lMSUpqb0JRQ1VCaWlqbUJTMm5JeWhSQllKUW5hSlh5bGtWanBGbm5KS01TSUhjNUZtT1oycm5FZ2FnUUpNQWlTSmdqRXJqQ1pBa3k0bEJhTVNKaXlDRXdMWUdFRUMxeGdUR29MSU94SkFuUUFNVUJpeEpMQWtvc1JJSUtBeDBBd0dBQ2hBQU1DV1pjWVFFRW9BRmFRQXhsUnMwU1lTVkVvUkJaQXlBbGwxUzJjekRFcFJCUlZVWUNnQXhxb1phSkJKS0pJTUlBVUJnaE1VUXVLTVNZOTZlRXdMU1VTb0pnRkFTajJIa1dUSkpqR0tKRXhKUUhRa0JFa29ERkNKSWlCT2diSk1CUklMZ1RxQnpvRXVBeFp6TUlGRWxBRlVjNFFPb0VtS3BORXFpa0ZBSkJpeVNsQ3lTU2t0ZVppaEVER0E2RUpKSUZrR0ZVZ2s2R0ZJQTZMQ1lrc2tvVEF1S1NRTXRrSUNCUzVFVm9oTXNGaWNpekZGc3hOZTQ0bkN1UklnZFNJZ3dGa21LSkV4aEpKTldLTUFHQWt4b3hqQVpVd0lrQUtnZ1VCam1VWUFTU2dFeFJpUldpVEpxeVFkam10Z1VZU0NqR01VVUFpSnpPaFJRQ2N5UkZMRWd4Z01xWXhKaEZLTUJqTGdCTVVKSzR3bUVDa3dFbGtLbUpBVENnSlJKME1BbUVzbXNRZERHRXFBSzBhazZHT1JSTXFrcUlGQ0JnTVNVSWtMakpTZ3AxT1JnV1JUS0dSWEdUR0xPeHhNWlJBUktKTVdRU0FpU1VKUkFtTVNKakFZS3d3aUJTZ0VpaUlVbWhNQWlvZ0JRQ0FsRUNKQUNKVmFJRURHTEpFREFCYW9BbU1ZRENZUU1KUUFVU2N6RkFJZ1FKUmpFblJSS0pFa1N5UVdUQ21FeXlsQUJCMUFnN0ZBdkFza3M1Q1VMUFZXSWw1NlNTbUNXNkRSZ0pDcmlqblVuYzVHR0pFQ3lBS0lycWN4akVtQWtwY21GUkF4Q29KSlNoUkJSQmhTU3lRTUpTNEJBTEFwSkxKV3lUQ1VKakVpSWlJZ1NKWlpnRTVtS1NoQUJNVXVJTEpQU2VVRUFBVExSaVVSRWxRc3haaVFTZ0pFRmt4akNDV0pJQWRUQUlnVWRLZ0RGRW5TTWM0TktnS3BFb3NtWGlVQWdnQUttVEZFbUJiSVFVS1JPOWVhQmJFQ1JSVkJNWTZDY3lRVkZJTEVrQ2lRRVRHTUppU2lnSk1ZeGpBSllDSUxKakpSUkkwa3hoQXhsRVNpUkVCS0lNQlJJbUxwSWdNQW1KS01CaWpLRkFtRWc2bk13Z1VRWW9va0JJRXdHQTZuRVFLRVRtdEpSUml5VEVFcWdkU0VGU2tnVEFJQVk2a0xKUW5FNmtHS1piZGx5dHdHVG9SS1ZSeml3QTFJMXloSktMTkdBd0hRNWtpYzZxRUJNUVVZdEF6UWlRQ3lDWXkwQUFkRGtabURLaFNKVXNsSUdDa3lZd0wwQXhqQ0FpQjNJSk95Y3pLa0ZIY0JBNG1MVHNjakdVU2ptdUJFeDdUeUdKTFdVU2lERWlCUkpSWmdBU0JJRXdtS01zQ1pLT2h6SktNcWxoU1lzeGdBNmtrUWtST2x4UmRZd25VbU9kU1VTSmptYU1BaVVZa3hKam9RVWRhbUlKQW9rd2tpQW5vT0lFbU1ZQk1Za1JGVXlZUU1BaUlHcE5BQUdBNm1KTUlBQjBJQVRvUVlTZ0FCRU5DR01VQmhOVkdBeFl4QmpHVkpBb3lKSmptSlJqRmttcTRnb29na0RGaVNTY2xzdEpFZ29nUUxXU1Nqb1VnSmlkR01US2tnVUpCWWlXbG5Na2dUcWNTam1VUXVTb1luUUpKT2krazh5QlMwY3dESnFheGpEWFk4OEJab1RHSktxQUdOUU1CZ3FSS0NPcVpvU0FLSUlFVm9neEFrbE04ekxob01NdU1pZ3RVQ2dCbFJNWXNrd2dkaWlTU1NpeVJFN0Vsbk01a2xJZ0MyWk1RdUJNV2V3OEpZS2xKQjBBa3NrZ1NnS0pNQkFtRURFbEZnb0IyU1R1Y0NTam91U3lhUklPeEJBbUVZNWlhdERYUW9nb1M2NFJqRW1NWTBRSmpvWXhKakVDVUJkVkhyUG1pQUNJR01XV2NqQUFGQ1VRQUdLRlpNaVlDU2pFbENhcUNBc2t4SlFtTVlDeEtPUmloTUFnSmdNSVZqUW1Bd2pRSml3S0pnQWhhQXhoU2lSSk1KSjFPWTFKVUpqQ1lnUkV4eEpYcVpKRTZBUVNBSFplUUZuVkE2RWtsVnlHV2pvY1R1QkFIUTVpbklUQ2RDemdCek9weVhvakJFNkJJSFpaTWlLOHlURnhqblNJREVoU1dFWXNnbzUxalZzdFdORkFUVWxqV3l5TFFnbVhxWTg1aVZST1ppUUZJRmNhbEFaY0tCVlFVWVNCRVJKS0VrUk94bGhNUUpaaE1kQ1NRSUU2RkVDY3pGR0pFeDZBVGtVc2tCU01Bb2lLZ2tDWXdKSlFrbEtFbElsZ1FJbGdJRnJkbUFUR0Vra282azFzdVkwbGtIUTBVVWQ5T0p4Z0loTlNBUUdNTlVjeE1FU1VZeFpSeE1JbU1GWW1Fc3M1Z3NtUUVUQVlsVXhrUktNU0FpQWlhc0VTSmpBWVRGQldFdUpFZ3NRTVl3aVNCWW1FeFJJMUlsSE1vVEZIT011TUpJRW5SRWhlcVNRdGtDYXRKZ0V4akdBeFJoT1pqQVVTVVVTUVNZb3BaT3BrVGtZcTJpQ1lTMDZuUTVyME9CME9pY1NWNUZHT2gyVHdpUVVZc2c2THlFd0NJRjVjNkNqbldPaVFVb0pVSVZKakdNWW9tSTBZeGlqR2lTYURxY3hHRUNVbFpyMG5saEZVeEJJa21TUlVLb1FHWENtQ2d4UjBKT1lsQ0FtTUpqMGljem1jeWhPcEowT1FHTUpRbEhVeEp6T1lBWXg3anpKS3lCalZab0JRTVVzbU1TVVpBQk1ZNkxpREZKakFZb3dsR0Vxa0N3TGlheHlLTEF4TU5Zd0ZGUkpWZTJ2R1RGaEhLc0JnaWdBbzZWeklqQ1FXWWdUdWN5VEhRVG1RTkVVVVVjeVJBeGhFUUpNQlJKanFCSmpDWXdnWXdtRXNreGpGRWhYVXFPUlJCUmlnRXdBSW1BVENGSm93VURFbDFRbWdNUVl3RkdNU3FnWmZRY2lUblpVU1VCaWowbmxJTWRERWxBUWRCSktKSktJTVNZcGNkazRuVVNhRnhNS1VJSFpiT1NkRmxJTE9TMmNUcVduakV4SmpDU3VNVVVCWVFuTXhSekd1aVFzbGtIVUFNZERrZENCSU5Eb3hKaEVtSUNxTVVZSWdvc3dVSEtRV2lWUk9aSmlpQkpHc2dWS2daTlFCUWtHRW9RRXhqSFJleVFRQklsQVdkRHpqSmw2VkpoTEtKRWtra3hoUGNlWTRDU0JZaUFpUUJnS1RGa2dCbFFLS0lBc3lKUkpqQ1lEb1ZTQWt4MGlxbWdUR01ZUUFrbzZHSnJ1Y2dqQWN5d2pIT3NKMU9VZEtnSWtUR0ZZRk9nbk1vS0NZQ3dLTE9RQVlzU1JBUUV4aURGRkZFQVlSSktLSktNRlVVVEdFd0FZdXJpREVpWXdpSklWWUZ3R3FUUTFSTVVOU2FNSjBvSkdJSUVLSVRFbVZCTFhxY1RtUWlxWkVUQ0pBbmNsWVNTQk1JR0Vva282bkFrb1Z5UVVVVldMbDVvR0tFNnFITkxCZWh4UlhvV0I1MDg1UllFaUN5VVVJZ2N5WW9za3hLSzZyT1ppZ0U1blFERmdZRFFhYUtPUnFZSXhJbFZJbWlqQ0s4a2hGWktCWU9oeU1Ba0NtTWFwTGlseWN4cEFvQU1XRklRbEVtT3E5VTVBU2FBdzBsRURscTYxSkFIWVNCSk1ZRENmU1BuR0FCTVlER0VrU1JMTUpJR0FVb0Z4WkFGR09pUVlDMXhLZHlSQ3FMTzBWYnhTQkxPWm93MUpZa2lVZWl1RUFBQkpjY2hvTVRGR0xKSW9NRVVvU0IxVFZFQjBBeEpaZ09weEtFa0JBc0JBVEVtSUtLS01BQ0ppakFZb0swSmpHSU1ZeFIwSkVrRG9TcWxBWXlsVW1pVHBwVUVTSkJRVmhJT2hVSkZhQTUxSmdpVEdNQjBvWFIxVHpsQ29aRXk0bEpLQTZrcXBCSjBFa0Z5SktxWUFGY1hWcHpBc3haSVJaakdNVldKT2hNVWNsc2dvNW5BNkdNWWd3blVDU1RuSmRWTEpWZ1FLd1dZN0hJUklNVVl3R0V1SUNySk1jNllJZzZCVkhNb3FBb0FNUVFxWURHQWtrczVpbUFhd1NVdEVHckNJRkxKWk1pRWRhS0FYc0NTQUJGR0pyRmtGR01BbUVvRENRWVRIVTlaODhza293R01RSlpnT1pSUmdNWWtzRURMaWpvY3dNV2xFQXFVQXAwTU5KUmhMQVFKS2pFVnlLS0tMQTdWNVl4WkppU29pc1k1RlJoRUFxVEZTZ0dNVWpSQUltSUxBb3M0bUxNY3l5QkFURW1LQVNSTVVZa3hRRkFZd2pUR0lLSktPWlJqcVNVWWdSRlZLQXhTaHJHRVJwclJvQ2hwSkFvcUFLWXh6b0lDQVNTU2lLMXJrSkpoWENnWmJLQk1VWXl5a2dJZ1NzcGpvb0tJRXJpck9wQlFIUTVnYUVURUZuU3FVT1NFZGp6TFJ5TzV6QVNSTVl4aVRvWTRGSUZXNk1rRkdVSUVRRXgwSU1kaXp6Z0pjVERvQWRDS21OSE13azExQW1FeFJCSmlWNkhJeGhKQXhKaEFTVUJycVNZRENZa3hqb0lHTUpwUTlkUWtra0VsREUwbUVTQUV4UlJhU1pRQUFUcWV3K2VKaWlTVW95aGlrb2hRb0RHRVFFbExCWkVreFNKZ0pGVW9Da3FxQXM2S29HS0Vna3hJR0FTenBYUTVreEpnSkF4TVdUVURDV1FXc0ZNNWVZaW9DV1lTUUVRRVJKSUVwUWtDa0NqR01zSllGbUlFU1RBWVRHRUJLb0lLaWlURWttT3RTRVdCZ0xLRVRHQVJNVVVZNkdNSlJxYTVSanBDU1ZXSkFnSWtLa3VBNXJTUVVRUUs0VVRFbUtBb0NpaEpKTVpRREFVS1VZYWswZERqWFFva29zNHgwSnBMRWdJa1Y1SFlEbVFuYzg0Q1VJR0ZRZ29BUVdnSkxRQXk0N1JCSVVHTEFSTGlDN09SbDBXUlZGbk1nQkNFVFYwT1ZHV0F4SkpsREVtTElKRXdJTGtRS0NzVVNZUktJTUJoT2hpUk5HdDdwam1BQVlxcGpBZFNUSE1va282QW1GY1lBS09oMVBJWVRHQktNb0pTVWMxUU1ZVEdNWVVnVnhqQ0tZa29ETGl6R1NxUktCVk1ZNmtHSkpKS0FvQ2lxNm5JbU1ZeGlRTU1jNnd3bG5NVkV4aEpNdVRHRW93a21BVHFVY2lEQ3FTQXBoSk1DcUJSUWtnV1NKSkpSaXpFRmhWRWt4UmlRTVNkNkNJeFJJRmtsR0V4QlpoQUN6b0pKMk1Zc2FxT2hCNmpsVUFjemtWR0tyempIVWxlS0JSQmpBb21Fb3dBWUJMcWFDSVlzVEVrS0lpSVZVVWRDYVNTekVtaXdxeXptVVRBUXVFNUZIQlBVY2ptSWdZdVZvQWdBU2xrcU9kVWdJTFpNZEFKcnVjU2pBWXVNYzdLSlhIU0lxUkFCSkdBRDBITTUxb1NURWdaY0JKUWtraUFNNjBHRXhoVW9STVlRTVNVSlFyS1VBZ1lCTElBUUtsbXNkVXdrR01ZVUJYQ1lDanVKNVRDWVFNeUxoS1ZJQXhpaEFTVG9KekFUQ1lFUUxKQlU2QUEyVUJpNENhd2lZSXFwSUVUSFF4aVFMTVlrZzZBWUFOTGk3SUtFZ0RSakZFZ1VZb3hBaVVKMlBPSmdYQVNLSmlGeGt4UzVBd2dZb0ZvbEFvb0N5UnJSam1KaVNqR09sUVltTElBVEVsR01JaVFDb2dpWVRGQ1VZOU5kaExPSjBFNVJOU1k4eG82RXJrNG5NN2tVUmlDaWx5ZERwWE0wVVFjNnhqbU1kVG1OV0VVQzJrQVNXWXZSaVRMUm9vc3lBMVJKSkJwZVlKakNlZzRBUWREbUszRURVbUpPMGNxMEVScFlFaVlva3dDSlJqQVNXWU1vMHFxeTVtMHFFa3hpU2loRTRRaVlrREVyZ01JRWdZQzdPWUNVU01xSk5tR0txQk1TSWlVb0tBQ1NVSVFoVkJGQmFGSlp5T2hnS01tTVlES0ZIclRtZVpjWW94a2t4aTFvU1NRTElFVEVsQ1NVU0JnU3pDSXJKaXJKakNLNUtDc0lDV1lTQ2lZZ1Nxc0FFa1NqRWdhQ3FKQXhaakFUQlhRa3hvd0ZBSlFrQVlTajBIbkpMSk1BQUpnQVFLQW9veEFGRW1BU1N3TElwTGlTQkdwRXFPWjBya1ZHSktBeFJZaVNTSjJQT1VzQ1VrZ1lveGl5UzZzc3M1SFNPeEJ6Sk9oQUhhZ0k1bkl4Vk1jeVNsU2tURjFFWWE1UW5Lc2FFeWlZVlVzZ3hSMExKSXBKTUJTOUlzaXl6QVdjWWxRa0VzZ29zeEpDMmtIUUY1RkdKQXFUTGNjNjUwbU1RVkdNV1JXS01Zd0NBRlJOWVNZS29ZNTEwSkVrVEZFaEdNQkJqS2twbG94SkFCVmtwSlFKMFVsNW5RbEd0RFVGR0pFUkZRUVJKRUNvb21EU3EyU1RiUmFlZzhSWWlVUWxBSWdvVWUxUElTb0JqQ21BeGE0U0JKS0E2RmtFZ0lGZ1NLWXdpSUxBbFdKTVphRktOV0Fvc29DU2lUbkVsR0dzSWlZREFTVEJWRWxBV1NZRFFoV01FSWlRSlpKSmlnT3BKSUNJRWxBU0pnTVVZUk1KSUZBU1lTUkxKQW9UQVNhcEtOQWVtdk5BWUJBQkU2SFE1QUltQXloS1VBbUFvUk9sWUJBcU1KaUFFdXU5RVJHSUE2VkVRQzRUb2dCMTB2TGtjcWlPUmRKb3NGeVVDZ0pSekU2RW5Vc21nb1NWcUpLc0NoSkpsczVuSWhPb0hjRG1jVnM2cEJCUktnR0VpU2xhZ0NZU3F4c3FxUkNrd0NKQmpGRUFVSmNjU3FjdFYxam1BR01Zb0pCZVpoSld6bWlLeVlDUUtKTWhZbWxWQXNvQ3lCS0lRV2pGRkVDSWtGRUZnSmdFeHFjdWdFMVppU2pGb0dFRmtUNlI4OGdEQ1VBbUVDakVraUlnVUlBbU1JR1hHTUpqcVFRQmFJVUZsRWpHR3FFb2tEcVFSRWxVeEJkUUpnRXhpUU5DZHE0Z1djNFRHTVlUQVl5NU1KUlJ6RXhqb2NoSUZhVEVDSUFZb2dTd0tKRWtRRUFFa3N4aUN6bVVKakFCb3JTempDQmpFQ0IwTkgxandXOFV4aE9aMFdRU2lST2hKSlJqcFdKZ0F1c0FsR2pHT2gycm5FRUVGcjFQT1VsQ3ZSS0pEUzh1SnpKSk91a3d3Q3RGSE1SU1JGYU5Ta0hRd2xGbk9MQ3BJTzBRQzQ0RW9GbEhjNUhNRngzVGdVQmlWQ1RxYzBwWkFzSWlyS09KWVpWV3JBVVk1bEVnSklpZENJZ2E2Q0p4RWd3Z0pRUkp6TUJZTGdSQlFDQ1RvQkthelJTaXBOaUJZQVVDQzRvQktBb2t4MElBb0JBU1M2Y2tTYWs2QUJZSW1LQlpBK3NmTUpBc0JBd21NWVJBQktNQmdSTVlvVGt1S01ZeGdKRTZJaFFKWklScWtvb29TZ0pPY1VUU01OQkpSUUZBQWt4WTBFSFdPSmhKRXhpaEpCUk1KUlp5TEpNZFRtQkpTMG1PWmpDQUZFQ0FGa2xrZ1lzU0NpU2lRS3JFeFJoTVFZeFZZNVFsR0pNWVRERjEwWGdnVVlrcFFsS0tBUk1ZVFYxT2NBR3BFREJIVWs2RFV4ek1ZcFpMSVRvU3Fsa25XdVVTVWN5UkVER1d6Rm5NcElLTFd5NjVwMElPaHpFZ0k2a1ZqcWVjNlFISWhaUk9wanNjUU12VXBPUUVrbVdqa2RDVUZnVEVWVVNkQ0M0eFpGUVVXU0pSd09nbk1veDBJam1hdWdHQUJNU1NXWTBTY3pHRUZvdE9aSzRnVG1kaVVoRmFNQ2hRSVZoTUpJbGtDVXVSQWt5MG1NQmhLSk1LV3BLb1ZKMUlLRVVvbFVrd25yUEVKZ01kQ1V4U3BKaWlER0Fvd0NtRUZTVXNoU3NYQ1lEbUtZVG9hcE9nRWlVQlFtTlhXRTVFZ0JSWlJJR0xJTVVTVVFZMFdhcmp6RmtnSVZVQmpBSmlnTE9RZ1VXU1FCUUNRSlJqRUZtSkFWb2t3SUNJR0dneEl4UkFpYWdaVkFxazBTQkpKUmdYSUZyaEtTU1FNcWRDVVFKTEpNWXhWZEl4aUFNU2RLQmhJTE90TXNwem9JaExBQldrU3hNc0NjemtVVUFwakxqQVVJaWRpVEZEWUFXU2RJVGtBMXlLV2s1R2hBbXJPa2N5QzE2RUpqZ0paeFdnSkFBRktLTXNHS0NNbFZCWUtDWXNnQ1RvY3pGaVdWSG5LcVRGbk1vQ0JFbU9ZZ0lDUWRqa3RuSXhJSFFoRkpYSFl4QmdOV0Vrb2tDaE1VSmpITVN3TVVZRENZZzZDVWN4RVNUcVl5WXdMQlo3enhFZ0pSaVVvbFpNSllBQml6QUtBRkdNZFY1azBsUWdBSmlUb0lrVlpSSlFtQWs2aFRBSkJpQ2loRTVsRkFJR0EwRlZCV01UQ1l3VUdpaVN3TVlza1FJRTdrR0pJS0pNU1lzeGlTUkVDU3lDakVtRVNTcUFoTWN5d01XVlRFa2xWalJ6TVlDaFdTVEphb2duYzRra0xRbVJKTVlUQ0Jqb1l4eUtBQ2hNZENCT3RSS3BCam1JQ0JLMGxtS0lXeXdPWmhNU2xtVk9ZaUpCMUU2QUtYUUVkeWlDVEdJR3FVU1lrNW5Ra29BRXRjY0VrNmtISXdFcWdJZ21FaGVweUtBb3BJS0pXRG9CaVNpREZtTWR6bWNvdXBFb0FNU21LV1lrNWdJa2xFZ3FBQ2N4UlVRUWFwQWtvU3d0bExKTUFDVUpaQWlCQjBNb21FQk1KSlpaQjBKS0lFeFJRSWd1SVBvSGpNU0FpU0lraVlvUUpMQW9CUUJSS0lXd0drSVJKVENTZFRFQlZpSWtuUW9neFZhQTdMMFRpY3l6RWdKUUdBQ1FoalVWam9TSmpFcmlVMFl4aEVrQ3lpVG1ZNkVWUnpnS0pFbGJKU2ptQzl5U1Vrd2tsR0FRTENzQVJaSkppekNxTmhBRldFY1RHVkVURWdkaVFLUklKQlV4YUJpVENLMGtDZERBU0IwT1JRQ0lnWFJHQWtreFJaSkMyaUMwSUdMSk9CME1VZ1pVd2tsQ2RBRWl5aVpaT3A2Q1NDVG9uVTg1Z3RtRXRJS0lNRnNuUTBlZzRuRXlKSWtrTGdLTVpLSUpGYk1RWXhoTE9CWUNFWXFwSlBUSE1pcklNQjBqQ0lBQkppQ1NDakFtYXdBQlJKSmtzeEFDVFZ4SWxHb0VTREdFeVdLaGpBQmlnTVVZeGhNbHFTMG1vT3B4SUtFc3hpUkU5cWVjNXJ6S0tBeGpDQUNKZ0F4WWtvbU1ZaGFDckdJU2hvR0V4Z0UxWTZHTVlSQW8xVWFKRWd4Wlp4RW9rQkVDVEVGa2dkRGtJQVpSRW1LQW9UR0F3bU1TVVlrQ1NqR01VQmhBd21JTUlDU0poTENnd0FhTUJaZ3JDWUJpemtCUkpCWUNBaVl4aWlURW5RQUtFNWlCWkJpakdNQWlTSUdwQW9SZ0pFd0VLZ0tJckpqSjBPaThpUUVDeElFb0N6SE03a21CRUZ4WlJra3hhaVNkaEU1bFVHT1JTekpqc0MwQ2NTVEFVY3dFc0FPUzVBeDBPUzlTaURDUVVJRUZIU0lJckZRa21zeGhXU293aUZRSmdpU1RFcGpLQXVBd0ZFQXpTNGtUVkJjWVVMYUF4Sml5UU9pWXlwakFCaEtNQmloSUt6TTFkWk5TSUVtQW94aE1COUJQQ0s4eWhPeHhKTEpBU3pFZ1lURkZKSUZFZ3RtclFpbUlxekVRRkFXYXNVSjBKTVl3RlZJd0dNY3pzQUVpU1lTakVnSmlpUk9aUmpFR1JVaEV3Z1VjeWdFQkFvQ1FFU1NoT3B4SkV3RmdCZ01XSkJqR3F5eUNEUkppakJWaVVjelJKZ0VBTUpaeUVza3hKWUZCcFVUQVVXY3hNSUdLSkVDQkxKQVJyQVdTTUpSekpKVk1TZEV3ckppa0MxZ29rc0RDU1NkZ0E3UVJXZ1NTbll5OHlnQkVrNktGSkoyTVNSV0VnRlpBc1ZzcE9CeklNU1lnc3hqQXVNbUVGN0hJeGpHRVNnS09NSk5BeFJaTmdBcURXQTBVU0ExT1VDQkpnRWxVZ3dDU0xNcjFPWmdPcXlrRkNLNEJza1RHQW94MElNWWdTaEFzQkVrcUV4SjJxeURIQVRGRkdLT1JqNkNlSVZneDBNY3hNWW94UmdJTWRDRVNnSktWQXNrRVM2Q1RRR0E2VkowR0pMb0VTU2pDTkVCUlJ6TUJZR0F3R0FBRXhqR0tJR05VaVlJQ3pDWXdrQ1l3bEhJUU1ZQkxLRFJnamtKaEpBd21NWVFFeHFvOUJ4aVFBeElpSlZkRGthSkpXekppU1ZSVEFkRG1BRmdZS29tRVRFRkdOU1VhTVlERUZHSkVzUU1RSmpFZ0FtVU9xWTVyUmkwQ2xFQ0Y2a0ZBU0lsNVRXTEd1aHhUb0N3VUpBSjZBQTVtSkxMQW9BT2RCVVk2RXFsa25KSU1RdUxRRXhKYXlRZFVBV1JFeGl6bWxrckoxSkFzeHpFd0NRbUtYQUJoQXhva2tDaVFNU0NwSW1BQ1diVkF3R01CaWpMaEpzb1FKTVVZVENRSW1BeFpJbGdWRWxDZWlnZ2c1RkNCWmpFbVBlZlBUb3FRVVk1bEFZb0NqR0F3QWxpVUJsREFKa3MxSUJBWW8xQWdYR3JDWXhpaENyZ0FBTVlRRWt3RkdKTEFreGhKTzBRUUZZVFFDQWxHQTZuTURGQ1NCaE1VWUJwclJNUVlUb1FBZ1lDZ0Frb3F1eGpsQVVRQlFrbU5WbUNJTW9VbUpCWlNoSkxKQXhSZ0lMQUJNU1l3VlFtaXhNSnlFUU1JRmxtT1lHRWtEQW9pQzJZU2tzRnlTQ3lTWEVWUk1VZEk1MXF4MUF5V3NGQ1FKU0FIWTRpU1l4MUlLSUUxTUFDdm9NWThpQjFPS2gxVHptS0pGYklLRkZRVEVBVUNJS21BQk1ZQ1NqdWNFRndIUURvY1RBRVlrd0FtQlFWQklLS09SelpzdG9BVXdDWmNJR0N4RWtDaExKTVlzMFRwTUlnVUpjY3hXaVVzdWtEa1lCQVFMTVk5UjVnT2gyUElXU0lDQlJRQVpBeFFtRW9sWk1JbXN4UmpCRkVIVWtrcWdSTVpWTUJqb1VZQUtKQXhSSmdFRmt4b3hScklFU1lvQUtJcEtpQ3lGUkZNSUdBNkVBQWdZU0tveFJvd0FZUU1TWXNneFJnVktyMFNjU1FFRHFvU0JJbEpKUnpNdVRHTUFHQmFSSk12Tk9oU2hLSWdCZ0Fva2FTWVNUTDNPU1lBRW9vQ2hMSklFNW1NSUZLR0tJS1NqS0hNN3B3TXZTT1pWWGxkY3dyb1lreGtvbFZKT2k0c1NDREpoWEZtSlN6bWRWZ3NrNHBTOXpIUThpUUM0Uk9RbENjeEtFeEowSktFQ1JNQklnWW9pbU1ZNkdLamhRQjFKRUNwWlpsWUF3R0V5d1VRVVNZa3M1SmtXckFFd21KS0ZVQVNySlVBVEZHS0pLS0FEQ0JRR2lxSTdIT2s3bkVDU1RHRXN3a25Rbzg1ajBFRUNRSkpRbUV5SlpBZ0Jpd0cxTU1ZdXhKR0tJRlZLb05MazFZb3hRRVIwcWdLQXdFa21LQ0FtaUV4cVFBb0l3VUJGQ1l4TkFtaktKUllrbU1KaXprWVRFbUFreGl4Sk1VQWdRSmdFVlV3QWQ2NWtuc2pxZUVBTEFrcFpUR0tJTVNZb1NCTVNJbUJaU3pFbUVCSUU2SE13Vm94WmdLSU1ZZ3NDakdKS01kamlCUmdKQW9wZVpSUjFTRExqbWRUaVVBSmk0TGJNWXdrSFF4ek9xQmlsa0NpUVJKWHFVUUNZREZBdUlLU2pzZENJOHRxU1JHckVpSVJRVlppZ0lMTE9ZaVNCSlJNZERsUlZ3SFk1Z01GY1N3aXFTZ0pDRTVrZ0pqS25NQ2dLSklKVEZMUUNpVVFBR1NsdFpSVFd5QWdXb21Fd0FVV1NXQWhHcGdOVkhjNUVnU0JZZ0pqSHJQT2NqMG5BU1JKS01CaXlpVW94SmpDSWdhMUxxOHBOWUNWbHFtaVdyTVFDa1ZaaXpGQUV0Mll4aVJFeGhDQXdVeEpob09oQW1pVnF5U1lzRENGWUNwWUJPb0NRVUFpWUNSQXdDQmdPZ0FVQmlqSE1rU2hCY2lBalVrbjFvOGh3QUN3RUZFc0NUbUlBSWdCSmhMQUZsTEtBa29reEltQXhkYzRUb1NKSjBPUWtsR0F3Q0JpeUJFQkV3a21YSFFVUVdUR0lLTWtDSmxEMUhJa1RIVWdreVVZd3IwQTVtUk1xY3lTMEN4SU9hMEIzU1RxVVhMNWFzNUhMSjBCTVFWQVZRSmdFNkZBU1lSTVFSRkUwVk1kQ1NqR2lxa0l3VW1NY3pRR0FDbGd4Z01Za29DU0VvVlNUdWN6Q0ZrRmhGR01KTlNKV1RiTmdVSkJRR0VVbzZTd0JxU29zOUJ5cm1RQUpSU3BpU1QzcDRsNkdPUmpGa2tpQlIxVGtZeGlsVVRFaVlhb3VNUU5ZeGlnaElWQkV3Z2FzSlpKaEtNUkRXR0pFS29JblJ5eFpGQXdsMUVZa1FxaVNva0NTNm9GSkVDZ0FTam9TUVlBS0lBVEVsbU1ZUU1BR0FSTXFTVW5RNWpXT3h4Q01Za2s2RmtGQVNTWXNsWlN5U0JYSW1Fd0ZCUWFKTVVRVVlSSk1Zc2t4aElBU1ZSUklMTVlrUk1DZ3BZbUJhVHFTWWtrb3BaSUV4RmxGeXVYU2lzY0NpcTV3RkdPNlFVY3l4V0NnU1NpVENZeHpBOVp4WElKMVZPeTZQR2NhNm5JRHBVeGdpd3FZeFpCWllFMG5RN0hTUEljeWdMcmpWeG9uUmptWW9SakhHa29LTW9BeHF5M0hNNmtra0dNWWt4Q0lxZ0lpSnJNU1VqRWFyR2hxQUtpMTFtSkVTU2hBdVdSMU1TTVl1T3A2VHlWQklpZ0s0UU1leE9LaHhLQUNnTVdTQmt4akZsckNKaEtFcWdpTUpRMWlTZ2pBdU1nSWdhc1lvb3dpYU1UUVZDWTFBUk9obFFqVUdoQ2lBeGpWakRBWXhxeGF6SlJpUkpFc29nQkpNSkpqR01ZeGl3TVlneGdFQ2x3bVFBbzFVU2FFa0NUb0paSklHSUV5cVNKSmx5SmhNU1VGQm94UUFZU0JLRUNqQVVTU1lva3BaUU1KWmlER0FnNkxLQjBMQlZNQllITW9sVW81bERaSXk2RTFKSWpBYXVoakpoTUJDNG90SUpQUWN3T3B5QUNETFJpMEMxNlJ3UFBTUVVFYXJHTUZhS0VUR01WVkhjN0h6b0sxU1NkbzVnVkRwemlpRENNV1JXQW1qSUFrQnJwS0dNU1NBbU9ZRXBZbUJhTVVrYVZGa2dXWTVIU05VZ1l4UUdFQUtFVll4cklMTUIxT3gwT0JCek1aRVZvb2d4OWc4S2VVd0dXUkFvVEVwYTR4aWtGRW82R3JDUkNCMEpMSkJVeUFWcTJXQUtvdUFrYXFFU3FrbU5Vd2xBYWtTQkpLR0NzWXdtSkdJR2tZREFBMVloR0pKS01VZFNDUU1Zd0dJcTRrREZBSUdNUVdJQ0JoRWtDZ0VCTVl4SmhLRWxZRk1JRkdKSkVrQ2pGRWlZVENTZERpWXhRQ1lDeUY2R1RBQklpQmhKS0U1Z1dRSmlTekVsbEx6S0tNUUIwQXhBaWREa0lFbm9NZDQ0a0VGMTBPUlIwSUNNZEtzNHBqR0FGc1VUbUt3WURvQlIzTWVlUE1PaGtwZFV0RXh5TlRGbXBNVVFXZlNQR2NDVENTSlVKd3JHaEtBd0NBbU1hdVpveDBQTVVXdEVFa2tpWXhKaUVvNkFjMXNDMG11WlIwTXR4RmtGR0Fnc3hRR0V3R0tKV3dGQTZrQ1dKOUkrZWNoSU1sS2lXY2pIMWo1SktJQ3VBQUtFeUtwakFpcWlZb3dtTVNKaEVsVXlBMWhnSkVSS0dwQ0xLWEpqRUNVWXM1Z0ltcVRERVZRbU5DUUJSRmRJb2d4UkpoQW9ERWdXWXNneGpFaUJKaVRHS0FzQ1JNU1djeWpDU1VCaEV4aVFNVVlBRVJNU0lHTElFa29BSkVTaVRBQW1FZ1NDaWpDU1VVQkpRbEdJQXhRR01TSkpRRkVraVlER0JhT3B5TElFeFpnTVl4MElKS0tPS2RaYUpJT3RCakNpVExqblhZRXhpaE9hMlpMT0lyQXBKUlpJa3J5aVRwWE9PcE5sTGdpaG9pVFVGVXhoTVlERW1BczdSd09kSlVTTmFLTUJJbUFBb0pqRWxKbHNoUUFBUk9ZSFFrQkpNVVVXY3lqR0Vtd0VrQkFveFM2SU1qcFVBcW1BNkVtam9YWjBNY3ptQklSam9UU0oxUFNlQXhpaURHTVlTUktNSUNaTUpRaUJoRUNWd21Ba3BNSmdXUkVvcXdOQVV2UWxNc2twME1kQUlLRlpBTExNU1lUQkhRNXFHTlFhTlloQ0FtSkV5cUpCMktYaUtCSmxvbExJTXNtRTZKek1LNFVrU1ZTakVHU2dLQW9rU0NnTUs0RXdpZERtUVN1U3pBWWt4SW1XZ1RHTXFDSkt5QlppZ0pMUkxKSktMSUVnd2tyaEpNaVl4aE1RS29KUkM0eGdBc0NqR0pLT2hCSml5SktPYTlpd2hxYVNVNkp6VzFDU1Npa3NCTXZjNWxFRW5NeVVkRG1CekVtVzQ1NlhIUWdva2tvbGJRQVNxU0FFa1JBeElrUWdGWEFWUkZvTEtvcGpFa2FURWx5d0xLcVF1QWt4aEFrREdLQXdsRkFCakdDekZTeWhTU0ltSk1hS29LTVVTSmhXNHNsT2xXc0pCQklpVVl4UlI2RHhrbU1Zc2trb3dHRW95WXhsb3RFRlFwa2tvd0traVVDSmlCQmJOWk1XTnNwVVlxa1lrS28wS3B6TUpqSnpLWEdTUlZzd1Nna2dZUkdnWk9oekFEQ1VTQUhvWGtnWXM1aXRFb2dDZ2lLQWlCZ01Za3hSSmpBVVpWTUpKSzVLQVJYbVVTbG1YbUNZdGNnU3VNQlFJZ0paSmdNU0FpSkpaSmpvWXhLNG9FeGlDU2xzQkFRSkV4Q1dVdU1RWUJNWXdrRkdMSkVSSUNOVXBReWhkU2VtR3VJbU5XaUN6Q1dkamtBblVUc2VVNXBBaVlTQ0RHbHhocE94VVFRUUJKcXVNTkprQkJRa3hRRUZrbWdBeGlnUzFEQ1lDQTByTWhRQ1JSVVdST1pRZ0FFbUtFd0ZnWW9rd2xoWmozeStWUFBXQXdtSk1WRFVnWTZBWVRMMGpGSjNDM2tuTWtTU2hLTVVTZXc4WmlCQW94QW1BeFlpZ1lSV2tTVncwU0pSakxpU2dLVEdJTVpjVll4alc0cXlJbzFWa0U2VkZTNGt4UUdLU1FNWVZDckU1eW9HTUJSSlZBU1VZQUVvQ0NnWHFjMG9nc0FYR1RBQzRURnBJa21LTVNZeGpBU1dJa3IxUklPWmxSU1FGVXM1Smpvdk1FQlcwbzVMakdBRVRGa2dXQmlSTVNVSkpSaEFETEpZSWdZa3lwUkpaaUNpQkpRT2loMUlJT2hKaURGaVNKQWdVU0Iwam5RblFKY05KNkl1dUpSekpockZpV1dZZ1NUcWRDamljMHdFQ1k2RUVHbFRvYXVZbGt4UkJJVmlvUnJrS0lDc2lBbkVva2t1S0Fza3hLZFY1Z1dTU0JxWUNDVEZJdEJ6TVVRVVlrQUVRTUtXU3RGSkpOSXIwU1RTbEFHTkNCckFBTVlvd2dZVG9TSlJjczJCQmhKS0VveDNFODRDU0lHTVl4akZtS0F5SUxrVEFVb2dWYW1qQVVnWXhSbGdwTVkxcWFBYkF5c2xDQmdXeURDVUFKaEFva1RWakxNSkppeVVva3hnRXBVaExJQXhhZ0lDU3FBRkpSaUZrb3hSU1lnQ2lUTGFRQWlxY3hSTXFtSkFzREFBZ1VzcGdPeHpXakFZbzVnaUlBVUJoTVVZZ0RBSlpJZ0IwTVF1RWtCVEdBc3lwZ09aUWdLWVZBTElBeFpnQXdJbUU1clNTSzRvd0FtT2l3bllzUWw1eFZjeE9sblVURXFtSU1BbUV4UmpBaWMxU0RwQVNKcXV0bFJJRkYxSnpJZ1RWaWhXRG1TYU1VQUVsbUtVQkpyRlFBQjBPUnRKekthbE9kTldhTkx6S01TSUNRU1VZUUtSSkZWQTFJbEdJaG9LWEJJRFVpWUJKRVRBV1FJQ1dWTGRra21LQXdpSW1JRWtERkFCSjBNSlp6TUtBcUhSQXhZS3BodElTVENtQUN6Q3FnU1pXbUZOWE1wYWt4Z01Vc0NBaUJrUU1KakdwQmFpQU1XQmt4aVFFeWhrU1JFNkx6TW1NQ3BqR1FNU1piSk1LWXhqQ0MwZ1NCU29HUkJWSUV4UUdBa3NncFZBVG9jbHhoRUNFc3hKakdNSWtsRUVpQllDVVlDQ3lRVk1Bb0dLQUFXakdKTE9aMEpUR1VLRWtvc2tERmdjMFN6bUtxWWhZRXhSa1FXa1N5aFdZS1lzNldKME9heVNVWWt4aXhFQk9aU0p5V3hLamtkaUFwcW9JeEpaSkZXY2lpVVNDRnh6TU1XV2M2MEJaekVERWwxVVNCMk9CSWFiTEZuRVJLSVhHRTVpQWdjekdMRVVnRTZyam1YV0tPaHlOQlFXdEhOSk1kRmt5QmdNVUJpeVRBVVVNdld6bUpKZ0Fza294Z0V3R0tKRWd0QXkyQUlncVVVZ0lqVkdKbGt3a2ltTVNkaUFNSUxpaFRGbkl0Y21Fa295b0dNaVNvbEVtS0FveElGQ0N5WXhhU29BZ0pCa3NsUktPcTQ1Q0NVb0IwTWtGSE1vRnhqSWtGaVpRb0RKQUNxU0lvRWxGRUZrbU1KQWdKaXhKQllSRUNnSktFVEhNb3hpUUVrQ2l6Q1l4SUdBc2tCRXdBWUJWQXN4aVVzZ3dMUjBPWmdLRWtDNUVDQ3E1cW1RQmVoekZLS01ZeFJaekE2cmpzVWRDQ0NqSFFvNGxHTVdFUVJwcEFWb3FKS09RR29ycmtuTXFnb0NBS0E0R0tPSkJSVUluS3FMakVrbll3bkl3bU1RQWFUbGdBVEZBcVFTWUJFa2d4aEZFbW1MSk1aYnM2a0VEQ0ZvVVFnVVVBbk1vZ29TQ2lpVFJaRmREcExTRlFCSmdFb294SmpHTUFpaXNDWXdpWXdnSmtTclZDR3NVUkFVb0JLSUNTSWtscktVVVFVcUlKaE1ZcGNZQlRHTVlWUU1KSmFZQ0NGUk1aQVRBWXhBSFU1cXA2Q1RtWXNrQ2dVRVFLT1pTWVFFeEFsaXNpS0pCWUVnSmdFc2xja21MSUpPaEIySU1VQks0NW5WT1pnRW9ra29Dd0xPWXFwQW1MTXNwUklHT1pRTFJhU1lDUktBcFJKTUJaSlJLb0NCakNTZENESmNjeWlyUXhCYWN6TFJoSk1VVUNCYXBKaXk0NmtsVnpLT3gwQVFKTVNWRWpveGl5WXhCNXpGQlZFakdLMHdSUkFtT05SSmxpV3pxa2ljaWhwamtZa294UUFkYTZFbk1pTWNxcUFrUU1JQWN4WEVsbEVISkZVcEFha1NpWmFKS3NTZ0dNcFZHT2FTVUJRZ1VBRkVDVUFGVk1ZdVhza2FWRWtBSWxHSktLQUFFbE1aVXdHT2hpQk1JbVNodEpNVldBa1lGUklGTVl4akNaUkVvQlVFRXhZaUM0QkpUQ1lnNkxJa2xGR0pRSkJVQlJFZ1RHQXhqb1NxblU0Z0pnTVl5MEJCMU9ZQ2xHS0lLRXhKbFNTMG9zNGxFbUV4SWdLaFNjaWpBVVlva294Z1hHSlRHQXNnNkhNb2s2R0FvbFpRTUpqS0pnTWNnUFFvQmpKaWlUQUFxcGlSS09aUUtnV1NVU0pqRm1aRjVsWnNVMVJpVVNGb0JJT3BpU0U2SGRaTVNZMWRvd0ZuTXNXUmVpNER1Y3doT0dsUmlqbUVRQjBBMVlUcEdNSmdxZ3FjazVwcGVsdmNrZ0dZV0RtQkJRR01TSUZuVTVWb2tCS0lKSk1VQmpITUZvQkVnbE11VEdDa29EU3BpMExMbENCSnJHS0lFeFJRR0pFU1FFc2tTZ09xOVU1QVNZa1JLTUppVENBbVFCVWtTZ0V3RkZHQk1LMGlRZENRQlVURW1NWUN5UkpNbGxFR1ZLQVNra0Zvb1NSSlRDQUxSSmhNU0ppU1JGRVFJTVVTVW9VQUVuWTVwakFBaUJSUklLQ1VnVVdTYzF4MHNBTkNKZ0FCSkVRRVRFR1dVUVhzUWtGbUpFNkVnVUNnRm9GSE1STUpSQlpwWVNCckhRRmhNV2NqQVdzbGtHUUVDaTE1b21NQkFGRnhNdTBwSUVWUk1ZcE9RZ2JOYTFkREVrZ21YRUZnWkxMV2lESjJJTVN0R09zY2dNYXl5bDVRaVVTVlhJeFl4d0xKRWt4UlpSaXdDck1sR2pHV2tGVm80bGljVURpWUJPWW5RNG1FeElBWVNWVVNCQUY2RkVFRW5RQ1NpU0Vva3hRR3BKR1hDblJTTHNneEpxeEpSSlFtRVNSRWdvd0hVb1RBVVVTU1NKQlFtTE1TWW81bU1TWkJhQW9veGhKTUltUUtWTWlCUnpLWEdBd2ttTVdTSUhkRTRtSVdpem1JcGdWS0pFc0VDU2pLQ1lDUkVra3dnbUtPWUNKSlM0c3hCMEpBa1NpVXN4Z0V4S29sSW5VNUdJWG9OZ0Jvd2lKSUFVQUNZb0RtVW9pUXFaTUpJQ2RBQVFYQUlwSW1KTEVva1NaWlFHa1NWUVRFRWlVcUpJb21KS0lWUklNSmhBMGQxODFkRWtCV1RvWXhrVG1ZUzE1bENVYzBrVEtIYzRpbnBJV2dLRkpBVlFLSmlEb1RaSmxxRXhoSW9NU01XVUJBRkVtTVVkQ2lxNkdVSWpKUlFLZ1lvRGtnU1lna3hJRUNZeXlDWXdHVVFNVUFDdUFrb3hJZ0p5UkVDeURGQVVzcFltV2t5U3MwR0VvQ1JLTElBQ2pFREZWNkNqa0FBVVdTQUFXWXdra2lKZ01TSmhFa3haaWdKTE1TVU5Jd0NVWURGRWtHQXhqQ0JnU3dLSlhBWW9VQVZBWW9teXlGQ3lCQXdsQUp6RTVvQ0pqTEltRk1vVWxBdmM0Z0JqRkFsRnJKSlNTVVVkakhOWlRFclEwQVZHRk1KaUN4T1JqQUluTXRZUUtWRVU1Q1FZNmxra0ZLR0xJQk1BbEFKaEpNcVFtS1ZJRXhKSUpTcFFGcHpBU2lRVExpZ0xBaGVnQVpKRUZ4ME1jd0tGTVlTVnlkam1TQUhRRkRKQjJMV1RGQUtZeTlqaUJSVUJGV0JkT1hJc2xDc2FYR0VwRmVRRW1FN2tITW9xcklqcUswbUtKWG9kQ0NpRG5ZQkVBY3FDWXdrSmFpeUtRQXJJR1RCV0VNcXRDaWpFQUFITkVDaEpFU1NseU5hRTFhTWhhR1JyTG9DZ0tBd2tnQXhaNmFna0N6Z0pSUmlTU3lqRkVtQXNDU2lBTVl3Z1VZd0NCUmdHa1lrc2s2QVlvZ3hKWUFVS1pRZ3BKWEZDU1lUSkpVcFFKakozT0tvRUhRa29wSldpU0QwbmxNZ1pWRlFvRElrbllWNWxISVJNVUJaQ1V1TVpPcDZSUEdLd0tRZEZ3SmxBRXBFeEpCWlpCSkpZbk13a0dMdHFNU1FsbG5NeFFBS2hSTVlteEVUQVVRdElGS0hKTXZRNUZvR09oQmdVS0V5QW1FeGlCS0lLQXBjWXh5VHFBTGdMRWc2SE1FU2dFd0VnSWtyWXBJbExoQXFFbXpIWlpLT3B6T0oyamhYVTFkY3VaQXBKVlZMQmlERmdBRkdPUmhPdEJFWXM3S3BqR0xYdVlvbXVja1ZNUVNUVUZSaEFnNXFtVEVtQXhCalZJamxyUXNzeElHTWNFd0hRd0NTWUZwTlRIVTUwbWlLVEdFZ293bU1Zd0FZWTZub3FTVGtCakZDQkpKaEVva29CRlZBQ0JFd2dXQWdJbUtKQ3FHQXdtTElFa0FNQW5ZaE1Tb1VTV1NZd0FhU2lWS3NERXAzTFdTZ0lFRTZFcnpBQUtBa3NDUkV3cDBPWjFXQ2lTU1JFb0RvSlo2QklTVGtCQzR3Sllxbk5BNkxCaFNqQUJRSFF4eklJT0oyQXNveTQ0bWpvWFVuT0tzeEpRTFJVY3dOWllsSFE1bGtyaWlTU0NEcVNsRUNVWTVxa2lVQmtDaEFnVm9TRW9sYUF3R0F3bUpPcEJKMEtBeVNXQlJTOHlFeFJDMEpTSmxDeVRRUmVzcXBhd1lDRDBSd1BSWG5xc3NCWUFKQWdRV1NkU0NpcTRFbGtsR2ppZERKMUZlaDBQU2dTYTJsaVFBNWlVY0ZvZ2tnNXNpaTVNQW1NWWdhU2k4cHR4UlJJRUFKeElFUkF3SW1LQ3NKakdsQUd3TUJRbEZBUVdRWUJPaDFJTVlneEpVZEtnQ1JYRklScUNUb1d1TkVXU0VsaGFnQllDVVVTWWtSRWtvaEpPaXdKaWlTaVFPeGlEb1NXY2hJRXhJbUVZa29pc1k2SFFrU0RGR1NqbVVRdEVnSkJaQmpHRXlKUzlEa2REa0tDNG94WjJTZ1htQUFVU1pBVEZrcWdsQVNZb2tCRUNqRm5JZ0NaYnNva3NoYUpLTVNTQWduUWdxV2pKSkZLc21wS1ZoMFpFa3hKRnFhU0JBczZrR012RVVrVExoS01nWXdnQWdkQ0ZDakVBZEFSSkVzZ1FYSmdPcEsyQklBbU12UTduSWs2SFFnU0JFNkNrSE1nNnJ5S0tLT2tjakdPaDV5aUNTaWFTaXl6bWN4QVFKTkdNQmlqc2RUMUpTOGw3Rm5BRWtoWUtPUUFaS09heVVnSUhJa3M1bXFDb2tsVTZHQVRDQnhBU3pvY2lSVEFZYVJNQk10RkVXVVlRS01ZUUFva2tUMEZISXdDUUpvNlZ5TUJseDBDU1JxVEhWY2FHemthTVhVbUVzY3BwcEpLSkVrb3drSkJTMlFVWUJKQTZGSElvU2lnT1FnY3pxUUEwblE0eFlGSFU1bUpPcHpMVEhNd0xRQUpJZ0JRSFF5SzBKQjJPQ2N3WHNXZFRIRkF5NG9vU1NpRW9rUkJaS1N6aVVXQkpoTVlvc0NCT0pyZENpU1NxWWdTZ0pGS01KcGVoeVRWakxVVllDdFE2UkpnQURTeWsxME9SQmowSG9FNEx3Rk1JQXVMQkFvQU1Zc0NUS21LSkVESWdKaE1TcWtsbU11QWtSU2lWNkZHRURGbEhJNmlTWk1TUVF0aVVVVkFCaURFR09kVldpem9KeUlBeFIwT1JZUWtpU0JaUjFPaGEwZEJPeWN5Rm9EZ2N6Z1Fra0dBQUtKQXhaTll1QUZ4WlFnY3dJSVFBbzdMa2dLd3dEU1NVU0lyTE9YRkNRV0FraUJoTUIySU5BTkFDVkYxeU1kVGpEU1VRVVlCTVVKQmlTMUV3UllMUnJMSU1Za3dsa2lrRW5WWkVBRWtnc29DekdPaVFRY3hBb0Z3Q1lxT1kySjZWZ2trNmtKZ0JjU1VBbU1ZREdGS0ZVNkVnQjBSTFdDVGtLSlJJbVcwdW9pZ0FpbUtJSkV3QVdVSml5amdJbG5BeEpLMm5RNGxtTVF1Sk1VQms2a2tuYVdDRTFKb0Nxd0ZBTnJFRndrcHpLWG1rSFdvTzUwUE9xU2FRTHFSQlV5WUJJUFdjVG1kVG1Za3BiT1lKUlJnRWt3aVNJQ1dKQkJSWjBCZWhJSFVnQU9na29HQmVnSnhKWG9ZRW82S0V5VGFra2lCaWl4U1FJaWxpcUtMTVRGRkhBeEoxT1IyTEpQU1NTVUEweEM4VGtrbUlNV1NXWUNnSUlTVlNrZ2hiS1d4SUpNUkVXVUlDdGdqV0dBMUpqQVlRSk1VU1VZeGlSTVNXQW5wT1pJeE5Za1NvcW9BQmpVaVlrVEFKWWdZNTFvb0JoR3FFd25Nc2t4aE1TbENTdlFnNUdBb2c2R01XU2RCU0RtQUZHQlFTZ0NBYkpPcXBKUmptbEdBVm9RQUNpRG9RQmtTbG82SElvNGltQmNKU1lvd0dPeTVHcGlSTUZFWXhKUklHRXNzbzZuRWtvczRrZ0JTeVdnWUNRVUFEcVFaT2dDVExSS0ZCVWFzV1NXUVdzQWFNWkFwUkU1MTJPaHhKWEFhU1NxU2lGb2xLQURBWVFFQUJjSmt4WUFJbk1vb29DREhRUUpMS09vS25ZNWtIUWtERmtwSUdXUVFCY0JTVUNwMHNoWU5DQmhLRWdVeG9wU2dEREdLVDJMeE9SWUNCMFBPUUJSSnFhWXFBZ0RFZ1NTSUNXY3pITktYRkVHTVVkRm81bU1jakppZ0VWekpXYXFJU3FBQXNBQXhpakhRNWxBWVNUQ1VRZW9vNGtnWVJCVkpFa1NqR0Vrd2tDZERHTWN4TVVFZFRsVm5VbE1Za1ZrVEdNSmt0Y2NrZ0RDcVVVY3lpaEpPcHdTU2x4UllDU0l4SlZsZ2REa1NxQ0lHQUZBTVl5U1l0Y1NKUW1NQnpRTXFZVURGclFKSlJZbGxIRXNEQVNRSmlpVEhVNkhNUUtMT1p5QXhSSzR5WXhJZ0JoTVFXVUpqUzBrRTBtTVdCZ01YTEFVd0ZJR09oekdyT1JpUmpDb2hRVVN0RkltT1ppU3pLQUJqSUFxSmtvRmxFa3N4UWtDV1VTWTZsTDBNU0pKZ0pPaEIxSlNEbUs5VEo1d0VwY0pqRklyQkpRZ1VkZ01jMGc1clpSNkRSUjFFZ2c0bk1vZ0FPNXpNQkpaSVZKSXhJVm9vbFFwRWdCSnJFSlNneUJsUk9oYXlCSnhNaWl1S0JaU2lWUkFFRXVsZFV4Z0tKU3lWUkFza3dBSlI2Z0E1QVlvczVtRUNTaEU5UlI0eVRBU1dVWVRtWXhoS0pMRVRGaUpDUVphRWs2Q2NpVGtXQ0psU2tST2k5U1JBeDBPU1NjMWdEQkpsdzFZSFE0aFdNVENVUUpSaXE1bWtRT2hKbFRGcEpTOHdKQW93a0ltT3BRQ3NwWmlsa3BMT1FnY2lpaUJFeDNPSUhNOVF4eU9GVVVTWXNnQldTa0lBS0pwVk1XZ0ppVndDbUtoTlVtVzBneWd4U0JoS3Q3SGxJRXhvREdNaldNWXFJcm9jekNJTGpSU1JXQWtwY1pPNXdVVEFVU1dVU0s0NnBoTFd4SkFva1RHSU1XY2hTeVRFZ2REbVpRQk9wVUpKTmRTU0JNQkp6U3dYc2V1UHVIeEk4dFNkRjVrcElrblFhZ1k1a2lZazFFTllpRUJLSUtJTVNOQXgwT1luTVFKS0tSYW94Z09KaFRHS0pWRURHRWtXZFZMMGpsVWdVV2xHV3l5RHFTU2RBRXM5QnhNY3lTekwxUUFrREhVZzZIWThvQUFrbEhRUU9aMU9ZaWRDVENRV1NkVDBwNTBGeTQ2a0VrRUZHSU9pWWxVNklrbkplUklFQ1VLUVF0Z01rbExJMFVSNkFPVVRTSWdCWWlFVFFtTVVBcUZnZ0t5QkppaVJFeVlvc0JVU2pLZ0prZ1NEb2N4RW9zNWlKeklPeDZzdkhVVUNZVEdNc21FMG1FREd0d2xvQUFMaWdSR0tpS2JaTFFLWG5GR1RDVlZMeUE1bUxHSU1BazEwQkUwU05JaVNDb1F5YlNEQ1N1TW1KVlRDV1NZc2xjVVVLVXRBWXgxTUJCaE9aaXl6aUNZUk9nbkF5aFJaNkJpQ0NLZ29EQ1VTVWdDNG1tTVhGZ2dLOGlURURVbFJnTVltcXB6YVRuVlJCSmpGRWxrSE1LeGNZa2tSVUJLVEN0TDNPQmppQ0poUlhMakdBeFNTbU5kV1RBV1hYSm5MUmlpVEdKQXNJbzdyZG5Fa29TU2xVQU1Zd2llczhZQUJSSmpBZERDWXM1R0VzVEVsbVRGbEVyekxQU1dlVTRnWVJKS0pBeDBBNWdKUkJpaEpKTUIyaVNqbWFzbU9nbkdYQ1lndXhLVklFUWdDdWtjekZqVWxrSklLa0dLTVlRU2lTam9BZ3RtRWxLSk9ZcktVVVl4MFZPS0JCWkl4cWdva29TamlxVkNCS1lzQXRTMGxVMGlRdEpRZ1pWQW0yaVNSS2dHckxURnh3bDVhWkV4b2trczFZVERrMFZnWG9RQmtTVENTQmF5Z1VZU1JJS05HcElFc3N5NFR1U2N3RUN5U2lnSk1ZeVl4aXptc3AwSVdnTE5DY3pWMUtqR09OSk1KanJRQXhxNXhpQU81NXdFeE5XVEVsR0pNTkpvRExKa2t3bUxBNWswR2pvU25Nd3JoTVlVVjdMQkp5Qk1TWkxNMVJqR01LUVVwWlpNVUFVQ1lTam1VV2N3RVl4UytoT2RZREdPaEpBbUFTU3hKS01TWUNpU1JMTUpnRWs2SGNnNW1LU2lTam9za2xuWThRR0lFd0ZnSml6a0pKUUhRQUtKQWtCS2lDZ3EweFJSeHRza0lJcXl6TElDSVJJMWNRU0pkQlJLUVN0Q1FJbU1aTEF4UlFGQ3VLUUU1Z1pST2hJZ1V2Qk1TWWtvMFRXTEpMRTZIRXk2S0pGTVl1c29VZ29YSUZMQ1lvczVMU1VhMkJKTEpqRjFrc2dJNXEwSlJnSWlTcXNCSUxoR3BLQlF5QklsRkhNN0VMeVNqb2N4TUpJR2dyR0tMRVZCTVl4UlJpQU9oZ09aUlozVDBIaEF4Qzhpa3NsY2RUUjBBNTFRUkpncWpSMEpDZ2txSXFvNWlZU1NqRkhPc1RHTVVTVUJGVklBcVpNc0NZa1NEVUJHTW1BRkRIUUJUTGFwQnpCTUJrVjZLR0VER1NpRkU2VkFSUUpUU0JqV1lva2t4akNWSG9ya1VRVXFuTVRBV1lDaVJBUk1BR0VBS0VvU0RHRVRvSnpLVEVuVUZzZ2dra3lVQWlCaE1DcEpKaXpHS09SUmlSSkV3Z1dTbUJlcHlFUUV5ZFNDVkJRTGlLeTJCb2c3Vlp3Sk1ZeGpHRkF4UW5NQ291ZzZGR0VwUktQT1VzcDZEbVN1T1NKeUtJS0xBeGpRRTFKUlJpbEJHU05MaWlWNkVnVVhBQktJRmhTQUtGQUtLeWRVVG1RWXlwQWxFcFJKUW1JQVRDWW9ER0pFU0RDVUN5bU1CaEtBREVtTEpMS0ZRUktNSkFwaE9nSFE1SHFsRGxaeEpJbDZFVmkwNkVtWEV4MUlvT2hnSUlJS0FvVEUxY0FSaVY2RUpaektLTWN3RURWQnBWSnFvU2tscm5aVUJqQVFVUVVCaUxORmtLR0xCWlo2S0xRbk1Fd3FvRmdVQkswQ0JLcVdjNndER1hGSlpOUkpkdFJ6cEF3blNPbEFBRU5CZ0U2RVJBMG1ncWloSkF3Z0pJbldKRW1zQlIxQUFJS09wSjBPcDR5RG9jazZuTVZ4ektGTVV1TUJRSlJDMlFZeEJoaWhBMUlBWXNTU1JFUlNJcXNhcEtseElvQW9XblE0Q3VBRElxbUFDa2t3Z0JTMldDV3N4MXNrQ1Z5V0FyeU9hWXBlYVRGMWpMU2Nqb3ZNa3BNWW9wV0NsQXBleVFXY2lsd0l4UUdyMEhrbHF5d0lLTkxGVW1XakdUa3RKZ0tCYUFoTVNKUmpHRXhSQmpDQlFHV1VreXBSZ1RMa3hTNHlZb2tCSkxGVWdvVXhhOVNTRXNsYklKVEZTODZoRW9aYkNxQTVnV2RCQXM0a2tIVWdDUk1JbUVreG94aWdBb1RBU1NKSkFsZ2F1WlIyamdVWUFNU0FtU1ZFb2lpRUZCS1VCTXFXSnlLSkVTVEpoRXBaTUNZeXBGaUJVdUFwT2hDak5XN0tkQVpPWjF1cms5RmN5Q1Jqb0ZjekNBd21OVjVHZ0ltV1V3bk1TZ0xoT2h6b0Fzb2s2a25Jb29vczVITWtCUk9hMFVRWVV3S21NWXlCbG9rbzlCNXhFeG9vazFZQU9wWnlNUUpSQXlOQmx3RkdGTVFvZGtEa2RwWUpwQkJVREFaTVl3aVF0a2pIYzVGMllzNkhFUU9TNHBNYzF1U0Rvc2hWSkpDZ2xsSnpNVXRRVmtTbG9FREN1R3h5a3gxMHVYelpYU1Vjck1WTEtOV29ZNWtDbENBQVl4aVJFQ2pHTVlTUkVURUxnU1FXakdLTUtVUXRIUkpJT2hBa21XZ0xJT2lKbGdvRUJXZ0U3bU9CelNqRXJoUFFjaEV4QmlpeUNRTUpBbU1Zd21NRVVZZzZrRkFVU29LWWc1aVlva0t4WkVZeElxTTVjQ0NxQzRBS09RbUJhRURBSlJBSUdWTVVtS0pPaTgwQUVSQXk1a0ZSZWlOY2pvQmpBUU1kQ2p0UUJBSFVnZ1RHTVlvQ3lBRkZVa3hoQTFiSXJvZFRtSmhPb0FlcFBNY3lUdXRKNURFbVhKZ0tPcEJKME1jVjZFSUNkRmtsTUpTOURJbkswakZKSWdvQW5ZRGdVWXRBNXl0SXhSeUVxaEpNdG5kT1J6S0pGUkpMbHM1MEdSTkdPWWxDYXBLZ05Wa0hjNkNVZVlsZXB6U1RIV0lWczVtRmFKUUVzRG1Zc3hLb21FWk1Xc2xrMlVSR3BGUTBnV2M2Q3pDVXVPYVlnU1FNV1lRRXdDVVNBZ1VTWWt3bEdKRTVsQ1lERmxFZ1l3a21FU1R1dlk1QWtrQ0lLbEhJNmxGRkhNZ0NVU2l6b2N3T1phaEJSWUhVRGlCZ0xFZ295QzQxWXFBMFVZQ2pKbHh4RXdrbUlLb0lFUXFzcEtJQURGRW1US0Njd0V4Z1ZNSWdJRWluTXRRU2tBTEZja21BeFlndVp3bWF1d0lNWVRFa2x4anFkam5VRUZIUWtBSk1Zd2lCaXlVRnhZRUNVU01GZER1Y1RvQWxtUElXbm9NU1V2Sk9Za2d1Uk9aME1VQUdKV2tTUkZaTWtuWUZTVTZHbEtncEVna1ZESFVDQ3hCQVphQUJKQ2tsTE9hK295Y1NRTVNxU2xTb1VnaENVUUlpTlFYRTBsR0tNZHprU2MxUVFFOUM4YW1SRWtGbEVUSFF4Z0pNdHh5cWhPc2ttVUpOWll4RlVTdGtXSm94aE1VWmVZcEltQXhSUkpSZ0pLSk1CanFjaWhKSktMTWNoRURHRWt4UmlRTWRBSkxMS09oQ3lTWk1ZU1JPaXdKMU1jeVFFUVRHQWt3a2lVb0oxSk9nSEVrb0NpUkpMVHBMeWpVbXFnaEFBS0FFeXdKUkluTUtUR0FDb2pUR0tJTWRJbUpTVmxFbFVCRWxVd21NQWtpZ0t5V1pBVjZFSmtpMUdFb2FpTVpLQzI3Q09aWmxER0FxS0xPaEZTU0JZRWlCam9jekdFb3hpUkF3bUxKaWpuVkNkQ2l4TWVZZ1N6MWtsbmdBUUFFVExpaE1TQW9HSld6QUlKUmxrb281d2dKWkZnQ3NtR3JPUzlva1FLS0NpUUNwSkMyOHRYb0pPQ0pLMEpCaGhKcm9RV2tuTlVVUktJS0FDMXNTU1V4SmxVeFlDdk1DaEpTZ3RNcXFTazZFaGJVUVZEcHhpeEFUSkpoTkRWbk1UQVVTSlJpd1VCQVFNWXhpU2hFaGJPUW9pWXdnQmlpUkU2bkV4SWdTQllHTVdVWVREV3FNc0JTNU9oQzBLSkpqRkxoSlNEbXFVV1NTZ0lHQXNsVW9TaE9aSlFDSkpKaW9zQUpwRVNSaElWUUVrQXBNVGswcEMwc21TUXBOQW9Xa2xHSlVTUUV4SW1VRVFNWW9nRVRLaVVrQ1dTWW1xTkdLcVFHTXFLZEs0b0ZrTGhFbzBsMjlST0FDSlJ6TWRDQU1Zb1NSTUFnSmlSTWRDQk9aUmowSGNRUENZeGpxZFFQTVl4Z1NTaktnWVNTeUVvQldSQW9sTEpCVTZRRUdNYWxBbFZNWVJXNENCRXh0Q1NnSUFMZlRsenJzY0NVQlZBa1FMalZqSmlEUjBwS0pBd0VsSFVEQVNJQ29nWVRBWlV3cGdLSk9aMExBYmRrVk1GZ3VMTW1YSkpoR0NxQXNnc3dtTEFBV1JUR0FvQ1RBV1k1bEdYQ2dBbG1FREVrRkZrRW1FN2dTQkJSaEV4SmhLb0dNWXBhU0NsQzB3a0dPUlpLNUFWUVRzdkVFc3M0bUpFb2xiRUJSVVRBVW9rckJhUXR4MElyRUdLR21BbU1OVEFJVUdESnFVdFlFeHE1bGt4U3lDQWxrRUZWTVduTllTMUJBeXFTWmFKTWxsTEFnbU9oQXJrbXFDTlZBUVVNWW9iQWtCWEZRaVRaWjJVT1JpU2l5UkFrb2t3Rm1BUU1TVXFtRUNUcVJBYWtzOUppWTgxWUFNVVlEQ1NLS3lZQmlnb1NqR0JRd0dMSlN3SkdYRmtnRlVRbUJhU1RHTGpLQ1FVV0drU0lGa2syN0wwVkFwQUFvQWdXUVVpU01CY1RwMEVrZ1NqR0VDaUNDeUY2RW9DWW9rRE5XbVN6SE1STVlzbTJzc25NRFZKUmdNWXhqU2xsblFra3NCS01zQ1l3cGlERkVnSkpSMEpPaHdLSkFvb0JLSUFnb3FOVWxFRkFkUUxFQ0FPcHpBU2hKTE9ZZ1V0RkhNbzRsRXBSakdKTE9hMENXdEhOSUJhUUxKQXgxV1JNblF4eUFzbzRGRkNxUVlTU2pBU1VhTlFWRWlUVkhNcUpKS0pwQUFqb1FaY0tRTk1VY2FER1FqQVVzbUVwTVpySEl0RVZ3QVptekxsQUZFcWlpSkF1UVdrcTBJRW9nc29sTWRGN2djem1KUW5NUkpLSkVrc1NEb1FJa21LRTVpSjF5NERUUUlsa0VpU1VRSmtveGhNc2pDYzdGY1dZRURGS0dUR1dUQ2dCVVpkUVhFMEZFd21KTUlrMEhhSkVtbE1CUW5KYU94RkVCaUFPaWN6R1hDS0p6S1hTV2R6bFFTWXhRaUp4VlFBVEtIVkFwWlFFeWdvR0tKRXk5RWdWa1V4SUNVWXdDUUpNdlF4Vm1NdllreEJ6U3lRVmdzeFFGQVl4Z0VRS0pKTVlUSGN4ekpPRXZvT2xaSUVTQ2dBNHFuWkxNWXhpUkFSS0tPU3lRU0lpS0FHRVFNSkpKUzBRSUpRQ1FaYUVURmtsR1R6bllDUUxNcVlTQ1JMQUJDQ3FOR0lDb0tNSWtrbERJQmJnS2xETXdVdUU1MXFtQ01Za0JFQlJXalM4Nm9veGpFbEprbHFnTUtJbTBJQU5GQ1VYWEVDU3hYQXpSMVhzY2pBUWRST1pJRkdBUk1Cbzc2Y0lCQVNpaUNnTUJSaURHRWtzZ3dIcU9Ca0JLSUtVTldKa3dyUkpreGkxZ3BPWmxURkpKaE5McWtZVFVSZ0FzeEpOV0ZYa0dvRkV3RWxMUk1HbWl5REhNcEFvRkJNVW1sSTZXU1lhd2tpZEJFbzhxNHlJR1ZNaVpWTUpCYXlnV0p6TEJhVEFxQ0FBVVlURkFTWVphTWF6SFJaSkFreVVBeEt0a2xHTUFpSUNZa3hKUmhLRTZtTVdlV1dpYVVEQ0JJaW9ZRG9nWW9UQ1dCeEpLSVVFeEpSS1VBbUtFa3hpU2dWRXhLUVNVQmEyU1lveDJBZ3lTSnpPZ2dzZ1dCSmpxU1FVYUVJS0NCcURxU0FpQmlaTVRha2x5SmxDemtZQTBJMFl4SklDVVpCYUpsbXVnbEVDQWtpSlJKaEtBTEpoVVp0cEpFVWdLb1ZRS2lqM0htc2dnb1JBU1NTaElHWEFZeVJXTlNNVkNBMUJoR3RDVVNkenpDVVFZd0NVQUNLWWt3TDBJaG9MRWtvNWlnQzRTakNnSzFISVNpZ09Za2lZRFZqRmdKUUpKcFd3TXRrR0JGWktqbUFXVWFLQXJUdEtSSklnWkpyb1FWSFExQkpDZ3BSTUZ0Q0JKUlFKaElFNndFMmhreDBDWFZOWVF6TU5XQXhKcW9KVUNEb2Fna3lBTGlqU0ExUWxrQ0JTaEJhSlFDWTZGR0pFOG9nZFRnVWRqZ1NxWVNSU3ptdEZpV1NrRUdLSkV5eVlCTVlrVXhRRkdNWXduSW9UTGtEa0phb0ZHRVFBNm5jOHdnRlRDS0toaVJNQW1xZ2lCaEFER0pNVVNVQUZBb1NpQmhNc0dLSkJrRWxaTVl3a3Jrb3lacE9aUlFGR0FFVExRQ1VTVVpJcGhJS1VLRkFrS1JWQTBkRHNaT1ZXSkFtQXhpRHNjbDBBZ0FXTWtyME1VQmdyRGtWUnFTUUxNWXNrZ0N6R0VvZ3lCaE1xYUpxekVIVWtDVVRMZ01KS1dDNG1Fb3hKSmpHS3FZU2E2RW1MSk1pTXNXSjBPYTRUSUxnakhFVXFtRXdVcUZFaEZBaEZhVVZEVm5FRExLSjBnSnRUQ0JJaWdCaXlTeVZBUk9veTh3TUlBVlZnakdOV2hWRWtCcVJMUkJaT3BNbk9nb0FBd25WZUlGcEpnRVJLQTVnWXNERW1PcHpCUW9za3M3bUpJSUFFa0NpaVFGY0FDSW5NdEFSTVlEQ0FHTFdRVEFVb1lva3dnV0IxTE5IRXhSRklKU2dBQlpCb1RxY1RWZ2pDQmdNSmlpQUVGUVFLQURMSW1BeUFrQUppUklFNkVBdUNPbEFGRkVwSmloV1JBU2pKakVtV2pWb1Vnc29rRnFneWRpb1V5OGlGczZKcWtrMFpPcTgxa0N5QkpUSUxTMG1FQm9ORWlvbEUwaVlRTVlRRXN4SnBHcEU2bklvbVdxa0tyS2FvU2dPWW1Bd29tV0lveGlhUmdNRkJqWmJRS01PUm9tS0lFNnB5TXVNazJzRVVTZ0twektBc0t4Tk9TQURaWlpRUzhoQ3lCam9TdXBFU1RGRWlDWmFKRWtnc29Ba3dySW1PWmRXakZySUZFSnJXTUlVeUpxa2xaS0NKMDBkU0JRQmFCRXk1QVJNdHBpbDVSck5WeXdVZWhPQkozT1JDMEpSeE9pU1N0RUlxa2lRbEdVUktJTXVFdE9ZbUVCTVVRWW9EQUs0eUJhOHpIVWdDU2pHRVNqR0pRT2k4eXpSSTBnWTBKSmhJcWl5SUFKcXhpQ3dNWXhLaFNRbHFySUNBbUpTUUF3R0VvNWlJS21PVVhRWkVWVWtUQ3VKRk1VQTB4Z1dTd01raVdVdENpQjZRcmxITXhDOXE1b0dOQlNkSUNGeGpJTDBUbWlxdU1pdVpWazZFR0dxSkV4alFoUldnT3BKUkFwaVZRTVdjNDFTTk9XcnNjU2dNQmdFeGpHaENrVG1XVkFGRlRHZ3FrNkVyb2F5SmdXaVVneGhVclF3Z2dvYXJPWmlpUk1tT2hKSmpvcWx4elVRb0FZdGNVUWRESE9nVEppU3dNdU1ZeUFER05XRXl5ZGtCZ0dwakVsVkpveE5WQWFoUXhRUnRHRVNVSXBRbEtyTFNTWXdLakkyekFtcEE5Wnh0NXdpY3lqQVlUa25VRkRDZ0NvbUpNbEF1U2dVRkF3SFJZU2hBU2lRTVlWQ1RDaUFyam1VVUpKWmlpUkpTaVZUREdOUVVCb3NBTVNJQlVtRVRFbG1nU1Z4akZuTk11VkF3SmxDaURHSlJNQW5Nc3hqRXJKUUFsQ3VRRUJYRWxKZ0UxYUxCUW9DVXNrVndnbU1uUldnMFNsclZTa3FoR3BHS0JRQVpXclJUa3VWRVJaTGVweWpWcW1QUWFDUVdheWlCVldjeWdNWUV5aEpaekVxR3NGYkxVRmdTV1NVU1lCRUl4TlVCaVM0NkUxRkVWQm95VUM0d1NVRlk2THpUQVl5NmlOR01XY3pVQ1lTaUJUb2N6Umh0eFNBVzFJQVlxVU1XUVVCRlVZeUlHQUZvQkJNWXFVTllDWlV5WVRHTkVDTllZa21rWTFvYU1JQm9Sam9RbWlsZ1VheTBrbU1TckdFREpxeGdMWHZIVThkUUlrQ1NVbUpWT2hLWUY2SElveENVWlFVRlJRSk1LNUtKS0V4aE1BS0NTV21NVXNrbU1Zd2xtS09ZcGdWTkdFQ2dwTE9jVVFZQkFpa0Nqb0FGRUJDU1VTWXlLcTRrbE1ZVkFMSUFFU0NpUk1VWWhZTEVFeGxVa1FLTVpjQmFZZ1JFQ2xCSlNUS0ZBSW5vTElKUU12UWhFbFFMRVJnV2lTVEdLQXRBeTBtTlZFUmhMQXdKTm9kQkxJRTVnQlpKakFYVVpCcXhqR01NTkpKUmpJR0FwUUM0MFJwUUVtR1N4dDVraVVVQkpZR01KME9aQUdNWXhnaWlnQURhVkVpSklGQlRGUTFJaUVWWUZITVZ5ZEltM0RFRFVtRXhSSWdZa1RKaWprdEZHVENvQmFBcUd5MVZHc2txZ0pXd01ZWlpPaE5jd0xGSU10U0JxQlhHRURHZ05RVWdJQ0NvQWdXU0s0a1V4aE1Zb0FGVk1TWUZ4akltTVlDZ1ZBU2dRRUFNdUpFVXhoTVNZUVdpRXN5cEpoQVRHTVVJR2dxNENST1ltRFF5b0s3SEtxeXk1QUFMSUVnUlhHSVNnVExsQUpPcHpTUlJJRmNhV2lha3NTRUFXa0JNV1FLNFFUQ1l4aE1zaUNKbEFBeFI3Q2prVW5NRnNsSkZVTE1BeGxzQUpFVEZKakxTQnFvcU9aakFKU1RiZ0VnVENKSmlnTVNWVGxKcXhJbGdhcWlpQU1KU1NBTGhNWXdtSk1NaWEyUUU2RWttRWtveFoyT0p5S0pFUUEwWVNSS0owcUpNSUdLQ0tBcWd4Z2lyRVNDVjZESkZvSk1WVWxBU0paQlJJbUJLSUJhRVVSV0RGSWlzZ1VBeVNhZ3FWUnFURExBaFFJcGlWd1NKcUJWQVFNbU5FVzBLU1VTVVNxWXlZRENzbEdUR0tNWUNpRExhUVlRVk1aTUJaSW1Nc21FU2tBTUFMZ0VVVEdKRURHVUZNWlVza0RHRVNURkNFYWlNU0pqR0owY3FOV05XeUZwTVFZb2tzNW1LVUFFd0pTeXVBQ3lFa1ZreGtSbFNhZzZpUVNZVEdFU1FGRUFFb0RDQzRDa0NUb0FDWmVwNkRpWk9aUzBrQ29ET1hKVnRHbHdpa2xBWXk0bExzeXNzaXpJcUZBWkJRb3dWUmdNSmlpUkpOV3l3MWlEb1REVUZnWXdScXdnSW1NVENXQUpqVUN0SE5NdENTWVRHQTdKeUpCYUpFa29rWXhka2lOc1pVQnF1TEE1Z1k2QVVheUQ2VXZsVGlWUVNxVVlnd25ST1JJcmhKRWtTaTY1eEppaHkxS0JqQmJpa0pRcXBNRUkyQm94U2drR0ExWUVzbFpLS0pNZ0NwaWt3R0UwQlZ2T3dqRkFVQ3FZQU11RXlBbEFVU1lva3hnTUMwWUV4Z0tCY1l4akdNVUFGU0ZvQWwxT1dOUVVraVpRVTk1NDFCSkFCTVVBRkdreXFTdUpYSkkwQ0IwSk5Hb0xqRXJyTVZLSkltWEdBRUJVTUlBWXdDQmdSQlVna3Nva0FBVG9TS1NTdEpTU3FCUkluUWdRTVNaRVRMakZDU0pKUjZUZ0s1SUtLTldsNm5OQXhRQ1lERm1RdHVVSlpGb2dRRkZVSWFBckdBQkVDaVRHaEtFa3dHTG9NSkVCcVRxY1lSb0NNSlFWaVVDaWxFZ1JNdUtBeGhLU0NEUzRLc0FNYUU2MmN5Qld6UUYxb0NLWXhqQ1liRSsxTDhkSXBGZXh6TVFZc2hBU1Nsb2dTU1N5b0FOVW1oRXhrU1Y2VktJS1FDVFZRRFlrd21LV0RHQWJNUVVDZ3BTeVpGY1pJTE1CakJGRTFqQ0JqRkNBQUtoUUpnS01VQUZBQkpqR1d5REFpQWd0RW5VNUdNVVNJZ2dvWktVTHlLMUJTU0psU2s2RktBY0FRV2dMSkVZUUFRSlhJRTFRZ1VFV1RVbEdpYXdtZ01JcmtUVzZJUVdpUUFDVVY2RUdRSktRV2ptc2xsQ1FTVW1FeVpRcFJFeEFsR1FXZ0pNSUdLTUlBWVRHTVdXQUtKUUl0SW1GQXdIUWdUQ1l3SFFra29UVkFSUUNZNkp6VlRLR0V3R01KQWxpSkpKdEhKTVVCQUdyRWxaYWlzWEFTQmRZeE1ZbzFtQXdraXFVRWVrODFTU1ZBRkFIb09Sb3dwTktoaW94UkppYXhvc1JPWVdVTXBWRW1PZ0ZFbUtpMDQwZ0M5REV4Z0Fza1JyUUdNQW5VZ2tteE11R01GSkVWU1ZKSkpTeUpKaXJJTVdRdEpJeW9DSkZpQmdLZ1hGRVdZeTBtSkVTMUNRTkNZQU5aWXJLWW9rRkRBSW1Bd0ZBSkltRUJBSzBWRWsxUklwWksxbE5GQjBBMGRLZ1RtSlFRMEFBaUlteTFZREVpc29HcXlTelNnR3NRcHlLUk5FbUVTU2d0Q1l4Z0VncElMVUJuTGhNU0pDaFpZbk1CU1RGaVFBaUlHTWlDb0NCaE1JQ1l3QVVZRVY3RUFKaE1xbUFUR0E2RUNKa0ZURTFaZ0FZUVJYR01Xa3JaeUxBbzVtRTZIR0dzWXRKVUZOcTFsSWlCSmhyRUFVQUZnRVVVVFFhRXFwQVJNbUJiTWRZRGhRQWdhRWthVFFpSjZEemttcXpBUUpoaE1KMU9Za0ZDRlkwRlpNb2FKcXFSSnlrU2hBVEhNcXFPaHdrb3RZTUpKcXhvYVFKRUlvYWtZbE9oenR3UW9rbU5RWlZBeXBTU0JSZ0xKRWt3QVVCUkltRXBZTVVTU0Jpd1JNb0pLSktvZ2dLcGl5RENTSkpoTVNVWURKaVNsd0pRS1JOWEdOU1lER0F4WUZFaVNKakZSZ0FRQXhqVUZtRW1WUW9FMGlRYTFHQVRDVFZLRW1oQURJQWsxVFdSa3hDb0ttSUpMRVNRTWlZd3FJQ1VZQUtSQmNCakdNSWtMUWdtTE1xZ2l0cktRSmkxbzZKeVNWeW9haVkwTXVSUjFjZERqQ0lFblNNYzB6VmtvZ2lxWXhqQXNwaVJyUzRwRkZWUmsxYnlUSFk4NWdOUVlEQVVZQWloR3BOSFVpZ1RBWk1DMko2NDhZVUdKS2lUR0dzYU1XWWdDZ3BNSmdLTkVnVVl4aEpLQ3FDQ3dLWEJDQmlnQURDV0FCUUlCSnFiVXhza21rMGFzQUNhSktwTkFsRTI0SXdKUUJWRUxhSks0VXdHS0lFeGpDWUFFd2dVQmx3RmtnQmlSU3lWd21SQlVESWd1QWtUR01RWXhSSlJoS0JKS0pYRm9FS2dWRWpYYzVFMFpWUUlBVUIxT1FoVnhNVVlnd2lkVEJYTURBYVZza3doR0FhVFFEb2dNdEFTYUF4aklIT3loYURTWWtWeGhPWVJkVUJJR1FLUVd3UVhHRXdpdEVnQ1pNdVRHVk1ZeGhOVndrRnJRSnpLSkxWS0lNWXhrVWJjVkVsa0dFYW1xZ01rUzRCRXhSSmpDWURJcmlUQVlURkFZU2FTb29za2t3VUNGQVJVWUJNYWtEUlpOVVlrUU9wemdyMEVSSkJnQVJBS2FZNlFuTUJLSU1YVUFkQ1pFTkdOTEFsRkFaRUZTamxWQ0JVa0dYQ1FXU0ZOTVlVZ1RBSmpLSWl1TUJoamFFaWFLcUJWSktRQXdTZ3AwT1pxeFFHTUFpU1lvQk1TWVFKTEFGNkVKaEVrRkRDWUVzQk1aY1lBQXdraW1CY0pqQ1FKaEJBcFFSUUpNdXJSZ01VSkpKWURCV01Zd2dKUklnVVFZc2dSTVViS0tLUmpFRFFKaVJGUktKTU1OQXFtTVNJZ1NpUVNJakxrNUZKbHlwelFrNzNXSUU1bElHUzFBRVFNV1VRcVl4a2xCUk1LZ0ZHTVVGVkdNdlVTRVJPUlM0eVlva1NpVFZqUlJnRXdDYXFCU1RDUUpZQUFsRWlTb3poVklFVEdBc3dVeGdNSmlhb0NZUUd0SFFBSnBBVFFWWUZITW9ERngyT1ZUQVNVU0FnTklWMGpSektKRUFFcXBFd3lCUUdVRTZFaUNZVmtSQ2t4cEF5b0JvR0dOQldCRW9CTVlGbEtGUVNSS2dvU2lZbWtwY09VMmFneHBjbGttSnBFQUFSRUJFZ1FNSkpqRkdNcUNKQmlpVkN3QXBBUUtJV2hNUUJqQ0NZVkRDQmpBWXNFQVdnTWlTQXk2Z1JBd2ttRTBOSklnSWdJR0VCQXdtSkV3eE5TZENZb2dxZ3dBSUxhWXhKcEt0QlZBU1RHTWFTYWd3aU10SnhPcHhXa1ZoQ0t0b2t3Z2dtTFdVelNVWm1Wb29GUUVFeUN5WVFBVENzbXNzWmNkem1aRWd3aVRXaEFvcFJFa1JFa3dsR01Ba2tuUWtRQmNsQUJqTFJLSUVnSWdZVENVQUdFeEJScXd3QlNJUWhXTUJSakNCaEhLU3RMa2dDVnhqQVlEVmpvVFRsZ0pFeGpHSzBJUWhNYWxNQ294aWdFS0Nvd0FJV1NYRVZoWEFJZ1NFaVZRSUdNdVJOYldRTm1NQlN5VVNVWXhaS1djcGNaSkxVVEJXTUJsRVFORkRRVUJJa21WQXlJTFJqQUNVU1dRWUJWTWdZWXl6U1NJa2lKSmFTSkJRR0pXakNnQzBBR01NU1lyU1l3bUV4aGlLU2pBQW1NWXdpU2FBc2dSb01CaVNwVkpPaEZZc2drb3k2TWF5UU1JeTBVSnpyR0NNU1RaalFsckpqRUNtQllpN01aY1pKQktNdEVyUlFJbEVpdEdKRXlDcVNBR01ZeXBrd3FwaTF5YXBHTHBJTVhFQ0tpQWdZUUVSQXhxbUVrVENZeXlqWFRLREJTWk1zbUU2MXhNYU1VQ1ZhUWdBMWlZVEZFbXBoTElBMVlDZ01ZU2lUR2pWanBITXhpQkVrUkNnNkhNeG91Q3RXTUlnbHl5U05VUW1LTUMyU1lUSUdqS2lTRktZd0NvQmhLVEVpSUdFUUtKVUVtR3pDU2RGeHpLTWRDVEpKaW94SUNvYXFRSkFWUU1qR1VzUUF3Z0poTUFpWlpKRTZFSUNZRnFDTnFZMGFwT2hCbGtvQk1VU2lZeWhnTkdFbE5hR0VreFF3R3JBQXBVb2FtTVhYSVRHTUpKaWhNa3FEQ0lEVEFUVWdVSWhGMUpnSkFUQ0FrbGpBQW1WTUZBSm9sVk1BSFZaQUVER0pYbkhXeEJGWkFVQlZYR0VvbEtGY1VZRENTS0FHQUJNcUNJTDBUbWRWbE5SVnhqRW1OR0FwZWljd0xNWWtURkNUUU1Zb2d3R0ZkWUZFaVNPVFl0U21NRllDelJTNW1MY01Zd1VHakhRQ1JNWUN3SkdxSk1Zb1FNU0lnTUFHQXdrbGdTYWt3RkdKRXNrd21SbERHMEl0SktNWlFZMUFJbFJnWEdOUUtKaVZ4akNaQURDSmpBVUNoaWdCRVRHVkpFQ3pESk5TVkFKSUtqb3lRSmdXZ0JFWlNoTVl3Z0lDSkpqQ3NpU1VaTUpJcWtDaU11c2t3Z3VNQW1NV2dTWlpFeG9EQ1lLUUVCQ0FLb0RGSks0MU1hS3FERkVtQW9EQ0taUTFNWEhRNVZNWWFTRENOT1UwMU1KSmhoSXJHRXhrdFpoQmNkRG5RU2lhV1VCTVV1SkJNWXdyeWk3RXBNc3JKakdFeGpGQWRnTUJaaUNpRENaa05iTVVvSkZuUWxXU1RxY3pHTEcyVVlEQ29VV0NRSlpKSW1LQUt3eWhSS1NXQXFwdElqQ0ZPUWxMaVFFdzFaemlpam1KZ0VER0NzWEVtS0F4UUdDdWhSek1BbEVvNUZwb1JqQUl3R0FTYVRHQXhRMU1ZU3lJMUpvQUhSZ1REQ1pReHJFeFFBdUNTaHRrUWl3SkNxTkJTQXBoRWxaS1JXUUtBVUNsREVpTVVSVm1KUkFCWEdKVG9RQjBJS0JjWkVGUlNEQ1NZb1JKTUFndlU0aVVCSmt3TGdLTVlFb0JJWHNjNllrd21Fa3lCU2tZMWFOVTB4akFZczVnZEFKRkF5aGl5U3lUQ1l4SmlpVENJR0E2RURDU1VsdGN6V05iSk1UV0F3R05HckNBR1NscGNTbU5MZ0taaHFSU1N6RktrQUFwSmw1SFpNWmNBbUpBUk1VSmpvU0lGR01VUVNkQ0FSckRMUmpsWUZLeUpaQkppaHREU0pSS2dsbVNEQ0lDWVNCcXlaY0tCSmpGTGsxU1NZd3hqR0V3QU5WQVVZNWlZQkVER3JGd0FJQ0lDRkpRa0NZb2hHTmJOYUtPWmhHSk1BaFdNVUFtQ05XRVFqVmhnTUdqR0xTWUJ0MVlKS01VQUFyRkdvQVl4akJXSmhyQUtBaUNwYVFvSWlTZ0tvQ1lvdU9WUVVVbUF3UzFVQ2lCSllHTW9XbU10SEpFd2dKaWdNU0pqTGhJRXhJb0F0Z0pJbEppQkJXRUt3R0F4Z1JNckFiVFpGYW1NWW9BSk1KakdNa3FGbEFBZ1l3aUFDWWt3bXlLYXhveFFIUlpCQW94aHFBQXhqQ0JqQU1seW1xSmpHbHhrcElXVEZtSktYR0lBVWt5OGpxWVNpVEVsRW1PaGpDWXhpZ0VSTUFGRWdOYUFxc1JKanBXbDduTTVXQm95b2daQXk0eFFDQXBKMFdUQWxrbU11UkFCQkZjWXdJcmdFeVpjVVNTSmlnVERhR0pORFlHVkFvU0JFUUV4aEFDeUVUTGt4U3lZQk1CVUpBRkVVZ0pScWNnb21zU1hBYWtrb2tZU1JFVG5TV1NKaWlVRExnTEpUR05MUnFBTUJoVEZySmdLSktCS0FzNXFtRXdCSFU1VmhUQVpVSXdWa1FBeFFtRURBb0FwUUdVTVlwTUpDcGhNU1VZa0VBVkFxS0F3RFFhTUJRQlNBd0dvTEFZS3hJbUtJS0F3QkNZUUNrQUV4akNZVEdHRTUxakkya1ZHTUJSZ0xKWEdNSUdOV1NRQW8wRllCRVlDYW9tV3pFQ3psRXhJTGFwZ0xXRXgwcnRtK0d5Q2lpeUJMSkFUSFU1bU1KUlJKSllHRWtveGdHcGhFU0xGR0xVWG9jYkFJeTRvYkpqQ3NpVVl4akdNWXdJSFE1aVlCQVRBVVlvZ1RBS2lKSmdPcHpNV0NTYTFBVEZ4RllvUU1CaEpKS01VQmpHQkF5b29HWEFVU0pVUVlURTFpd01UV3lSS3FRTEFCRWtZNkhNeGlpSWRNSW1Bd29BcVlRU2lBV2dNWXhJMHdKMFdCTVlCQkVvRlFBd2lFQnFRU2lCWEdyUkpSQ1lTeUNoS0FsY1lCUU1LZ3hpYkxFaGNCUW1KTVl5RXJVbUtnRXdGV1NyR0F3Z0pKaElwTUVVU1lzeE5VWXdRZ0JaSkpncEdpTUlHTU1Zc21pTEpvVEdXb2tTU2l5U2lpRnlDeUlraWF3TVlDb21zWXhqQUl4bERHUk1TU0NLcXAwSkV4MVBxTGM2Zm5MeGhlaGl3TUpSek1Zc2dTaEFvU0NqQ1NRZENpUUVSSktJc1RSMFdURTJZSUZwTUZZdUJVREdFU1JBd21UQUppbGhtbXNtQXl5SXBLSzR4SzlFREVqV01ZWVFKcWlSTVZMSVdKUzZBbXlqR0FzVEFBZ0NKbElRUkJjWUtSaVRDSkZZb3hJMFpJRkFBVW1OQVdZeFJBZ1lLeFVKSmhwU1k2S0dKTHFCSkV3Z1l3Q1dWSE0xWURGR0pFd0ZHTUJVQkkxaWlvNW1xZ01CaVJNSTBRd2FhRTBBbXNEQXVNVUNZeTR4Z0tBRlVTSUNxQUdNSUdYSWdZc2tDU2dBeHFUREVpQmlnb3JaWlZNZ3VBeGpHSnBBb1pjZ0pSSzVNSWtDbXQwSUNZeFpJZ0NxQmxSSkF5RllWUWpWaklHQXd5cGpHQkVrRExLVVpRNmxIQXhoVDliUFIrUGVlVHJhZ1FZVHFjakNKZ0VSS0VCSktKUVNqRk5RSUdLcEJFWlVnd0luTVZXYU0wMkF5eUpTWXhpVlFSTXVURkVHS1VUTG1jc25SWXNvQUEwSksya2lrMWxUVm9EQVlRaFNscFpNYXhDWEFtclVSWlpCakNZa1JBQ3N6VzREQ0JRQUlrZ1VUVkFhS0lNWVFBUkFRRUNxQkpPc1FZd0ZHTUFGR05RWUJNYXRBSVZvMFlRckNCaXlDZ0FUUjBxU1RERkhNbWtxTVVCUUppYlF3U1l1cFhGRUZFaWFNTmdJS2dJaEVtb01sRkxJZ0pVY3pxY2dNWXdtTFdTYkVrUU5DRVhYT3NKb3dtQ3NYRTFxSUN5WXhKcXhoZ1VSTWlvSmpVbFN5bW9qSzJZd3hKcXdtclJVQWdTVVpaTE1CaVVvNTFaakttUUNKcEFxTXRrSXBLcURVQVVXUVdkanprcGhQMWs3ZmxIT0didGtUQVVZa3dtRW9rU3pBQlpKWkJKMElSWENDSnFzNW5RWlE2RWtJR0pWVEdVc0Jsd2xwQlFHVk1raXVUR0FvRm9sTWd1S1Vza293a1FHVlNpYkVsY0pvMUFpU1hBZ3RLRkVXSnBhSlNqR0hTWXhqRmdZQ2lSRE5xd0VER0tJTVl3Z0pWVFZaQklnQlFraUpKakZBSkpaektBb3hJbUtJTVlRcEF3REJvd0NWQUFnYXBLQXgwSU1ZUkNHZ0NnZ0FhRHBBU1dBSTBLQWFSS3JBc2xrZ1VhRUxNWXk0a3NrWXhOQmFCbERDSk5WREZuTWtrUk1aUUxFd0NhaUpFc2dUUmlnRFJnZ3FpREZHakFOU0pveTVKS1JXQ3pCV0tsbEd0R1hXQlF3QlNFVUFtQWtvczVxaUlHSlJKckNVb1FtQ0NxR25MS2tNNWNaQnFEQ1lvbzdua01nV2ZwWGI0TXg0bWJ1YVhDbk1wckdBRTZBVUM0c0NTeWpHSkFvd0FZMW1NV0FqTEowS3M0a21qTGRraERTVEtpS1NVSzVJTlRDQUNZVExqSUpsVEdNSUFGU0ltTVNXQlFCRTFRUmpDWWEwQVZSSjJKaWlpRnpPdERHTUpqQ0JKc21rS0RHaXlSTVlrS0JHcXlEQ0JoRWthRFJaSWFWREVDQW1FeGlDaWdKTldNVUFSaXJKS0lBcVVLMGNwckdCS05LZ2FzVVlBSktyUlVDQUNaYU1hcE1pQmlSTVNVSktwa1FFa3lwYWN5Z01ZREtnWkVTRndpRk1FWXdXSmxEQ0FDWXdHTUFtQXNEUmhBQkdwQXhqREFZRENZRVJVTVpKQzJoa1JYQUZZUWlnckdseVVZa29nUk1zcGhDcUpNWUJNWUt2S1FNYWtJeVFVdVhKa2dwY1plZ0FRWkFUOUU3ZlBtZmxNTml0SXBDOUZreEprNkFZbGFLTVFkREFVU1duSmFFa295RkJaSXhhd2RpTEpNVExqV1kwSVZwYUVnVXlwa21xakdBQkUxRXVGTWlzbUVERkNjcVRDSkIwT1pSZ05HcEpoQ21BcWdJYXhqQ1hBWXlGcVl3Q0JSakdUWk5zaHBqUm9vd0NTSVZKam9NU0FrRmlCaTZnSTZHSnJHakFZc2t4aE1CUUdHcEtBUWhOWkpoQXk0VFJOSWlrbEt4alVHTVNKalFVMXBORUZndlU3SG5xQVRDSUFZd0ZnWXhnTUpLMFVrQ0pBbUpYRkdSTUt5QWpBWW9rMWdDcGhBeFJCaWdBd2dKakdHQUJNRkJnTVlZRENTWVFTaktHSlNqV2taTXFVQnFvazBVVFdqQ1lvQUV3MUpNWVRWakdNQmpGQ1JDWW9pZzBCUW5OVk1nQzBkRmc2SEVrcEtKUHJ1blNUNFRKVm1RTUpTaEFsaUFtRUFMTVlDVXdyakNJZ2RDU2s1bHFGRkhNeEpqSWtpb1VTV0FHTElySlVTSzRvRXhOVkdVU1RWb1RHTUJqQ2FzQUdNWUJHQ3NZd2dVYUExSm93bFZJR0VZRFVnVVlwUkpLaEU1aFdpeURDQlJnTUJWQk1VU2FxQ0VBckNhRXdrR0VFQzF4aEFRTldqQ09oRWxER0pzUVhBWXhoS1FNQzBBeFluTTFZMEFhVmxRVk5PV1NqMUxCd0pyR0FDa3hqQVVhSXFpUkNYVW1BUUVzZ3hoa3c2VXM1VFdNSkJqQkdLTllBWmNkSW5SZ0F4aEFCakRRQmlvQUFRRWt5Qmx4aEpNWUNpaVJKRURDVVFZVERRaUVVdUpNbEdVTVlTYXhoam9jelVtTUVCcXhRQ1hITW9ORExBWUFNSkFpWXhhd1l3bEVFeGpWaFFNV0twSUZBQWxDU1VKa2t5NUFTbG16UWdWVlM1SktMclMyU1FLQUdBQkpyckx6TVdRWXFoQVNSQ1doU0RWakZBU01ZMUJoQVRFeGRBQVhFbXBLaUtCUk1vV1NKbzFZWXhGVUJRQ0JSZ0FSTEpBb2tTVFJpakdvTWtSUUtqUVhBUWFrNlFXY3hNQzNBQWlBSmhVTVVZd0dHcGlqRTZNQlJpaUV4S3BoZ3BRRmNtTXVORkZIT3NVU1ZCUU1CcXlWRkxhRkV1T2RnTUFxR1JxUWlnTU5aUXdnS0JRR0V3RkdBeFN5U2dXQkpDNDBWWmhNWUZZeHROSmpHS0JRd0pSSmpLUlFBWXhoUU1vQUZwSkltRVZ4Z0VEQ1NKWkJqRlZLVVRHVlFHdEdNWmNZS0tZNlJKM09OWXd3RW1wQVRDYUFLd1FHRkpCYkpBeGtSYXBJS1VKRTVJbElpb1lSV3lBS01TbElpQlpCU2dxb0ZKQ2xZcUdnSktLVXBHV3lpVW81cEtpeVpHc01zaUpnckFnSUNYTEpSS0ZZa3NBTkZFMVlHTVNZWUFwTVZFaFZHZ3FSU2lWU2dFSUtTNGtLeFFDQmhNQWdJZ1VZeGlRS2pBRll5TVVTcVZVakFZa3dqWmdNWlVJd2daTUs0TkFvMGFBc2t4aWcwMFlER01raXJXaThwMHlCUzVNQzQwWVNLUktPY05ZdW9nTkpoVk5aSXk2ekdpQ2x3RjJBUWdhRFRLbGtDWkFSQVJBeGhBRlFURkdPWXFFeFZtTUlFd3JqYU1raVlUTElsSklHTXJHQXhpaVRKakxKakpSQmhBUlVNSUdNQWlTWXdoV0ZDV2lVbzFZMEs0eGlhYTJXTVVha1lBQTFZRENZWWtLUWpHSlRGTGdNQUltYXlTVXNtTWtDSlIyT0prQkZjcVVBSWxBSmxwa1hDQVVDRVVZd0dTalcyQVMySUlHSlhKaVRGQVl0T2JWVktZUUVERnhJaVlDVEFLQUxxVENZd0doSkVRRUt3a21GTVpXTVlUR05VaVl4VXBZa21Fb3hxQmhPWlFnQWhDQmpBWW93Z0ppVEFaTVpXbUpTZ3JLR01hRktxRlFFMVZJR2x4aEF4WkZJSlNnMlRsVmR6aktFNlZtSUxnaHJHR29NWTZFSUN1Sk1LWXhVc2pXQWFBaWpRMkJpaVNnSnRRanFTWWdwTVlURWlBR01ZUU11U0N3TXVKR3NVTUJDTVVzRFpqS3BqR0JjbUF3cUpvVndraUlrQ0p6U2lURkxnTFNTRndwaEJjWkFWeGpXQW1sU2tnd21NSmxBS0pNbUxWb0tKTWlBS0dNWVRFZ1hBU1l4aEFEQVl4akdTeUFYbXFVaVlzaGNpbVdsVEFLSlFrZ3RKaEtJQ3BFWUJFRElyTmREQVZMU1FRSUtwWklBS1VKRFJWb21BQU1NVUFDQW1BRXk0S1FNSmlTNGdTZ0FCckNZd0ltWHBFR01CMElyRW1NVkdvTUpqQ0VZMVdjeEVBTU1CakNZa29EcVNBQ0pJSlJLdGFMU1FvTXVFMEZtTFVNU1ZEWmdseGdFQk5XUktXU1VxTldOS0dyU2RGZ3F1WlVZUXJFbGdaTUNva2dpWTBxRklHaEpwQ0tzVEdNQlp6aWwxQmdLRk1ZQ1NqQVNkQ1RHQXk1Sk1VU3VLQ0pLQTFFbEdVVFVtWEpKSjBKWElnWXlzZ0NwakZtRUFKTWdBa3JnS1FNdVNSTEFEQVVvWWJBd3hsVXhKaEVveWhqQVVnS29VaUNCZ1VNWUJBa29JeGpBSmpDUUlBWXhsd2ljd0xaQmFwSktKRmFFd0FpV1l5aFJpZ1FKTldHWEpoTVRiUUpSaG95UUpNWVZCQkpPcElvTkJpd0xRT1pSUkIwSUFza1RFVXhqQ1RTTVl4UkFDSklsVkpZUWdCZ0ZWSk9xY2pXNGtveG93TFNCUUdNQlZZeG9zNWlBQ1lER01VQWxsbk1nb0RGb2d1Sk1DWlFEQ2FzSWhFbVJyQkZLVmpHa1RBSXFnWVFNWU5LeUFLc2tGd2xrd0dGTVlMVXhna3dpdUpNbU1xVWtrMGlZd1JaS3FBcWttb01sQVpVcU1SUVRGV0pNWXhxQkVreGNDaGpvYzBnb1NSckRLSUVsZ0M3Uk5sakZuSW93bGtDU21GWlRBWXhnTXFaSkFTZ0FreFFGR3JDRXRBWUVERkNLNEJUQ3NsaVlLd3hKcXdreGdKcEVrWWtTaURDSkJqQ1NZVmtvQ3ptRVhjaGxRUlVNcVdZREppaWlWb0N3TWtsbk0xYVhDaUpsS1VDa0ZtTVVGU0pjdk1zRWt3aUNnbUxNU21LTVNZUUVDcWthSUl4alVsUkpoQWtURklCYmhpMGt5eVl3Z0pra3FzdU1hTVl4UW1FZ3hZMUprcFVpTUFBWW9rUk1TVVNCUmFXQk5hSk1VU0lHdHdRa3BRVXk0eEpyTVVFWldneG95SUJXbG9va3FrSUFwaEVDYkJVME5ZSkVva0FwRmRHUUtCUVJJU2xxaVFLcVRBVUVDb29GRW1VcEtRTWFYRkpqbmF4aEJNU29qV01KekdFRkRHTW1NSUdyU3Brd0FZUXBDRlVER0VSSUxCQURHQUJBd0tnZ1VZREdKS0FUR3JDYVZNQUlGQ1VaUW9rVVZ3MWNCakdvSWlqVk1ZeEZKZ05DWXdFbUVDUkVCTXFTSWtoRldZa3NFQlhMaXhTRXBRdFVneFJaSmlUSWdDMEFwakxSVE1yakFTWW1yQXFVQmxWSkFwVXdnWW9BTUpJSllJcmpWaEppUk1OQm9TZ0F4SW1SQlFSUUcwS2dFb2dRVEJhakdCVkpFUkpBVHNTQ2FoYUpoQWdURmttTUlHQVJUQUlWaGpDU05LNHdSakpOV0V1TVNqUVlZVExBZ1VZS3hVQmhKcnRVUk1ZeGhBeHFhSUNna3hqRkxObU5hNVl3RkVpQmhvTkpZVWttVUdBVEpSZ0JTcU5KaEVGeUJTNDVsQUpJR0VTREFnSzRva1VreGhCZWhKUkJoTWswZ1VFdUVCS01TSUFpU1lva3hpVEdWRkF3Z0JnRVZFdzBHbG94SmpHU2kxb2d3Q1lveGRNU2Fna1RRQ1NZeEZJR0tpVEFZU0JBeGhNb0pnRktJV1l1eVJFRENaY1dpUVlwT2pVR0V3SW10bEtDTVpVc2xBSzZFZ1V1VEVpUVVJUmt5MlNTSlN3SWlCUmtoRlZSbVZwTUNnb2lzSW1VRXlJTFFBQWtpaVNxaFZHR1hHb2hNbUJSR2hiTkdKclFGR01KSmhFVXFsWklLR0lBcXdGV0F3RlZJaWtSUURRWEJhbVFNYVVNbUNzVVNxQ1lRTXVSTGprSzRvazFBeGlxbzVqVEdnQkFhUkpLSkZXTWdGdVJBVEdDRlF4aFRBcFNkSklCV3dNWVRHQ0xNQjFYa2dYV0dNc0FpWmNZbEVpZ3hvb2xhSkJNSWxHQWd3bUpNVUtoU1l0ZU5sRWlhWEdNaVpVVElHTUJKUUFKUUF1TUFHUU1VWUJNWlJFdFlUR01CaXhLSkFwUXcySlZyQkJvR3l4Tk1KQWlra2lvSUFBZ0lBQ1lSbEtSQXlKS3lVWXhqR0FwY1dpa3FGblJPYWlwakltdEV4b1FYRmtwZ3F5UktVU0JNWVNUUlNDaGpvUUtnQ2laTXVCTXRrSUtpVVNLQXJLU0tva3BqTFJKaVJBcEpLWFdZVERLR3FpbzVwaFdVYXk0cUpKcW94UUdBeFFGR1M2Q1Zva0lCQ3lqTE1JZ1ZVbEVwaGhJckhTQzBNbUVtTXFtQ3NBcWdnSmxrVW9Jd3JqRWxVR2dOV01ZbzBVUWdkYXhBbUEwS2lJV2lJaVNTYUtKVk1pSXJOSnBBbGV0bk14aE1Cb1FLQmFRTldDQUZ5QmF3VUNBVWdFSUxSSmtUQUlrZ1l4aWpFaXNsSmlsTE1TSnBRd29tV2lUSmdLTVlzQ0FNWTdMeExPWUNtQVRHRUZ4a295NUpFQk1XQUNZRm93MkJjdEVpUUlFMHhqRWdrbG1YR0lBQU9oSmlVRENNclFZd29rcUdNSmlpUUZhTE1rR0tXeWprbEF1RVFSSk1ZeGdqcHB6RUlvb0JNQkpTaGhCbkFKbHk0eGpDaVNBbEppRnNRSk1pQzBRWXdJbU1ZVkNVcGNaSkJic1Nsa0lCcTBJd0JhaWFFa1UxYVhDWW10R0V3MWkwQUpWTVRWUm9Rb0tpVEZpUU5BQ1l4Y1NKckFWWklBNkJVbWwxWVlLeGt3eWdtQVJNQUpRRTJwaklHbG9zZ3dvR0VER1ZKTHFTVTBPaENhTUJWU0owS2lRRUNWYk1TVVlTQmlUTGlpcXhwTUFFbXRRaEFURUNKa2d3Q0pqQVVBVm93TFFDQUNDVUJxU1l4bENoRXhnTW1LWEFJRUlpcUpSQjBPQUNnQlFDSzRDZ0FwQUNoWEZBQmt4aE1LNHN4akVnSkJreGdNczJZMHRFZ0FtSkVFQUZjWkxXVEZFcGJVQ1pKT3B6RXhKaWpvWTVsTGl6SkFpVVlsY2xBSkZZQ29xb01NVUpnQVNUS2ltTXNDWk1Vb0NKaEFERml2TVdjWVZCUU1vQmtCTUpqR1ZKUlVCTVlhb1ZrSXhkU2pBWWJRU29TREdzMHVLb01TTVdGVUIwU1RFS0dNWXFOWUxvUUFUQ2FwQ3NWQ2FFRFdKS3NaQXgwcUJndGtZYVNFb0lWd0dNWXlha1lDYmJNQ0pJdzFnakdBN25FU1NxQ3hJTUFnRUpnckNKMmprWXNraGRaaEpFa1RSaFdURlZpNUlJRXhWb0VVUVpNWXhnQXdBVUpKUUNGQlVBcW9rckNKaEFxcENLSlZNVWdLNHhreGxvUklTQ2hVT3h3TUJqRkpBa2lJTGtSVUVVQU1LcGlpemtsR0FzeW9rbUVBU1RLSWs2YU5LVUl5Z0dBVElMUUpKaEZaRW9EQ2tySzlTVWt5SXJKaE1XZFRncVVJQWxFbEZtdGswa2xCU1NWRTIwbU5IUXdHTVNCbHhLU2RERXFwaktwUkFpQUVsQ0Jaa2dGd2dJQVpBUk1VdUFTVEdNQkthdXBhOHpRaFdpaVNnTldKaWpHTUpqVmpHakNUcFVCUWdTSUNZRXcybVZBQmdMckVtUUtFWWxhQ3pDcENCZ3NRRmNZd2dpWXhsa0RHTzZjQlhBWkVEQ1VCaEVnd0ZHTVVTQW5ZZ2d4UklScUJNWVRvUVlRSWhvRW9nd2t4WUxKWVdZQUdNWXkwQUZITk1WVkVFeGlTaVN3SkVUQWFrSVJyQkdNWXdVd0dNQ3BoUUZVd3BKbHhpMGdEQ29VU1l3bVRVQ0FBTXVzUmxER1FMQXkyQmdFVEZKakttSktBQ2JBMEloYUV4VlFhTVlBQk1LNEJBRVFFVkN6Skt3dlU1cFNBbVhBSmlrdGVaUzRwTUFnSlpsa3hoRktPWmpHRXlvcFJLS3dTS3lpWVNTU2pDcW1NU2xLQUJZR0Zja21Fb0NSSk1KaWdNQWdZQ2dBUUxHeVRSME9aU2dDWVFDazBZRVZUQU5ZMFVOUVlTMHh6WEdSWFJOSmpHS2dFa3FneGNTWkZjYWdxVFZJZ1pXTWFneGhnckppcFdvTUFHTkYxSXdVR01pWVRSbDFTbEdBeGhFQ29CQ3FXVWtvQkFJMUpJaXRKSlJBUmdLckFvbFFDSzRsTlNZREFKcFV5WUNURjFKaVlTUkdwakVpWXdDWW94cXhnakdBcWdDcGNBZ0tZVndBbUVUQ0NoakFVU21NQmx4UktKaE1ZeGhGUkpLWEFkazVpdUFSS0pFQ2dBUUpvVFJRR0FGa1NTakFTWk1aVUFKTVVtRmNZc2trVngvOFFBTnhBQkFBSUNBZ0lDQWdJQ0FnSUNBQUlMQVFBUkFpRVNNUU5CRUNKUllSTXlCSEZDZ1FVZ0ZDTlNCak5ETkdLUkpIS0NrcUZULzlvQUNBRUJBQUUvQU9YUVRwK0hVV0dVTVNyWmRSaDFLbTQ3R0dCQW51RTJUcGx6c1o2bURoL3p4Y29XM0FTUFpVQnFmcGhsa1k4YjFNWXdpTVBoSVB4eXFEZTVjdVhPWHhnWThua3dCS3VZKzRRcjVWK1VSMndqQXVJd05Od0ZMbFhONGp2dUV1REJZRUxaVlB5Mi9BS2FqWUJLVzJDaEM4bS96M1BJSjRoZ3NKbTIyeG1MSHY0cjRZQlRPanFHUE1lT080bGxKMUF4UzV5OXNFZTVjdVhCeDRaSHNoc3VOalAxTEFwaHBqVXFLWXVtT2NNcm43bDR3cHh0WVM5N2kxMUJpVVRVTXlxWnE0NURvbGJ1VnFIU3dyais0bXlhTUZPNENrcjlSMFhqTmlWS2FiOXl5WTVKRldPb1JzOTl3RUpUM01ZRzU3MUFSaXoyL0JVMUQzVUF5ZU1xclBaTDRzTXJ0aTN0bXIzUFFlaHVMZXlKZTNJaGpjeEJ0WmVraDNGM08yVkN3WlRjdGdUR28wTkRMMHM1TU10YkpaNmhVWVhFVXNtK3dsdTdKVnJHeXBtdWFEQlJwaGUyYk5rMnk0dVZTOXpiSEhpV1B3L0E3aXR5OGdpdFd3eWpDMG01Y3JHcVNHTnNwSWlSUkk0aFViTngwWENtSk9PcDBSdmpxRXdsdDNGM0RpaksxTXNlT09tWkNCTmhNR2lHV21iaGpEQyttT0NOUkdweEFoMU1lMk1OTVcvWHhROVJyL3VFRy9VMDZ1R0JUQVIvVXhYRWFPNHQxWlV1dlV3ekZRZ2pyMUt4NDJkeWpsVVJHN2dTMEpwTi9GUmVKcVdwZnlhNkNjTDZuQkh1ZmNJWnAyVG1SVDBSQVRjMFN4ZFI2NmhpY29mVzdtTE1uMU1VcU8vZ0dicjl6a3JQOVRzbkVOKzV3RjQ0eEswd3hTWldZVHc0TDJSb1V5bWVSa2RRNGpQcFZ1VEhMamc0anBtNjM4Y1hrVE1GK21wc29tRHcwRWNFM0MveE03d3lzaGRNYXhudTdselB5dVpqYjFvbFBjMmFuY2ZqQUxUS0pTbnFXa0RZek52S014UGl4bFZMRW1Oak1ZMVA5RTcyUmc2aXdMTjZZV1FMbHBsTzRuWHhrVGRSSmdZL3k3bjVsNG5qMkl6bDltTlRGK3pjN1ZodnRtTlhMQkdLYzFZdDl5L1VwNXNjU2lHei9VS1pZd252NFdGNVcvaU1IY01qNEZtVUlFNnZjUTBqOGVsbU9WekxIM0RLRHVNQzVZZHdRMlRsYkZoQmhUTHBtMmNXVlBIaWNtNEYyL2lLMDZnWGpVYVFCM05TNWRrRDRUNDEyc2VySmJMVWdTcUpmMUltTXFVVFVBalhxRERjMlhmeWZCM1JPVE4vR05tTE0zLytWeFlNdUc0alB0QmJuSEticUpSOEcwdlV5WFlQVXh6eXcyTXZKVnZ1WStSeHdjZUZ3QkpqankxSFZrTm54aWwvQXE4ZmNTbW1kZHc1MUNudVA5R21HOFJUNHNsV3k2TmtzeWFENHVXUzR1cVlSQlppVmxGdkpxVkVRaGtBU3psRnZGbDlFRlBjRXUxaWk2bC9GaEJ4T29iaVFGZ1NtQXA4Qlo4aHArTWNNVWJoaVVoQTlNRUxNWmpxMTdZbWtaajQxd3VBVmxLSldES0ZqamVpWjRCMGtGQ3JsMWpENC9NNHRYT01NSndkeHdTY1dEVFNUTGlRQ1VTbWFKUVFsN0pkdW9JTWNzTjZsbE1NaENGT1VPS3RRUUVqOFZDV1ZHb0k5ejZ1VlNzUmp4Wnh4N21xNmdyN2pqbzNLSXRsUWFLK1BURGtTc294eWxsUkJianhxY2JsUUdKbEZRaTZuSFVMeEo2dUVFalg2MUQ5c3UyZHordlV5eHNuTFhHQzFVc2cvdGxxd3RMaGN4WnlwbFlwY3I5ei91RzlFUXFZNHlxSVZjcXFMbUp0SmhoeWU2amp0THViU2duanhESmpqdUlrQzdaYk9VZjZUU1EzOEpLWjB3WTVRaHN1ZmFLVFhUS3hoamkyanNpY2ljSW1VVnFxanVwUnVkazZuSUplNzlSSHNtTU1FRm5IVnN4SExxSWpVeEV5MTNPODZtWnlaWElRT3A0ODhqRDlUVGJEcG1iZzRUaGpkWEY3TEppbkdlNEZEZmMyZy9EaTJMTXc1VHk1NE9BWWpjUllqampCdDNQRm5oZzVjc09RbW8wUW1WekZEQnVEZngzTmNmZ2dPTnNUVndOUTZTNm1HRG5tWUcyT0tLSlNNUDNOTEZtTEhRc011T01OZkJFSi9yN1NvWGpQK1RDWGEvcVg4Q01HMjVua0xaUDZrVkVyY1hrM1ZmR1gxYWpxVUV5NG5VRDhSRzlkeHU2bGZaWmd6SjZJR3RRRmxJeHlzcWRGRUNWS2kzSHFZaEtZRDFHWWhNc2FqVkFUcU9wY3hKbXduY0hFV3kvaGg4b3BaTWNWTFpRVFZRUW1PV0xsV1hVWEZ5amN4VWJZcGt4ZGNZRk1ZVjhicXpxRnd4NU1jWnhZYnRZdUlRUWgxTnNOeXBVeXFLTXNZTWR6SDlSK1JpM1AzOGpPUVlzei93RDJVK0NwZTR0RXo4bXNadG1LakxlTFBmeHNHRE9vdFR1QkFKUXltVXhIakM4dXIxS2UvZ2cvdWY4QWNiL2pkK3lEOFdRV2NtRmtwVGMrcE5iaC9hTnF4NjFNZXZrakFFdlVaZXB2VjlUS3IxR0dJVFREK2lRWWFQaTRKY0szQmdrRVZoVnhDNTB3UUlwRmd4eTNPVDhLdnh0WlV4SVlDVGhpR3B3eGR5aUlWQ2hsRTk2SXRuVUNtL2plNS90WXByY3MwUU1WYm5iTWxXRHI5eTBlby9hdFNzdlU0NVFNbWNmekRBWmxoVkF3RUVHUDdaVk9tRnpKNVljV1VVemdkd3hTNGVJZHd3N2hoT0IzT0V4TUYrN01nMkV4OGJPS3hJWXNSaU1ibTdsd1laME9wenVZSnVMdU85SVZES3lvcDFCclJQNU1nQ0sxYzdpRENVb2tNUWxFQkQ0TFhSSDZ0RXVzcmpueTMrSUMyd3ZqS3FVUWVJem9qbHlJM0x1VVY4SXJkVFpESnZ1R1c5enlvd3FvQ3Q0d0t2OEFNZVVxb3R3Y1NaSTlRYmFaWnlDVlhVUzJlNGx6SEhiYzRBeXVXVVI4ZWlHYmpjSGwzOEFMSDR0amtwQ1hpRXNKaWtVaGJFWWl3cm9uNlNZNGdkVCtNdS9nSnd6eXhkTTJsbzZtWjd3S21LT1AyWUoyVEw2Zy9tYk1aNHZLK0hGeUkrWDdWbE1zaklvbk5BSmxPU2F1S1RFSEhxWWhicU9BWURMYm9nV3dRRUpsaGxpZCtyaU0zRldaYTFObWlHSTNENGVnOVRManJqQmFuRVJqU1ZISm9QWkYrRUttdmNwbXpkL0dKVENhZTVqR2Z1RDN1VzQrcHVFTHJVTGZqRXY3TTlRSmlEbEFTNXEyRUdKdXZ6RTNVeWJBbDB5MWFnWHFjS0ozYkE5a3d6VExrRnNHL0lyRXBuQjVSYVVTQnFBN1l3Q29kdFRqTGxvMU5EUjhKRzJvRVdHT0ZmWnBnOSt6NDdaNmdSdUh3VEt3NVZxSHdET00wUll2b1pUOExVcFNrK0VnUWVPUlpNbTgyQTFPTXg4U2crcFFLZGtCRDlRbTYxOEJPR0hBUnRsYlNBS0VyRVcvVXR0Q056SitwWGNObW80c280L3VKWkFERzRNd3l3eHhlTzJYdGhBaEwzWHdaREsxY0g0eTM0UW1qNDdmaElPcGFETHAzS3ZHNXNteE5SN3VEeStBbFRVMGRReWpaSHlPc1VLSnN4MUJwcVpMMEVHRTFELzlDdGV5RjBrRzVUVFJNRGxqSDZ0UTVUSEtkM1h4aTJzV0g2bEkwL0cwdUVFZ3I4WHBnNjNMbTV1RXQ2UGk0UVlPbzViMU9jY3FKenhyVTUwemtzTnhXSHZVU1ZESDRVcVlWTHRtTVc1aWtYNE1xNm5POVR0WnhlTU9UQVNiZDNDdUx1SUpwaDNwaFM5WENqSnZHQ0NxYWczNmx2U1JZY09OcjlwWitZUHE0WkFTN0ZocUxBb3VmbmMxcHVMWFpFdnJVeE4xY3Y3UW1TY0p6Q2NtY2xvSnlobGM1b0pCMWJITllacE9iTHUwaGRRMnl3WTBRcEp4dTVWRXI5d3dLWnhBS2xLWEtnTjB4b2hoNllZNVArcFZ5aytMWVpzY3U0YlpwWWdRWENYVGNTY2FuRnBCZ0pqVTI5eE5NdWtHRlM2bUxaQ01XZ2Foa2FwbDczSzNab24xTWJaWXpnUnd5Y0Z4SmxobHhHZllpd2pVc1lHNXRkRThuWDdoZHhkNitDbUpBN1pTbHN1ZldmV2NBNm14bE8yQ3dwV0RnejZ4QklCNmo4YnJ1WVdMY1VyWGNyTGJNRExKcGlVb00ydEJCY1djOCtWanFPU0NETmNKaU9XZytOdmZSRE5uSjJQVXh6SEpuTW5NQlp6L0FESEtOSjNES3NPcGp2QlFsTGdRc3ZVcE5wRER0bVZ2YTlUaXlxeFdjcjJSejVGVkhGSWRzQWo4SmNIVk0zMFJ4Ym5lVVRqR3RSSmFRR1Y2V0ZFTGxoOEwrUGgwUUp0K1AxTVhpTmZGYVdXOGFsSVhEcTVqL2JVeHl5Ymc4bjRScUxzL015YTc3bDNBcHRoMndPT0szdWMvamxVSlF2d3JZeDM4WlpGVVR1T2lET1ROamNCeWJsSXhnVEhCUllVRGZ4YkNYVDhIeHhvK0tvaHVmY0toaVJIR0d2OEExdGxEOEw4TGNxL2cza3dDV1hVeGRwNm1JY21NRUlOenBtR1ZYY3VWdFlQVCtHWk5qKy9nVzVtaVExakxsempBWFh3YStDRUtsSHhxQlcwK3NIeG1YSU5ScDZtLzQ2K0NCVDFjckV5dEprWU5WcUhIcUlGTWNibHQ4Ym1tTGY4QWJKK0JyNDlRK0YrSFlSTWR6WEdHNVNzb0libVZFcS9BL3dDeVZSY1BnZFVTaUR3UDl5dmdHRG1YTm96SGxMZVd5ZHExQjNVVmhCbDFMUGcrTzRNdEdMY01nbHhkTUYrS1l3S0lueGpMSUpMZ3psTGpDeUo4YmlCakFPaU0xS0pvMTg2bEV2OEFVS1dwUml6MjB5NmU1eWptR01Nc1paT1l3bUx0dUxXakgvdWN4eG9OanRpOHRqc2psbk9XVlZGeFQ2akFLMWZLSXNMbkwzVVdBenZVNkphRTVaTGN0Z3BESnZjdU9VNTZnNmcwTUhQMXNnMStDRGF4ekUvck9ZZjhZZVFEcWN4aTR5c1B6RCswMVZTeUZVcVE0UkFibWdnYmlBUUJqZ1F4TFNmeHE5emdqT0NNM1VicVhVYzdZdHk4ZU9waTZXN21LckdOY3BlTWNTSlJLMURxYXFHVkFSbURISVNwcGdWdTVqa25TMU5PMW1PS3lnZ09YVXh3SExhUndCYWhnbUxjeGEwOXNjWEdYVXh4bkhHdTRZajB4RXlpNVRrcEUrQmhTZGhNVE5IVjR5d29pbHY0aVkxZUxFQXFKYksrMEpldTVpYjduQ0RXNWk0R0xjd3d5TWVtbytRTE5iK0E5eTkzSGJxT045Uk1zSGNzcXBnTG93V1kvd0NQNWM3K2pYNW1Yajh2aWNlWk1udXUyT0V4Nm9tZUNHNVpGT29NT0xNZU5wRElKenl4RVR2M0Zja0RjeEt2a0xaMU9HZWZpUEk2d3hLQ0dKTXN5MGpxTE41RW94UC9BRVM1V3ZodnVBOXdSMGtmZ2wwekhlVXlJUzduR0JBbWNjZUpjTFprVk1TMlZRd0J5SndCZDZuZnd2cURUQnE1Y0JZL1dkdHhMSUVOWGN6R2lPcWlBd3hWajl0UWR5d2ppVnFOZFEvcjhDS3JEM0J1Zm8rRzRaUERqQXZ1S2ZBb2FZRFBjYVpaTmRrSjA2Z1JkTS9BU3E3bDFISmhwdVpadWFXVkZtNHcrQ09KeWdhbEF3bXQwUUtLbXFocjRCNHoxQ0F3eCtNVUhjZG1vaU5NYmcxTG5SQitMQWkzQ3ErREtwVTNQOWsreWFpVnFCOEJEcnFZM1NLMU1ERGdpcEFLWWRiWnhwWVNpNHNJWjc2SXBPVmFoWGNGR0dkOXR4TGFKcWlXeXZjMUFKcUZKTDNVWHVZMUdxbC9IdGxJUTE0c2laR2hHRTZQakE1VDAyd1paQkpjMVRMYW5PYzJkMzhhRDR5U3ZnUmh0cVdsL0JIZDdoMThZMHpYd1pUa1RsTGw5eHkxTVk0N2xRbEszV2lBckcxNmxUanAvVUQ5NmpWNmpWYm5xWExJc1g4TXN2YkZXNmhPVjQxVUZiWTVaSkxmekJZTTFOWHRuMTdpRUhHbzhBc1ZuT3RoT2Q3cWZ5cW40cnFDOXpST1E0d1VuUEkyTTU1WktyQy96REpMSUtrTzJXMUJWdWJ1Q2xzRjZWaGF4V3B5bHk5ZFM3SU81MFRsbCtXY3FJc0g0R08vZ0NhQ09kcXk1a3IwemtrRzRzTW9QS0dSVXNneTQ3Q0Rhck9KbGxIRzJPT09VNGxRd2UyY2Z0WFpNc2RISFg1bUxSREZYYjFOMnpWelNVZHd5RFRMb25FaUVUVVN5aVkwSDJtaHMzQ0RPYjYxOFduVFBHblNvTWNNYmQ2Z1BLSWpjVzVsVHVMcTdXYVdhNnVPSDdtQnhpUGY1bmk4bjhTcjR6TC9BSE1rVmFxWTVBYmdIYytzNGk5ekc4Uk9iVUNpZW9VU2k1ZkJwQ1hGcUJpNDlFQXVXVzdnMU1YSGkyUXl5OVRJc1g4UU5oNllZOTQ2STRwTWZIbWltTFV4OE9XTHRKL0hocm41Ukg4UmZCaUxqaGxrSHZLWWY1bVdMOU1NU1ovNWZsemZ0bXN6eVYyM1Vjcmw3bU1YTExOc3NsNnJoSC9XeVVtdnpBQ3hoUTdqdkt5ZVR5T1FFOFhrZkhseXhCWjV2OHIvQUI4LzhEd1lZK0t2UGprdVdaTVZ2MllYSE5kREUzR0lCOEU3WWt4bW1aR2hsMnM5VkxRaGNQY0FDQTVmQnJjWC93QmNkeXJibFhOcUVjYWU1YmNCQ05RYXdSbU9Lc1Q3OFk2eWc3akNGc1NHb2k5UkthaXpFS2l0eHRUSk5URkJjcFc3ZzdqM01NcXlMNmlEbXNxc2Zpb0RBUStFM0VQanFEY3hMaHF3aTE4Z000eE9NR0VmaE9YdjRVaDhKdWlZN2lUVW9sRlRvdVZrWTh2VXFpNDlRYWd5dmlvNWNTcDB5N2xGYVlTc1JtR0pjVXd4ckhjNWFMMnN1RzVnRVpVMFRWM05YZnhaOFkzOFd3MVpPS3hLSUZFNkxnckM0NWVxblRVeUxHVXpwbnVaVFI4RS9iTWo4ZkZGV1FaL2FCYzI2Q0JBZ0RxQnh6cVVXL0FSZFRHWFJPeFNjMXhDRGZoWTN4SnViK01RdnBsemMwZkRMMEV1TXVESDRibWVLWWpBcGlBUTlzN2ZnM0JwM3VaT1BXTXV0UmZnTnlwVVowU21BTGNNWnIzRUlKaWFJWnFNS3BYS2MvckRKbkpiSmlvZnFQTmRUN2J1SXVNNC91WTRqMno2czB6TEhFcWNrbHJCbDVSV0YvQktibU9NcW1MS3JHTjFOUXhFaFJqS0dVUmdGYmpoVXFwVU1ZVnhmZ053QWpPbXBaT0JqR3BSeXVaQk1LdWFWbW9VKzV0bE1DY1ErQ01xVlVQZ3VEVXVEVWNsWTVNdE92bHFFTWxabGt3ekNZK1dsaWxXVFpyMnpkVkRKbVIrNWdmeTRxWU5ZZHNEQnRJK01wYm1QanNqaWtNQWJaa1dXVEpnczVDTXh1cW1XWmxwSm9oUDlRYWpCaHN1UFFlbVlZTnpJck9wajNGKzFUOVZCQkl0NVNvWVBwajVNK0ZFNVBiQk1wcTUwUU1ZZkFrOU1TcUtnaVBxcFRsdFlZSTl6SVB4UDBUcG1PSkUzTVFXTHhhSmhqbGxtaER3WUNjL0tIK3Bsai9pWUZZcjVIL1ZRODVpZlRBbVhuOG1Yc0Y5RTNuZHNRMCtpR0FpOHRmaVZ0cU5CTjhiZ2ZISUNlTEp4NVZIN1RBSE5GamhTbzNIRzI0c3V2VUtPeWFtV09IOWgweTF4NHJvNmlPTWJJQnh1QUozUDZmQnBaUXBNZzZJQVJSdW9kUmx3aDNQY3dMWGZ4aU9SUGRRSVkxM09NejFCMU9vTXVJKzJGSHhVeExabG5jTENabEZUOEU4WGd6OHBsa0o5WlZRWmFzS3VQZW1QSmgreWEyZm1OQlV5ZVhpTVNVQkhJQklYTXkwZ1ZoQnVYOEpaT29TcjZtZU9qSzQ5eXZnYWgvV1hPNXdIM0V4TkRmd2ZGYitLaXpWL0QxQ0J4TnMvWk5RRmxBeGpOczVLSmVvOVFiSlN0QkRiRitMK3N6MzhFb0pXb0J3dTZZNUtqWFVjSEV1NGJQMGZCcnVZdFFMYml3eHNYLzBxQkxRbHpwSTV3V0xjQ1d1ajFDNGZsZy9hRkx0bk1COXk3bjFDNXFybXNtWlloOEtrNDVIZlROazduMWdZMTNQNnd6UCs1YmhuY3RsL0N2Y054d0U3Z1ZBdUJ1T04zdVVoUkFaU2VGLzJUY0xoY1JTWXFUQTJyODhmbnE1M0FtOTZsWlZkUUxqTW0vSHVFRXRzZ09WcERGcjV4TEtJRHVVK3lVbTBsbFF2bEg0d1FLUXVPc2JZWldmSE5JNVA0dVd4WDh5Nm4vR28xb21nZ3ptQWxURjNPWDJqTlZHVlVRK1RVS3Rpa3I0cS9nSWxTaE5zckVPN2xsUmdsekZMWVFwdVhmUktzaGlWdVk1ak04ZlpETGJjN05NeDBNdUdVTW81UzViT1RYVVhWUmVKQjVNY1hGNHlxbkxjdW91TTVrVjVSYmd6bEZzbHQ2anZUTCtCYnFKOGF1T3YvVEg0clVGbHR4dVpoalgydXlHUkRLczd1YzFlMkVYN1hQRC9sWitIeDU0WW4xeWhrVGtFSDhNdEdEaUd5RHVpMGhpV0tSeHQxTWowRUZ4bHQzVWNqakxVMTFPdW1XY2E0bHpIUnVNcUdTUVVZdjI2dGdqcEtuMXY2eTBpYmpnM2R3dWNucURMckZLSVVYQUk0TTROVGkyd1VhWmtERmoxY3F5NEZ4Mjl3VEU3ZzhSSWJaY3F2Y0dybUxjdkxmRzVqU2RSOGlMVWNsWmpqbG0xaVRZSW01L0c4REw5eTBvZzdZNG9rUzJyS21ab0NWUFRxWUxBVzVXclpmb2hqdVVVekVHSi8yUnhuRUc0QlVRNGlzUXp6QWFKbmp3ejQ0Ykk2WXFnTVBzOGVvbkhVL2NxNG12alRLcTR4Z1IybFNnNytDd21pQjdKZDZTWk5GU3hKWDFpQlF3cUhjWUJYeGdLeXpCNC9GMlNsWnNtQ2dnb01YNFRiVXJaWkVLc2dzYm1PVnExSHVZNlk3R3B4anZWYmlvMGt1ZHN3ZUk2bkgzQzdTY2R4UFVOU3J3Zi9RdnNOZkY5d1VpV2ExT0VLaDhYOE1EVTRIRzdtSktnUmJpdFZOVGJFcURNUTNiT1haREhReXR3cFphWnNxamJ0Zy9CdGhsWlZRMC9GVGduanVZWWkwc1hiWHdVZkgxK043aVBJMUN3U1pnVlRjQ2RRbGt4U0ZUcCtENEdDbzFNYlJnVnVMRGl6Ni9BQkdyZ2hGdGwvQjVITEJ2U1JXWFVXOHRFMnlvYW5OeVFlb2c5TXBsbndOUTQrNWwrb2FnOS9HMW5GbTN3NWI2WlQ2WVhjTDlzdDVVUTBzdlVKVi9IUk1TY0tudENXakJXVzFVRDRaNjE4R1NDSFU0R1JmTGNjUy9jNGVOeDFZdzFNY2RMTis1dGhOak5LM0tMaUJUK0puOTBlcC9VcWNneGwzTGZnamlmbVkwckg4enYxTVMzVXM5L0JXMkF4M0xRNmdXU3ZteVdFc2ZsYTZodGgzU3dXVmI4RVBqMGFoY0YzRExpUXlYY1Z5SUZROHJqTEdtbzVOdENUSEtoaEEwei91YmhCMU9XNDUwUThpdXBkOXdRamxMM0hxS1ZFb3VZNUxGaDhGK3BjeGpPZHd5amxCSnE0cExoUDhBVEsxRWxhZ2tZTmZ1RzIyYWxhbFM0THhiSmFVSFVNcmJxS01FSVo3am1QWkxDcWwyZHNORVY3cWRuVVU0SjdtQmpmMnVPSXIyRUFHZHZjYnZmVXFPUWFsekd2ekZSL2NWTnFReW9VSVpXN25MbGNyWGNOTVMyWllJV0UvM01EeG1PZHd4OTNCeWZjMnJ1WTVPUGNjaFpmSmppZm1YNm41Q0JSTVNMVDFQM0hMMlJaNitPZDJUSDYrcGpuZVNPcHE0aE1jbnhsNE5NeHpLZVhjd01VNHJRTWFJdFZVTXJ5dEp2STBRSGszUDl6Qm9ZVXBjYUlFTk15NUo4Q0VQSWNVQ0REWjFFKzNXcFYzZlV4NEdHNW54RzhkM01BMnBRUmVTd3htN2xlb3VvYUo2bUR4Ym1ienZKalRzaDhlYkREeGNYeDVtVm02bDMzOFhCdURXcHl2Q28xUVhETEhpbkdZNDFnc3krRitBZ1F6QXIyeXQxYzVWbzNMZzFMV0VNaXBjNWR4eVIreERZeTZZeXZxVWZGVDgweFRKbDFuaWhQSThrbGFtSmI4Wkx4TWFnYmpMSmNkRlJoRDl3NnFZbjBXWFJzZ0RqOE5zclVxaVhBM0VwaDNZU28wUSsraG9tVlluR2VFTXNrV0J2SXV3Z0VvR1ZiVnpNQm9sVWZCM0EvNHgrc0N0ek1IZlViWlZRQmdWaS9BS3hkM0xvZjNMeWNhdlVJRTdZaGM0ekVJOTNGL0U1MzNMdCtCaFNmQUQ4TE5zQmJnOFplbW9aVnFybHNGSU92aXRRSURQMUFPRDhoYk1uNHBZRDB3S0pqSEVEdWNaUldwOXBXT2V6S0lFQVJpVkxXSVE3aWZBRlI2bmp5Y1BIblpjYzFyVlFkOXltWHV3aDNIUlVKaWh0aWlNdFNXMVV0WVdmN2lMdUExeG45ZFBjWUg2bUlqeVRYd0ZSVGdsZHl6R1hhemZ3YXRaaTNxS0N6R3FzZHpyYk1xcTRiNllpc3gzT3UvZzFLK01ZdHdRSTZQOXd5Snk0dG53czNVdENYT1U1UzVTeGZnaFJEY3BsU3lvL0I4c0piMUIxWHpjV2lEcGhQR0szSHBoaXltVWhOUW1RR2lkYVpVeTBEQkI2aVN5SDJaVkh3djZpcVRIUkszRUtnd1FKWXZ3TnRTcldVMVJBWmRFV0xDYmhYeU1zbW9CQUE3bHk2cGc3ZFJsc1NDa3hUdG45b05Rbk5saXF3LzNCWVp5eTdoU081d1pjTnpoMnJMUTFQMjlzR0NhWmxsY1c5UHhUQ0Q4aW1GRWNsN1NBSjFPT3B4bU9LUnZMNEk0eHNtUFN5MkYxRzU0L0J6d2MzSVAxY1M3NkFsWDB3SDRNYXhXR1ROOXpadGd5aExnQ2JtMXM2alNhaVRETTVVdzhoa29hbTdtclJqK0NVMU9LeEtzbUdUTnp0bGJnY2hxWWs0bkYzVXNJWldKR0JGb2dSenh4eHFZbmJMbUZJelZ6UHVWVEg1M1UyWS9Dd0ppQ3FzTWlId1pFeFNrbEZ3QVdjQ0dBd0RGL1JNL0tJNDRFZTR3MUUrTzBxWWVMTHlMeHI5N25HeXNUcWRwRVhHYnlMWU1HN1dDTTUxcUc0ck1CTEpvVVBoWVVFY2dnNlk1cjNNVlZsNmh1Sk9SY0dFcDJkd3h5eHc1L0FEMU5Oa3huU2tMdnI0TVpWa2FxVytvNUsxSGJLSXRQNmZqbzFPVTJ5eUVYVUlOUzFmekV1TTdJdm9pcVRBcVpIN2dBZHlwNlNFNkdDZkJOM0xkd0dybFBHZE1TcHBOUWZ6QXNXWEM0eEtZTnpDT2haaUQzbEErQjFjTnlzVWh4bkltT1FNVllDbHltNXVZT3lLMnNZWTVleW90RVZsM0FLZ2ZhY1cwK0tsQjFDbnVKVWJoM01WYllkL0hjWS82bUt1R1V5eEVLZHpnRUd1b3J3bnFvd3hpYWR4eDJUaTB4d1FHWTZuQ3k2bjhlamMvcXpMRzhyWmxSUmNIVm1NNUpoVHVHM2ZSTW5XcGJETGFzR1k1ZDNOeTJWdFlZakVDcWl6czNNVXhJVENMcmZ3OTFMK0MyaUo5K01XRU5GUi9wOEJDWkVyNUNQd3U2aHYzTENYcVVwcU5uY3E1aUc3K0NVUllmWWdRK0VmVVBpeUZXVHZKaXVJaEZRSVBxN2pSdTV5TTlCTlFTT1k3SDVaM3BqK0wrTmpPRE1zZUliR1hPL2hHL2dIay9BWE81WHhiYXdZczBrTjVROWt1Qml5dTZnSktsVkV2VXFhcVkvN25KWTlmRmt4KzBUNUtkTFJQOU1TSFZXSHgwelVJbE5UbFh0aGtyT1JWUzROTEt0SjlSWmppVElwdUg1WXRLRzVmd0c0MTZaeU1ZS2R3YWhraXprK3lHV014eUoyekx4MGJaWHNKbGREOEJyVTNDK01SbkdjUTlRT014VUdjbWVQN2lYT0ZZemlCdVpBd3FvSDRtSnBjaUdpcFcyWGJIR1lCbXBQSjNROVQzTWU1eTJ3c3RHQ3VXNVhjT3U1VUdGanFBMUY5TWFDSUE3aDFBdnBpd0lKT2hoT3A2V0VTTXBnSnRsV3NXeXZpaUZzcWQ2eG5wL1VDMnBVR2R6c2hrczVKcU9Td3Y0eCtMbVJmdUFoTVFMOVR4TGlyNm1iWHdaZkNuUkdwVnNDaTR3bGxTL3JIUkRFUzVRdytOaGNaeTFDYVdtWllHTHBsckRIOHNmMWxjWXZFbHpaakF2SzRLc3FFZmpkeFFQakh2LzFNa2h4Y0g4d0tHZW9RN2RYQzhVb24yVmlaUXhRbW9GeEs3bFkxTWE3WmNxR3BRd0tqa21MUkQ2a01yMnkwWnlEQkh1WTVPTGNjbHp0aHRqZU56Rm9xS0dyK0JsUzdsVXhmclIyemZVcjJNNDFPRTRlcFZRQ0ZFMUN2d1MrVFJIVUVxTTYrQzd1T2VXVE8yL2dQaTJGaGVVcVZFaERKeGo5NVZYcUJFaHNtSU1vVzdsak1ENnFST09KbE80L0c0Q3c4YXR6Z2U0OXlnS2luNDZtU0xxY2tPNVhybEZicTdxWlpRMnd6ZUxnWFZ5N1o2K0wrYWhxT1UxS2hXTTdsUHlIeFNtdmkzNEx1RjhybUdJMnI4M1dwY3U0RTZabHI0SmRQeFpQRzQ4MStQVUdpR2I2bHVYZi9BS0RiVXVtTnNETEVnTU1hRnVCZnVOekhIOXhHTkVEUXdlL2g0MlhNWEU1TUVyY0N4U2FOTXJFSnd4R1VSTndDb0FibGt2NlZLMzNPVGRYT00wU21sRW0wbEl4dVU4WnNpdnFERWx6dCticVh1WTZVZ1JJWU0yTk01SkYzUGVvWE1nUHhjd01lQzM5cFVxZEVCcFlhaWdRTElOeG1uVUQ4WlNxajlpZEZ4bDdsK3lYZTQ3bDFMdHVXd3lodGdmc21hbGR3eUVxQVdzQys0RWRTMTlRSEw1R1hCR2FobFA1RkladE9wekhHSVNweEtzbnFQSkpXUjhaTlJWS21PdXlWeDNNSFV5dHgvdE04WEZQY2RzeHUydW91WEdEcUdVcmNYVmZuVXgrbUN2ZlJLaHI0U3FabG9zN1pqQ0tUc2hVQjdJWnR3eWZ4UEg1QWJ5eEVKNXMrYllBUjZxWS9VM0dvT2tnY1NtRUdNWlNFR29ueGptVTNHcW1NWlVJekhXVTVVWkJBcWVvRVBjTnpxRDQ3dktXWHFZNThieG5SQ1hDaHRtbVd5NzduV01IVy9qQk53eW5IM0dDaTFCMUVWaFFUdVpGWXphVG9sMTFPb0N6aitXTFVDOHBXNHZLQnFDQk5zRUpreTdKNHpmMm1UMkhVUGtuKzVseHM0azVSSWZ0bVZCRDBuYzk3UGhKeHJFVm1vTEtRZFF1WVhqbHVJK21BN0xtT0w2WmJ2NEx4NmlyMlRxR1o3SmY0amVtR0ErTGx5aE1HZTVlNGJVZWlGREZ2SzJLWlpMYWZCZURaTXNsVjlzQnFPcVVtVkxZUUpWRndMMEVUVXBHS2pjRDRiaGszdUpjQUVJOU0wRXVHdWlEVnk5R292d1NxSnhYZHd2ZnhxRGpNczhVNm1YbDVoZnJSRE5QaFNhR0xjR2lHVjZZNEkzQ0VDaHAzT0xWcFBVOGVOWC9xYldHQ3RNNFZpZ3RqTWNCZjBFYnNBMUJtT1IvRW51QmxwV0o5a2hNaWsvY0cxclJPelREcEl2R0tRNmgrb2lNTCtOazNMSmM1TXRxQlpGS3FYTFlXeXlWR3FqVGhNYzBLSmN1L2dzbTRkTnNvcUg3bGcyVGxMaGJPT2E5UkYvc3lpVzNvbTRFeU9pQkdCY1pjR0hVMkU1UHp2TDlTbHlxNFhhUHFPNXhadTZncE8ySkw1RlRraFBSSHAzTS9EdzhKbVptK3lWUjNNUk5rb3k3N2lKMzhiaFBjeUIwUkFLR0dQUFY3ajR3MWU0Qk1lbUpjelF4cVlaZFV4L0svREVaYitJVWwvREtxYWxFWVJnTVZJc3VXMUwzKy93QXcxYjhCYlU4WmhqaW1lOG9ZdjVoKzJYTGdpMU0rcGlaZTJDMThtaGprOFphRUdOUUpXcHMrTEtxQWhxY2tuN21JQkZmVXlWcW1XZjhBY09VY3NyNmd4Um4rcGpvYVl0SHdTdnJBcURPVU1jYjNEV3ZVUk9vRXJLbjNQdGloRVlLUjVKOE9EYXc1UnBKbGZ0ZzFNRVdzdW81ZlpyOFFWbXdZVzR5K3pvZmpDMFc5VEhpdStwbTI3WTJ6RWxzNU1UbG5LNHhZMUR0bUpCc1NjR0kxQVF1WmE3bmJjeUxuSGM2TkVjYk56RXB1Q2VvbEJiSzdpdHgyakc3b2RReDVhcWNiMVpNdTZKcTVhbE0xVlMwS2xWVlIzbkNpOGF0V09OYVNmcWYxTGlvYTl3YWhGRWhyWHhWc05SZ3k2aW5Ccis4YjE4TzRFQWxRMEVReW5ScGgzZGZGd2R4ZFJIZ015ME0rdFRETEdLM3FKY1ZoT3lwUVFnRXp4eThlcFVxVUVMUGk2WVkyWEg0M3lucCtVSWdGRURIRUtuM3pua09ETlh1SVhyNE1idmZVS05MOGN0Mi9JbUpjeWl3KzJRWFVkWnVJM0t5R0l6WkJzVWJKb2dWTHY0eE52eDNqUEY0enlOT1ZhbEJvZmhsVS9DUEMvZ0prWkJDOVF3eVZnTDNFL3dEUlBqMHdhcTVaREs5UlVuTm5Mc2xzM0RjeVNnbFd4K29IelJHbzBRSmtmQ255RUgweHhIcVZYY2NCUWlHT2h1RkF6d09MbmwvcVAyV2lPZkxJNDZTTGtidWFwWHBuTEhvZ21JYTdaZEdVTXBrMndMb2lQSkZtaEgxRnhjdnJES28vYUdOU21Va3RTb3FhdVYrNWN2NXFvRURIRWk0UjZoc2d5dmhnM1pCQVplcGVwZHpiTDNLSW0ycDZsZkJScWN3bjhtZHprUnFZdGt0aDhiUGpIVXFhaFVJOVErTFlQYXdiMzhqQSt5d0xHVmM0cE5QWHdqYk9PTlhBdkx2cUpqQTV0WXg3cjJUSEw4ekxFK0t1Vk1RZHM0Z2NpVUcvZndVdFRQSGhLQ0laVGhnQlVUM0RLelVKc25LSFVNWlU3SlgvQUw0MHpVd0djTVQvQUVUUCtOeHg0R3ZjUzlFQjZudW1LT29uSDRVcUJpVEx0bGYrdGIrQ2lMQlpiTVJXQ2RTcGFFM09MbEV5cVhXTE9Yd3FGd3luT0NNR1VWcUxaeGx3M044cHVNRGVvZmxtVGJxYnFJMU1US2REeVpvSllUbVRMS2Mza1RrWTVzNzBlNGlTdVRHR1g3bHA3bkpjWmhubGpsVEdsM0F5L3dDR1BLT0dlSVpvR012RlVsNHNKc2pNZFRIcFkzR3ArWnhnVkYvRUZsem4yVFA3ZHg0bU9wdVkwMi9HN2pvaEg5eG9ENDdHQTdaWnhtSEVLUlZpY1dlNFRqN2xNcGxNNUphUmNsNVBmeFp5bTl3aUl3Z2JYNDZWbDdqQStORGZ4WktZVEU3K0xyS0d4bW5LbktvNG1Mck95YnVQR0VVRXVQUkg0QTVSdFk2SXVIQTF1RTIzVXVrbjVmamk1TTJSR28xeEFuOHFZOFo2WlloVXZjL3NKTHBudUJCYjNPTXdDY2dXWEM3Wnh2RmhpUHhpNGwzQmJhNmhkeTQ1RmRTMjdxRnNxcllRQXRna3A1d05yYy90OGRrNHpKK3N2NmtNZTFuU3pFdENPSkVQaXBVNjB4QTFCQ1h1RjhvNHhaMlNyTzRsKy9oSngxWkFRdjQ5UTVjUGd4cGdES0IzS0swd2ZoUVJKeW5KdU9UQTdZTjNjNVJaYzZpNjJUZGFob21COWRrQkhSQUw1WlRSZkVtRFdWdU1VOGluVWNERk9Lc2R0TUNtNTQ2SEw5a0FTRmJKNHNmSnlvdzU2anJUai92OVFRbW1JQjNmd1JpWTkzY3RXVnVLMVViSWpDRnd4M0VwanVOUUlJNlNjV2NmckZvb2hNWEVXNXJvbDFGbFhBVVplcVlRMndMWGt6UVY4RFVXY3B0bTFtcFJDVlcvaGJKNmdTcWRTd1BnUC9RbHcxQXJjTVEzTzVSR0ZSK0dIeGpxS3JDWTJ0UnlXeWY4SUI4WXd0WWxURmdZdS9jcWx1WDlZZFJaY0g0SFZTOXhDRkJVbzRzYWlERkNZVnR5V2Y2Wnl5NHdMV09nSUxVM0F1T0pCbGpBN2xidU5URmdkeDFqOFU4WVh0WnlvaTIzTkJaQ0l3Rm01aTJyQ200VmpHN2FZY2crR3ZnTzRGVFpBQnVZSDNkeDB6UkszcUxsS3lUY1FBSnFNUDdYRmhCbitweXBJeHltSVJFZFJkdHc1R3ZpL1U1MFFSWlgxK0RFcXB3VnFJYXVMaU9wWEtmeG9VZHN4eHJUM0xSU2FXWm00RlB3NUtCTTY1UXl0Si9qZjVlZitKaDVzRCt1WkROZkZ4VjB6bDJ6c2cxM0RLK3B5bDBQN2dSREpqODRVczExSFhVM1V5YlA2UkZaYVR1WFJVQnhJL1p0aU1NY29yL1dkTGN1WThiM0dyMUNqRkV0WmxlU2ZxTCtmaXBVYmQvaUVxOGFaM2xBT0wrWTZLbVdzU2U0aExsd3AweWdkUm1NcmNTQjZKK29rSUJpemJjTlZOVkVwaUpLdVZ4bjVpUU1ISHQ1RVVJQnhqYTJkUllFRmxrVFVDeUdTQ1Jmc1F4dHVGbHpGc242WTVRdU56SERKNk5UTXd4b3h1L2NFdUdPN25wcVVzMEU3ZC9HaTVoS0VnK29JUEtDcXJHb3hWZGU0Rml3eFk3eGk0Y01URmJPNHFRVitHYkNXNU5wb2hncTFNU1k0cXdvbU9EbXRWUWUyVnFWTnN0aGR4M0VBaGo4RVRrcXltQS9CTXRzcVl6NjNMQ3dQamJMbDFDSnE1L3hsemt5NlpsbldOVUxCNzFEZnhrb0FUbExuTFQ4RmF2NHFCS21PVkZWREQ3V3lpS1hwMThITFozTjh2UkJYQlBjeE9MZVJjdzhqV1JSVThoVGVNNkI5TXdOcCtvUEZZN05URFBMRSttYU1jc3JONzl4SVZHRnpxL2psOUtNZHpLQmNRL1B6YzVWRFpjWWxTaGdNS3BaellLa3BsYWpIVTFCcGprWHFjMkpyNDhYaVBLb3RBWERIMWZVb1c0VWZQMlpqNDgzeDVaYW9oaEFpUW15Q3huVUFlMkdOUUxsdzNGcVBVMkZFeE5RUGp2VDhhbFFxR0J2Y1dqNGU1MUVyY0toM05CQmFXY3FTUDJaWlh3QWR6WHdReG9jcjNDc25jU2FxQWZBUU5QeHFjUnFva0pveHFjYTdsYVdKOWFXZEcyQ3k0cmNINEovcWZWbUFXelMvb2xZbzdqaUJER040MVB6TWJZeTNqVXFHTFVvNitGU1dqRnVZdTVvR21BKzUyNmoyd1dwZGpIUkc2SVJtbUdQYmN4MSsyYy9TUUkzQlFpM1VxMklFcjYvUEtFNVhwSm53MFlSYlpkTXUyR3lQVmlRdG1wWjhjbUxGU0diRjVYSEVaalk2aTVBTVVWelpqa0lyTWpweG1ZMWNCYWpDN2djczBleVBTRVZuSmxibXlhQ1l4S2xyREtPU0JPejRzR1lkMUVyUDQyRXZMajNIVUh1VkViSXJGYW1OcE1XK21ac3J1YzVjcUEwN2gxRTFEUjg1UVNjclowM0N1S25jeDNsYjFMeFYvRTR0TXFQeFVKdVlGc1cyVnVXNDlRNHN5d1F1QnEyUDlvRURqQWxMTXVPUVZOak9VRTJFT3JZZHN5M2lUbDlaNitXTG9xWmJJS0FFTnpqQVVuK3B5aGlwT3RmUDhqME1OdThvZE14eCt0eFQ0QmdUakZvcUMrcGxMbHZYeFYvQVQ4eXJKc1BnR0JPUDFkU3ZkUVNZNVk0NFpCN21PdHgzRnZSTHFkeWthT2lHTXFGVkRwK0x1YS9FTGdzcTR4Y2V6NGZnV0xETFRBbHgvUkRUSEcyWUZUTEk1VkxnNU00c0Q4L053SmtxM0RHR0VvYnhnRXh4M01zZDl6UERFL2Rrb01BSUY0ZFNucU9EM09Nb0lybE1USmVQTFU4T09EbmxqbG1GSHN1TGJWV0RPVjVmb2c0ODI1NDh0dE15OGRnbVc1NHNCOGp2MU16RmFnbUx4cVpEZ3RRMjdpa0VwbDVCdVZaOFhMbHN3UTNrV1NzVzBLbVB4UkNpYWdneklQamxQOEFqY1hrWExtL2lwU3dDYTlRSUU3Z2JpYm42Q2R2VUQ1Sm1xY1phSUVZUTFPMk9NUmxmTytNOUVKaVJ4dFM1VCtZTldRWnZKcWQvV2NZYWlTaEpRYkpVUzJjUWliaVE2aEdjdnJWUmhBS1pWUk9VRDV5Z2FoRWhPTU1wbnFWcVZOaERVOXdqS1NiU2VyaHMrT3laSEdxbW1VRXh3eXBSMUt4clR1R21ZaHkyMUhBTXRiSlRBVmpMdUdvOVF4c2lvUTM4UFVvZ24vcHNUNFNEOFpsMThHVTB1NFZ6K0EzOEJUSHVlb3Vvd2RreVlUVWNSampSR1dsUTl3Yll2cUhkUXd4Zk5oamxrR0s5czhuand3eXlNTStaZlpvaGh2VGNmcjNCK0JsM0ErVmNDb1pycktMTUtwY21aWmdBTmJtZjRKei93Q3FsUGsyUHFYbGp1YjdmY29HS2ZGUUoxTzQ5VHZHR2hoME15WWZEazhySnlnTWZKVXd6OXpMSXpZOVFnMHhiR1Bmd0FSNmg4RkVTYVNJblVNVzR6L3FjWmltR21VQkRmejZuSGlRNitHREhVQ1pRYUoweCtOUHdGUzVqOEkzOEdHb0dvekdmdVdKVWRFTWJJdjBLZ1hLcUlRVEhka3o4Zkh4bVo1TVcvVXNFYUZuNWZ6QllXRTIvd0JZbjJtN241V09kNnFZR0xnOHIrREdtSHRqRENWOWRURkNFdU5RWVBjTUpvZml0RE90UlZoYzZHSFU0ekVuRm1JaFg1bVdMZ2NYcVpZenhrQUJpa0VJTzVvWitiWUlFWDRWTkV4eHZ1V3piTUM1MUxGTndRdWN6anhNU0IwTEhTd0ZsVjhIVEZuS2lja3VMUkxlMlcxTXlIVUwzRzV0K0tZWXQwemk0c2JkVVNzcHczT05icVluZEV4eHZ1NG0wclg1WmtGRFpEK1BIUEVLeXMyenlKaG5xT1Rha003d0xaZXBlMFp6UWd1V3BnNlFHRFdwbHhWcjRCcm9KdSs1NDZiVHVaV0tSVlJuSysyV0JDb3NObTJKTG1wWk9XNXlhaXM5VEZadUhVTXRNdlJMdUI4Wk5nZWo0cUJER3hiblVFSnBnZHBBbGF1R3lvRjdoY0hJZEJIRys1eFp4b2dtdDl3eDNjNFdzY0tKUlRiRUI3aVJ3RHBsTi9DTjNBWUZRMFNpVkFHeGxFTlM3OUh4aWFmaWo4elFTNWdDc0syTVQ0czZtdHBCMnNPTDNxTzNVMlRrL2dodU1DTkdpQlF6b2dXL0h1ZTVVd0xlNWxnSi9jbU9KZGNvOGNkWGNXOWZCdUxxbzM4WFVJdnVMUWZ2dVhMZ000ekkzVXFqY1c0ZEpNY0RGWmx1VitTWFJSTW1qNHZqY3h4RW1YNGdKSFRxZFFYYUVIMnprTndtR04vQ3EvRG15dmhBMFFLaWJoYzFOSk1jRldlcHlyVVc0Q3hKZEZFcjZNUGhJUVpiQzM0UzRGRE9pNWN1RnJGT0FnWGM2eUFsOGhXTXc3aWcwU3d1R2F6Yk9IdTZqYTdZMFIzTWNHclo0dkp3L2xNdkhobXBWdjhBeGp5Z0JMT2dnY3p1cGxrcVdkZmlBZHNaVE5zNmwwUW1LN1lISjFPSWpFQWxETnNDcDJUOC9vaVpZbTRJdFROREhVeCtMOVEweGZ4QkUrT29sci82TFVEY01ja3lUb2c5c0l3dVY5aVpEMlFGSmpvK09pWTdkOUVVNlBrbjlwMUdCTUFlZkxzaXlvVjh0aENXWE8yWEJyYk1qVmpPUDF1SkVvdUhjWmkxa3cwVHhZamVNeXN5UjlmR05VMTNNSFRUdjhRSXpjQmR2d3IxTFdNUHdURlVSbGpOcy9qUjNMRFh4amx0dWUwK1FocVZMK0RlTE1EUVNweGdCT0Fzb0xJRnh4cWNsbmIyMlRsWmVURkttd3ViV0F1NXhnSVRpczRyQXFCdnVGY2x5M05mYXVveTRNR1l2NWxnckdvTVZjWmVpSzNOeFlSM0FicG5CeHE1UkxhaTlSWjYxSFVHRXFZSDVnTG5FdDJ6REFjWGNlZ2d1TTVTMDJRenl5UzJaQ3JOY0xZZE5Ua3ZjdkxoekRVRzJaS2RReGFjZ2dPVDFPVFNYVlRBdHBZMk9pY2k1M01tNFV6eE51WG9KazNpVkxtcFpDaVh1Wk85VEg5eFcvaEpWTWE0L0RmdjRIVVdZWTl3QnU1eGdNQUdYUlZmSGNBYzZZR05wNm5IOFFMTmtvQ0dybTJIVk11cGp2dlJGdCt2WHhzeS9VTW0vd0JUelptZm1QNDhLd3FtQjZOVEZpcGFUSVhJZ09TeEZnVEV0amo5NnVGVS9BU3BrQ1ZjQ3ZoK1FuRWZjcWpUREN1MkVxMnB3L1pLNHQzS080bUxsVnd4T012RUpSQ0lNcWpVWVMvbWxqcy9aUFVKY05TdFhPUHdSTmRXUXgxNkNPRk05eEp4ZTR0a3BtTkp1Y1YrREJXcHdSZmtsMlhjVm5RZkN6U0VZVk5NelRxVU00MGFsUzMzR3JJOXNJMUtDWWtiTkVDbVB3eTcrRS9FNlM1VndsRE9oSmdJTGN4MnhCM0tKNm9sTXFWS2ZqYS9BUTFBYmxGYlpnb3h5WExxWjdhZ053WVRCck11ZVgrL0k5enFOMU1Xb1Zhc0E0M0xxWTVlcGRhaE1pMmFuSnMzcUtZcS9tV3k0ZTVVQng2Ym1aa0hGUGdkRXRWK0xHZFA2bG5STDRHb0R3Y3ZqTDlRS21YVU82aDJ6eTQ1NFpwbkNobVplUk45VGxMcU9WL052d1phWW1oaWtLQ1ZlNEROOURwN25XaVh1RlpUSVl1eUgyaUM2Wjd1YUIrT2lGMThodVpDUWJnZkEwdCs0bTVUTVQ5enIxY0kzTVE1MHpWdFM2STdEOVI2czNNdld0UVY2TlJHRnV2akptSnl6cU9sSmo5VVprM21zeEZ2bDFBbUp1ZTJGKzQvcVhmd0Rkd05XUjhZRnJIS3VpWTJ3RWYxQW9sb2RyTHVFdXZnRWkzODdKeDVFU21WTVQ1cTR0ZFM1amR5MVdCYjhWSEdpWFpPUUVjaXFJWkF6TEluS0dTemw4TmhEZjhBNkZCOG51ZW9KR3JZYlkzMThCRkp5TlRtM2EzTnF2eDNBb3FCS2IzQU9VeHdXNklEWXN6enRDcCs1dkhjd2Joa1lyTVc3dUtVazViaGxjVGM3UGd4bHZHc1dBYmgzdVdZOVhCWFkxQWNtbU9JRU0zcVVjNDFjWVR4Tzh2OVMyV3d1Vk92ZzNPT1ZSR1dRMnlyV0xXTXh3dmF5dnRBMndBZHpWZjl6L2wzSytNQkNMVEcyNDdZUUp4NHdaYjhZb1h5bGxJWEIrS2JaaUo3bytHM3VEcUszRXRKUkUwN25QNlZDeUZ4d1NtZUo0NVhOTGxsVUQ4d3FINEp3MSs1cHlxSW5aTlZFK04weGRRZ1N0c0FZbVBKTGh4NmxZa1lBempLTTMvVTQ2V2NkYW5HdSsvaHY4UkdENnFWQW5LYVdVVFhLSW93eGVjeUZLaGRKT0dvZFEweTdkeG5HVnphTElqalpjT1V3RzZZNjlSWG9nUVFoc2dRdUpSRENpWkpjdThZTmtvWis0N0pVR2I3WjdZNVVWTDBRZHMwc0VtUGNRWDRvcnVFYmh0M0dPUGN4SjdnMC9IcjR1WVJobHBJbnFNQ2J4R0RHeUhVZTRTclg0cVkzTlFzZ2ZWV2UxZ3ovVVZaaGxQTDVqemVMSENnNEZXZTVxb0t5cTcrT2l2ZzFsTGw2WmRNNURsREV1SnRoQTNIYktsTnpMSy9hc0NqY0VXdUxLNytFU2lHTHY4QVV3YnpxUGJCdHFaRXhLbWpFZmR3dHh0akNMbG5sZVNySGpPTGh1WERHNFVyYzE4R0JHM1VKd0NDUm9oL1ZhZ29Rc3grTXFoVU5RZHZ3a09vN2xiSTMzOEJIVEdkRXVGa0RKSWR6S1hxWVBIdUtmaWNtcUNjbDFNdWlQVnc2V1V4L0VXbzVXQk4xcG5KY1FtQUtqQW1ZUzZRbms4bklBd2h2T1VJMmI5UUV4bDhWbUxERGphdHcwS3d5dG42TncxTG1HVk1WelpRRTZKZjAzcEpqbGpTUDRqcUNiSVRLVVZMWUhJcW9Zc3hKVUNINCtPK3B4WnNoTGdFR21GcXNMN3JVV1V4YUlzVVNlL2tsT1BxRVdIN21pY3BiOFlzWVM1L3doaW96aVVibGJuUGRmTlFDS1ZCMVVDVkNZa3FhdUdhV1IxMDNPVnNkbFhPVDFCcU1mVlF3V0dyK2JxZDlRNVBxR0pidW9sUVNEU3NjK1R1VzNIS0dWN2lxeFpjWjRudi9VdVdRWjNER1pUR1ltV2FuS09EaW91NGQwa2NkMk1KN1dHTE1TbUhiS3QyUVF3U3A2bXErTjluVTErTnpQd1o0QS9xR0trR21XdndCTFNIMk42WUVMTTNXcGU1ZXBSeE53d2MxQXNDNTVIeDVZWW1KdUxVUGN2NVFUdWFvbWlHWVJ5c1NVUlVLOVFSalhCbU9LUjBiMHh4ZVJIRGo3RzVyR2R6Z25jZStwMlFkTncrd3Q3bDB6VzRHTmJobmlXY1pWdDlSWVRZMzB6N0E4dHJER2gxQXlpWlRaTHVGN1dERmhDbjFCS3VvSmNhSWVRNE03TEh1Ym5WU2lsdUt4MFhPVmt1NFoxcUJzY2NpT0NaL2JkL2lldW40NVFxQ1hLSWVMTE8rQXNDY0xuSDhzUkJUcWNiT29ZYWdCRUxvbkQxS1NGMjZsQXpKWFZURnJIcTJmYlBObzBRaEVSNmdySEpxRXZjUzNUQVB6OGFab1lxMVJMcGwzR1k3MHdpcTlmQXdnVWx3M2NZckhMNEFUYkh1QjhId2tCalUzVlJicTVpQVQyenFnN2kvYUtKT09qSzQwL2FhcVVMcUV0bHcwVktBMHhheW1Wck9NNmh0WDRCN3FkNUJLeHZUcUxUS0ZsTnd5VEtvMnQvRzB1VUdGOHBqcHVPb3pkYmhHczIvd0J4NnFhaThaaFYydEVTOHFJYjdkRUNtQ2JtUEdteUFmRFJML1B4ZHluNUN5SzZnWGNVaWtKdFpjRGRUcGlmYVk5MnhkM0haeWk2bGFGaHVWcGl3eUplUVgwTUNtSjhzek5EZ0pQZHcyeGxIVnl2M3FkRnMrcmozQW1HUEpvamVPYVFlQ1B0ZzBreVJudU84cHduVXpZRnYybXNkSHh5b2hqYkRUcWNxZGtjbVlFb0lZMnhHK3pVdWpjRzUvWS8xQTl4Umg4WW51Y1ZLSTRBZHpEQ28wUlJOUk9JTTRCdUNiZ0tRak5TaWFnMXFjcXdxWk5oQmJmaElhakVsekdtNDVwVXQ3bjdpd2xTcDd2NEMyY2FZaEhFcWNxeG00Zm1HTnpSQnBtbVlCYmNRVlNCTkJCS2xrR3NJZkYvQitZSXhFR0JDdDNDQ3dvbi9OQ2NaUkRJbk5seHliaXB1WGZ3OUNRK1ZJOXdtR3hnWGR6R2p1Tk1GbUlWVndMWWpnOVR3N3lDZVo1ZVZZdE1HTCtZZGZxT1h3Vy9xWTk5eHhDQmpBTGFtMFNVaEFsNlJWb2hvS21CYXpMNjlmRkQxQ3FYM01XWEIxT3huSEV4N2dCQVJVYWgrQ1dkRU1UM01UeG5hc1hIc0lyS1pmMDZscmk2Z05kUjZoMHk3Z3k0TE41dFpNLzdZTExySzBtVGZVRGx0dWF0TFlFcG5HbTdoK0pqZzlCYk10MEdOSktZNkltcmhqWk54VnlHTHVFdEdQMmxmQkQ3TXFtbzZaZXFqU1JsVHFVcEthaGZ3Q2p1R1RWS0VNNWtDeEFhSFJNSEZ5ckpqNGdYaTNLeU1rSUE1ZmVPZGVvZmFVVER5T0dEVDNPU1IxTVJYbE9kVUJaMms1Q1hER3UyVW92cTlTaTdUY2RDemcwTXJpVVQwRmJKeHg3eUdaUDFLZ2NTL3dBeGhnbndMY2NaVlNyV0VNYW03L0U2bnFDazMzRFJOZFJRbFdXUXNnaEFHVlRVVzRORVA2eS9nU29HcmlrM1BjUUdZNGU3aHRZV0hjVWhGV0hVNkdJdnZjNk85KzROQ1FkVk53VmwxT2lZN2xTdFQxRWxzdThJTDdseGd6eGVUam5pME5ST1M1bERNTU1QS082emppRHArT3M1ZzdxSURDMWpWZkhiVUQ3SkMzdU9WdFJXSjdnU3I5eitwdGo5VmVQWkJ2RjFVVnFZeGQwZkdERjM4RTl6REV5ZHNmbTdtU1ZVRFVBakM0WGN1RlB3UjNQWEdab2hYdy9xRFVYYk1VdU8yRDZtZ25jdUt3VXhxN2dvYkppMnhmZ1JLbWNvRDR3c3ltUVJaMlRLa0RwK0dxR3BpbVBjZHEvRk9VTmFDT0tkL0JVYzYwRXhWN2hoOWVWL0dXVXYzQnhmZ29qK29maUdJRU1OUXdVMFF4ZU5WT0xFbkZxY1pRWTlUbDlmOVN4TnpERnlhSVhVcjUxK1l2d2RzTjZsUGNmL0FFdU8rb2FuL0tYYS9JL0FnTU1kZHh1NGZVbHFYS2E1MUxlVWQ2akYrb2t1T0dydVZSS282bFVUVlRvdjVCbnFxZ3k5ZkJSWXZ4MjExRU9OcjhVRzV4dk1DTEhNWnpCbkpuTFh3dTBqY1pvSU1KZ2xVekxIam5IYkExREZXUHhnZjlSMEo4VkI2R1pjYlVnbnFaT2VVOExsam55ZXNTTHZ1NDl4bU5kVGpwWlVOUU9Ya0M5VFBESERQaVpYTk9YY2RRM1k2blRNU3lidEpobmpwWVo0Mi91T21aZm01Z1l1R1RsbHM5UXpjUjEzREt0TTVMQVF0aVVTdGJOUXhFb0p4aGdRN2FKWEZuZmJERWIzRGV0RXJGMUtNVWpranFYcmJPUlZUWFVKa1UxVTBZMVZzNHI2bE1waGpFcDB3ZVNqOEdiWEdKVnZxV0JMWHFWK1pvWU5JNHM1VmtzNUx1Wm8rbzl3eHp5UHJNakl5cklnVkV0bkRpZHp0cWNlNllzTng5a3h4b3U0eDBmbUJUYkQ0N0ppS1IwRWYzcVk2MzJRL001VFNseG82bUdYRSt4Wkh1Ni90TXF2bE1CT21HUFBhMU1qamdnaS9tWTREMngzWjZKamlKQUp4VGJvZmpCeTFqeXFMV2VWSHFOUHFwZnQwUXlyUXh5UjNITVNYeUtqVlhETHV5Y2pHdG1VeU9XUzhlTUNzNlN6NFlBdFIvQXl2cktXSW5SSFdIVUdvN25TUXBZMWRUYm9ubzFBKzAxbDY2bjJKYXhMblNWTW1tL2dtdU1yVndsQXhTbVhGbmMxVVlBRE1kVGl0cEtvaFJMRHFmbTVxcG1lTCtDN3JNZXZ6UDZKVzROdmN4SVl0UHFKOXAzREdwbGJvaFZTcjBUSytva3FNTzZJU3U0WXdJMTNOUUpmM2dVVVRFT2RMVXFsaWxSTElIYzRyQVZiWTFjYUNXdW93ZU83aGx5N0kydmRrU2lyakhRV3ozRzNLVTVOWStwVVdPbzZJWWhNOFRGb3l2NFpuanhNWDh3STNmd2xRUDNBZmcrUXFEcG1ncWNhd2NvQkVtcXFjTnlrSWRYUHJ4M0RLaGdRRjBTLzFWUS9jUGs3K0FYYkhSTWZ6Y0RVcmk5ZHovcWFjOEc2SlM1cExyVVlFMFMzWVFHVmtvWHFQMWxReGdWT1Y2NmhuSEs4bFNZcDVRSDYwUk1jVnB1Q3Z3RTR3SnFGeTh1VWVSdWJadXFJV0VwWTRSY0tuK0VYNXFEc1lyYU03NlpzaE5PcG9obHFjb1V2Y1dtajRJeTVVTEorNEh1VktsUU56dU1JSHhnM2RFYzFLWXRwS2xUSEF5UXowU2tXb0E2WnE1enVONVNqSEdwNnI1eHIyeHIwL0xNYVcyUGV2aElOeGZxd3luS2JXSVhMcjQ1TXIzRitLdUJBTFlIVlJWYmpNUVdvaVpSaE1QdXY2SlV5SmJBdmN2ZlU1SjZsNVFYWXVtWTBZMFJ3cktvL1hxT0tzc3FweUoyUStyUGRzMXluS29UYVFhMTdaaUhKeFJHQVZ0M0FJd3ZkZW9Dd3FldVVPcklmMDNIS1dYK3B5L0VkUW1Oak83V2VpQWtUZFFJZTVjTWVVNTQ5VkJ4TTlrYVZTRmQzQk81eVdGeEdvWlJKcUcxWmZjQ2pkN2pRMUN5SXZjQWxZS2dvekZxeHFkc0M1Y00weStydVpadVRiM0Nzc1lPcGVwZE55d0w5c0ovcUJrd0VzWWJsN2p2NENaTk1NZ0ZJclZrdSs0Mkd2aWk3aVJ4dnhtVXJTTXZlTDJFZHF3L3JaQmFxTWZMek9QR3FtVjFWYWhDOWhIUFBNTUVqamtTbWRSYW1PS093aGdlUlZRU1pZZTFodU9DWTNWWE1pOEtJRGRNTjVQNm5MTE5tV3UySDk2R2RyY1FOazlYT0tqT0xDNHVrWmpCM0V0ampSZFhEQ3hlTTQ4WWpBYWwwSkZlTlFKVU1kRVRrL0ZRbDFEUXh1VkdtVUdtVlhVcEpqc1ZqUHFtNW9sUkJJVmpURjVyWlRQNDRZMGpWelBCNWNtWTRnZFJjSVpicUR1MGhrQTZuT281MzFESmcxdG1UYk1wNmd6eDByT0Z0M0FSWUNTa1JZK3lJTEcvbmd6aUpkeXpxdmk1YkZaVVM1ZngyMU1HbWtsR1BqVDNIb2hxWmJoamt0QkJRbU9LRGtNR0dLeDVSdkxUT1ZuR2RGd2pkcFBNbWZpOFFPOFNGa1c1MUx2NFdpQlpiQS84QVRIdS9VSzNNTWVlQ0xSTWQzK293THVkRTNXNTFFbzNEcjR4MWRSOFllRG11MzRxQTdubytiT3B3OXJNYVdwalhPV0t5Nm9tWm9nKzd0aGp6UXVwVDExKzV5VFJBTFlhalU1aVVsekh4M2JCTHFkWHJVd0xGV1pDNVRFTm54MDNNZTREREJZZU1qaUN6RUtnYWdOV0RBaVBIdVUxM0NLVG1lcHkzcWU5N25nOC84T1hJTjFxS3F2eGpYQnQzRFRGaGpaY1RjQ3BpSTdOVE5YTFJSTjFDQWZHNExYR2YwVTcxQVUzTmRUK3Z1V0o4Qkc0S1FZV3dzMU9ETWNBM0JJL3VXVkRLVnRYNEdzZml1U3d1MjRZd3FxcmN2WWVwaVVaTUtTVkF1YUNwK2lWSHVIVDhLWFVvMUJwU1hPVmt4dW40cWlybjEvRVFxVlV4RDNFM3BnMDBSL3RFWUZzTWJMZHdEWWtLbUZpNjlSM2xvb25lVlhPQ1BjUFpLM1FUdlZSb2pYZmN1aVlvMnNZdVg5cnRtR3hXSnVWWkd1TXhjVkRMcUxpNVB4MmJtT1ZGUk12RDViOWt6OHo1WGs2eW5PODdaa3Q5eW9mV2Nmd3ovaCs1YUhFaGxXcGFrcG1EeHZrV1JVMm1tSFVxNENRc0ZTQmZyWHdZMjI1UXd5TTJwaUtOeEZ5aGczM01zS2dWbk5DMFN5YTYrQUpaRUswUkFDaUV3Q29oSFBQUEV4VVFnVGJWdzNjcEVBbVEyS3dvdU5RQVAzY3g4WmtwTjR2N1BqajhCSzB5ek5BTnpMeC9zaFVDcHdWMDFjOEplZkhJeHJMUXJNL0c0WnVOMmpVUmgzSHJYY2Z1VmU0QmdJTXUxcGd3MXVIN2lOYVl1cUlaUEhqZW9iWWZUcWN0TTZ4K01TWkFkWlRISk5KWk1qRXhzZHppa01iWmsvaGhMMURLY3R4SlZTZ25KNC9tT1dWbGFobTRyVExjcnRoblJMVjJ3ZDNjckdsSXRCTm4rb3NWSFVGdmJVNUdMdmM1WFZFY3FhcURlYzdNcDJWQVRxY21yeTNMMUJqbldpR0hTczFVQ0tCYkRHK3B4dGlJOWFnQzdQakhITFBISmhnaEszRWFZWXh4V1ZSVEthcWNkVGxPNFllcm1PUDdpRnQ3WTlhSVU5dE1RcmJiQXM3Z1gwOVRUS2YrTUQ4c2F1TzRGM1BWTVFDR0o4WkUvcjFMOXM4VGlyeVkxU3U1YmxFY2M5eE5zYUNDWDFPU2FHYnVLOVJLbG9hZ3RUcHQ2bU8zS1pkdzNnczBkbHg2NjNCY1VRcGpudlp2OHhiM0V1dmdCSU9WMk11bCtST25LR0hMcnVJNDhoalRpY2NPdTVVU0RaY0NNQ054MzFLREhmY055bEt1Qng3blhUQzM0eFhlUEtoOVRkNjJSSUdwbUJXL2hibVM4UWdSMU5RaE45WHFDRWJXL2owU3BWQXpMKzAvNHk2S0pqa2paTXM4TCt1TURGTnRNeXhPRjg1OVRJTVluRTNPOHE5UTcrc3dNRERMTDNGdFdEYkRYUkxoN21rU0dTQ0VHRzdoS1dZNFVYRERVR3BqVnM1RUp5WnphbkppeTJjV00wd3AxQnBxWDNNdlc1ZW5jcUZ3U0RLYnY0YnJ1T2llb2IrTCtMSTl6M0VKWHhWZkpLZ1ZMTHVPZHJCWXU0UXI0YlQ0cW1ZOUxGcnFIVEFzM01QcGJLNU53ZlV1RTFjWjF1Tk0xRHBsd0xGakF2S0FmQmdzQ2x1VVFDbHVGNVNtcFVFbUR2dUxlZmNSTXFuVFVOUmJiZ1ljVzVobS9ZL1V3eTlKREtXaXpGN1dacTBqTGN1bWR3L0VGbVdpQmVvdGFJVmpoT1VXeUdpWCtUVWYwUWIxQjdJdjFwRVp6NWQ3WWZ1Sk80RXA5eW1HMnBqaVQ2MUFwYWdyR3daeStpSjhFcjhRdUNtVWJuMUp5YStzZFN5NDVTeWVsaFVTVmNQdjlZSEhVcUNSU05RaFRIZ1k5UVFORUhTZFRpMlFNdUxuK0lwdUdXTWNPR1k5aktOdFFiMk5RcU1ER3U1NzE4Y1ZvZ2RoTkhwaEMyWlpyZ0FURGc1T09lZEZhMUFXMjdqbEJDRHRaUXF3eEJXR0JkeE95SWtxL2d3YVdOd3VvQy9HU1VTNWJMR2FmY0ZTY3hvbVdDOU1xVWg4VkVjblVMMzhBcktka0MzYk9HOU1SSjAvQUFUZTZqMFJ5MUIzS0cyNDFVc0NjZDdhSmhtK1BMUVArNStaaXBDWFFoQzJVeW1jV29hbTZZWk80b2tNbXFsSTl6MTNNamlGZkdXVGhnWW51S2hURmhzWW4xbUxNaytOU2lVUU53b3lZcHF1NXVHbFdjN2RFeWJsaEY1T3BqUU56WTJNeXk1TXVvTmZHeDNFaHhJUEtHRmlSd2FwbkRBeHRuSVVDWlowVkJyTDh4cTJVUkc5VGlET21CamsvWnFlUXh4ODJaaTJSMU1kekp2VU5NWmsxWVFCQzRZaThsajlrTVpuNDh2RzhNdmNjZUpVNklEZkU5ekxETEZSWVdmSFdtY2NSMDNEYi9XQzROa3RWdmJjRnhzL0pCci9BS2kzdWQ3SitaMnhOVkFxR21kL0dLemJORU1tWFo4V3dhN25jeXh0aFVTVTFIcVZYZnhqRW1KOEJxNS93djRJczd5bVF1TW9KanFjaTJpZHgzeElDSk04cnkzS2ZpNkdwamJFSmVSMHkydHkvd0JUSmxhaFFOd3hzL1V3OGJ1SGlUR1k0b1FvalVPTWM2eWwzTE1mOXprNVRsREtpWlpYTDFGMURLS3JMK0J1Y2lETCtLcVhVdVlpa0xseXBkUkxuRUNVc3BZSHdNNmxRSTBZd2NjVzY3am5Ub2c1SkFtU3Z4cUV4MndqWkt1Y1p4VWxSZ3pKYW1MQ0M3cjRHZHZ4ZndFcmN5QWcweGZqRzJEbGw5YjFPaDNOT0kxRmpZYStNU1ZDT2l2ZzBQN2huTVVjOXpQSnlhOVEwUWlnekEyL2htZW1vekZxRFU1YmdreW1MamdmWVdOenYvcUZaNFpRL3JPaWJZRTRReHJjejhqbW42bXZpeElKYkNjbUsxY3BZQk9KMnNhUGpvaG1ZK281VzNVWGQzTU1xVmd6alRjVjdMbXpwWU5UbkxWamxEMnN1L1dweVRxWTVPSk1ieUc0QzdtNyswc3Y0ZmltUElpamorNWdMY0ZKaXU5MUYyVXdhNlc0clV3dUNPTUsyM0ttS2pGdmN4aW1KRHFZNUxHemJqREwyaEJUcUM0eTV5NytHaEkzZFM4dWhtYWxrZkpvaG4rN2k4dDFNV1hVdWR4Z2dRUUNVTTQwU3FpUTdqUkJqbFVNOWZhYWNXcHBQaFlRRC8wUDdNdURLbEFkeGZqdG1Wa1RSdWJGbUMwL0dPKzVraWxROXNHQ0YyV3d5QzVmSVc1eXVpdmdic2xwTFRHSzhKZnh5anNobGFReVJWbDJhK09VNUhzbUNOeTBaemdqT1ZzTWgxRi9Id0VBcVYzVXJYN215T29kejFBeHFkbmN2ZlU3V0U0emlHNDRnYWJ1Y3FhbVdVTWxPTExLY1p5UXFCcGc4RVhjeVp2dWFKN3NKZHZ6bGpaTWVPSjlpQU4vaWVoamw4VXVvWlltc29QSExsaEhMTExLOG1kc3lpaGpRYmxCZzhuYkZIUXk2Qk1mOXpKNTVsRUV3VVNZcmpmSEx1YldsZ2xNR1g4T1U1S1F1cHArUDhQL0FCRC9BQ2p5WXVWWjE5RDh4d2ZIbnd5MGpTVEZQc1ZNYlh1Rm51UFVjOGJLTndnL2VvNC9VWVAyT1JCK3l6bmVvd2g1SEZhNmYvUTd1RGEzR2pGQ1gwVFpCK0F1SU9OWFBHZ29rWDQ2SmoyeW1aZjF4U0ZvU20zNXhPN2wwQkVScGdNQXZ1WkF0WXNxQUpEQUtKamh2Y0x4Q29xc1VENHNpNGtjL3dBVGRUQTlzWXNjZ2d6Y2RIeGRRcCtYQjRjdFFaVURjcFp4V2NhSlVRK0svY3M2U0ZyWHhpd3VJL0JqR3JpL0EzTVU0VXdZdUt3eSsyb3FzZmdHWTF5V1lpck05dW9ZejY5UnlTRnNZTVZnS1RvcURVMjJ3bUVkc1NpZm1DTXVMTnNJRTFDNVZkekVLYlo5Wmk3UjZZbTRjYTNNcTlRWGpGYmdPeUxTVGFxVHRwbldqVThiand5Y3J1RlVjbWFnSGo4VnJ0aGF5OTFNaVZaT0tUZU1YT3AyYmhUVXdUNy9BTDZnbWc3OXd4dTZRQ0J1TFNrdUI3WFUwaFVPbjVRTElBRTRwSFVHRnM2M1VPTHBJNFBLaUltb0NkeE1vWXAzUFRxQm9BWVlMZGFxRVhJT004ZE9XU3N4THpZNGxzK3ByM0E3MThLdXFLaHBtMkpSTU0rSGN6d3BYRVc0OVVtNVQ2bTdwbVE0OS9HNEdyOXdHQldLczJ0MXFkTFdNcWxTN25QSTA5TUFIY3MzTEtxdmpEajdabHFZMnhnS1Fqa3JUUDBNN2pRVk5iK0RRM0djMWxmbGxScmN3NGg5b0xCdUw4ZEVOakg0N2hzYWczM0NFMHlxbFN3SmlvM0NOcXl0MHpVYVBrMFM2M0hiY2FHYm5LL1VyNDZabGpjUVNOa0haSHViaGp0amN4bE01SFBacUozWHVZMlZLcHRqcUYrNWJOOFp1YmxRbWlWWkJwcjFLR0lzRkpWYmkvTjNvaEI5SGNzbkw0eGhtREhhck5yRkRYdVcxREZZWTloVTRZaHQzRk5jWWlMWGN0U1pNeGVXTEtnR1VLT3U1aGk1cUZDUnZsVERDeFlXTVNWVU1SWm9hdWFHTys0Nk5KdjR1NHUvMUt1OXh2MUNCYlZ6STlSd280ak1jWU9rZ1VLeTUwVENoV3BlU01CUGNZa0M3Z1J0MThPaVlrVzJPTllYQWhpc1BJK0xQSFBCKzVQSms1WnE3Y20xbU9PSmcyL2FLZXBTNVFWWmRzTG1PbVdsVnVaWnJWa1c2ajNENEVNVWhzakNOY2YzTEh4MTdoakFKdmxQYzBUOWtiN2xSMWpEV055M0tZbE1MYm5XSVEzbVR6QVphbUhiS2VUTnBBM1RMdkpaVnpxWTNhekhHR01NVEdDZHp2NGNpTVltdW81SEFLbk9INWl6MUhMMUNaVHZHR01ZWkZmSHVhdjRDMzQxS1BUOGRSWldXSnV0elRnL2tpdEZ4cXhJZFN2eFBVNUJPVXZjR283SWZKR0JCSlJNYWwzbDhHZkZuTEpndlRQMUtDV3Z4b3hnMnhKZ1B5UDFuVXhkeXJsUktnV1JuR2lMTjNINDdJNlpsTDB5L3JMV01Dc0YvY1A3Sjg5ZkRNZjZTcjdtQmpYSnhpcmNxdHdaZTdsd3NnT1RLYXFGSGMwZkZWRklEVno4ekUzL0FPbCtveHh4SnI0RTlibnZxWUp0M0Jxd2l6SE5tWGozeXVaZFIxak1UTFV0MlJ2MHpERExPeTQ4aWc5VGtYdUdJcW54UXo5a3pQQ2Y0bUdlUG0vKzEvdGh4NmplSDlpVU1zSlZkVGpYY3UyZVB5dmpPTEZsaHVjaUNVckZHWEhOeEladmN2Nk01czVMN25MVVYrTFlQeHdhWFh6VGNYalFSMHcvNVE2K0wrRUhxQXhhbHQzTFhLNDU4bnFKTVpmeS9CTGw2YWhpMUFjWjNDTU9vQ0VPb2pBaGx3bkp1ejNISWdjc1lZbDdsWXpRNml4VGh4cVl5c1FoK3B1YnEvamxjWDNPY1dET1VNaGh4djNQSnhNampINkV4NllqTkVhWlc0a1NjWngrS1NGeWtuYzYrTDNMK09VR1VaRnpMNnpES2xaZ2x5dHN4MDI5UUxaVU1vUjNBcHV5YVdjZ2g1VUtqa3JDZjhZUFN4eXJHR1U2Smo1T0E0MTNQMThDU2htUDFmMUZsUXh0M004ZUxzaUp1QXN5dFFJajA0Nm5FbWo0YUo2aDlvMWk3bGNJYXRKYk1TMjJMeW5UTHVYVTVhZ1dSS2x3MHpKdjRXY3RmRGpNVExxVTJzMnN6eElBektFR1hBK1NkZDdaM0MyMllsa092Z2YzR0hYdzFDa245cHNYR0dNb3VEcGl0eG9QajNDRnRzTzlSS0lOTXpWYmZpN2dzUDdYUGJBdTRHb1l3TlRBM3VORWNwaXpkZkNzWFpNc24xQlozQTFURTM4SnE1Wk9XdXR3NVErS3VjV1ZEVEIweXFZMUJJazI2dUEyeWxKNnBoakcrb0FGUjFDMkpLbWdsbVh3ZkZmQkdIVXhMVzQ2bGtUOFN2ZzJiK09WNklOdFFoM0dId2R2eFZGRUQ2L0orWld0d3FXckxQakFnZXJuVDhXa1Z5blkvQWpBS2VpWFVUbC9qbis1amc5eXJaWlN6TFhGcDNPNVdQU3cwSWRUQzhzd0o1dksvd0JRQUlxaEExVW9DZHRlaUMvTnZVdEIxR1lyRmxTOVZVcXhyMUFVS2wvSGVVVm1HSUZxeXFDVlVOTWNyNkFseGJ4Q0RUZHMxQ09TRTU4aWRrRExUTnF5dU8zM0MzS3JRakxIWWJnb3NhQzVlckppSFRLTmcrN2o5bGNtNEl3eUxsaU01TlNtcWxxeDFqdGkvV1VHb3psQlo2M0Rlby9YQTVUS2tnY1libjVXRnNvcTVZbTV4OXNzZ1d5ajRTazNNOGNERXpNaGZ4SzJ2NWpST1U2SUNpd3hZNHU3WU1xeWNRWlpmVThYZ2ZNdElBWEUrTVlCYkRVZHN4TzR1SjFFdVUxTHFvRksvSnJHREZvaVZEWGJyNEpRczZXcnVEaUZJMnpnQlZ6TFV4SmVvVk9STW1GajMzTHF5TGVpSDRnQ3h4QWlmQlRNUjVRYVpaY3ViZ1QzSDRONmZuTEFNZS9VczlFRllzNVhCTGk5ekhaTjM4VXlpaVcweHVpcG1wRnVZZGlSVEltLzYrb2JtT0RsaXJBQ2N3SVpaZW1NdFdHNTJSK0tqMVRPeVpKV2lXNVRSMmY2bU5JcjNXcFJpS3U0ZFc5c3Rxb2Jkd0RMVWZycWJOa2MzTnBuVFRiQTJrTVprcVZjRFc1d1paYVRsWlNHcGNEVS9iQTVZMnl0MThIY2FwSS8wbFRqTStBRHU1aU8wbHdVV2dsSnR4ZHpaR3JnZ05rYWpzbnFDaTFMU0RxRlJQWk5yUFVDZWY4QXhNdjhmdytITnp4ZjVzYkE5UTczQzduNlkvNUkvd0NPZUwrUERYdjNLK0JvVDh3UU81L3d1ejQ0bFFQcDhZNDdnQ3g2Nm1DWE1QSmZLemN5cmpaMzhPTkVENjJzVVRWeWtVQlNKOWJtTVQ4TUFSWTRuREZXWDk1a1ZNNVZFdVlpazF4aHFGT3B4eHFkZFMyQ01jZFFoYkh3NXV5WmVMSWlud2Z1Vmo2WWZCTnVwUVFVNkkyN1lmRGNIVUFPbzR3SWt4cEpSY29XSURBWlRPNXlEcUtzTG1vTmZQY29OSHdFTVlFNFRwbktET1VMTzRweWhyNTRyS2w2cG5SY1dQeHY0NkNjaGxpUzM1QnllTWJwUHhOeEsrQ0R1VVRpOXl2Z2FobEdybWo0eHh0bUFQaHpMNklhTzVnMWNMYkpuNUZBaXN4enhNeHl3dWQ0TlFUeFkvdW9Ea3QrNDRPTFViR1hiVU5ZWE1mR1pOWERCTWtJcU05ekxIcmZjQ0JFZ2JqaWpkekJCZjNNTTN4ZVV5UFc0NTVlWExKeVRiREV4MDFESDZPVVUrTDIvcVhaOGFoWEs0azE4RlM0VkNjKzZuSkdjbERrVGxEYlViRlBndGhzcWJxNVVTQXNDSmZYeFROMkl4M01QeExOc043bXZpNXhaNWs0WUQrSVBxWEF4bkdjTHlxWkhIcGpWWEIxTk1OVFlYTUJkeDVQVFV2S0VaUkNjY2d2MUIrMGUxbmNJcFVxOGZyTGZTak9vMUJnVXl0c05NNnlZVnRmZ1dvZlpJNVUxRjlmQkJ1SlpjUnlZaWtDQXk2Z3RyTDV0czBTMWRrNERzanBwbXZVcmN6aGo5dmdFaGp1VThvcXNibE1NYUlDNDNENDR6N0VwZHh4ckc1NlBsYmptWmFyMTNQclRGSmNLbEVjWUdyWlYzWFI4VXdsN2xoTk1SU2U0RXdLM0ZMbU9ybU9ic21WTU1ZY1k1am9mZytPUHdSK0RKbU9ZRkJTeTd2bEMyTVZ5Z3gwWERxNXRkd0xZWWxMTWNISjIxUDQ4RFkzTXYxSEcrcHdYYzRtYkhBRnB1SlJLb2pjZTZsZXJtcm9aMDdsQVhLV1hBK05KQkFoM3VaTjNNczg4c0RDL2pqOWVVeHo0ZmFyWDFFRGY1bFZDRVdvN2RUcUZQYk1NSExycVpnZE9vbEUyMFpaTHJSK0lWQ0dTc0Vtclk1VFV3eHh1T3MvVy9VYXhhZzB6SldheGx3YWVyaHRwYWlVem1ZcFBWeXlMS3FZNlpqbWxtTE96YnY0SlppUmRYRGJNM29peFVMbURCNHdMbFN2ajFPaUtFdGhNYytQcUhsejNUSE56N1l5dmdRbDFLVGNJV3RFYnFxaG9pNitGQ2NwdVk0L0hLRzRGUkpWSkZHL2dpWEFvK2FZaVl3WGp2NEpYeGVxbHkvaXlVVEdVWlJsZkJBOXkwbHkvaTduY3Y0QXR0c2dHVHFad2dsUlQ0NitPVXVvRzEvOUtZRUpxVVZNK2lDM01WQlB6S1ZnOEZsdE9vNEdPRjVPNGIzSFVEVUJwbml3SHhXa3plV2Y2SWJiamEzTzRpRWNyREdFUDNNM0RKeG11U2hxSGRzTWo4UVRmeXc3bGFuR0dvYk80WWpaRnBxQ0JPVVZHTEFhZ2x4K05MS0VTWWlIWkxibHN3dGR4eXVBTFRHaENPNHpFTW82c25xTzlRbHpqcTdsL0F3dW1kaExoTEo3dWMvVU81YzhsNmhkMlJ0aGp5YmxIcUJEdnEyZDJwUFVERWpEUkwzVjBURmJaeWwyckJ0WmNiWi9QbStNOFJVMFpUS3QwL0pYQk9Fd3htaGw3bC9BaDNGQnNtTDlvdjJoWEZucUhVdzFPTnF4UGhneTZoTDB3TGkzcUpPSVFLZ000ckc4Wi92YkRFeGVVY1lZQzdZNFlDdktCZ1lYeTJTOEhMSGswVHlPSE40OVJTb1pGVG5EUC9VY3VSNm5KNmlWdG5HbVZCY25meXNNYm5VUGpGMHlpLzhBMDVMcWJvSmJINEFoVzVxSlh4eDR4WnV2L1FaWGRzcGhpY2YzT09vUy9naTBWQnFkZkR0cCtSL1U0d0srTWNGamp2VU1RSmxFeHJidVBMMVBUQmNDNWYxNVF3Y3NqZEV6eE1WbXUvek90VGxCTGkwZkdMeWR5cm5Lc1UrU3A2UWdWOEVMakIxWHcyUWFsMHN0dWQ1YmlBU2xuRmh6T21VM3VWS3VKdW9hbFBxVzlWOEtRQm1UT21DWGM3VmkweDJ5b2ZYY2NyYmhsR2x0Nko3Qk4rcGxobGYyMUNxaWEvVXlGNmdGZ3pIRzFqWXN4bmtmc3pMZUZRTEl6bExsaDhiSWZGeFJJbEV1V2g4YmgwM0FudlVWSVJMSVJKUVN0YTFEdnU0VDFER1VRRDQ2bHZ3Q1Jxby9GZk4raWIrTGczR3o1NmwwUzRNUGhnUzVkekhUTnR4RUplb05SZmcrTGxud2tSaDlFWm5rT1gwamQxN1k2N2c0dnpWeW1mcVVidlRLbXZneFl5b1lzQ2R3WGpWUzliS1luNFpnTGJjQTRxeXlxSTBkTnkzSmxYT014RnpBTFo1THg4QmhqRzA3bEZKY3h3dWdqUW9hWXZVeTF1YmwzMUxaYzNML0FIRkxOeHlBM09VR1hMcGlyQTE4WVBCMnp0ZmpqcVhLeDR3Wm9KWmxnNm1Jd3dyRmFtSjl1bzhYb2dZMU1mRlpNdkdrMEU3SlZpSk5ERDNjRGNRcVZ1TE5FWDQxS0Q0cEpqWERLVTNERFc1VVdzWlNNU0RQTDZDWExaZXVvUzJZWnVDcGlMVXI2V1ovWjlmRmJ1TXBTaUJaZm85emxCKzI0WlUvQTMxTlE3WWJxMlo1WThBRDRXWCs1YlVldFB3RUdJVHMwVk9tRlJJMU1TVWpxV3k0TXVDUW0vZ0tKMjNCUlk1czU1cE4xTHpDWWk3V1k5cXNDcmJqbE1RWHY0cWFGNlNIWGRFN2U0aEFLaEFDWTB2VWZ0TDFUTmtya1ZBWTJ3S056Y3VYQ2FwZ1VRSzNIOVJOWENhbW5DVktQajB6aHh3dEsrTG0yRFpEUktTVitmbHFXMytpWTFNcnFVVHArTGxxeDNMWXQ0L3ViZ05TcHh5bkdqdVVFTm5VSmoxY3JQMXFaRis3bEg0aGFJUWk2aThjYm5QVU1PV0tyVU1MVllkc2RTcTNCdGx3Mnk0alV4ajNOZmllbjQ0clB0ZEJIQmhqNmNxbjhXSS8zSWdkNWt4TUUycXh5d3F2dExLMFAvY002UDZrZktwb0k1cjBDUzRaTnpGT0dWdS9ST1d0L0RwK3U0czdsdnhYSWpxRERidG1jeDFVZlo4VTNmeXVxaE5FOGVZRFpiNm5OeXU5dndqWDZqdlJNZUtBdlVkdW1WM2JCQjdnTkxlcFhMQVoweFlFU0E5aGM0ajRsV3NvTlZPVzR2eGNYVTdZNHlrblpNOVRscG1MdUx1NFJoOEhXL2pqcWNZUXk0NVJUSllRRitOWGNNcWZpdDdpbDBRVTcvOEFRRDFHNXVGekV5aXczTENYNlpZeGdrcTVkUzdJUlNFV0RIWkszRkp1WEJtMWhxT1I4VTFjMmtKZFJhUmc3VmhVU29Rc0lMY3RGb2xYdjRLbFMwZ2tyS09URFV1VXhJWXdveG16VXA5VG9nUVNYU241Z2NNTC93Q1V2LzZsWjJNeHhoOUdlWi94bnhEaC9mM0RKeUtzbC9sbkwwUXk5ZkF3YVl3bVcyWW9hWjcxS2xVUUJxT21HTWU0WEtXVk9NNHhOVERWM3VNUHpjNVZvOXdhWWhlb2dNRng2Wmo1cTdJZVBEeWVPeGdWRm14NXQxT1N0MGJna1kva25HeUFMM0FsRUVXUGNhY29yTGFnemxaT1p4aHVXM053N25sVXpsMzhiUGpxRnZ5QzZseE5YTXFQRGppUGNBNklsUzR1bzEveGxqQWxmSUVlNC84QXNYQXlZREM3aW00ZFRWa1RFSDRkSHdQcVB6dUJOVC91SCs0bEVJU28zVXBnVzBUR3kvaXJpblh3RmtwSnhnUXJILzB0SmJVdVZVRVp4amQxQ3pURDlSajFESDl5bTRGL0Iwa3ArT056RTJqMFRQTlg5RXZVVXFDZEVyVi9DckZlbjFESWxmR0tpekphQWwrb1lYTXNTTTlmQjNIVUprMkZFRU1lcHkxMzhZdW9IS0dGSHdEVlJpMFJVSU9yK0Rxb25wbEZzRGxqUlBJR09QN081YVBMMU12akgvY2Urcm5CcTZqNDh1RnNCVGJxY2ZIWDkyY2NQeXN4ejhlT0tKYk1VM3FPZXFKL0prZTV5V2NtVTNjWDRGdS9pL1V0SVV6bDZQaXBVWUYvQmR5NTAvRi9HTmJtTE5NUUNpZjFLZTQ5eFloK1pjdTRES3RocUZQY1VodGJoeXRTSFh6VzRtdGUyTFdBRUpWTUNjYVRjdHhkUnJML0FHL0Z4WVB4WUVmeVMyS3N1aWlVdndFclZmRlFHNVVDNVV4TDM4MTdnUStDV1M5VkR1WGM5MlJWM0IrVm8rRjNCcUdUSDRTNWRTNGJKaVd4YWdYSCszeVM0RTJsUloyeDM4RUlzc3FEWlV1aW9ONitQME15TE5mQlRNeHFZMTJ0SkRKamszVXhlSWx3U3B0Z0o4Q2JZMTZaYktXVUh4VFU0S1NsMHo2eE53SlZqcUJUR2pVOFdONVhsNm1lWmtzSDZNL2tDYzJLNVJ0Z0I4QVBVSWt4SWxmdjU2YmhWM1h4VUpSTHc0R0lidnVYQ1hOeFZnOWx6Rm43dUhlcGk4aHNoTmQxSFpCU0RyYkdWUlBIazRzMW0ybHpqankzakZTOGZVOVZLaFpBYVNXd29IVXh5cWNydURLWWozUHNiWmplUkVvZ2U3alVLRzRNV0JTUmJ5ZmltTzRVUkpzblJFaGx4Zy9ydWJXSldWZHpvZmxOUkRFSzNjVFZrWDRDNGlRUC9TdHcwd080RXFWUlVMTGduVUFXTUNwNllZek1CcTRFTWFqWXp0bVc0REtnVEhka3hXdW8zTVJ0aUpLWmVvUjF1R2lFV3BVQWwwUUZsTUJMZ3hoVlFtdmNVV0pib24rNGg2amZHNGdibTMvVXhIODFGQ2F5SmtFcGlWajNCWmJMZmdXbzVmcWV1cHFCcGdRSFlRdWxuTnMxQnQzN2xFeVlGd2FXZnVHSVd5M1RQMWZjeXc5WE5ZOXlyblh3RDhMWlU0Q2x0UXl4MlFOekU5OUU5ZnY0Rk1WUWxjY3UrNVdLYloydTlFdkgyekxEVjR0a3hHTjNhUjhYME1qdG5neG9mOVhQSlN1NDRZVnRZMFpWVXN0MUR1Y25xT1ZsTTVOVmFrb0NOejE4WTVka1NtYitLbDYrT2lYNi9NcWU0eTRWY2ZkUWZhL0RvdGhkWEdnK0ZFaFJOWGNxMWxQYVN3aFJqWXdQenFhdENieUp2cElhYWhpTnZ3Z1loRGxNY0x3eWIyVHhlSFB6NXVHRXB3Y3NFcEphRnh5bXdsNmw3cWJKNmkxVXpUaUozTVZENEg0SFV1MmY3aDhPWDRJZmwrQ0xNUmhqOE5YRHQrT01xNWNvK05tNEtkVGpHWER1YVBoZmdZNi85RDR4U1pVa1ZJeTVmeHYvQU5EUkJxY29OTXZsa3dKVXA0d1BtcGZ4WHppRkxLYloxdjR3TzRDcXdES2RZdzF0bUpGZTRCU3N1NWZ3Qk1Ockx0WlpjeGNaUmZ5N2xCMThFZHpRVGxxV3dHYmdPVXp5NDRtSVQzQitqRGpHb2ZJTWNkWERHYWpYcVhHVzFHQkEvZnczQldWS0oxdVhES0xQSGhod3l5WlJWeGhvdVl3TEdHajQ1RWNyT29iWWZkb21XT1hqeWhrakZzbVhjWmZ5L0ZIRzJGQjhXeThtZEZNeHllRGlFVDVNanF2anVHMnB2SEtaZDJ6VXlLSVpSZ1MrTUg0dys2ajBURGlaL29pL2U1YkxZd0krL3dCVHg0dWVWRVRiZlo4WW02aWVwaThidmNXL2lpQlpiT0RxQTdpVVErQWw0aFozUFc1cnFXZGZCUjNNNkdCN1BuaVJhS2xReDFjcHVVall6TGxZU29ZcEVabFlRSDJRc2wzS2d2S0svajRTQnFWcVlqQnNibnFIWHlpd3hqOVN5ZlppYXVYNkk0Q1QzRUs3bERLQ0JiOFh1RW9paVY4QWNkOS9JZTJYVUtnaVhBbEU0N2lSeGdUaUJIRU1JNktob3BpUVRhditpZUR5dmgveVR6Y01NOGc2U1hlU3g3MUQ5dzQwMUFoaFU0R1RNand1SEhFK3g3aGlZSnU0ZVBJOFBOYlB4SEFNTVVUbEJPVjJ6ZzFVY0JKbjQ4YTFsQXdCRmJnNEFVUThwVmNJNTVaZjF4QUlLdHVVeXpjMnVlaWVMRjhuaXlUS3VKRmNyWHVaUDduWisvanI1RDF5MUxWNzBmQkVoMThHdm1oSXVxSXFSeUd0YmpBbGZQVUJWak1VYkhxRmxoMUJ2WHlmTzNwbGlRbzZqYkxxREd4bHl1NXh4UEVQdVBRekd2ekt5RDlNNXVHVm1TUUZiV0pDTTlFOXk3bUlXdnhVeHFaYllFWC9BTkFRaDhaS2tQNnp4bW1WTGx3cG1wWHhjSlVZRDhHcDJ4aCs0Um5VeXlFT0pYd1l5cHY0MEV2VUx5aWNXb0pGWC9xWGMxS2c0aTJTN0pVOWtNajdDUmZpbzlRRDR1SzFPaWJZYmpFSVZHS09EcmNPa2hRUVhjYnJjUDFMcURYVVpmMWdQY1dEOEwrQ0FzNmV2Z1VOUU5Rd3hTZFFiN21PUDdtNjdnU3E5eWlyV0llcGlmYU84blU0MXhWN05rT21Gck9PNEhFY2duSlc0VC9neHhaeGdUM0FuMi9NQjk3Si9KWnhDcWxQdUh3L29neEpVcjRxVk53cW8zVUlBZHhwZFRMcWlkZ0U0ejFYeGpxWmVvREVjZFhLdjRxT1hJRjJ4Y1hvbVNtT0hGcUtPVEV4NFh5M1ArL2cyU3FodGp2R3B4eUExTndhMUJTT3lhRDR1V01yNEFtTkx1WjQ3aVFvN2xDUXFGWEdtWE5CTzVpVm9pQVA3bFJqQVNiWUg1WmprNEs0Tk1mdHYyOXM0NU12Y1laVGJBQWJJWS9XL2dhTnNZRnl2VTRaQmRRWGxxWTQ5ckszdGlFTVJXQVJMTnd3VnZ1VVQ5UXhUT2FUUkRIYk1ieW1uSC9VSy9jeDQyaktZWTcyUi9xNm1LNnVieWpraE1VZ1c5VEhlVk5FYXdVTnpsbDJ3bzI3aTRwMUFFWXB3Q3FZRkVDMm9GWERCdnNTY1g4YW5FaVVRWnlIVU9xV2NLMUttWWhBTW02bkVCaGorcWpnUkFpU21CWHRpWkExY3hEM0hUWXN5Yk8zNFJuOXB4UWxvZFRCeHNjc1puajhicTBobERGUnFmYkUzR2JpUGFUYXJFVWhnVkFvUkxuRXQxSEhwNm1PR1RxWStMTGtDVFdDbVJjeEF4ZVdXRGZVdzRCOWxYOHl6QlRzWmprS0JoYlBHNFBNYk9CZisyT2VWOXhhTzV5amFUSVoxQjFNTVh5WkxsbEE0aitZcnhxWTQzcUtCeEZBaGxNMm1lMWc0OEgzbGNXNFM2WUZGTVF4QXUvZ0ZkRXRCR1ljRWVTa09QdFlVdTJPbXIxT1Yzak5oOEZ3eTd2NFVxVjhham9neTZkUm1McW9hWUpVQnUyWXRMYkhQOFRORWdWQUFobEJ0WlpNWGFNRzE1ZkNSaGI4V3NXcGhWaWx6RlhsVTA5a3lmamN3eGhxNWV5TU5SZmpxWDhqOFZEUkxobDNMK0NGUmkvQjhFR2N1NWN1ZEZ3YitENFZJRGI4VXk0TXU1ZG53SnhOYm5LODFaVGQvRGpSQWd3aUo2K0xxbUlMQStLZ0t3TnN1cGZ3RnkrTU5SYmdOUUVsU3hsUUNaVjhjckFxcStHSnFjb1R1Vlh3VGl6WXh0aFlUY0NGUm12ampSREV5amlkUkFxcFVBdUlXTVV2WHdBbitwNU1ocmoxRjM4Ry9FeG5HRFNUU3NDWUhKcTRyamxWejNGMUQ0REpsSkg1QmZpNWNJT29TMTFPcHVIVnkxbDFMdUVJdTQvYWJKY0dIU1RpQkhxRlZDdGlhaVkxcWRSYmFoOGJDWlpaVVdrM0x2NDlSWVFoaXd0aGlzQkR1WXYybk41czVibHJLWUNFci8xM01yQXVCYkZHSUo4REN2aWhXREtxTzRBRVlVa1BKL3hxQ0R1Tk9XdmdhbDd1QzdncGpNZGpiRE1OQkxwbG1TK3BZUnpFbU9iamRRY1UyYm1LRmtYU3pIUXdhcG1zV3ljdHVvT0k5VExNV2doQUFiWmlseHFtQ2ZDQXhXd2w4cGtWTjVFNGFnRmtvdFNZbktNM3BKU0NyT091NFl2NWxNZkd1NGVQTktBbjhiaktYWjZtMnBTWnk4bGg3WmNiaHAzRkkweDBRUUpoazhFWHVmWWJKbG12WWFndjRuY3VtSWRrSGNWTTRQYXg4Z3R6bGk5RTVRVDhSWERaSExsNm4yclJEbEcyVTNVMFM0Rk1NNktvWmQ0dlUvbFlaWkxkcENnWE80SDBjcUljOExhc21IaDhuay94OHZPcFI2bmc4K2ZnelBKNDhSYTl6eWNqRXplSzViQVlpa0JEY3gvWkhpWTNjc2psdjRFR2V0d3ozSFBpaUVmK3R3TG1XTlM2aCt3cVpRbnVlNllZbTUxRE5Oa1Jya3Zmdzkwc0RIdG5jZFdlNHoxS2VNckhnL21NNklQMitGaHNoSHVlcGlUUmpNQ0t6VU5FcTRhRVp0bGpVTXdHaVZrZzBVc3h4d3pNOGxweDZpbE53S0Q4VGJQMUN5WE9pTmNJWmNSbUtseTV4dUY5eFlETU1ISmQxTVRkRVJ2YzQvVEpsYUpxcFVTaUZKRWpvbi9HVzJUVXE0Z1BVUGdnVkFaWHhqUXhmNU0wVGpVY20rcUpjUjQyeWxxWGN0SVcvSGRrcEp1Ymh5TjFBRHhRL3dBTHplVTUrUEM4VDNjL3h2UDR2OE5Nc3ZEL0FDZVV5TGN0bFR5NXZtOCtlZkV3TWxheGh2OEFRN0lWcmF0VCtTL0J3TUMvL3dBVTJTNjNMbTJBMDNERFdtVTNVeXlXajhTcFRHNFNyVm5qeHd6Y2x6bDFpa3NBaS9BSHY1R29MTmQzRGJLaGliWmIxT0t6aTAyekhVM0M1VDZpSjlaamhxNWppWGJPTzlTcFF6aUFpelBINjRoS2g3aGpEQ2RlNVg2SVgwaFUxRGpVSy9NQ0VZSGJPTjd1RVlvem5qeG83bDdnL2FjN1k1ZlJnMnhuMmgrNWxBSlFNMVBjcEg0TGxxM0NKRDQxOGRueVNxK0NVeEk5UUpVQ29Rajhud2J3aVV4MUxEVjduR2xaVjcrVEVKUXN5Z1JMWjJZeExXVlVPN21Qa3JETW43dWRGMzNGL0JNQzFqT29DKzUrMW1PM3VibFh2NEZnc3hMb1o1RmMvd0JFSFU2aEdoN2hWM2NZUHhmd1IxdWJsR00vNVhGdUZUcCtOeFV4bStNSlJBM2Mwa01SaFhWUjlrQzhDRDNjTmxFQ2NDbVk5WCtJWTJUVFByY05FM2RzOXJEN1FDZnE0MzNISnlTS2tHMjVqbFh2NGJtMkJSOEFNN2xyS25JWVpUa214M09hOXd5Y1hVV09jSFV1b09MalNURGl1NWxrWE9aVWFKclN6T2NxSjBWVXJCc21qVVFsREVCcUxqQWlXYStLMVhVcXIzY0FHQTl3ejlTNnpkc3lkZHR4eGMwdktHTzM3U29aWGdZT0pSN2pvUTZmekFBWmhURUxtVmtjeEFtRCtxMzArNS9pZUx4ZjViL2xaLzVIbXc4RGg0MXd3RCs3TWVaZUoxTWI2V0dKY01TcVZLaWdmbVhPUk1zcll6SEYvd0NvazVVd0J1QnhsVzZJQ0hVOHJrRjFPMlZ1YWUyZWxQVXg4SmQzNnVOWEI5RTdLWmtVL1dNTWtzbit5YWkyeHFGdmNPa2hDeWRSZFhNT0wzY052K3ZnYWhNdGRRRm42dVpGeGhra3gwM0dsK05yQ21GTFVSLzZtd2x3Z1JXNVZ2d2JZYW1Pcm1xaHFhbTJXcFZWT0lIY3hpendsc0RiWkFPR1pBaUREVVlVUS9yREo2ampqV25md0FMTFNLeGZnaEhMVUlyVTR4YVYzTFdGUlhST1Y5ZGZPSXpZaVV6TFBsbW9TMk5NR3B6VVNvNTdPdFR3ZVhpNTVodEovamY1R0hoOCtYazh2aVBMOVVwL01XMjhTakxkVFB4K0hQeGo0alBuaWZlelZ3eXhNTWF4THFZNTQyWm9YK1BVcitYeXY5Ulk0OHJ4SFpLaFl5aHZjb01kTXgvTXAzQklOc1l4OGJnWXFqY2RiQ1cxSHI0Q2NibFNweEEzT3ZpejRkbW9HOXlxNitOVkh2VUNkR3U0N1AzTVdpdmpFWlVwaGpwdUhjdlZRcTVrUXgxT1A3bFVRbzduQVNBRWE5Vkx1TFRCbU5WdU5ReW9vSnlZTHRnU3F1QlQ4RmZ4TUdwbG5PVmt1NXVhU1VWQktqTFFqZFRiTCtMK0xVK0Q0ZTVxNXFCODhuMFNtcmxzWFVCZm1yWm9zUmdTdHl2akNxem1uNHgvdjBWTXphaHFmcU4zQWl6R0lUMVpIWUFOczYxQnBuYzRhbkViZ1ZCdDYxSHZVOGRWa3A2ajIvRHhsN3FYNmh5ZmgzT29NdHVLMXY0Q3lOZFV5bjRUaWZIRzFaUWZEZ3BOKzRMTjN0Z2JXQyswajhDckxYb1lqR2JDVTNLckNwdUJPTlphWlNaYlovd1pZc0docURjVmxyZFJTbVl3eHZjL095REMxL1UyTWJ2cVcvaWE0MURLTGNBUmppVU1xdW1LdGxreEE3V2NMZTRxUU43WVliVVkzdVd3bXEvY0FxM3Y0YkdLamJOaHNobXptOWNaenl4LzRUbCtvMjlCQkh1Y1NaeDI5VEVCdXBrcXR3cXJwaDJxVFV2akJ0WVl6TDhFNmdnUWU1OUhEMlp3ekJWdWJUOHpIWnVpRFF6bXR3eXJLMGdMZnEyZVBENktwREhQTWFhQ1BMUHgwdWo0Tkt4Z3VUVXp3eXhlcXFZZUJ5dk5RQ1ZaYmxiTWFxVWpxTTV1V1BHaUFuVUJ2Y01EM004TVExdU42S2pZMUdWTXFBZzcxSE91cGl1VGN6RnhWak8yWWxNeVRQSFJYcVlZYzd4NUFoRHg4c3VObW8wTkVNUndsb3lyWmRiaTNLNHdBSUZId1dZd1VZM0w5TWJORHBqWHBZWW9SM1JNc2ZyQStreHU1VW9oNlpWNVpQcUdCVnM0N2pqUk9VRlpiTGdvVTlRZ0t6R1pRWGhBOXp2S0h3VzJRMFY3K09vMlFVUGpxQXBjL3dBYXBveVhLZlRMRE5JdVRMK1NKZWlYUkRjWmgzKzQ5L2FFTzRIeGpPVVdCZXBkUy9VSlV5aEVsd2dmRnhQanhDNWhQSjRzc2ZMWmpxQmtmcUlqc21EV1pab25KNTVVMWl3V3RUa1lpVExFNFltTHRtSlRPWXRKMUZHWW9EcUFJNmhsSDRKNmo5UCs1YjB6T3RWS2pLaEdEVXRnbFQ2czR3eGxRSjM4WXhKUUVJMXhsYWcwa00zbXczTzJZNTRjTXNFbVRqa0FGVkc0TUdET2FhZ2NweGxYTUNJd0w3aHF5QjcrYmd6SDdNekthSU5STDNMK0QraXdhaktsUzUxcVg4MHA4WXM3WUVjUTdtdlVJTURUTWZrbmNOTVdZNFpJMUd3Q1ZUY0F5Vm5VeURpUUxnSWNpWmFMSWJJWEV5UGpEWEw5d3hxTXIzTW5uNDZPNWtab1JKaUh4amp1Y1QyeHdEWTZoMGoyUmQvR0RITmhhL0M4ZEVHcm1PYVlaLzZtMStPb0V4TGxwREpmaGpGb25xVjduL0Nybkd2Y3hpTndGZ1Nva3FpRFozRTMzQW5HZFFNVmxsMThFTW1NNklOeGRTN3grTHFXM0YzTW1qNElhbDIxODZpY1NVTTBhSnVHU0VjbFpiK1orNDVPYU5VRTR5cFhxQlVNVEVXWW9zZE9wU3RSd0JxVWhwaDdmek1icHNqSytERWR3Q015eXZYNGxRRzd1Wkg3aVZPTFV3OW5KSjVESEFNc011VVhMSnRteWZaank3bHJyNHlaY0lzdUxXVnd4OXcxSEtvTU1uR0NOcXd5S2c3Wll3ek9tWFhjNVV4YWw0a2Z5UWJuNXFYazN5enVHU1UxcUtjblhjeXkxcVlHVmJuQi9EREVJWXF6aXNFTk01NFlSV3RUT0xYOVoyN2wzRDlrc05NeDcwenlZMlVNY0M0bTJkNFRQT3pSSysxT21vMVRBQUpVWU1WeHBLbms4Ymdnbzh0eDFCdU1VcUViV0t6SEU0UE9PWGNDT1dXV25vSmlsenRqZDFNWmNPNFpXcERkeS9VdVhGZzAvUEorYmFoS3JHTGRmQ3NENk14MUYzR0t6UExRUWpNaUdiUUJNWGgvajJTNzdaNHNYUEhJeG1Ralh1RXFqNHVpSGEvQXlobFNuNElwOEVBQy9qQjN1Tld6U3dDNEpITFVGU0JVV0Q4RmNYNHdGZHpqOXRTK0xxT1RrYldMTE8yS0pxZSs0OVVKTzVpVnViMlFpMjBUZGNhZ0lXd0MyZHlpbVZCcU81MHl0VG8xQmFsd2ZsZ29TajRaVkUzQjFYeFVSOVN0TUE0L0ZzTzQ5eEFOUW1vbnhVMVVyY0w5ekRLTjR3eWxzZXRNRkNXcmJFblVGamxVR1l0UXNaUmR3ZXlEeWdRM2d3WnVWRSswQ1hLeGg4VkJxTlFnUjNQVmZCTVhzZzFCMnovY3VOdzJRRlM0c0k1cUlFT1dnbTc0c2JoUk1FY1UrTEM0dGtWb2w0ckxMU1pMQmpvbUdRRzRaWmJuS054WDQrekRsbDJ6STNLUGdBZ1d6amlFZmtzd1FPNWNZTUc1c2xhdGcxMUczNGR2eDB3bGtFdVg5NjlSbmZVZEVzcWRsa3RaYjg0RjdmbTV0c0lZelpNWmszQk1jcGtIY1d5WDlZZFRsQ0tzSnZsRldPcFNzMzBFTVVOazRqRkRVQ2FpVGlNNEZhWnllUEVDcFE5c0ttWFFWT0NOM01UdjhRYUVnMTJUTGk0SEh2M0RwWHNsZTcyeEdjM0xFT0lCTjNLbDBTL3RWUVZLcWNqcEpqVG1DNm1ZR2VteUdWckIxTDFDbXJXR2ZIS3g2ajVISzFEY0d5cFJPVXhZN2F1T25Yd1V4MlIxTEk1d29MZ2pLQmljcFJZQjhYTlQvUkRlb2xOUTFqUFZ6N0pYd1U0N2dUY3h4amNkYm1PM3FZNHY1cWN1eHlaam5qaDNNdkxicUdUREpaL0hiZHpNTWNLTXJpTU1jcml6SHVDekxmYzVWUUJMM3lubGJnRlJnMU1zK1dibFJiTmx5M2pPdjlNL1RBR3QxUEpyS2pkUlZiOXppa3h4dE4wVFBXVFd5SnU1N2p0bkdQN1pjSjNmNFpXUEgvVTdOU3FJZ1owUktJUmg3Z1J4bWdtUEV5dkxaUEp3eThpWUNZbjUrQzNxcUlaWHFJNHN0dVZCQ0xEY05qOFdFdlVyY1pkSHgwRTFjYkJtQ1ZIREwrRUlZUFV5ei9oeEREdG1TcXdxRS9jcVZLK3NEWHd4RXhqZU9rbWlXUlpqQ0M5UXhSbG53RXNDY3BUWEwxRmdVUWxMQXhJRjRxUzYwekUremJHRXkyeExuUkJzbkZlaUJ4bkw1eCtIeHVIZDB3MHNPcmcvQ2FoOGVvd05TakdBTXFWdjROL0lUSVdEUkhLRi9BSnVYRHVDU3lCN2xXeGxRUStLbFFDVmxVWUZiamxlNXJ1V3dTRHZjSXNwZ01TYWxrWmN3eSsyeVA4QWRoM09zSC9jeGdNcTducTVVMUE5eFlWY3RpaEt1R05rTUNWWHlZTXhPNENYT09yalVvSW43bFViWTFBQWdyTnppQnZLTkpUbFAxZHpSTUUyd1JtVzBnRXlzZ2tEWXhOL0RVd1JZNjhsWE9VYzRuRUpYTTFFNHltNXlSbC9CRHFZekpMaWswRWM2dzFMU0ZyYktsQkFXSjhjMDFVN25VSGR5N1dMQXJ1VlJBcUl5dlpMNVRWei9VS1pRUUhhL0dMWHcxR3BoRmx5OVFLR0ZaQkhHc3BXN09vOUxPOFlZN2lTdm5Bc1o3bVdHcmg2WTVyN2x0U3JuR0FIY056NmhjT05RWWthNk5SeVZwM01iOU15eVFsTno3QmFSV3RTbFp4ZXdoeVh1UDZmZ0o3R2VUTXpkRWM0NUZkYmpiSHFhTVlCTk0xdUFUYkVqQWgyRVFINHE0QUpGeDR2eHFKS2hWVEhGN1k1L2lZblBNcTd1SjhBaEdKUis0R3JaVXM0d1lsbHdOWDhiNytOc3h1NS93QlN3U3k1bW5Ld2l1VU56SGxoZXJnaUtrNHh4eHJheGFpMmFuRnhtNjJRRTJzdkdDRE9RampNdTUxTWlpRFUvYzViNU1kbGtMMWllb3JrMm5VZDQ3eGpyNEY2bXJCbEZwTC9BT01KWVRaOE5LUnFFcG0vVUY1QlZ3Uzdqa3J2NFEzQW9zbHN0WWR5dldNRldxajhGUnlzQ1hiTG5jRWhGTG9uVVVqQzQvRG9sL0FPU3pHcDRmSndiajVjOHVTaDhIejZtTnVxZ1hlL2ptOUI4WVEyemlYTWdZRUQ0dlo4MEVyNHZjNVhOcERHY1NwaUJENE10NitDV2NvQ05reWphVkZtVFJSTWMzRWlOWE9Ld3hyNDFVRmdpTnNXUFVETGpMeDRYN25KbHJ1ZUx4dWF3dHNzMU4xdUh6aWdUdDYrZW9DN203K0ZneTVxRlY4RVNNQ3htZGdUdVhCcUR1WFYvQk80ZTR0a04vQkFsd2JoajhFb2liMUVRaVFJTXlXN2x4RXdJc1plb2RRMXVYeWx4VzZnREJXNXNxZTJiYTNMVEtNeEJuQWpyUXlvaGUyT0pqbzJUaWtNR0E4NjdLbm44T2ZneU1Nd3JzWVhzZ1BHcFhFM3VBazNNTzl6TEdsQ0dOTW9Dcm5FSUF5NjZnaXVETXViMmRUQnJ1T2JCK01DSW1WeGhUMlEyeDBrSEpIc215Rmo4RlpOVEVSWXRzWTJ4R0pxWkNlUEgvY2I1YTZua01lWDA2cUJYd1FqY1NFUWx3bE1yM0FGM0Z4YW1pNGZGWDhCUktLamxRRTZsRmZDMGx5bFdCVWFnRk14NHZmUk1reWRTNmwrMkRBaitDYUg0ekJUVnhRZXErT1h4WVhGbGZHTFVINnBMVW5KblA4QUpPVyt2aTlUdUJVdXIxQmFsak94Q2VSY3FOZFFzS21VcVZaREdHQ3d3YmlVMUhINE1CYm1XQkhIY3h4M1U0dlFrQmpONCtwVTQ2djRyY1NuNHFJdU1wdVV5bGx6aWtGcUdUS1dPb3MyRUYrQlZqZHd1YlNBdzIyeHkzUkJsQ3hBYWlscEJlaVVwT0M4bVU5dzk0dzQ0VGVXMlpNTXVKQzJjR040ckJFL2NIQXlGVzVuVGJNYXo3aWcvSGs3cUZqRzZnYWo4SDZtUDF5dGkydFMwSytUV1V5YWIrQjNVeGpRNm1HSDhtWUxSTTd4OHFEWk1hNHdMalFWTnpsUk1idFNJbnlmSGN5Z1VSWWFtMW0vZngrb05TaXBnSkVTVjlOOVFyc2l4eW1JUnlIb2hMbXlZc3Vka0FOckxzYUlTcStHdzM4QnFVbnVjYWJpRDZxVS9tWXJMVmhCS2x3R0h3QlRmd3FzMkRNRnJjeE80RUE5eGEwUVpZUzFkRUNVVkwra3FNTndhWm1qakhLOUh3ZGtyN00zMHpvN2x5L2ltcFU0eXFOeTJxaWd6dmM0b1F5Y0lVWFh3dXZpbGhnemM0eW9RYTFINEpxZXJoakRHMmlPbFBpNnVZckRVeWVRQkRCSjNBbGJqMzhCQStEWkFoVXI0MUhJbUkwdnhjWnNqZGJoS2FzTlFWeW45aHFHcG5sOUNGckR1TTBFQUlKTEVsUU1mVEg5UXdRVlp4R3FaWDIwMlFmdHFjMVpVYlp4WXp0Z3VCMUM4dHpjL3JxK3ljc3NtOGx5Wnl0Q1hWMHpISVRyY1g4VExjQUhidUdSa1Q4M05KcEpWdFNweHU5d09vL2JGcDNMVFNmRlFHWXpMK2wzcVUrbUZzNk5kei9IZkFPZi93QXJ4NTVqaDlEQnFtYnZWOFB3elZhZ3hnRlRhVkszR291OVM0TXl6eWNLbTdQaFppTXRIcVpOazJSWlNUY1BpMzRZVnY0UitPVjYrTHRqQ2FTVnFYQkFmYlBRM3VHU1F5dTd4bmNzcXAzaTFCMVNUamsrcmlhaEJSZ2N4bVJWVGtnN2c4dHJ1QXNxamZ3alF3NkdLdW9iMUN4bEYyd3ZjTDkvQVFhWUtNR09UVSt6Q1dEcWMrNWZYNW5OZ3N4NUxOa0VxWXRTM2NwdmJGWnFFeDJ4YklMMFkzRnJjRXhXejRXR1E0VlUvd0MvZ1l4WmJOd3FtMmM2N25LWFVGV05QWHdNdmt5amt5NGx3RWhycVdHMmM2aSs3aTJkeFoxQWhnOXd4M3VjY1gzS01LMTNNQmNNc2pvZzh1MmlHR1FwNjlRMHdmMU9iVzVvSTUxNm5KeTMxSHlPUFVXeU9WTVhqVFZzdTI0UDJtTDl0a2M2MEV6S1pvMjl3R3RrNWZIalV5NVZZUytXYWhNZGpPV3RRU3R3UmZoZ2F1WjA3SmlHUDlpVVU3bGxRai9xWWtkUWJkbndKdVlZT2VEUjF0Z1J3UUhLTm54MnlrbElLd2xUVXh5NHpMSzVjdjR1SHhoUm5lZHBNdVBMV0tFc2pkb2tvNTNISy9HSEhZd2JiRFV5V044WU1VaDFEN0ZKRW9nbkdQeHZLRmZDeTVkL0hVNm1NQ1dERnVZeDRqcWJXVnFKRHhLTEFqUzJTeUtYcUMzOE5UYjE4QVN3bkorR1l4MHkvd0FUa3gyUkVCbi9BQTVRYmg4QUVhWUZ4YVkyc0xqaXNMSlVNYklFRFRBSnhsVkNrMnpqSFU5ZHlzSzl5aVVYR0U5eWpxY0krUGo1R21PSmF3U0NQclV0blVEVndoQXNZWE1VdW1aZkQ4RFJwN2x0UUgzOFZ2NHF1L2lyK1FHTzROc2JORUZKamo5a2hubGlzTU1XclpuaHg4djFZaEUxTHVGUmhGaE5kTUFXaUpNUkdGakd1NHRrNXh2NExqREpwQW5KRDRNcUp5WnlZTEJiallzMnR6VUsvRW9wWldybW9KR0Z5dFhHREJtT1Fkck9RZUpMbk1aam5URlg0R0h3UTNBWWFYY2Y5em83aC91Q1R5WWJxY2FoR1dueWZBY3BrVjhWRUQ1dG0xbS9nbmVVSnY1TGhkeTViQm5aQWx3YXhTR1VHSk1NYm5IY3h3NDRMTXNXVXNxRE04bXVNNHVBTE9TNmxwZ2tMZHpqWHdtb0h3czZKL3hnNHc3aWpNZHpWeHFhaDJzc2xsUkpWRncxTXNYQ201aWZkNU15cTNjTGRSR3U1ZEVORjNEYnFHVFN6YVJieWkvSExVSjlzWU9XVE9XL2dxVnEwbG40K0NxdGhTOVRIZlh3WkRqT2N1b0pBdWNaWmpOc3lMSWYwbTBvSTQ1Qk9HNG9NTTc5UnptMkZtcm04ZTFZY2NNY3U5eW1oeGRWSEZLTW1XZW81RlJZS3pFWExjVWRFTWE3bWFWcUkxY05rQzdtT0hVR3M0ZmladDR6dGpsSHZsRFR5bVRwcUdvSEUrRDQ2K09iaG85d3hWYnlpL3U0dXZsM1BTekc4bU9uNUZ4RUh1RmRSK3dGd3o0cFpjejhyNURpWUJITDk5U2pMTUxtZjFhanFMYk9HTmQvR240UGcrTmNaYzdoNVRod3hOeisrYTVka1dBa2NxYStSaVEvRUE2aGd1NzFHdmdaY3ViaEdNQ0RZM0NYcGhzZ1d4aE9KK0lFZmd5WmN1WXRiN2dnVlUyVGNVSVRmemF4RVBpNWt6cURiM0hSY1d3bi93Q3BxWWc3aWtDNXg5WEtsVjcvQVBYY2R3N212ZzFMUGh4c3U0TFZSYW1PUWI0ak12S3ZXSVNpQjhZN3VVQkdrRUlRc3ZMdVdBa0djdFVSVWwyeS9yVU1waW1MZFE5d2hpZHpOSmUvZ3orbkNqL2NVaGx1T1VHTkQ4WGJVR240RmIrY1NvZ0dtVnVDZmlZTGhUTXJ0amwwRTUwWFc1amVUTnJNQlNVazQzRFU0RDdtT0k5TWF4ZHR6a0hSVVJ5WVk1TXhFMHpNT1BjT0lKT3k2bnVvR3BkRk1LWTZXV3pjc1libE1yS0psZDNEL2NEVlQyNnFBak1ucU9SZlU1TUhjV3ZnVmpxQU1LWlZzYmdCQk42aXpvNmxFRDQ2MG54djR1Wk14WUo2UGM4emVSK2lIeGRzcjRJQWU1N3FMWFh3a3BocUNWYzVTMCtMK1RUQm5LV3M3ZFJXS3BMWTNLWUtTNXViZ2FxTUdZWjFaTm51R1M0cE9hemtrTFpXWG9ndnVaWjVNTTI1YU1GU3BseWxOVDdkUVlFcUpxWEt2WVRxQUVNakVZTi9CL2FjcktxTXhZclU1M2pVb25jN2Z4TXVNQ3J5cWNieDdxYXFvOU1LTWh1cCtYbDNPYTZ2NEdYcWErR0ZCSytLQ1hub0prWkdWVENYRnJvdUZ6cUhjQStCMGxRdS9pdjFIR2lOR01FNHpMTDhFSEtHaHRodVhSTFpnWEs0N2hrTE1sR3B6SzBSeVdCV0sxTWNaeEt1N2dWTE1TSEV3VzkzT09XUlpQSjR6QUtiV082blU3MlJFcWVORERJY0JYM09TQ3gzdU5FS0w5M0Nka3FobDBSYloyZkpNekhFS2JuVGN6VjM4WTBrekhFTEplMENhQ0FwT2hseGFuN2lyTVFENUhqYVB3RVJmakVsZ3gyeG5Hb0N5bjUzY2R3bnVaQmlkd3BnZnVXY2taWVkxMHdnYmdMR2htL3pESmwvK282K0xuZndud0VPcFZ6alh1R1VHREF1VkNVVDJ4SytDb3lvZmlXeTM0TEVpcXh6SUl6aU14VEc3TGhWckhaVUdzS21MeXhoWUJNSmdnekp4cXlhb2lFWUVxVlh4VU5NNUV0ZmdKVTVhbytPL200NkxHTE1WbFEwc0tqZlJBVXVmWklSYmhCZzdqdUhJbkZscDdnNmJpL0c2aENGRnpubzFNc3k1eUswVFpjNE5sK3lHSVJSbmJGM1FhaWxWV29mYjRHTEcxSm1HSmhMdk9xZ3BMU1UzcG02bHNMWVlrQVA2a0RIakx4Q3FndGRCQXlNUDdRV0prNkpTRVQxREd5R1BFbDIxVXFPTTR3SEVtbnVKK0lzWFVDS0VzSnRtTGVOc2RaUi92OEFEcCtNY1dMZXFxQXVtY1hGbUJiT08rNW5qQWxCS0NjNzE4OHE5VFNXOXdZc3UvZ1NkVHhtejhzejFrajNNZmpkemorNXgzOE95R091L2lraEEvTTE4aUVLbHdTTVBqaitaZzhiQXU1Vk5CT3RTdmdTQ1JRbkw5VGxVdU9pWDhHV0IyUjRzYU1aWUVNaUxDM3Bpa3NQZ1FQaDZnS053SVkrMWwvQzZoa1BaRjFxRGNFSnBaaW02SUZ6WE9KVXFCWkVRamllb0Vxb0U0dHpqcmJFUUFoakEzR2NkWE9NTVhjTWFMaUxLVStEY3BYWHdId1daUlhKVmpaMUdZejFBWHVHeUFzeHhaeGhpSHVjZ25KbUlydG1lQjZaVUpZUTJRRzZKbGRmR0xSRTFEVExWdGpqTVFyNDd1bURZa3hEdFp5R3hPcC9KK29xeklLanlnL1ZtSkUrMEtDT3lKV05FenczdVZmVUlPNVJBNWpYcjNEL0FISEFLcks0L0RER3M0ZTRsdFM5UUpuazVhZlVKVnMzMFJ1Ry9oaDE4VnVKREhVQW1PcHlTNEVMaGpUUGFWS1RWUkdiN2lQYXhoZ3BBYmlWS3FWUDl4TmFuRFVjc2NjSzRXdzI3UGgvdEZRcWVxajFVdHBoMFM0SHdwQitLUGlxK0RGZ1YrNGRSblJCSzZqTUdvUEdPU3oxRHFFN3Y0Q1V2dUJYeGZ3U3FneXBqREFIdVluMllvNTFVY2FoaU14RXY0M01HcFFrU2o1R0VOd3p4UFU1UTNCaGxMSU55dFB3dTVzbi9VR2paTFlGc292NHY0cVZxNFM2bldOSHdNeExnRnpxRDhNR1B4aWgzQnRsc01XT1A3alZRMFJ2Yk0vSytVd09QRklKdVhxVXZYVUZOUnVHcHIzTDNvalpGNnVaNVhoZ0pOS3hxQlpPNTBWY0J0M01LQnRnbTRaSkhGclRPTFhjNFRrQjFPOWhVYnJUTXNhWUU0OGNYZHdaaGxTem5keDZzbHN4YTdKZStvM1dtYkpiTlJKaVNtT05ZU2o4d3gzdGdCY2FXcHhtSW00cXNOdzYyN2d5eEs5ek1EVEZyUVRiRW5HaTdsS2U1eGhxRkJ2YzQzaTVERGM0aDdsSDVsRVo0ZGVZVW5rKzNreXlnL05mRnNxMzR1YnMrTnhOVDNFN2xaSjFLMURDY0NLZFZMSzZtTVJZYVdPSk9vWFVNYnhuR0R1THVOL0FDektHTm54UVlGd0NaaEt4dmN5QW5EUXhPTnZ4UktCbXhaeGJnTnZ3dGxUSFU3WTZtMkhLZmFGblpLWVdFeDVRYlk2bHdkT29aelBQV2lXVG5PYk9UK0phNUZFeXkvVU1sYWptZFZNY3BkRTVmVjFESVdDMUwxTFNjcWcyeGZSREtvUDUrRmcyd29nMXRtczI2b2lsMEU0N2hnVnRnWWs1WW5VTTRpaHVlcVpXb2w5UksrRmdSTGxWak1WK0hFZ0tYVWFLMzgwd1JKL2JSTllrMmJtbGx4L3JNaXBiSDVZYlp4U3lQMUFaNUV5ZFFHdFFMWnhpT0xNY2tzdlRNWTZmaXNwcGxhN2x5Nm1tQXhEMHkxMVdweVNiN0hmd1dTaG1kZEV5endjY2NERUVOc3JjZFRhUTFPNHBzZ0pTdnhpbXlWREtubE1zL3dDUjVTMStGV2RreFdrbGFpVVFXV3haZXBaVUlDa0FKL3Nqa3czT0ozY3VEcGdUcjRLK0tmYk5COFZVR0Q5YmhURjFPeU12NENkczNHL2owekh1T21MV1UyL0RBblU3aS9BbExCMUtvbVdWR2pjdXk1eTFMcGhMYVlMTVNVd0cyVmI4WXMzOEJLaHFId2FobGJDWjFSOGJseDcwazZoRmhzK0Q0OVFaeGdKTnJLbUI5cFgyK0FnRVp5aWxTMWxhbUJFcGhsRXVOVnFZbEVmNkdVNUtySDYxRkxxV2hxVXBBZno4S1JKOVZyY0I0b1RNYXhJb2dFSWZGYWhnMGJuQjlwT21xakthbG9kUVg0YzVqblU1em5xWS9VYlpjUEpRaVJTTE9VVllEQmpsTG5KK01haGVlY3p5UnArRW9nNlBnSnVjVkpzMC9GbFR3cHp0bmt6TWhhaTNBWTU2ZzJkd3kvYzVMR1hjRkNHLy9RbmpYYmNWcUdFNHh4aVF4bFJtUkNpSmNxTXk2aTBmT0RqdGlyT3AyL0dxK0JCYitBdUV1elVJSngrQXNoUFQ4ZEV4YjlSTGFuc0JpT0trQlkzRnNaYWdmREZ0bHR4Ryt6NHFPUHVFZFIyVEQ4UkdBemxaVXRscVRGNHlweDNQNDJsbE1QRzFkemp2Y3E0WUVCWUNpUVVFaFpLdG5iVlEweFcrb2pkU2dJbTUxTXNwUWtYNXlsU200Rnd4cUo5b0p1RCtDUEpqOGFoaVNxWWdzTVlNZDVSMHczQVVnVkdZbDlGc2NVNzFNTVhKbmo4K1hnd3k4WURjdkZiWTVrdUpvWnh2WXcwenRsdkdheG5iTXJNWmdEVWQ1UDZtVlpTb0hjU1k1dU9LYTNNY0hMUGk1VElITnA2ampSQnBZVVRtK3B2dG1ZYW1PcHltbUFkVGlrQkdWVEt1RkdvTDZsY3AvVStDTnlvZE00V2xUakxxSkhxSGZLWm8wazQ3V1Y5WlVLcUVDN2ZSQnRhNm1pVzhtWTR1Uzdob2hLM01tT3FxTTdQaXRmQnlsOFp2S09DRnJQV293RWFZQXM0bzcxODVVQnhnVGpjRUpmeGN0bU1ZU3ByNEdDbXlXczdpU3ZjM01pb2RmQVY4RE5zU29iUGlwcUdIamNGeWF5SWlwK0gzRXc1VXNBMmtyN3pZeWhKd3BtQUVVU2Fad2poREdWTWNiWjAvRCtmZzFEVUZuR2NjWHBoalh1T05NZTRHNFkyUlBSTndXb0dvRnM0Sk9QNlpWYjRyRy9lTExqQ0VzZlVHR1lSZllRZnlRM2xLR1V3d2VEYktySGtTMWFnVkhLaWE5VFdNOFRlS1FvLzIvRHBucURNVUwrUEZoeXpDcnVmK0wvd1BGL2wvNS9pOEhuejRZT1gyYm4vbi93REIvd0FiL0EvOGpuNGY4WFBuZ2RNeFZNcGtQSENWcC9jQ1ZiT013Q0JHRnphL04weHkrTVdDY25jb3lsRWNSME1UZHpKbU1BV2NDRkh4U1NsTFozOEdOcGM0N2FZbDdjcDAzeWovQUxnZmFOWDNPTEdZQ05zUmR5bktHbW1HQlYzVXpLTlB3Y21jV1k0UUt2VVJpM3BJVUxGcUFjVm0wK1NEeG5PM1JMZmhZRTVNdWJtNWMzTnppc3ozVTlSMFJHWUhjREo4WVZIRldIallZZXVVNEpiT045c0NtY2JnOFlDcTFENFNvSHFkYW5HVWtJMytJWGRSMU1UY3pGOXdFbHd4dU92VU9QdDNHR05SS2h4UzBoZ1pZdGFtd3FCdWNHY1dvWVAvQUNsSWE3aGFRdVYrSlZNQWxFTmtjUXdqKzFoaXA5UlNLLzZuWnRoNC93QXNxblVGUFViWldvakVZTlI1VEhsMnpMSmdKTmszVVIrTVBGYnQ2bVFYcU8yZHNiRnFwNGpDMXozRFBBeWFOVCtUbXhXQXk1YkhaR3hvbXlXeTFJV1JuRjlNNHdJVVM3NmpkN2lsVEJ5OFdabUlJenplYnlmNU9ibm1ZbjZEdUQ3NmwzbHVaZ211b2E3bGoyVEtzaWlHb1kzdjFBM3FiSnZKZ01PVDNNQ3Jtb3NYNHhLeHVKRFVEYXhIc252Y3hxVlRNdnBPUWticVlsdTRnTXlmd3k4azJ6aXJ0amlFTmZBenZxVSsvaWlvWEZZNkp5L0V1NEZ4ajNLb2hFakxsWEJodXlkRU56cURLV2E0d3Y0MUdYR0Z6ZUxMSUt1NGt1NWpyY1FiWXR3SmxsbG4yeG9uSzlSWnVEcVloUGN5WVNyaEF0am9sMzhBd3htWFlFSDdTNWF3dnFjV1pGTTFkZkJLcjRGaDlzcW1lSDhmazRxTXlQZ0lZS0hJcTV5b2NVMlN6dEpqdkZJZHZ4MlZLc29nSjhBWDhKY0RjNC9BT1hST0dSMlF3eXFjVWhnZTg4WTQ0djhBK3N4bjhlTHYrUWpoNHV1U3hQQ1kwRGNIRDJNK3BzR0dlTHZqRHlGNnhKaDVqRWI4V0VQTlMzNHNaL0x2K2hPVHh1aWNtZnlOVnFjOXh6ZnpQNU13MUhQTk5zTWtJTFZ6blVQTHVmeXY0SVpMNkl0LzhDR2RlbytUR3FSZ25vZ0VvOU1NTjI1VGhZaEhETEUvcXpnMWVVNGxiWVVQNW5IbE1heEttZEdkVFVFWmRrNHNBTlB4aXQ5MHkzSEpSbDh0cXY3WjQ2dWVWMEZUSnhRRHNtcGx4b3FZamZaT2xsdzIxY3RGTzRMTWJTRmpQNDN1YmxRN2hqV1VjWnFwV09MYnU1ZFpVUVZuYnNoaEFqak92VXRZaXJDWWhUY3JjcEw2bVRVeHc1ZXduNWxGZE1BOWpPVkdpV3JDN2k3aHIzR3U1Z0dVZE1XT011V3ZVNTV0QVI1QnBJcXpFbjVoWVMwSm9QZ0p6N2xyTVNVM0FyYkZKcUVxeVZFSjFML1UyVXc5L0dVR3hJRkZRVjZ1WEJqbkQrbTErR3NZdXBkYkkrVEwzT2NUVmpMZmdsemt3eVplWU95V3MrK1JBeUpzbk5xTGxETnZxT1dVSDNPZVdSdXB1S3dWZ29NYjZKOXI2aHpGMHo3UnZqdUdiK0c1YVRscW81ZmlHNVlOTWN5WVpZVnNubFFRSzBUTEl5UHhNTStEM3FLTUFmZnhSRXhUKzN4amdKdk1JRnZaT3ZZeDJ5OHBqamxrUThXVGtnUzFPcFM5a0xKYkdjbU53WDJUdU14UVZKcjRGeDBFUnlMQnVCTjdnMDNVQ3R4Y25VcGhOM1VEOGpORVVXTFJCSmQvMW0yY1VDeVpaR1Qxb21LWStoV0dPVy9qQWRpNmpNYlp2SHVGSXdVbTB0amRNQkppOFM0T1RNYkJ1WWVFOHV2SGtYVXlYSEp4eU5rTzVsUEcvQ0NUcHhKeUxhbWVJRjl3ajNHbHZjdW1MQjE4Y2ZpdHhJQXhUbytNR0twOGJSZzBTMzNEY1Nsb2g4Rzl6Qnd4OFdlT1l1VDB3L0UwZkxPeUJEUzFLWUViZzFPaTR0RUlQNUg0MThuVkhjcGRNWXdJQUxGNkpldEc1Y3VFWW5VNFRxWXMzQW5IY0FqOEY4b1FQaTRNOXlxWUVzcU9pT1ROeTdZL3I0dVZGU0I5UDNGdEZpa0F5WVk4STVPVk9UcUZDanRnV2RSQVp4cDBReGZ4REZlaUhqeS9NOGZqc2J6SndEL25EamRRY0NHV0FYeEdQbFBXQU0vbHk1UnpYMU9iVU1zL0oyeHlwb1lMZTVjWlJER1ZNU09Nd3gvT1FSTjZ5Z0QyempqMHMrdjVsNEdybVdXQjdnNHMrc29Jb0V2RDJNeDRwcWNnMUhoZjltQmhmOW1mVGxWeXNUcG1KaitadzMvY21lRnA5eWNFaGptZGU1eGJvSlNOUzBuazhPSGkvd0FieCtUeGVYbm05a2MwMGJ1T1FtOFo5YXNoa014REtPTGM0SjZsTDZsVVRpZDNMbmMwUWNhM1B5RUdxbmt5WmR6anFiK0FSbFRFKzNaT0NyU1RFVEp1RmNsbVNuVXRnSk9Tc0c5VGx4YWl0UzV5R2Q1dyttU1B3MXhqY09WeHlZVHFhSTMzTnN5eFFuQnExMUduUXhLK3NCWnd5bFpReFNHT1V4STREYk1lSnFhTkVDOFk0YlJaUWUxbEREREdWKzVSREV1VlVSWFV3d1pWNlp3aVNwbGh4UDhBY3d3cTFoOExyNG9xQjhBc0FJbDdtdnpMQ0tFdjlRVytwVytvMzFCTVRjeXlFb2dIR1VFeXhvRmRTMEdwVkZzeWJJZFM0NitDSnE0ZFFoTjVRYTE4QUM3aDMzTmZuNHN5OXdWWlQ4QmNXcHVjV0F3Slg3bk1EOHd5dU9VcG4vMlBhUzhwUytwc2lLZFRpVmJNRG16eUp5UHF6VDFqR3Z4Tkd1RWE5WXNLWlpPTURFT1Z4TGJsRlRUUCs1LzNOL21Wa0s4MG5IS2dsWjhvcktZaXpjVmlzNE5YY1lFU0RGU1laNTR0a0RIeTJtbUJ4eVJuYkhLRGI4Mm5jT1RxTERHMlpRTVQ1WExPVlVNWEhVNXBET0xiS0lJTVc0WWt4QjhlWDZobHI0R1lZbHpwb2hMcmVPVk10dXJ0aHlHYlhjQWoya3FvTHlGNmlGcmpGclVSSnVLdy9jR1Z2Y3I0SlgxaHNuWHl5NksrTG9ZT3ZnSTNDL2NNcFZSTGgrWXlpb0ZiaWJ1QmNZL3FEcmNmbmRVUXZpMU1OMWhZWEhETERORnVXajhjSVIxTGhHRTQxdVlsNUViYzA2SWtBaEdHNER2NG80MzdoeEo3dVd1VVJnSEhjQVpvbHF4cytTNDdnOG1vcmZ4MFN3K0tnVktmaDR5eGxNNHQzVUNjTDl6R3NNZElzd01VZVV4ZkdEWkR6QXBnVCtUT3VpWmM4dHhVeHZuT1ZPbG0zMnd4bUpxWmdHamM0cEdjWUNuN2xoTWNMdEk1bFZqQjNVMndabFZRZmltNFpiaWx3eW5LdWlHNXFIN25UTk1DMkpVSS93QllGZHk2MlJjZS9jU240OTNLQ0ZTNFl2dzNCckNXM04xRE1GZ2w5UmlmaGg0N1BnTXBiVU02N2prTUhEWmM0ZmpLVmt5cU42bGk3K0RiTXpiQlZBSlN6SEZJK0xVeHgwblRNalg5cHVWd0xtR1JrTE96VXZVUTB6bEN3bmJCQzV5VzRWTlZEVG9qOTIwbXNTM3VOc0xIYkd6WktWdGdmRlMxZ1h1bVpZbnNTWkhvV2NSS25GbW9MQjMweml1K3BTRUllTlVxY01SL0RNK0k2YllJYmp3eXg1VnYzRGdiWTVZOHRFZW81YUorYW1XZy9NVldEV3lPVU43STJUN0pPTE04S3IvWHhUT3NmZ3I4d3c5ckZxR1dEZzhoVzlReWRnVGk1YmwyUDZsd2l3MzhZakcrWHpxNHR1cDVBb1YzQnRtV2ZMU1EwU21jS3h0aU1NUUxnRU5sU2dJVkdDNHkzdjV3eE8wbkczWnFaZVA4TTFLRWhpL0JZZkFrdFlFcWo0eHBXZGFDYUpRejFEaVM3V0JmdGdBVE5HZUUrK0wrR2VVZWJYNW4yeG5jVkdzdW9IYmN2aXdkc0hrMEVjT1BjV3lYcVlqS21QZFZIdXFtK010dnRscDhzTVltNFkyUjBTcFkvRlN5SVBWekd6Wk1PUG14cGF6bWVMaGtudUlzY2VPUVJLU2NjVFpCQnVaWkxrcExyNGNGZ1U3aW1UTjFCbUFxTldFenp4OG1ZNnhqaVk1MHRzNzZuS21pRHl5bHZKQW1KZDdnVHc3TXl2VXgyRms3Uk5Sc1g0L2p5UEMrVlJMcUtjazJTbUFGcjNMdVV6alZYMHk1YzJ6REJabmp3SDQ5ZktnZkhJaDhka0JkSGNVNVV3U0orSlVNVzl4L1JLRWhVNjcrS3VIZitwMU9YdVloNURLOHFpVk12dDhEUkszYzRxYllJWE9TL0YvR3FtT2FDWXdOSkNpakgxTHRmaGdyT1ZFN0lBbTUwUzRVRzRhYWZjNnlvbWJNZDZuR3N2aXJKVEJaYkIyRWRqQTFBbk80cWt4TGl3aWFpbndSR1lZT1dzWTRwcDdnMzhjWlNUamM0MFRjTlF5eFArTTVocmhIT3lncURreTV1WWhrd0dabTlUQWwyMHpKZWlVUlRpZldBVk1NVmwwVFRLdU11aUdWYm1CY2Nqb2lFTmJqQUkxQ29ZTTcwUUFaUmM2SVpRZ1V4ZFR1TUZxYlNWQVZnamd4TG1pTE1aay9CRXVXeWxndU1MenVCREt1NXRiK0RHaWY5UzJjaVhjZW9BeEtoZ2ZDYi90REpTa3NqeGVzYWhoRHgwenlBT1V3R3lCWGNPMkJreDhPWjR2NUhIVWRNdDlURWJibFAvR05oS1orU1ZSRVVsSTBRNUpNYml2d01QMk01blVESnQ5UnNZY3JsTE5FREd2a3U1bHlyYmZ3TXRnWHY0R2N0Ymw4aXBqaVZDWGFvemxDNWpZajZtZUovZjFLbU9MbnFPSUtUSUFBN2pscFBjR2RFVmh5SldiS3lHWWYyQm1hOHN2MURDdytBZ1d6ajdCbTMwU3JsQkFPUEpZdjRoU05TeUdRREI1a29jYmhpUWk0MTF2NEtDVUpPUFV6THpTSTRuVlNyMnp5ZjQvbDhQakh5ZU9zY2prUThhdEVlWExqS3pHbVV3SUh4YVFiTFpraWZHNExPYkxac2RSQjZoR2NXSDduSDJUbDZtNVRxWkl0VGVVeEtpNXM0eW1OT0ZReFIrT05RWnFlSTVaZ1RoVGxlVXkwWGR6SElpMkxIRk8zVE1EdFpmSWw4Q0xGcGxXUXVPV3ArRzUycmNGaDNNc21iK04xWXd5YTZnTXB0Q1U2dHJjenc0NU5aWFBVSEtwYkZ0MWpBV3dKYmpoTFpnNCtjNFp0WitvNFpZNU9PVUxOTTJrTFNvWXh4eGpST1RUTFUzS0lHcmxVN21LM01WRXh5c01wNU1lSG1jRUV4ZmM4dm1QSUtZQW40bE9WVzFFRE9wZ0dHVVFGZXJnRmJtc1ovakwvQUNaSC93QzZ3VW5JYkpzSWtMY2Flb1dzdUxFb2d6TnN3SVdreHVNTEdJNTR6UEdyK0tTV1FSbHdsWE9vUzNGc2wvYlpjc3RhcWNwVS90TU1qREJ4U1dYSEg4US9ERStBMi9IMUJmY1U1Vng3SlQ3aHBqS1lpUVQ0TWJ4V0g5ZmhsYWhxWTdZNUZhaDhPTlQzcUpiRDM4ZGtDR1B0K1BkZTRuRmJoaVJJbTQ1UXlxTlZjRXEyY2hoOFVCOFlpdFNwZFRCS1JtMS9VYUpuamhqamp4aFJHVzQ1WERiYkNqS2E3amtzSGZjcHlkTTJmSkFnM2M1L1dweXJVR3BnOFdlRnYrYkZNZnNlNW54RkxOVExQS1pWcW83SmVvWnF6Q3JpR3o4enFYVUdwYlV4eDFiSEhsRm80bndmRndmaXB5U2NraGJ1Y3AyeDFQOEFVRXY5eGhqQnFHelV4L2NmckVadURPNTVNOE04UEZqaDRqRExFMjMvQUdnYXNVUHhFUmhxSHpmMXFiWmlNTkVDZjdnNGtGWnd5Vzc2aGl0MUFTYlltVTliZ0hjLzRzUDZYREVxQXdJSjFBNHN6eHp3ZVNFNWJHNEl4Q3RRMFJjM3hwZXB4WnhRblJDanVWZmNmeE1nYXhnbXlMTEhVcWlhSndYY0NWdnFZWWl6TEU1NmhxT050OG9BZHBMeGpsaTZwZ1paRm1NMnhzaUNFeklFQ09vRlhDcFF5NWpER0s0OVMxZ3d5Ym4vQUFTOXpEUExSZXA1TVVWTGhmY2NJalVwaEtKUXh1bW1EbGY5cDQzMjdtSGtIeWF4amtPYk9XVU04cGJNVmRTNmxjb0hHVk9FY1lScmpERlp3U0dFNHd3ZlpLM1ZSdzNLWmpoK2Nwc2FqWm1zWGNWNVRtcHRXT1RSVTJ0eXN1bWNhN1lZR1RxUGpTY1VKYktpRU5FeWVVSmlOeFBnR1UzRFRzbVNNeDdpWDFLSnFJVktLbkxqRllSbzZucThwMDdpWXBMUHpPeXJqalNEbE9OL1VKNGNjam4raUxtckRwdVk0a3FzYW1VTWtka3h6UHhITjlrYlRxcFdvUmdYak5rVnFGY1p6Q3AzZHk3QWpMZ2U1MU5rVmlIRzRqeHVEWk9NTVViSUx5MDFIM3VVd0dZQjU4S3ovd0QwaEVESk1qWk5jdFRkeHVkUlZtTnNWdW93ZHpKbitOamgvS2N6WHI5elB6WGxlSUFNdGNseTNHbkVLZ3BxRTdHQzVkdWlhcmJjb3luK01oNWYvd0MxSnhMamk0WUROTnd2aTZuTU1YRnhtT05tbXBsVWVMRlhUMUc1amc5ckRGeXUrb0hxRmJibUxidlpPczU1Zkc1NGM4UlNiMlFJa3JqNmpqbHBmaWswVGl4UHhNRUw1RndwVjZsckwxVVVkVEtnbGZJWGN2Y0xuQm9ZME11dHk3Ylp6S2p1STNCY0ZSbTFWWUZ4MUtDRnNLQ0RWeXZyY3JVdXJuY3FZNDJTOXk1dkx5Ui9FZVhPbnFWc21UZWNNS0xXWHlhSmg5Ukk3dWRMTGwxS3hlL2psRWFnSjhCS2d6a201eXVBelJ1WE1iY3FxY1V6ZFdTdHdoc2ppMVJPRFVLZzRrWEd0WXk5ZFV3eUdPUmwxOExHMDFDSlJPTzRIdG1BclBGazJ0ak1nVmFsWHRpVXc2aVk0OXNjU3VwamgrSmhqU3I4Y1ZkVExGNm1KcUdMa1NrSlV4eFpSS3BqQWorb0VwaDhsMU5lbTR6REVxL2NZTVF1eUVzUDNGdDJVd3VJa3FqY1poN3ZyL2orcFEvbTUvdVVFZjdNR3o0b0dWcVhXbVlveHNnU2ljaDBUL0Y4dmh3dzhwNWZlT21ZVVd1by9vbjZxVVI0OEd1NHJ4Q3R6djhBMUNnMDZnbHh6cnFGc1pySElidWViZVFDMU5va01ZSDdobUVQemM5Vk5WM0FBdUFlVEtaL1JuMmRoTnR2dVk0RkY5dzhWNzFPQnN1MkhqZU56K05obFhjc1dHWkRPclVncXhZOVVRaFRBUXNpcGpwaGpPTE12N1FveGFibmNCSUFrVERGREZ2NDVWb0ozT0daTVJEY1J2NFVKWldvNUJXb1BkVERLeWNrVXFiWnRKVERDdmhLNitNUUNtT0JRNFpXK3lZNDcyMUtCWHNoVEhFZXZnYW5jeFFaZHMwNmpoWHhXcGhCU1o1WDFCbDNNUU80cGZVY205U2xsVHc0aTdmVVJ5WlMxS2hVU0Y4WnVyZ0x0M0FiczFHL3pCczNPRnpqVEUxQ21CUXNDS2szOEVIOGJaeHZ2NDhlbUpSWkdCR1U4WThlSUhjdVhPVTJrY2Q3WjNyMUtDYUM2aWwzT2RmYXA0VmY1WGY5ZmoxdVl0OVJhcUpwWmlCdFkvcVd2OW1aS3pYNStMcG1PVVdYTEtsOXdMaHBaZktBZkJURkhVVFdpY0ZLbDFqdWNhanZSTWNkVmM0K0xodkw3UWNUMU9VNVF5VFpITThuajYrOE01eTczQzNWempSYlA2elpGaTJRL1V4eVhLR25waW5DcWU5UnkvRXUxbVI3WmpMS21XR1lHeW1VZW15RDZDZUEvd0R0Ym1SZmx5cm9ZcndQd1M0bzRZWW5mdWNnc0lNSDZyV3BsajllU0lQVTd4cWJDb1BxNFgxZW9KZEVOcmVNRlA4QWlCTnVWeHp5NFVQSEdaWU9MZmNiU2RSSEwzTnRXM1VVdUUzRFJCM2NUbFBXaVhBN1dBdHkvZ2lNS0dweG5KeEtaNi9jUll6RTFNc3JLbGZYdUhWTXdveU5XUlJ6YWpERWxocVZLTnpITFV4Nllud2tGNitPaVh1NGpsMUY1TkwxRW8vY3hHUGRYQW1LbmM3aVlvTWJDaWRHNFJ3ZkgzanhHWXVMOEdVdUkxS2JuVDhWTnd4djFNUEdzNE9ObVdVNVlZNDhlNElQMUp6YmRiblBLV3NiSWQzTzQwU3JOUVVqZC9IS2JSK1NjdlV4YXltTDl0TXl6VW9ZRVhlaWZhWlhMV0dPVldTMTB3QUp6cUt1NWlOTEtjWXRmRGxGK01jamR5N1phVGpjQ29kTUdYS1NYQ21WeEdZeDdsVjhhbWZwbE1wK0tnRWFxaUl3UGdiYW1zWlFkOXNCMlQ5eTZodCtRK0EzVVNwVk53RmZoZDNNSEhIUGx4dVo1WWVUTGtZVWZGL2dpTURrTTlFbzRLOXh4MVl6c29ZNVVURkZnVzl4R2NNNWFsTXhjY1k1eitSclJETlRZUWNWOXo2bWdZRFN3TStwbUlzc2d6bEZtOG5VQldvRmtNTGo5WVpwOVp1Y294eTNEcGhPN0p4VENIN21PSElzbE53UGEzOGNzV0s5UUNHRUNjUGZ4Z0F6TEVObVc0WVk1cTVlUUVsbXk4WDR1Mk9SakhPNXgxRFJOOWtNY2d1YnpLbFpZNmxOemlNYXgrRDRHY29hK01TRVJteWNWTlNxK05TL3dReS9Vd3pSV1dWRGptY1RzbVJ3UWdnc0txT1lsRXdmckdkRTk5emZwaGRRdUMzMnk2ZTR2cjR1T2NCdFlNc2lsU3pqY0tTY3FnWE1jU3U0WGZjYzJvTUdCY0RjR21XTTFOUlRvbXBmcWVMSU1jLzJRYk54Q1k2dUxGZzFMcUZSeVdFQllZU25sTXNJSHhVVWxWdURVR095YkNZVTZaa2ZqS0dmR1c1RVhVdXBkd0ZXRFV2NEZsOGRrek1QSlNGUlMwSmpRWEZ4Y1psWEtOTk56VXNpSmp5T21ZQ1pheW1MbGpsZVV5UHM3K0RGdUtaYWhqOWZxeG9LSFpES3kyV1ZlUHVNOEwvOTJKKzU1c2EveWN5Q2JJQzJNRnhDc1NLbWFwRFBFd2NFMndPSWx4eVU0ODlIcWNwVEFsa0ttTjVScTZneXgxTXptejhrRGR2VTh2RFhCbDdZUkxtSWZPVExaYkIxT1J4WTRaWTRHYjB5ejJmRndxTDBSRXkzSEdMRWdMRFYvQWtadjh3TVArNWJ1NEZrTG00TmFxWVkzTXh1cm5VWDV3ZnVMRlhQV0pMVDFVSm9MWmRyVUtJcFYzTVdGQnFZNVdjVUFJUktZbE9wbjVjdktobnNQZ2RmRmhNVzUrVW1MRGFzckhXNDVZNCtwelNPV1ZSL2UvaFM5YVlDN1pVQTY2bFV3Uzl6UTZZN1kvcGhQWHkvN2cyU3E2bFgxQVJqeGY2dHM4ZUplK2lCZ0MxUGJVclU2STVRWmk1WENtQVJvT2lMOWVvUDBTaVpaV0VVdGxXM0dwbHQxT092a3lDY3BiRFVNZmo4cXg2S2dGckZLcUJOd2RUdUdNUWZEY1VtN2phejFERjlNcWpjeEhLQTQzR3VOZmlGVEttWTVBYjNMV0NtS01xNVE2dUdtVVI0aGRzTXNXV0dpTDBTMjBncE9jSDZKRHFCcW9CRzRDWDdnY2YrNWdtTGlkM0hMRzJpQTVhcUdQNkNjUDFEeGg3bU9HQ0tyY3B4NnhJcXdEOHo4L0NOZDFNVnFtVUIwUTVYZHpueW82cVk1UEpiam1PTEtqeDR3QUdPSDAxdVlZWkc2b21WK2lZNWxWTWs0NmR5OWRReXQvcXpFTXM2dVh4VXFLL0dJc2ZIblhSREJDYnFyaDF1R1lIVXhKZ0RFQWpqcTZJWWxiSnFGVXlwdTBtZ2kweXkzVVJmdERGZHppY1ZidWV0UXhIQlYzQXVGRXFBSHVYOUNDakV0dmt4cDl6aVZEdDFCL1VzQ2RibGpOZW81Zm1QMmxwUlVkS3prdEJDOGUyYzJPU3pHWkFOR1VDNFVlb2YxU3U0aFRNTXVGb2R6Tlg3VVRpcjhHSWJpQWFmalN4S2hmNWpiOFUvRjIyUUVGWUxkSkVxV3d1RndHTDllUEdCcVVUR2E2Z0hUS3dCbXZ6OEdZUXlqeGZiQW1pVUpLdDFISGNLcWVLbkRMNXg2WUk5eHBOVFVxNVpESUdaQjNMbk9DNU15Y2lieW5xV3h5UFdNTjNOeS9TUVlOM09wVkY4WUYzQlNIN2liaDFMWVJpQkNvb1E4a2F2VU9ranY0WmszOEdlZkV3djZ4aWZadG1SWDl1bVpVTkRaTWM5emFxVHhsWmo2OXhmSGw1WEl3b211SzFxNW1jYWNaeTVUd1luODJNODYvejU2OXpQTFE4YXFEeXU1d1hHRHlhaUJNTWZFK0Z5enp5TXpvaW5aUHJYeVVIVnNLaFo3bmNFbU9OaWtXc0xtVzl1b3R5NlBpdGFuUjhZN21vdndFWlUremdZT1dpSk5wREZsTlZNVkc2dU9YTDFMbVJ4Z3R3V0VxQlV2N1NqOE1adUFYREdidlRLYnVjbUpHV0pVQ01hcjU2amJMaHQ2bFdyVUNhQ3BkNGZ1WUR3dVZ5aVVSRDRCbkw5ZkJuT2RFRldEUlU3V2NBd3hXSUtrYUNjVmhqREFna3lvWUx0bGF1Tmt6OEg4UmptbzNIVEZoR0h3d3hwcVk1QU14ek1mVXRWWnhEY3hPU2ZpT09JUTk2bHRMTFdHQ2x6RXRtTE9JclRESDl4d1VuSEd1NFlNUm5FbTMzQ3VtSUh1THZ1YS9NWlN3eGpBM2JMZ3hSS2dIR0UxT1JOeXJaeUl0N0dlTVVjSmhqVmpEcVdSbUtIVVc0WkdNeXl1VnFHS3lxbEVHcGJCZ2J1VmJPRGsxTXNFbU5EYkZwbW9taU5Ua0IxTElmQWdiZy9aaHVIanJ0bmo0NGNjczRjZWJPcmpTUnhVMHdFSmpldVJNc3NvSzlrUVRVcmRRQTNGSmVNK3FSaEVpVGw5cHkzMUJOMlJ6VERVNTV1MmN3TlQrWU84Um5QQi84QTFVeHc4YTJqSCtOYXhzbFk0bHhMaTNvbDA5VCtXalJITEo5eW10ekRBaGlzeHdKU1MwTGlyTWNFeGJZNHY1MUFuOGRFY0JCdU9vWWx0c0NOWE1YYVRWTzR0bGt1eW9ZNGt4bzlUamU2bXFqTXpqaGo4Vk9FTU1yV2JHQTl3cGl3Z1ZHRFJNVzRmWnE0KzlkZitsekx1YzNHYlZuSmpHNE5sTUVNV1ZaT3lwMFJxT1FPaVplUytpR1NTMmJscVJockdYbDlSZ2x0emwrWmNWbHprU3grYm52NEMySjlxWWtDRVI5Uk5WY01IOHhQYkwyb1RrcGZ4NHlzSDQ5c0l5d2wweHlzc2dRbFM0RmJobFc1eVc1aTFFcUxBU3BidU9wdGdNcXB1WitYTElBT281WE4vSFpxRWFZS1FiWUZzUWloS0NiQWNpcGtSTlFtYTZDRmt2OEFNd09UOUdZWjRuTGtibVdRNDJNOEhqUE1OK1VNam9ZbzNqUmY1bUx4eXBvbENxVHdlSEY4bi8yWk9HQ2Jabmo0ekpNTXJ3T3N2ekwxWHFDTndTcTR6REJmTGpQOGdCcVo1WHFwanAyUXhyS1l1R0YzajNPTFJVN1crNFJvZGs3Z0I3blVKeWJtaGdjWGNFQ2ljall6TGNVaVFKamp3RllaVFo2bitwZFN4bFZPL2hJSDdsTnlwemhPcHBobGJWVExMVlJJZktRQUxaNXNNUEdZWllacTVGcEh1RE5GckxVZ2ZBQVJ0bFZPb1ErRWx4blpVMThYTEZtdTVpMFd6a21qWXp4NWhwWmt4Q29QTFFSMDhibE4vd0NvNVhSVlRRdnMvTUJmMlFLM0FhTG1KampsYk1uUE5DZ0NHbW1jYkpRTVJ2UjhjT0xNcUlaemxOT2tpeTZaZTVjMytmaXJMbE15TkZURUh2VXpLeTFEU3JIcWVMeFo0UFBLcXJxZnlHdnFGek55d3lUMHdIOHhLSmVMNGdMdVk0OFJmakVwZ2hLVU54YWFpc3Bqa2tVZjl3MUhLRGZ6ZFM2SXVwYzM4SDVpd2pGRDFMY3RIeGZLY1pqWWlQVXp4ck5YcExsdEpBcjUzUDQ4akcyQWJoc2xoTk1BV05IeGlMQ0h3RDhOMnpZUytRRjFLNGRwTFlOR3lGc3BnRk1HeXBqalAzY2NqaHZjUFRVeXozS1p6ZWdqOVMyUGsvS3M3amtWM01XMW03WlZ4RHBuMVkxWGNNaUVHS2ZpYWVtR0VPNHloS3VJOGF4aCt5QXZ2VU5UYy8zSFIzQXhsemxycUF1NXpmWkFVMHpFZno4WmVURkFKZGlFQ3NKejAzTFdBQmF6dlZ5djM4TGZ4a3duOGFGem9TNmhpRXh3M3lZc0ZZekFydHZjOG1RNW10QkJwWmN0L2NGcU9aRE9XVjhXVG1RYll3bU54dU9vYllQd3FaZkFrNVJac0ppMThDeS9qY3hYOFJYOFJkZFFsekdMQ1hadDJUVE9WNlNPdEVOeGVBa3ZST29XN2x5NEpVSGxSVXRNNWxrOXNGWXpIRTZXVUh1VkxncVJ5ak9WZXBpcmhGZnhOdytGSTFORWZrMmRTN0srTHZvaHJzamJaSzY2aVhGMjFOTld5aWFpVy9CdU91aUI3WXpvMUFsRTFPUDRsRlZOeXNYdWY4WGpNL0k1NFk4anFmMndocytOeTA3bFpQclV4bzloT09PWGl5eTVuK281Nm9tM3NuTDFLMWN4eWNkeDhybjJzY3AwWEt0RTFDWWVSNjkzM1A4QUxMOHhpalZYY2NoMVZNRXEyWmVYRFBpZVBGSDNNN3Qyd3lZNU1EZGtNSFBCeVJudlpxY1RpdnY0TFluR0Q3N1p5V0dWVHVjZ1p4eGRrdGd4VklGa3BoM09QMjJ6UkxnMFFiK0tyNGJUVENWTVEzY3VWOE0vY1dwak5rQVJ0Z0Z3c1dHTVJ2WkZ2VTRoRUlYZjJsdTZpQjdoVjl4WnZoY3NKNzFMQkxJb3VqVU45UkowazdZSmpldmpXY2V0VEdxVm1DSlNSQ2V0YWxmOXppazR4eHo0VWJKeXlyaXVwZ1cxeUp6MVNiZzNuMURIOXloblRCR2M2SnlLL2NYTExMNXVjdFFMTnd4MWNKVmtxcGhNL0c0b0QzSFdtTEZsMlhjeEZ0WTQvV1lONnJVZUdSZ2NLMTJUTHhVbE5rOTBFWmhmOGVWcEJVZ1hLaGcyTWROak10NVhBbHk1cmoxdVBJTncrR2RSbjRmZ0xnQktqa0V3cG5xVmM0emVNRU5zY2k0ZGFuL0NaTG5pZnI0TmxRK0JHeUNvREV4NU5hZ1hjcUdPemNSR09QdUdUV2lEZUhVeEc0RlJXNDlTOU1HNjFLV1lHTlBLVmd3bzlSMjlSNGtBN3VaNTJhS25ESm45U3BnQ0l4NDBrc09pWjF4eFJscm9aNHNmdnVlUzg4NkoxMmt2R0FMTERvbDJrYk5oSGIzREdHRzRnZXdoUjIzSGc5REVZWVY3Z2Z1VktnMFMvd0J5MkNoRnNnakZxYWx5cGNwZG1vekM1V1hyVTU2b053d3UyeWRGZkZnUWprVjFER3k0bjF1NFdSeW0vanZHWlpLdzQ4RzJIQzJobDZLbklKZTQ1VER1Wkl0a0N4bUNiV1A1dHFPVmtHWEFZc0ZtMlZBMUhzQ2JHc2hJdHNTVnI0c0k3WnlwMlM4VitidUdRVGxmdzNLWUN5M0dPYkxVaE9NdW9lNE1vN3FDVXhmVlExOGRrclROSHg3cVZZMlRqS2RVd3UySXNNYW5HTVFTYmdFY2dqc3VhWWpQRmd1T2JmUkJqc2hMcU1zbmJDQTB3bHFUR0hmeFdUTWRWWktHN0NabkZsQXlodWljWnFLZW9zeFpVNzFFVFNWQ2dtRlBiS0p5eGxTaTVZeW1Va1JxWVdZSXhRTk4vRzV1SE1QMU5CTU1YSXl5dlJHZmJqVXlLSi93U1l2MXBJNm13NmhuTGcyc3dlS3R6L0o4eG40Y0hkMGJtYjlyNmkwVVRZZmFiN1lZcm5RUjJwT0VORGp1YU5FMlE2NUlsekdsZmpxY2ZkeDEzTFdmV29Zcmc1WWpSMnhJZ0J1WFJISXJxYm00Rk5zYWU0YjZoWTl6L1VKdnFBR21EU3dxTVZTTE9NcmNKZnFhY0g4a3FaQ0dwVjBSMVowd1VJSEo3cVVpaTNLcUROUWRsN25qeU9lV29WVE9KU3d4VXVkWVZMSFZReUNidUdXa2FocjQ3WDNISFZrdTRhR0JMSVRrblVNdnpPVmlFd1hFSURtL2laNEpWVG04S0llTnpiSTE0M29qdUIrNWoxdHFDQWt1YXhpaVJTYzQ1MzhIdzdOUXNLZmkvZ21MYTVQWkczQnlaYXhRUGd5bk95cGcwekh6S1VFMi93REtQMWlzdXU1elBVNVB4eWxvUzV6VFU1TnpiN2dQdG5lcmxrZXYzQ2NpT05RWnlFb0lOZkMwUiszY3dLNmpkMmRScDJRUStMbHd6VEdxbTBtSGpjeDNWU3QxY3BjcUk5Vk1YN053eHZPQlh2NDZIOXl5cFU5N1lVYWxtTUwvQURyNHZyY0hVNWFxY1R1NW9ZWnpyY3M3Q0xOdnY0VUNkNHhWYUdvQk1ldjNNc0VhbXlZMDRwUHJlcHl3TVF4LzduTnU0dG5VNC9VbEJPT1VBSnRiOVN3bjJkakRrc085eGQ5UWFtV1ZrdDZxR1ZPeUdUYkdHZVBHa2xub2pPRE13Q3hsajBRTFlDUjZZWXJBQ1paUFJBbHMrNGR6QXltNXVhbEQ3SmtFeGFLU1o1bFZNc2lnamwrSXVYNGppMURVWVNsOVRFUVpqY2QvQUxNS0xXWGp4bytEaWFqM3hqOGFJNU14eWprUVNMTWN2MU1ta1NaWnVUYkVsckxsM05SdUl3SmhqZmN5eElIeHhoaXl2aXlyWm9tNGE3SVVXMUc4cC9HMlJ3U2NHYkNuNE1aNlpqYmpQMFNva3JLQnJmOEFhTGp4Szc5dy9xekhCWTRPTU1GMVVSV3B4bFZ1ZjJZRWRZL0cyWWhPMmVHaktPcjFxNFpoNmdqZW9IeFh3RlFWME9vMUFTRU8vZ1k1TGxWNkp1KzQyKzV4U0JrbjFqbEZZRmJnU3ErQVZzWlRsL1poeGdXeW9FcFNHRTQ1b3RFd3ZHN0oyeFU5UmZTekdweHJ1SWVwamgwckh5bUluWkRESk9XWW1ML1ZsSU5JRVo2anAvMFJ6eGNwZktkd1owNjNOY1laQVZVN0daZi9BTEtmcGk4dlVGY3BjTHpvdUlZNUZPNWtiWDNCZTRydGd2R1VrY3VlSVBXTWVQR3pMNHF5TDlaU3lwU096VU1uN2NWNHZaOGErQVlWRnRvanFOSkJxTmNaaWNXZm1YRnRsUWFoOGRIL0FLY2FiK09tWmIyTXRka0hsM0tKcWlYdWQ3WlY3T3ZpemtFTWU2bXhtMkluMXVKREgrUkFtSndjaEJxWFl6VEVvdjhBTVNZUVcwWVk3cWNacmRkUWVReWtJRWFoQkdpSDQvRXRlMGlaWHJVUU1OdFJ1dmpqa0V4RlB0TXU2SmRUbHVjcGp1NTlXR05ueVAyWUV1eUZUc2FtTTQzYk1FTUZkeFdNcXlZNUhPNmlDNitERFBoejlYTUZTaUpMVkd1b3BVb1RjQ3BnMjdqNU1Sb0p5bVdaVlRrSkIzVTA5d2xXU2crQjM4TEJtcHNXb1FhbmJERUNZMmRUTDlNRUowV3M1Sk4xM0NMYjhZMk16RFZEYkFjZDN1Y29iYitTZTkrbzl0UVdWcWF2UkttQmFqcUhqeHZ1WkdGMGJuSGpMdCtET2pxYnVLUVFKL2I0c0ozTWgwRUNVWXk4VGFUTHl2VXVZa0J4SUR6YW5xcWwwUnphaXN3NWtwOWtVSHFHK21BeXVMdEovcWVyZ05YY3V2ZmM1VjhOZHh5SlVDWHVPZXRSbXpjRmphT29jb1paTFZ4cVd3WTVoQlRjY3NtRGt5OHFxQmxFemp6cTVkZ1J5cGJqa3BERmw1UldvTUtZcmM1dEpPY1JybWRRUmgzSE1PaUZjSnA2aXZHd0lpN1lNZjYvRlJJWWhFNm5EVUtDSW12Z05NSXR1cHI4WE1DenFwdzNkeGdzSXRTN242dUR1b0RPWDdoSDNESWpudWttT1gycVpaanFweW5PUGtHcGxtSVF6SmhuNDNTVHkrSXhMeGJqb3VZcFNzQjRMNm1LRVdLblVHbmNmeVJiSVd6QlptcDNEeUk2ZzEzdFpsWVM0YkdlNWJPVXhMWndJaU9wNGRaN21lVnFWQkp6ck9aMXY0dWFaV0tUR3NZcEhJaGtJd0pwbFBSRUR2dUZMRUkxQ3pxY2Q3Z0V5Tkc0ZHNXZHdvZ2xRTUNDYlNPUXl3TlRuSEpRcTV5UWNSaG04WnBsckhBV2F1RjVkemk5ekxHbmJxQmJycVplVHlaK0k4ZVQ5TWVnbkczWU1ZUXd1eSt5QnBLM0RGUm82ajZqWEdZNmpsOGN1MllXK0RJZlRjRzhvNWJTUFJEVE9tNDNreWs5ejB3NUlVUmFZT1RpZ0ZURkYzVVJZUjZTV0FWSDRLQ3BvTG5iZGFobGdhZHdnTnppL0dmNkpvTmtEZ21Uc1kvYkxXcGRMR2Iyd3VYVTFISWd5dlpOcnY0dlZYS0dkWmJtK1RNV2hHZlU2SDRlNFZjM2xMUlE2Z0xqSHViTVg4czdnd1o2bUdONDVJMVVaalJDcllyWWVwZDU2Z2NSZno4Q2hxR1dua3l6MU1kRE1BNE9waTl0UkwrQVYxT1cwZ0xQNUVTWjVtZWN4cnFQaTVGNHNNSGozT0xYY2IrUTVNU3BYdy9HUGJEdjR4MlEvcnFHSDUrS2FZbFkvQ1FJUUw3aGszeE1uODFNRDJ0UnlvcW9JSGM1dlFTMGl3VWpkd2hoelc4b0NLY2lEM01UM0xsdUpSTGhLamNENEg0cVZEVXV5Y2dJWkFRaVdFSUdybC9OMU9mMWYxTHVFTGxzTVozbDhHK29qS2FnVDZudVpaazVFOTZuSnk3aGxGdVUvRGpLblFrNDY3aGpDOFl3eFdZbGR6UGJxT3BVQW42Tnh5eWdaVCtOZmNmSHFjR3R5bXJNcGV1NEY3VzV5eE9pT1VDMjJGR0U0MFd1cFo2bENYT1JCRWJKWUFNdkdHUlAzRE1acS9pNlpiRlp1VnVmOG82WnRlb0d1cFVkczFCaVpIeDZZS3hUakJMcWN0WDhka3JHcFFFY1N2aS9VOFdlSS94NVZVekRES3cxTEVtS1RMcjRCZ3Z0MUUzQnZVeXM5Unl2NHhSZDZqa3JYNGhsbEY1RWM3ZTV5WU1XWFJCNGJqbjZKeWprdnFjb1pWT1l3eXJydUM5cE9kdlZUQlZadVdrdWJoM0w5emt3dnVIMkpWTzJMQkpwbUdlUVVzUVNKNmh6TWF2WHhpcnBsVDl3dXBUTWJpdlF6ZjhBeVprOFpiVnptczJ3c2gvdVZUdGxUblJCWmtvd1Z5c2lxczJrSnQrUCtvaksrQWpoRXFYOFZ2VEVWZ1Y4QjlwanFOckRGcGpBdWZ4d09NNGNtVlRVOVFERW9aVFhKbGtzZ2tkN213cVhBWjZnTUdocVlDNDVMTDRLSmR4cC9VeE95NFlaOFZJRm01N3FVaHl1T1I3bUxwQm5jTkVPU3hLK0grc3hCOEdVeGFXZTduSExoZHkrbVl0NWJqcFlzeEM2aXVETVVwaGxPTkZ3VjZqR0I2aTZnM0UzTTZnT1Fvd3FLMEU5eTY5emorNERLVVNlaVpKNm5aL3VWTVhscWJHREZuSWhHNWN1SEc1blM2aHNSaS9HbzNFU29sc2RURERsYmNST3BqMy9BTnpJaWxRcjVOR3BZZk5GQk9uNFNtYmdQdnFHNEI5cmJtRURhUUppOFlDS2tNWU5Rb2Q5VEV3ZDFGQjBReUFtV1dUMHd6T0NOOG9XSHgzOFVSZng4T3l2Z2dSZ1RFNHhlVVdWSzFURWpRZkdPaWJTd2dwTWM2bVdTa00vekRlVVduWkVidUxDWWs0a29sRjl5NktHZEU5eXJtdlV4Qlkwc0FJdjQrVW5VOVJGaGg4T0xBbkNZNnhTR0pFS1VnQ1FhSFZzSGtwNlpTdFIxTVhYeGRNeHRXT1BFbUhHZldHWU5KTXNtdEV0dlpPVUtZRkRjYVlIeFN0TEhEOXpaZ2x3V1ZLVTduRjlQeHcvTEtRN25Vc3VaWXZiQ0RVNTB0UzFKeVVyNEZlMlczdGwxcjR3MDdJNUY5UXlLMlFmVWQ0MUxldTRtdFl3VUVaaVdRZDFNM0Z5cUFSM01ycUpOekV0bkhFLzNNdkxxb1V3MXFERmVVOTdtU0xEcG5KS0ExT2N3YnUyZWxuTEtMbE9UT1ZTeGc4ZGtzaFNkejFVTUxqalZGL0ZoRS9jQTNiUEhuamtjTW8wS0hxR3BtMEN5OVQrMEtCQ2RRczNGWDRxVmZmelh1NXhXSWtMcUN5bUJSOGNmZHlxbVIxVVBmd1A1K0NiSU5IeGxnNHU0V054cFZoRFR1Y2owUWZSOFdzMVViaGNCV1pGUzRRMnpRTzRCN1l3SmppV3NyMnpqWGJNc0c0WU00bzZoaWkzT0dTOXdHeUlyRXl4SVZpUHRaaGxYWk05bjdlb0xqL3VMWkJUNHhpUHVKU1V6dGZpdGZ0aGkxdVhXbUkyWDM2bkJoalVlUDRtcWh1VmpISEFlN1lwTHAwU21jQmFDR1BGUmxKamZxNG0rdFRyUk1NUnpnWTdKa1E0bW9BcVRMQS9FcU9pWUhLR0FNLzFBL0x1VXpIRkJaenlNSEU2Wms4OXA5aU5KRDZMTDBCTExtUnFVcFN3bW5xVTNCMjhvNG5LUFU0dkFZdkNZRC84ZlBKaDdhaDNzaWxJUTJCTFRKSVd4MVBkeG5HcCtBbWVrTHNtSU1RTk10WmlaWTJqdWIvNWZHZjZOUXJyNTdiWWZPSTBxd1ZkUU4vcWNRSDVjZUZKM085c3I0VTlFVzU2K3M5enJ1QU1yOEVjbkxLYUJaMlhGdkNVTHRqT2JFaHAxTFNmNCtCNVBMeHl6NHpMYmtkMHpFTEY2bVJoZjFJUThPV1dHV1lmVWcxTTZOc09tVkRiTndMK01iWmw4T0FBajNCcmNVU3p1QW0yZHpBV1p0ZldkSmJPQ0N3eTFxSy9HNEIxRVJTSDdpK3NJQWF5aFVhUGdqQml3UGd1SWtHV1dUUExFRU80MzhkVEVXNEtXZkJGMURyY3NyVVB0dTRxdW1FQ0RTeFMzNDBNY2lBcjhZSjdpaExoQ0FCR0xyVXRZRVNZRXRnbHh1ZGtNVUxaZG56YlZrMzZnWkJiRW4rNStpRkhjYW5LV3Z3Nm1EQnRyS2ZzWWtDTDFVeHh5VmpaTVZqQ1dmR3BvWlozRGlSUWh1TXNuSmxmQmpSY2ZqbG9JeWlHSXdRbklnM3FOTER4R1RydU9EakF2S29ZWmN1NWhqYTNIOVRIQjV3d3UwSTJmOFp1WkdWVGdyVXl3Y2RFeHg0bHM3ZFF3RzJHSkVDWVhkVDY3cnVjVmhpVkRCaGFNdzF2SWgzb2xaT2lXbXBreGpoUmNEVi9IRmZVNFJzZ0x1ZDMrb2IzR1craUE1YlNkZGR4dzU0V2R6SEZIY3p4NUtUaEI3alUweG1qR0tTOWZCQkpRelJGSzFDd2dzVmpkVFpPNXVOc280WEc1a0JBWjNMcVhOVExMbXltVkNlOS9CSzNMSlVkYWpnaE1MNmlNcFpUa3pqNkk0dW1vQ3ZVcGppa1JDRm5jK3c3bkp1SEsyS3dYS0hLSHVLcEN6KzB0V1BLY21JNWZhWmJKam8rTCtQVFRLeTQzQWJEOHh3NFpPTHVvcmNKZGJZS3dIdGpuaVRtTU1naDVQOEE2Y2pqQTBFWEVLamtFTXJqNWZ4T1N0c0hsNCtQN2c4YkpraXpRTEFEYzJ2d0ZNYmJDSmtFQXJjSVkzTWFGbEhLMkxicUNzTG41bklxS2FJdUlNNGtSaGpnM2ZjQ3RzZjFCaWhVN0lvTlROWllwY3d5L3dEcThoNnFHU0VNdHF3aU5URk5qM0xxZHgrTGdONmdOcjdJTzdJN2R3djFPajl4Vlc0ZXk0YU5zQVQ0ZGFoUkxQZ0xoZTRZdE5laVZZTWJXSWsyekpvTGdpUWpVSzNBaGp6ZFIxRGN1cGo1T0IrNXRHQlJiT1ZuNmxIOGF4QkIrRGNKN2pNRGVQS1pNNHV5RkJMSVp1TjRtZW1lMloxcE81Y0RVcjRFUGd5WmhkS3crMHA3V1k3UHJBN2cySk9LMStJNWNTanFGSzhvZHNGY3FnQXNOTjFjY3VYUk5oU3pqKzRZcm9aeGViZnhsamlZanloZFF0LzliS21LcE5WTnphYkp5dkhpWXlxSitXTDhYT1VJRXFIVXVtYlhVVDV2NFdvYlBrVmg4OWFpd1NLeiswdWlwaUVzZFJOVERSRVZnRmZGN1laVnFWYlU2dUc0OVF0MUFQY29ScUpLcVdzWlNRZ0F4cktIZFBVdCtQMWN6emNnRjBTN2cxZnh1V3IwUm1tWWhscGFpWTQ5WlhIRzJIamQvaVkrTUx1VUd5WThvdTVxVTVFQi9FcmV5ZDZsSjdoWmR6YUU1SVJ5WmlLYUxtSW1LWk00Q2IxTXNNUUhHYXUyT1hJT09raTZEbHVaNGNXN3U1aUlwTXFlT0oyOXh6TVJNY056eG9ieWo1Z0tDR1N6SzNIcGk2MGtja29HR0ZJT1dxZ2NsRmwvV3RhWUp1RjR3eUZ6djNETEc5TStqbXNMQkNiQnVJSVRscVk1NlJnaGl3ekp5SlpLbytMYWhoQVErREJmUk9CaXgxY3QvRnhGYjR3Tnc0dGtzSmhsd2YwekxDemtUdFZJbjRJRnNvdXB4U2NkeDNxQkUzS0NaQXp4QmVVYXFvQWt5TU9QMTdtTzVRblVhcUVkNkp4QmlGeGxFQWdFTlFTMkZVd2NZc05kRXg3dVdjbFNOSFJxS1ZjMnNhQ0pmd1hLdktPaUJPRml5aW9mcUR1ZUl2SkdQWVBxRFVWeVpYcjVvWUIwUjdocXg2bUlaTVRha0tsRTFmYk9KNldhNUpjOFl0bGRFZkhoM0RCVkExTXNlUDhBeG5RZldZdU5PcG00Y2VwajVGeG82amtwM01QSndibUdZdWF6RGJjd0JmdjFNMGNxd2d0Vk9SYlp1WUdtYUdGN25FWVcwUjB4VzVwZGt6SlpVRlBoYm13aExDYmcwUXoxdUtkczVRYWdqYlU1TEh1NFp0VkdvcHdvK01hdGdHNDhxQUxJNTBhaGs1bE1jalF4TU9FNDN1Y0xxaTFqZUtuVE80bEV5bURXR2JPYXpjNDF1SExJWWRqSHhKbExDZHRSeFRWeEtqUXFRV1lmeGdtUi9xZDZlby8xcURSeHE1ZjFkRWE5UzlVeGRRYitBamhPSmdYUGV2amw4Y0hNdkhjNFViZHcwTW82ampVQWl3RGpxRExxYTZqUDNPMjQ1STZJbE95V1hjVXFXVUV5YjBReG8zQ3dSbXExOFlaZHkrL2dsVXNQanNqMUNKYmM1dlUzQVplTmI3ZzVYS1Q0d1hBUU5UaWRqQXMxSEtzQUowU2hJMVZFQkdkTnNNdGJqaGlsNDVQS1lsc3F2VTVmalV4OTJ6SU1mSEttRmhGSjFQZndZNDlyRDlUR2k4ZmdTZGRrNUNkVk0vNjNGckVQY3UzcU5zc2lJQ21tQkxxSHdrL3JqWkwxZnlXZkZhM0FZNmcvRncrRDhzcUdJQ3N1QUU0cHRuT0REY0ttTGJSLzZjWlcxSVFJZ0UxQ2ttTHY5UktmZ3RhSTZOL0RMZlJOeGxsUkpRRjExRkhTU2xGZ1pJYTFNUmlRTjlmQVNnSWhNZW9XUzlRaWEwd28vdHVjbjhVUWFuSkdjbHNINHl2ak9JR2xXQmNyY1Myb1ltT0g3bTdHWlpaWjd6bThjR0Y1UFV4d3pSb0tpSXRFd0JOeHFoSi9GaGw0TDUvL0FHallWNm44Zkl2M2NlbjlNeUNLWXdjc3JKMUhpeWw3WUErNFVMak9OazdhbG1HazNNVHg4VnlJdVBIcVljYXQ2bWRhSVQ5VExGdzIrNWpzWmxUVlRTd0NHV3BVUllGRUJnWXl5OUVUazZHT3FLWUNyS0FUZHl3bVBUT0U0cVR4alZIVXo4YmpsVSs1ZU1SQ0o5TFp3end3TXNrNHNOc3ljWHE3bitvZnNtZWVDbFl6R3Q2bUY3aVBLWWlRMWN3eFcyNnFmOXhDRXFpeUJjenhnYmhpRmtxVjhjZTVSQW9oTG5aT3NTYzFLQ1VrQ0JiT29Gckd4aGR3dUcyWFdGRzdnNmVSSzFRVGlWQTZmY1VXMllZajE4QU9WK3B4S1poaFlyREVPaGdIN3VPSXZUREczOVN6Zm9qUWFsVUxLbExkc0xIVExNK2pjdzhqamlnZDZZWUdXTWI2SVVpemVSUkVhQWlCZ2xUaFFzeFBjUWNPcW1HQmt6K1BFTzl6ampWcnVBV293NUNUamFxN2dmYWNlN2hLR0x4dWJZT2taNnU0TEtPTnk1amh6ek5sTTh2aHk4R2ROUnl1Vk9KZHpKMVpDY3Q3amVXMlhGbU1NcHRzaG9XR1NrSGMxdVl0Q014d00rbWVMeWNCRUdKYkR2VTN1RFFzeHpaeVRMa2V0azU1Wkxsa1dzRFErNFg3ampNY1V3emZVWmFNeWJKam5Ra0JoazVaN2RWTWVQQnMzS0Rhd2U5M2NkVTl4VjlRSXBvcVl1TG04dEV6UHRycUdaaDJSM2N3OGZQTGpqM0hDczBZNDE4RVd1NDVReGZkMDlUclRLbzJrY1ErT1RqL0FGYWx0NzNNeGQvRzRUamNRTkVRUDl5bjQ1UFZRNmh1WWk2OXkxMDlrZXFyY1NEK0Nka2I0eE5rc1NFd3g3djRWSW1obHF0UXBsaE1tSHh5Zmd4U2Rrb2U1b0lNc25KU0FVc05Hb3JXTWRreHh1eWNlT1UyNVN5NWpoSzRzMnN3ZFV6aDlybkdZVzV6TkxWN2dyRXFCUXJLMExFWVFnbW9oaTZoQW1WTEx5cXIxTDlzenlLK3BESElMWHVibkp5eHA2SnFkd2hBVi9VL3RiNlAvVXFaZkZUY0svN2dyM0FyNHE1a1ZGc1BnZ3JBdVZYd1dNcFdCWHdCTCtDSkQ0TG5HWmJ3aDJ3NllIS1krSGxpNUQxSytBVDNLWUVkTngzT01DbUNYTW5jOXNwcG1Dd0cxZXAraVd6Y0ltcUp4U2MzcUhKYmdMbk1vcyt4aXNFZTVxcUdjRWU0YWdXd3cvRS8zQlNHOXBMVHZwZ2x5c3NsQmhnbnNtZGgzTUJjYXVDZ3prNDBFc2N3U09makxnNFpzSEZ6UTdJcTVSSHV5R1N0VU14Kyt1TlZLQzVXVmFta2Z5UXdVdUY0emk1TnZVcDJTbG1PTEVRalh0YklWT3RRRTNLRzRoamdUREF5bkRFSGN2RTl4ZGErTXJtQ2pGZnpCZnlSeVJpbVhjQ2ljcGprcXhvOGN4ZVpNc1hGdmtSY2w3bSt2ekhXbG5GR2U5azRVMlJWZ0V5NjFNY1dhM0taVlRBeHlHMm9tUFJINUdvc3lneFNEVU54aktLamlQVWNhK1IrTHNoOEw2SnlBcG1PYkJXZFl0aFBWd1laQXh5M0xBbGtIRTJFNVlyQkNEVTVNNXY1bkpYKzB1ditVYzdOVExOcmxGeVhUT09iN2lJUmJJSVRsV0dxZ1BGbUtCRnh4WThVYW5HalV3TlJZWXdJNUFWREtpRnN5dG5Gc21XUDJtR0ZYOEhqS3UyQ245cC9xY2I3bkVtZ21XRGpLSngray81RVFYdXB5eW9WdU90d0JQakwrc081eUpjY2ZuM0YrMHlRYUppNzJWTWd2VE1lTTVZc05iSDRjdHd5bklnRHEwampVOUxMdkdZVmlSUmpYR0NBa1RjNVFwbEJxQlVxb21raFVPMm5xYngzY0ZyNDJKdFkrTm9YM0NYVGRUdmRFR215TkxCNDdsTHRqMU1TemZ3NXJVUWxsYUloNmczcUx5WWlUMjNCWjczQXhtcGlQS1pZcHNtL2c3bXNmNnhGZ1VYY1dFNldBcE90UWw3Z2ZIaTI1LzZscDFISEk3bkg2c01Ic2hpSkhVY1VMWWZDMHpFNVQxQWwxQXVJbndCQmFSbUdaU01IVTNGQm51YlpqSGpYYmN0bW9ITGNialppTDFBUnU0dlBHcUlZd05LcEIrMXhiZXZoT1JxSDRoa1k0cHhJRnNEY3ROVEoxQkEzTXNzWERpQkdkRXVpWUhkeFhxWWtlUXltWlpmVGdmN3Y0M2NwZzBSMC93RHBaT1U3K0tvZ1RycVVCZHdaamVWd0ZJRlR1ZFNwZjVuS0RCQ1hpK3BwbGNqU1VUUkxneTJZdFMzSktnMW5YcG1XUERLb0c2Z2s1b1FhWXU5QkRxRTJSV1h1eUpxWFRMWld1VUNoV011b1BiYzB0bnc2YUdJOHBhUWZyQTNjeHNzSWlUanJheHdPcmpvcTdJQkVMMlVFY2k1eW1MVXNFcG1VY3dnN2JZNXRrd1RjNTFpNmdoZW1PWStxbUEvMkNlVE5jT0ppekRESlIxS3k1dHM0WldydVltSm5UTmY2L2M3bU9XSWhPZGJKekl1TlJ5cjMxTDVOd2VOMnNGN1p6MU44b1pYM0IxSE8zdnFPVjNaQ3ZVTm5VeGZVNHR4UHEyYUl2MStwY2I2VHVVVkFjUzVqZzVQY3R1cmxOWExtTzQxK0lCN2wzOENUMVZFS0hsVlR5ZzQ4eUlkQkM1bHNxWDZqeGxFYldORXhVMVV3eTRzeXAzTGkyVk1kRERTdFJ6cjFCV09WR3BobE1yWnlaZkw0dURSTFVhZ0pOd3ZIcmNjbCtLcjVyVUVDdmhnWExCcVZzcGdiYmlZblg0K0FWdVZLYWdkU3BaY3ZHQnlZdE12VUVpeHppcWFnTlREUk9ROXl0WEUxY1Q2UXFyV2FYOVJvaUZRbXdqaXM0Sy9IRkJnTTJFd3Rtc1NDRzRlMjR1dE13enFJWlJBNllZeHhuSDJ6TEhKMnNTbVVwVTQweEZiZzBKM2M1VC9lcGNIc2drNHlpQ3VVMi9IY0hTSVRYd0JNY2QwVEx4MDFPTmZDMmZQN3VaWlM2SVJaeHRtc1N1N2ppYUNaK0p4YUVqUnBoTEJaYWx3YktmVTdaeHFVWFByeWw3bHk3TEk1NVpBSzBRSUVyNHg3NmhXNGZpWkFNZTRkUTQ3Q1pIRmwxRmhNUzJMdEkwNFZDTUlGNVA0Q1lhYnk2OVRQWk5rUmxVL0lhYW5BQ1UxcURMYmkyeFc3Z1hjdW92b25pdTh2L3dDbVhITGZkekxxZVB5dmk1SEVlUlc1eC9HVVNqY3p5NTRoVlZFVHVjYlBncmsycE1ZMk5RbEJFOU13SzMzQkJoaTVDK3B5SEZBZ2xCRmxqNDNXNHQ1akcrb0U3Ymc2bFMwTlFiSm45bmplaUZuK29aQkIzdGFqZ0xvMUhXcGlDTncxQzNxRHhqdUUzM0xqRW1PTjZKVnYrcHRWOVRBdTc2SmZ5NE4zY0pWeXBWd0tpYitENHFETHVibE55MXNqazlWQ3pTUTNLbXdnczJ3b2dUR0pUc2pYbytDMmNaeGJKbjQvRGgvallaNGVaNXE2cUJlMW1WSHFWdWlVbVZRQzRJV0VCWmo5c2J5N2hxRXhTZDNST2kvbmxPNTFFaGpjcmRRdGFqK0pnNGdqRzd2dUFNMFRUSDgxRDRhdWM4UmhtRVBKSE5mVXVYRnJQdGprNUZZd1YxVTJ5MktWRHVmV0ZNMEU0aGpabENGVGlEUDVPT2cxTWM3ZXB5UVg4eHc5eW02eGxOM09QMXFHaUdJckVDSVRLbVdkT002cWlaZnNqNUN2NmFKWTc0ME1Nc2pDNm45Y2JuSyt5YzlzR1lUREw5YWxqNU5TM2trNXRJbW1ZNWNWQW1XV1dlMkRGM1ZUSit1clBnY2dwNm5MajZuYmZVdWNZR240REdaSVowTUc1L0lWVTVtMlljYlc0NUZ6a1RsakxKeVlOc0cvakpseTVqbDNCV0l6RTVhR2NZYVk1VFVLWldKaXhNUU45eXlYTzQ0NjdtTTF6L1VYRzlkVFdVR1k1WSt6NGVMQVBnK0JyMUtiK0srQVp1dmtjZmU1OVB4TVE0clVURGlOU3pxb2YybWFkd3BoaWVvOFpRRXlNVWxhaU5oY3lPZ2xlbUFrUkxpS1RFbkwwd3k0emtyRTkzTGFtMGx3ekFsd3NMbTJCUVM5M01SeWRSS1lMTEFpenYzOFdKTDB4ZnBMWU1SZTRBc01Ua3l0cVM4b2xRcUt6L2NLSmxLWS9CcVd1Mld4Vm5CWTQxTHMrRm1xaCtvVGtTeGdveEpSRHBxR0YzRjVZQWFxVkNLd21WSHhVQkQ0MUd4SVdxSlh4NDhjczhnOFplZm9qYnBLUjNOWHFMZmZjdzd0bjVTZUZ3UEY1ZVhiMUZ2QlYzZnd6MXVPOTlUVU55NEg1bkdtZUxBYnlXVUwraU9WNU10V2JJN2Q2K0NMVFVDbUQ2aVZOUy9SQ1ZORlRPditQYzhhbmp5LzFBK3NzUGpBZmNhT2huWmMzbEQyTUdOdzRwYkRLMkppR25jTlRIY2RreHk0M1A4QWpCbzB6R1dERjFPT1dHSTVkWlJMYXhnVVErUDFMNC91WEJtT0psZDVUOGt1Vmk0ejFwK05jcGg0elBKYnFYd1dEN1pXb1RISGtSdytIY3hFK01kM080RVBqRzdteG51TnpIRnkwRWQ1VWxUai93Q3hpcWhEWGJCZzE4WFhjc1BoZFN0RXVqNFpqTW00ZnFMeGErVExJbHpHR1RBQXVQZHhac2hjeFlqZHdManFZM0dHclpaS0lwOFpMUHR2YzNGZ2lVVGlrSEhFbWtaUURNTVBvdHhtQXBjQjVLczBaVXJISEgwUW00cUZrdzRwTStJdFJBM2NNa1dwMXVGOTMzT0wzSEVSbkUvTU1DY1N1cWhoM0RER29VUXFCYkhFSGJOZWdJdXFtVGN0SThWSXVxRFVNcHRnTXliS0lFU0kxRGJhNmp5eDBmMVl2UWVvdGs1b0VScFpqamtPOWtjUTBRTGk2MHpDaURhelpuTEJ0V08yY1lNY2ljc1lwM0Q3eXljdDdsaVhISzVTcy9pZVVmSGNjS0lZTlRoUkRLaEtKVTBhWUdNQWdGeWlFcTVaRi9CREZtSjNEVWJaajlKbFpNVldKdVhoRGd4d3cvTVFoNG51Y0kvV0xsVUg5Ulg4Ukc1MFRkMFRvNmpSaWJKMHFCTGZ4TnZjM2NwaXBMMHdabGxOMU9WRTVrTWpxRWRRVkljcVNQSlNOeTVraVRFaC9hSVRTVlA2OWhDMFpoaGVSY3kzazFHN2d6eUR5K0NKcWFZaEF1L2dQY0pWczQ1UXh5ZTV4UVNCZGs0OFpobjZ4SXU5eTFtT0lxM0VkMUJZTEdBUklDU2tZa2JwZ3o4c04vR3IrRW5xSDIxSytLQWhCdFlUamp4RDNFclJBZmJLM0daY1ZDYW02bGFsUUlTdjNQOEFjMWpCL0VHaUtNdWhKVUlsekVvM3VWNC80ZmQzTWVRSlJFUUxsV2FsVkZXSm9oNUhETWNGeFQyUWVWckc3VEdPUFg1akNORTNNWUNrRjZTYlRjeDAvcWNvQlh4aXJxaUdLNU50QkhPN21PVlZaUDhBblpBVm1RLzhwZkdiVzRtOXhEVTZMSVA1K01DYkZqT09vRlF2aGxBaVR4dUJkOXpBeTNOczRnTzRZdnFWYk1SVkRHT3V5V0oxS0tvSmpvNjNHWVkzbDlrRDRDWFdOY2R5eTRDb0h1WmVQTHh2MkVtTFVjbk4zMFRrVGxMdG42cmMxN2FZRXI4d0xnM3FpT1c2cjRIaXhSVm5ETGp6cDQvbVBkeHNiR1hiQU05WEE0bTl3U3A0bHVnbWNkRWNFTHJ1RVlOTUlNTnNQaTdJNVZqT1V4enpMY1p0eHZKTFpjdVY4ak9WYkdEN1NFdjRJWEg0ZXBWeXAxR1lhN05TdDZhbnVWS2xKQWcvcVUxS2pBblI4RlhNVVdtWlljV3BRUzhURFRMc25MVTMzTnNBOXNFQ09XTXlNZlVFbU5QWkZEb2dMSy9VNHhkQk1VdEZvaUsxS3l4K282K0FEYWJuSnZmWHhia1ZESEk3aFZzb25xWG9vbkNHQk1rQ0NMREcyQVJSVUdYaUlMQ3FocHRJRXVsTVNwckxiVEFvbkhMbFlUTEhKYnVZNHVmZDYvRW9CbzMrNWtCaUxpWEM2K3VwVmRQd1k3dVpGUHdDTXEwbmt5TWltQjlZdE5RUUdXRlRsWnhwbkhXNitEQnFaRkUyVEZMRE1vbVNXaDFBQWxzdUc1a0U0ekRGem5Hb1k3ampLdUkzUEVaOG0zVWNWdmIzT0dWOTZteTl6aFozSERqZ0tOVEh4NHBkd3hJWVlzUWhoZURsV2p0bERNUU10NkowdngvR3lxZ2gxQVZtZUxlbUYvbVo0WmdPV2g2Z0xvWnlnMzFPc1lDa3hMZGt2MUxxTnNJODQzRzFuRjl6OURHeVdwTGJTaVo1b2FobXNGV09TdFRkVGtRYnMrTWNrbkszWkh2UlBlaUdPVDZXZTQwT29Jc0hHbVVUNkVhWllhSUZuN21uUXpqUCs1c21HMWxSWEU2ZzNqTW5jWmkxdVpaRlJNUHpFQ0NVUlpqSytNYWl3aWhVVUppaVdKRUhjdlZKQUJnZHpqalU0bkZFZmkyTERLNmpsRm5LOVRFT2R2VVFWcUFSSnhlNVVHSmNjY2pFYTErWXp1R00wazQ3Z1V6Z0NxNm5JSTJ3djJSd2ppWE9POUU0empFcUN3cTl5b3piSEZpbFFJTTVmQVhQNjBHeUY3b0diRTB6MnNDVzN1S1E4Y3RNa1RVeXczZlJBQ2tuOGZFY3VXMkRxREhmd1VTN0tHQXVvWmhwbTJKS2JtR0t2Nm1oUUYzUE9pQWZHVzM4ZkY4ZW9pKzRrcUJjdDJCQkszRFpDaGxsYWxhdGZnZGZHM0RMVUdVeTU2WVcvQXIxRElIcTJHZTJzU09wbGN4UTlyRXZwbU1jalFzWTJGa2MxYm03dVdjekluK1I1ZjVzK1FVRUcyR0VSWnh0Q05ITEVMYW1KZDYzVTBTNzZZUmZaTVVsYnVEOFZSL3VHV2ZIamNXb1k1WmJDd21nNWU0Vzc2bk9BTXd4WE1ibmtFeXQvTXl6TTdLcWllREhCVEhOWi9GWHZWeG9nMjdJNFVYQzFaenhOZTRPcHloRkdXUVkvQlU2bG53Um9JUlNvMXhoamNjSUh3MU9QcjRHb2xzQWUySmVyaUFkejFNWDRjaDB3b0pjM0ZnTlRGWmlxU21KeGdMREgrUXIzRVN4K0VqakF2VU1FaUVwaFI4VmpOZW1HTms0Z1Q2Um9kUzhmeE5lNHBlb1phbHNMQzdnMzhZNExzSmtaRHNtSjJ3TCtDV3djUDNjcXlBVnJ1WTR3eHB0WTBaYWgzMFM1ZSsyZnlJc1BPbWE4ZlUvbHljZFlrRlMyRldselA2cEZES1p1T1dCeG5aVXBQamhjeHh2dGxiN2dibGhLV1pJTXl5czFPOXdTcWdRQ09STVdaWlBIVXQ1YmozSGJMT3FpSVFhbktEWHFMT2lmeUIwUzJPVlRrem5iTC9jeHlyRExjMytaeVpvUGpsay9WMkV4elQxRitDcXVjbkhIaVhUTmtwK09EcFdKdnVNQVlsYUdPb0JHME9UWWRUSFF2NWdZMHorTTlTcWdJTndIZFRsUjFQN1FKMHpMS2N0Uzl4eVg0Y2lXTVdYQmZRVGNEYmNPTGU1aTEyRWN1ZlJVSWFtb0M1UTFjTTB0aXdnUUQzRnh1ZlMyb1lyalpMeUhaTVZXNEJ6WlNrTUtpNm9oaldNL3Fhbkt5bWJpWEs0a0NLSHFJWmRSTDduRUk0K3BTRUJ1Y1d4bkFDVUlxekR4Y2l4MU16REdrZnNUUEp6MDBRUVBoWXh6cUc1eTFVY3FobHVhaWRJemgrV1VFRDRzT29JZkRuNitLRzRFd3B3UkdHRjdENENDUmg5aVpkZHhINHFXTUg0VFZ4dXZnbFJKVnlwU3hBbkZUV01weGRsUVp5SThvYUlNYjFNWmtmWWJuSzlNb0lMWFZFeWNPTlliWnMvY3JwaXJBakJnUlJsQVMxTlFmeVRmZnhpWjUyQnIyd3pMQXgxalBMbUdMbHdxK3B0MnhseTJWZTRqWkxyOXpMTm43dUZ1NXBJbFFnQVNxSmZ5WlA4WFh1RnUrTnpURjNCVmxhU0NFd0M3bmEvR1htOFgveFR4ZndIUDNuZmM2cll5b2ZoSUdRNm41NTBzdlZRM2gzUDBSYWdEY1RvTkV1bVlORUxWZmh1N2cxYUx1Wk9MMW9xR0N3MW9aVUM1ZXFuY3gxRk5YTGIvVU5zNXVHQ1l5clpzbUFSRzBKNHo2RmFtZkRKRHBxY2RwRjRZakcyaVZaQXlnL2xxV3ExREFsSXl0dzdxVlN3S3VWUmYvbzJrQ1B3WEJibGZHS2hPVXVVK2laRnZVdW01dFBnRm5iSEU3R0dQY0M0RlNwOWIrTlFXRlgxQkRMazdEMUduSlQzQ0tRZnlYRC9BSFU1VUlPL3pENzQyTzU3cWNjb1lMMnpnbHBMWHVaY2VGa05FN241QW5EVzRZUVVsNVMyZmZmNm01ZGt1ZEJPNFhNUldHSm10NWNhaG5sZjFXaWNsN1pWaFVDbTRlUEtscVorTERERERJOGhrNUd6OFFTY2pFdXB5dGxuQkJwaGt4dDFQM01PTjJqS3g5RTlNdDQvN2phd2FJNUpnWTJiM0NuN3FFY3VSSDZ6bmVORTVHSkxWdTZsMzduSTNESWcyNldLM3FjckljbUorV0xBb3RaUTVhSWFzSnNTRlBZRTRrOVZmeDlZbE91NWJqT1dXWGNDMkp4bDZoTFNZTHVJemlxazRzTUtkemhiT0NZV25jcTJlTEFXbVBIazZoT21IK3lPNXBLaUlUS3lHL2grQnVKamlYeW1LSTJ6Vi9Ba1VtS3ZqYjZ1Y2RVRVZ4eXBqbVYxREtPVFV4RlprSXpiMUxvM0t1WWoxTzJCM01PSmJrTHFCVnRtNVF1bWF2NDFOVnFYY01jSWcxdVk5TUV4bGp1T1JNVUlJNWQvR1ZNQTRWREJqNHVMdktPSzRJTS9qeXg3YmdzTVZLbU9KaVQyMFRZVXhjb1c5VGlwYXozWVE3dG1YSUxsT1dNUlNpT3RMQ0hhaEs5cE0rUGRRUkxDQXJLbTBsdC9ITk5FNUhTUk1iR05kQkFTSS9DUS9BUlV1S3NJbGtvNDFlNG4vb3hEdUZYSGlTanU0RVJoWksxVzRXZXArcGppVXlnZDdodDFxZnFXMUFJb3lzWVlqQVZqcG9ZcWE3aTBYVVdPZXRrYzZJSUhjdStvS2FmaGNndkd5SmxrN1libkVzMUc0MXgxM0I1Unl2ZFFGNm1RbVVTTWZKeXF6b21XVzJYcjl4ZmdiWVl1UXBHaUE5d28xVVo2MU9pQmszN0pqanlZNU84QjE3bmd4QVZYVS95TStWQjZtQTVJTXpIRlI5UWxRSXQxY3FuVEdVVkJvWXNCWmo0MHd0ZTVTc1VjQWdSbnVOOEFEM1A4VHo0LzQyYmxuanlIRkpWM3NpY2JzaHMxQ0J0bEV4ZHBMaloyM01aVEVuYktQYktYVTZaVjdQZ0wrSDR4dTZpY2NxdTRpZkdCdmNiSFVwaHVjcW1KRXArTXQvOEFwamtkUkxaak10WXpETEF3ajVNWEM1dGhpcWpNYTVGeXd1b3F2Y1ppMHhZVVMxNkpqNDhuZFFISDFGZnhMemNJQ201WHdYTFNXc01ZSHlUZFRVR0RNa1pVdWE0d1dEOE9VRm5MVUxUNTBRV1hLZ2FzSWZYNFdGZHN3UW1PVlAxeG1lOE9XRkRCY3UvaTBFR0FzYTZKZ1cyek9vT0k5eHpoNUYwRTNDNGF5ZTRaNmRFNVErSGNKY3VDWk01T3lvWGxpdzFCWTU2dFg0TEp2TFRNR3BrNFpHZ1A5U3c2dG0rNGFOa3lhM1VPb3M1ZXBaTUF1MW9tOG0vUk1uTEk0Z2FqWmpWWVRIQlM1eGpoWFRIQlNjWUVTcHgxcGpncEJyVnpHamRUSnd5aGdQVDhiclZ3dzRuS3liK0dEUkJ5WTJPaVdxS1RJV0JxQkYzVWFnY2lhR1hEeU01ems2WnplVExablk0aXlsYXhndU9PZDl4ZFRsQkgxTHg1YndtZmtMK3VJRU9mWk9hczVLekVpSHFZbW0zNHhvK0RQMVVzbkk2Z0V2RGRrd3JnL2lEdUM3dUsxMThCeVRkRS93QW54NGVKeE1NeC9OUjJQRy8rNEdSbnRtdUFUaXpHeFlKT1VjeXBwSmlBeHhMWlh4aTRuZUZ4NDloVUtZRWNFaDhHQXlzSVlIT2NZWXpFbFBMdUsxTFQ5d1Iya3hDS3daeXFDdnFmWTdKZ2w2bktzbTRQY01SQ09HS2R6UUpESEJKeGdaRWU2cnVHTHlvSnhvM0FqTVdtYzRQdGwyeHd0alJGSXdjYTNISzM2ekszNHROazVjcDc3aVd0TTR2NWpqSFpPTUdXL2lEWkVFbW9VeW9XTWJXTERaREsyV2QvUFVaaEdhZm5MS01SZyttVkE1VGlTbGFJdkNYQVpkRlJ5UnVXWlkwYVkyTlF1cGRTbnIxTG1HVXlUSTZsZldYVEhQRUlJczZsWGJDRFYyUVQrUFRXNGc5UUVKKzVrak5oTGc1ZXZjdC9yak9QSHZjOGRxbFRwWU1yTDgzY2FxWWZJUkl6aXd4QXRoTUJRdGdaVzdpeTFaV3JqSE5NQWxTNWIxTVpWUzZJc0NjWWIrTHRuVE95RkpCZlVLaFNWUDBRK3JGRlhIUjhZb3M3VUlhakF5cTRKZFJuUDZhS1pXcFV4dGFpM3I1Q2NhbVhaVUNtUGNHcHVjYXdpWFVhNGFOeHpjZW5iS1pzSDhRb0xOM1BjQXFCYkF1VWtGQ3JscExvK1BTRXZYZE0zK1p5QWwvQTZ0bC9IVUxXV1VpWFRPTHh0NmdOd3kvRXY0Q1ZCT1BVUDJSM0F1NFVFd2Jpa0dJRTFMSmJLbUxxZ21hOU80ZGZJMFF6eFo0OGdiV1BIUGVHVk1wTzRCV3Bsa0JVdWkvYzVCajhHTjdsaEJBMUx1Y2E3WnJzbjZxYi9FTVh0SlRBQTNDbTQxQnFiL3M5L2lNeEVocGJKWHNqWFZTajVORlFtZ2doMWNmSTVsc1d5WXVhUmhpVjNNY0FoajlWajVEUUU5VFQyMUJpa1VOckhNcUdRZFQrUW5JN1krUWVvSSs0WVdMQlc0b01HR1NTMVdwWG9ZQlRXVTk5d3dzMng0M0JWZ3VPVXlUS2dJMFR1VlV1Ti9uNXVGeEgyd2ZwQW1YaXp4TUh5NE9CbHNtZTgxR1ZiM1RNakV3QzdmY3JHZTVqVnR4SmQ2bXljSDBTcTdJQ3hKUWQ3blY2aFJ0SXArSlVUOFRpa3VOa0VCMURMYzVTbUpwZ2hoTE9Ta0hIaCs1emk2c2prOGlZQ3ppSHFJUkFJVVFBM08yVW5iS0lSd2RNb25URGQzQStMTmJtTXNJOVdKQllhbG5QYkNxMnpKQ3BSNkdZRkRjSDg3WWduVWRyVUxvR2NFTHVkUThlMjRZUUtKbGwrSXV5eTV5ckIrazU4ZWljMUpYdTV5b1djbGwzb0lJNThPTzVrRm93TVNWeU85VHgrTmN1T01lZThQOEFrZTVSVzh0d01salkxTWlpeG13bHl0UzlWS0k1WTEvV1ZLbFNxN25icVlaWTRyZUhLUGxYVGpSRGRwS2hSR29VeWlCdWNEYVRSZFFoaitDNXdWbVdLUlg4UUNwKzQ1WlF1YkpVdjQ1Z1NodGdWUDhBVVIrTXNNdnpLUisycHovQk9XVHRtR1IveUxuQzNlcFJiN3FPRjdoY1ZkRURjeFFHNWoxdWFpeFBidVlzemR3em8vM0RIMzhWY3VXY2dlcDNlL3IrSlZXRXlGN1pqU0xrV3dReCtGbUNqWXhMV2NTY3JacVhDZjcrSGZVY1lHb1gxS2xmRmFZRWNqR0tzelByaXgzMUtJV2RReFJ2NGV1L2hiSWRRTnNNcG1jYzZuVUpianFZOVFKVUk5WCtZWTFqOEdSaXdkczVWMmZISTRWZndKOGFoTU1rYklMYXNNYjBTcTFBVDRaMlhMSDRJV1A1amx6ZFJNbzRxeFhxWW4ycVU0NXVNTWJkekxqZEVvRDR4czdpM0g0cUdaaTNONU4xOEdNM0xZQ052VVFTejR4U1dMcUdQTFBoaWRzek12RXVHWHBpd1Fsa1djb09WUW04cGpaYXhhcEliaG9uR0NqS3QzT01vSUZ6OVMwSmVwZ2o4azQ3c0lqK0oxMVBya1hjUnJVY0ZqZzE4QkF5cUh3RXZIM0ZEUk1LdjdUSnc5VCtSeUtHNmh5dVUzYk9NUTVUSExqbllETThuSjZCbFg4TG13dU9pNExCamRTdmNBTVpqa0JxT2JMdU9WRTVXYW1PVDBHNHRtemNNY3BtNUdQRVovRTFPR1dNNGovYUFCcU16ck5qeHFXZkczMFRvMlM5MkJNVGQ1TXZEckJpaEJJTDdnbGF4MUN4MUhEN1JvaEtnVVF4WWoxT000Um1pSU1xb0t6R3htUXJaQ3ZjU1lKdmxIL0l6OHpoL0xsWmhvSXBsazFNUTVmYU9Ea3ZDT0RqL2I0Q3o0d3djOHRDeEtaeW43dUZyTFNjZzJUeDU0bUdUa1RrVmNjNDVNQnhpMnpUTEc0OWFnTDNBbEpEVEt0bkdvZ1B3RmpLS0djc3ZVNVpURTVUaW51R0t2Y0JHTTNsRXFIOWRUOFdUNjMxT3hpUVNZd3h1OVREQkNpY0NxZHNBNjR6bVhSalVicTVnQ3F5emV1b3R4YTZnck1TNTA5eE1SRzRaWWozQjVUdG9ZNHFXNVFWWmtOVExzK0ZNcGpoeW44UzZqNHN3M0R4OFQyenBobCtKU2lqdUJaOXBrZmcxS2c1RzhGR0dYMit6dUJ6V1VqVnh5QjlzNW5kUzRKYzduSDR6R0ExdUxCWVlzSjcvRWQvR1Zsd0xQZ0FsZXlBMU1SQ0JTL0FwTnZ1QS9tSEs0bE5SNnI1QTlUY3FkVFRLaGlzNmx4U3BZc3p5NTRiSUJVNFpUN0VyaVZscGdWanR0WnlvcUpMNHh1RXNWUGdtUW5VVTZaZ1k1WExLcUFrWmk2WldpYTdacXg5UWF5U05aTVU0eFJzK0dka0ZyNHhMajhzSVk4WXNTcXIzQXFYRzVqSFpCcUtNTWJJN29uOVYrUnJ1RGl6SWhqdUdSU1NtR0tpd05UdnZ2NEtab2FaZ2dNeHA3K0MvVEhJcW1mYi9xRHk3T3VvdDl3WEZFajVISzNLQ3l6bEJNb29RSUdOUzI2STRUOEV4eTR0OU1xL0krNWYzMzFNc2kweGxzSlZSbUk1VHdaL3hadVpnWkZkTVBlVkJmb2xQRldXeTJYdTVjQjhaY2UvakVLVm5NZEJIL1h4alh1WkdQcVZVUmdNQUwrM3h6eGZVNVBjNUR0bTl3alIxTWRGeHl0Z0FRcjVMWjBVVEdlNVU0eWtodlVPa2dhK05zSU0vd0JSWTB5L2h1QWdRYWJHWjVFL2NDdnREM0FVbisyYU9waXF4YWloaHFZb2t4THk0anVaWW8wc3g0UnhYcGpnY0gzQlhBS3FvR3k1bGU2bFpzUklDOVFKdFlFcGdmVmJnMUdYT3p2VnpQOEFqeVRocERjc09tQ1JZYWhCckdweXFZdW5rVCtSQ2cxRHlaTVRPWG1zKzBwcS9qMHdyaE1lU3pQbEF1Qll3OEM0NkNaSlFjUzRwRGpXOXpWUDFpVWRSYUxscVFVbUlWYktZTVJ5bkhQMHdFN2JabDFOSGNzNmxSWU5JNVJ0eVgxTjNMdlVmcVJZVHhtbk5JcTJtcGl4c1dYOEc1eEF1ZUx6WitMTno4ZVhIVk1WeTBQcnY0cHRnTnh3M0hFQ0JLbkVsUkpVdUcxSmlsYm5GN3ZVTk9qVWR1aWNVZmo5aE1jamRrc1grc3VsbUhiT3lYUlVEanNtMDdnejNNaGh5LzFBNUxIRFZSeGNTVXpFMnppTE9GV3pWUnR4aHk5UjhlZUpjWEtnU0hRSkZ4R05yb25yUk9VeHFKZ0VFU29MMVVOOWtNUEdScXBpWDJ6T2pZdzVlcGp5WTQxM0JTWCtvTk1mSTNIeTVaVmkyaER6SU5kVGtydVl2YzJ3TWU0L2FHcmw2Z0dVekF4S1pnRnhNZ1NjYmFuQ2NLM085RXhHVlRjVmdzTnRNMWlwSE1xb1pnektzalU0cGp5dVpCN203MUtibm9nelJPYkxXR21HVzI1alNURU15Y09MTXFqWTNDa2hPREFSbks5TXNoT0h1NFUvN2xKMzNLZ1RJcGxUZ3JwMU1NRnVwaVpPbGpqV1V5VGxOQktOT1N6T3N0NDlUVEFGUHhIRGJUSEN5ZUxQanlPQmxxSDZBZnhHQkhNNDBFRzQ3eXVWdUpVVjZpMUZnaGlsYmhWdktGRUpoc1JtdXBvMFRBMC9tTUFKN2pnSHhVcUlLQXpobGVKcmN6d01mSnhqN21JVk8yRDZuRjlUVHFMVVprWTViTkVIOEdwWXhDdFEvY0VpVkczS0tRWVpKZ2tCNHcweFlTaVZFdnFVVGxDb2lNM2xxcG1jWU14dWYxaC9adjRNYmFuVURVTEFadDB4cElhYlorelREcG0rUHdiV1V2VXJqcUZnUXl1M3FYWkZ5eTBUaCs0WWt4eFVXWUh0bVR5bUZCdUtRbUxHWERjTlRjRkpjNDQ1ZFJ4cGFocjFPWHpVQUhjTGxFQzhvNGs0S1hBK0FxWTN5aUxsZno2dVlPTnJNS1JqbFZ3akRpUno5RVZseXJJNGhxSitHWWt4RldJWVkxYzVCQzJja2Fnb3R3WnkvWHhpOGIyUmQ3bDRuOVlXekRGaWVwUmN5NEJRekVPNDJOUnp4am1QVWZJa1ZaZzdaeTNxYzQyd1U3WnlBbXFscjhBSHRnUXBpWUVPSXhjRTFORVNVc1Z5OXpGb1Nja2RFeHl5M2NPUmV5R2VmdXB5WFVwSU8zbFBxYWdsUllNeHFxNVZESXh1c3BxMVlJYWNaZm9JNWNUVWMzTEdsblRTekhFSGJPSk9PTkNReWkwWEJXUGxaL0orbzVLUmZ6TDNES2RzV3JJTUQ4d3l4Q2N1VEF1RVVQRlF3aFp1QzVSeGJoZG93QjZ1VXpGQXB4bWlEVnhmckRGWldYeC91QTJWMUhGdUJUTXZpbUYwMUVlSlUrMXk2TGlveC8zTWNSOXh3UXJrUkMrNEFFb3E0TmZGQ3haaGxSVE15bXhqaHE3Z1pCTVE3WTVjZWlieWgrR0F6QXU0WTBOZHh0QWg0OVdkUTFNVWpzZHo4d2lGeHhTY0FKWEdPVnRBVGJxcDlqb2xmcVhib2xiMlJES1lnc3l3QXFHTkRNUmJuSHlEUlVCOXhHbEdiR21BN1laNVlqRExVdmJDdU12NnluMHdlSGM1TnNHeVdFc1lOTU0xRzVtZ0RNc3BhRm93M0ttT0dOeXR4TnZ4eHRqaitKeDFNZVVyNlJtTTdKajJ6Y05zYUp1b2J5bXR5cU5RWENjM05uRXB1SFZNMm1vS1MwWmU1azR3d28xS1p4WmR5L2lrWTFVNytNWXk2TnU0aWtvbG5HcmwvV3BvMnhicmlhaDljbzVYbFF4c2FHTUg4enQwUmdzQkRjc2lMTW1KcS9oZE1BZHM0Y25VTUZ1dlV1bVpVV3dOV1F5cEZtWU5aSHVNQllyT0wzWkZqUHJGMkV5QXhYL2xCZ2R6UktHWEM3M0VDRDZtZENucVk1MTRuR3RmR1V4TE53aWFWWU9tT0FlSEhJOXkvamxwQ0pBdDFLZ1g4aFVzQ1h0cUxsRE9yYjNIa3JjeEJHWXhaY3pGTEozQ0NrRVFKNHM4VFBJekxsYlVhSVQxT1ZId1Ixc2xwTG1KeUpsaTRrVk1hbU41QmpQNGNjTDVNbzlRZEpPUmhnSHgrb1RFNVBjNC9oaU1TcFN4eC9VY1pVQzRGRUZxRnhvSVZBSjFQVXVET3B5Z0tYY1g0R0V5Z1VYSEt5VzNVTlB4d3NuSFVXcDM4SzJwTUFZM0hiTWNNWmtCMUxTWld6RW5LLzhBMHhSbEI3SW1OZFRqZnFZNEZ6ZytwV1VNV0xqK1paRElOUlJuMWlnd2NYL2o4QlVmZ3VZc1NMa0VMNi9NQkNvRGh2OEFNYk54VitCaXd1TERVTWx5b0l1VCtvWko3blA5ejFkWERxK05UZDZoaXUxWUdOYkp5eERxTlZvbU9EbHBtZUlFNEFTb0lFeDRzNWFaM09OUURkelZmQzZsOFA4QXVJd3NtMmJQaE9VcW9WR0FYQkxTREJ1TUkydWlaWVpkVkFhWlZFeFNwUjNGMWN4S3htSThuY29XSlh3VHA3Z1JSbEZTaVhUTHRtUkJyVDZtTlFFdUkwUXVKTXVUVmtyNS93Qmt3NDFFM3AxSEY5TXNoWHdBUzF6N0k0ZnVWRmdPY01RYWNvNFUyTmtBU1k4UmU0STNEaVJ5TXVtT2p1RlN3WWNYM0xIUk9WNmlGN1dPUkhJZW9EM3hyOXkyR1NDVG1tTTVleVk1cjNQNVFZZVFVYW1lVnB1NGNaazExSGxjUk81aXBMdWN1TXhkVGx1cWdWOWtndE05VHVJRVc4TGdRY1EzdUNLbnd1TC9BR0lWNkk2YkkrUno3STVzNXpGcE1vN1hjZWxXV0JCbkp1RGVSak0zRTh2RUpaYzBzb1BqM0xobE8yYUxJY2RzRzRJUVJ4bUZiZmc3aGxWa2M1dExoQmhsY3VtV3JxWVVYY0tuRGNXNGx3ZUUxa1hBVWpjMUJLaDNNOU12Yk53ekRKWTVTOFY2bWo0UURUQlRGTHU1d1dkRXVEZVVHaG5KTkVvVDQ2WnhUWkg3ZDZuSlRYUjg0NmY5elBHblUveDg4VXlNdTYxTXNVWGxNTWM4eFBHWFhjNDA2anhnbnc0M0RUTFc0WTBSM2d3MGJtdlVvZTRVU3k0VmxsRzV5MThkUTdpZGJtNjZsbDFVRjQvcVdWSEg2R1hQL3FKT1ZNTStMYzVYQnE0RnRNcHd5L1VhU3p1R09oanRqa3d6UDRuRGhpMzdlNFN0eTZnU25ucXFnOW5xWWxXTXFLRXhFZWlGRjMzRCtzVmhCeGZHcjJSZnhDVkRLdFZNTVhMT3ZST0Rnc2N1VkUvaVhUQUNPVnJjMkRSTU1IdktBSXZ3c3c0c1VuamF1T1RNc2k2U0EraUtqdGl2eGNGaDhuZHNFdWNvTjl4ZHhpcVR4NE9VY1hGUmhyNHFjbUJMMVJLSytCM053eWJsb1FPVTlwQ2pDR05ZN2dnVmpLZmIxS2hCS21XSExFcDNLY080RjNOc28vTVpTOVRyWHVhQ2tpcUZReXlKeWhuWkIxdGluRHRuSEYyc3hwTnNvVzRZWG9KbGlHcW5FOVF1YnJaTW9iN2xUS3lEVXRadmpObXBzTzV5L00xNldjWVdNMnd1NkpUc2Fqa1ZDMVpqcjdYdU41V3I4VXdVam0xQnM3bjF4Q3NsbVdWekdodGpuajBFRzV3ZmNHaHN1Q2Q4WmZ0Q09aZnFPUXc3dU9Tcy9FS2o0NXdjbytPdTJBZm1EajFCTVl1TEZPeWFDQ1ZQcFc3bG5xSlRDQXdOTXBmeExtRFNUUEsvSXFzT1NhZTV4NHRMTWNQYUUxTEVsa081aGlLN3FJbDJud2pYeHhsTXFDeW9Dc2NXY1J4bVBqeWNGc3NsTEZRbHkwNllHV1IzREg4c3l3QjFsT2p0aEQ0Ri9CRUJsVGtrRzQ1VVhQdmszREpCSW5JbUdQR2ZWM3FYTUVJcXF6SE1wSXB4aHdUVU1qcHhJS3FJVDg2SUErdHl6RW1PWDBXWHNDV0kxTWVJekxKY09JdEU1VlF4Ukx0bXRRMklTbWZ4ckhJeCtzc2puVE9jTW9vM2N3L0xQenZVQmRzeHVZMTdua284QTN1NXpHWEJHQ2M5K29sczF1eVkrT3hTVk1POXM0bjVXYXVpWlA0bjdJV2t4SzdoYk5yZEVIQU9LYW1mQjFqTUJWbWhwbEU1YVp6c0FtWnhRRVlYdWN0YWd3WUVZTzVRR3BaREhjQU1HWHF2VERETGoxcWRaVGh5ZFI4WUxjS0NQY0FnRk1NTWxuQkpybEUrc3FmbUtsUTJUdktvWFdwdG5HcHhmOVRGZHpJYkdPUUExRExsbG9ZMWNOKzZoZDEyelBEUEhzN21JcFJESEV3MmJtT2xtNGRNU1dtd2wyUkwyU2szQlA4QWxNWDhGeksrZExxZXFtcWpyNHdKVnRNNUdBQmo5cG04c1hLZUh5NWVMbHg5NmpibGN1RlRFL0xNY2VXaVpvWlV3OXdzN2luR2FoUnVpUGF5MkNEQnZPNDhzdW9mdUtNVmlGUnIxQnk0dndEd3E1VVQyZHh1dHcrODRSMFFxa2U0MDRVZGtjM0ticTVzakExQVlWSHFYNm1LRHN1RzFjRFJLbEliN2pBRTNPVmllNGEyeDYxOGwxVWJ1cHViVDR3YTZZWmJwbEFkUTZkekE3Vmo5blJHM1VYL0FJckNzZERNeW00T0xPb2ZXYlc0ZkhMOXgrMFdMQ0JFcmM0OHR1bzZOUVBxckNndUZQempiQW4rT0hESjlqTWd5eXljbU92OVJEMUc0REFuVEtLdG5jTlM0MTZnd0ZzSmlQVEdpS3BBbTd1T1JDNmxaVkJNRlZtRitXMWk4VkdQRWhnTzRCY08xUFV4UytUSEl2YzVsYW5OZlV1eVlBRUN4aVZBaVRsTVR0amQ2dWM0NWhETTkzT1l0Q3hHV2pMSjlaMFJ0aFRqTGZpd0lyTGdzUGFPNWs5YjJ6L2xQeFhjejhXUjdJamRYSEF3THVjOUJFUWxmbUljWjNoSHFBeFRFZ3BPVG5uUkZ6Rkk1NWpBc3RpSHBnRlFDYW1xWUxkRSs4MmQvRkZiSUFGOFlVOWtlNEk2bkVnVElBSzdsNjJWQWhCWnlibjUzS21CYk5PYkFvb0pwTFRjWElKVEFLNmhoT01KUkFnU3FMbmR6RVdaaVF1dmdMWmt1SkJXMlc5WERsTnpEeHVWL1loaGZiT05kTTI2cUI3Z0NSOGJVTWFPcHhZREhGV0o2WmxnRU1iaGhUdUkrdW9CY01jVjB5aW1IQTdJOElRZHRUZkZhU0pody9zOG9VUHdwVTVVUXpPNHBCRFRQNU1EQ3duSTlIYzF3Wjl0QzZsbE1BcVh0aGl1TndYWkR5WlZGSGM1MU9jNWlNMVd2Z2JZR0hLMTFISUdqcVhXNDB4M2hpUUJENHI3YWxVeW44eEFDNFpwbzZuTEgwUXlwL3JETnVHUnltWUg5WlV5MlEyUWpHcTBTeUdOYnVNOVZBZWlGaWlFVFN3dGd3VjFPcFRDdmJLS2hjcjl3RXU0dGFqVmJHQzEyaEJnMjkxS3hjZTVrRzRIdGh1VXJLU2VQUGlaZTV0M0dnMnloSnNZUllOZGJac0Zqa0hURHk2Nm5tOHY4dEZWVUdtcW5BL01CNE5zdzh1V0RxRzFuVTVmbUcyOHNybUtHZTFJNXk3dlgvb2Z2cWFXaVZSRHJVenVvTDZoOTlwOFVHNDdoaitXWmNRb1lqZ1kyYmRrY25KdjNQRmtZNVZuL1Zua3JESlNaK0x5WVlZNXByTDRjUkltUHBsbzBTN3kyUW91bzdnYWlCYzlmQ2tNTld6U2FqY0M1b25MOHlxSlV0OVEyN2lRd2lWMUI1UUUxSDZrVVpVOGVmQzZCdU9MZ2g2WmJocFBnSUc2aWNZR1NOVEVSYjZtcHdyY0lkeHRZMzNLbGFJQnRaaWhoVlQxTVRTeW51TXViZ0pxR0w2cU90KzVncGp1WjVZMVIzSEpDbVhnRnp4NVlZWGt4eTVLekVhak5CTzV2SFdSVUVIZlUwN0prTlhEZlI4MTlaV2pVQXQzQWhCQlNDRndJYUxZN2xRVWkzUEhrbUNCSzlzU1Y4QmNScVhXS0pBbjdKYS9EUjhDa2NtRjg1K1lNeTE3MU9tVzFvbUpsVnI4WVo4SjVOdHhxb0hHV3NMR0pjTVJZWVZjTUYvcE5uWkxkdzBXc0RrMk00eXEzQnhOdzgvMVRpRXg1SXpMQ0FCOERhZ1JIM0F4cWNVakRJNDFNc3JLSmlVZk83bXZiUEdZOHprMFRQQ3hwMWNyRTBSQmppRUFtZkYvTW9Oa3liZ1FYNDVNeFlzQWlZVmNzZW1EeFlwbk9JRU1mek9KS0gzQW8rTEdZMFFhWjJ3ekdHV1BzaitSWWNvZlpuR1dETHM2bks1ajlqY29IVVRJZjFGcUF3eGZaQXlxWUxqZ3JIYlpEVTFIOTNDMCtzM2k3WnRsTTlPTXd4S2RzY0FuQ2lCS1YwVGd4d3NoaFl6aDFjb3Vwa0MxRUkxcWlCY0FZSVJmeENxaHVHQk9WRkVmSWhGRUV1Y3BjRU80SmV6VTVCTWNnYnFhVllORVhhMUxtTnh1R2lYc1lXN0lLL0hHbTJKV3htNHVSNmhjdHZyNHh0RWxMY01aVEVscERJdWNrbk90a0h0WTlWQkRHcFF5aVV5bGdwRXVCVXFlblVyRCtFM3Yvd0JNSmdiYmppc3BKMFhBNVRqUVRCN21uUVI4V1Fsa3k4WnkrckgrMUVxWlMvVEhGZ0RLeFdZNDB4eDNPNGtlUTZnTDhZRXB2cUdEdDR6RVlBWmJqVklUN0VlVjFGVnFHWHFkM09waU5SeVVscXdvbFYvYVVlbWNmaENwY3VZdTVVRXBxVkVEcVd6MURlYzR0SkdrWVduenhtRFRZYjZqams1ekR3NTVxZElTMnFlNXN6bFpMeG1YaFBIbVdpSk1zUVV4YlBVeFhwalM2aHlZY0twZHg2YUp6WEFLQ0ppK0t4M0xhaHJEYzl5bTJHNkc5UmNjUFV4d2M3VHFZWW5rd2NFK3hITFBMU3YxOVRxZXBRdzFDR0p3V1haQVEyUjBEOGVOY01XY01Id09mTTV6N1BiTUhBOFdZenQxOGNaeHVVMEVFamNOd01KbFRsWkJwaFpsYzdXcGpocThwVkdvRWF5VGZFbmx4TVU0NThwbDVNdkxqdUlkQkMwc213dEk0dDdtRjdPajh5dEpkbjVnRTJRK0xoaXVybFZySmxzNGt6b2REVUd5WWp1WHJjcWlHTXBkL0ZtV05CVUtOcGNybHNkRXp6QTBTM043bUpseW9MSTlnOUV6end5OVZVTXNyVWptc3U0RGVvNWN0NXhLL3dDTUZUV014MjdpOWdWRVlZc3lGZXlYeEt1N25FcTdod3BsSEhXMG1XUW5XNFZGL0UvVDhLUVFtTzU0a3hNcm1XUyt2Y1lMQ0MxTi9tRFJVVTNyNENtWmRESDRESm1IZzhua0Z4TE1kc3hIb0x5amRzcThmaEZZQ0hkenJHMzVXeHFiVFdNdTljWWFsc0JTZjE5eHBxR1Rpb0VGcGNpUHJWUkdVOUdwd2ZiSzQrN2hhMnRSeVhST2FNdHlJd0NvS0Uva1hTUUNBZm1HUDVqUXRNRVp4Q0c5UXdUTFpxSlJOZTJkSlpjeWFDcDNNVDB6SS9jeEkzZW9Lc1d5YktQZ3RsaEMxbkJXY1E3bkVSbWdvWlJLTVpnZmJjZHlpYStMZ2hHV2NlNWJEVXQ5TkVIbHE0amovd0FvSlZURnAxRGQzM0Z5Q25VUkNEVTJsQk1WQ0plMkRISmNlb1lzcDRUWkMyQWtTNEpqMlhNc3NmV0xETFhVNVF5MjYzS0syVHRvSUtZN0taZVZ3VUpjdC9jV3RGeWxuVzZpMzBUWldvSnhiSUZUanhmZzFPTzVZSFV1NEZTdTZlNFlwakV1T0g0WlhIdWI3Q096cUIzZFFjaUdsdGpsb0dhOVFVaTJ4L3RCTmk3aGx4MUJIcG1RbmJHMGdwTC9BSE9Xb3premsrbWNrTG1PYzVRVmkvYVdLaVFhZFJSOVJmMU1hU09RdmNZTnpaWkRKTlNrM053aXk1WkZLSmJGaGxaQWpqKzRYdVczRm1LblVOMlF4aTEvUTNEUHlPSzVkZFRNREQvYy9yTVZiWmxpZXZqTDlrd0RjQWpmT2lHbmNMOUU0djVoaWM3ZW9PTU1jY3ZjTEZDYmRqTWM4Z1laTnR3cHU0QVY5WmZjeS9OeWo0UzBxSlRjM2NNdUxNcy9ySFFQYzNtYmhpM3FjTTZqWnBteGlzcXU1WVF5bEk3bHorS3NPYjB5bFVTZVBIRFpua0VCdFNPWk5VVk9uVEVzamc0RlpGTUdPdGpPZFpHWk1zODgzK2JwNnFicG1KaStPM0k1VFp1Yy93QXEzT1ZoZ0ZWN2dPVHVxbUppTE5ndzR3MzFLZHl6VkVXMWExSzVaZnFZSUxaRzBhZ1B0aGhsbGIyRXcvN25Od3l1TlpZOHp0Z0h1ZTRCakZ2NFpmcG1Ya2NzZ09ncUpqeFYvdDZJZ1l5NXdPNXhOWE1zRERBcGdhMU5CTEdVNEV2dGx6bzNNY09XN3FGYm5IaVd0eDJxRkVINjdtS1hxWVc4aG1PSVlxNVRMTEhLdGVwbFVkYWluSWVPbytQaS93QzVqbFdDVkJQOXNkYjJ6REw3SDRtYWM4cTYrQlg0TXB5djFPV1Y2bFB1TTlRRkplNkl1dGZCRmcwekxJWjRlQ3N4NFh1WlU1SmoxTWNzUTNqY3d6eHhjdnBESjRxRVB5enVBM0RISDNBd21PUVJ5M2FUeG9sSmN2RWRFY3d3NjNMYXVwY3RkRVJJWkRxb0UwTEg0S0kvK3AvZUcxSjVNVEdIelREalVmamszQlp4WEdMcUNWTnBPWEhlT1NYTVBMbmpuWWtWVlY3bHdvVllQSm9aMURJZE1vT29VOTFGeHBvN21HSnhpZHd3bkdXVkFzMlMyWG9ZNWd4enVjcGFURzd0WTV6Ri9NVTlmR0t6ZC84QW9hYVpqdG5teHc1ZlZZRmZqNEtpNzFMeXlsUHVjVEppRmFsUXhad3BzbXJpN2pEUk1jYjdqamVWM01RRlYrQ3BZUno5RXRtMmNYcG5IY2FDa3NoNWNEeGNPRy96Q2FPbVl2cUJNaXNkUzRTb3NCeW5CSlFRTVp6eE9pWTkzeGpkL2lQTkxaZjFxNWk3dTRwWFVFWURNTXZzNjFQNUxzQ2J1WkwxTWxpME14U3JnSEhsYkt3cTVZOVFmVERYVXgwd3lGcGpsVE1zOGU1enhTY3I2VW1HWnkyczU0cXpTemhYWkdWeEw2aVdkd3dXY2N1TTJJczRvN2hpN1lZNU1EZTFuSEh2VVhmVlRsKzRaZnVMY01mdDNFSnh5bDFET0xsQnVadndPVGNyS0JwdUJUWVhMWHRtdnpIR3kxbTJkZkhiOFZGUmxyQnFZNTR0NmhXNGNFdVlOTStxemxxYjdsUVB6S3FWNytYS09Wc0djbUdjNVhHRExGbVBjMk5rdks3aTNBWmY1Z2t1cGhrdUd1NWxjK3cwdXBseS93Q3BUYTNBU0NrNTdpcXp4MTlwVU1xWDh3eUUyV3pnZHcvQk03YzZHR1FRZHpkMlNtSFVXYXJxWjVIQWVNb1k0eHNOUUd0bnc1SkROclpGNm9tUDdJZ3JOSFV4dmJVTWtFaWk5dy9VdFdCN3lsYjNNQWNnbmt4TWZJaGxaS2ppbUF0MWNYRktNZGtySmI0eDErb1ZxdC9tSTVacjBWS0JKbGpoYmtTMVhsT01BU1VTdnJWd2EzY04vRFVjbEppWHVLVEI0dHBjVWVpRHhuY3h4alExRlloRWhUTVVCSlZNYlc1am1ZNWI2bm53QitwOVppQWFZRi9KdUJiRkNYY1dIVVNkeDYzTnJxSkYvVWFoYm9sUUxHTFRxTkV4YjcrSzVUREQydFFLTlRMeFk4TVhsdGhobGxpZWlWZW9rRGxGc3Q5VHcrTjh1WmpZV1RQd3Zoek9yWnNFcWRlb2pFcUdtQTVRR2ttT0x4dVkxY1dzNTNMOVRHOTJ6SSt6OE9SQ0dvc3hDdjMrSmhseGJxTk9jemFVR0x6cjY2SmdBdGx6Szcwd21odTRMYWtFcmJCTFdaSXJSSElDWVpLUUFMWlorWVpmR09OdFRqa3FUZzQ3eWl4M0E5WE1zWEZwMC9IVXVIWHpqcHVDbzFFeTl0d0tuY3Bsb1NvUWdRT010bFNvdGRUN1ZCdi9BSEM5M0J1SU80WUM2bFFlOVRjSGM1amdGVlVNNjlRV2NtNDVlZ2gzVUZuSjM4RVNZbHdTREwvVXhBMnR4Mi9CTnNCeFBpeVV6eDZkdFRrcTNBdGJKUkErQUExbGJMZ1lEWXhReFlKY3UzOUVHOHRRU3d5OXpPc2M2RzVlNW02MUM3WmFuVUgxVTkxQTNLMHh4UjB6RzQ1TmxTc3Q1TEMxbnZiWkhpempNY1ZoalNYN2liWVB5WnlsaG9pcnRKYkthMURGTzJGOGU1VjVVczcxY3hjUm1BUDRKblhVNHBQSG1qdU9SVHVZSVEzbk0zN1VUSWU1YkxaeStwcUkyd1N0d2NiaTcxRE42WTB1aUZxakVRL1VCR0pURHVZZ3ZjYU9weVkxVnpLM0FDV3NiNkdjeGFpM0JiamNjbWlCS2hVNDNjTEprWE1jQTJzWU9WYWxEMjdsTnh0TzVVRGZ3L1dYTHVZNWNkRU03aUF4TmR4S0xIVXhxNG0rNGxNOVhjTFBjMnNZR29YQWVsZ1VNTVk0L2lHTmtCeEdHMVpWN1lzN0taZm9uYlVwZmpaWkhKWU1jdmt1NXVZck9TNmZpeE80RE9NNHluSHBnTDJ3TnJjV2p1WkZuMWhnb0s3amhSY29GaFhTempWcEJ5cWE3bU9SaVJ5eXltTGxqM0JFWThRbUhFSmtoUVRrdHpFU1lDc2NNdnlUUFpVYnI2a0xTVXdYbE9MK0k0UDRoVWQ0aVNzcm9ibVJSQkNEcGpVUDhmUEl2aXppNFpKRVNiQnVOY1M1b0pTcXdHT1d3OUV5UTZaampuMXlvbU9HTG1jdGs4dU9IODJiZ1VNMnM0OVR5VUZCQmRyQjVUR2JjcDdXb1VhU0loMVJFU21WRTRCcXlFcjVSYWlUb2gzYjFNeXM2eGJKUTR6RXZGRm1CeEk1V3dGaGZUQUhLT2J4L2p5LzZaeGNGc2RNY3BUVnczamN4QXVNN0hVS0NPc2JuSU1JV2Rtb29oVWJ6eU5SMURidmNSWVFzMmZCbitweFVsUXdjblRFUVJPb05hTzVabDZobFFJVEhobmpEbTJGcGpCaXdLWWs4Yjk5K3BieUVuSlhLNFd6Y3BVSTRveEVMdVlDeTJDUzdZRUtpSzNNcGl6ak9vYmlXVG5qWDhkZmI4d0JPM3VHSnpwZlV1KzRHUUlkUnhyRzcrS2hqZzR4dXFxR01NS2hqWkhHNEFiMnhCdy9xdzRoMUtQamxPVk1WdjV2ak1zbDI3WVZWL0JMVDFFbW9hWVptT0tIdVhPNWxDMCtDSkQ0dUQ4TXE1dVk2M0ZFaFVyVUdBbTdsN2lrSVZ2NDNDVk1Tc291VDFpVEVjZjdZeHlWNmlzcG1GaTNOS3pHb3Q1VGNJUUNjcHlZdHppVkxiam1WTHN0N2hZN2xsL0YvQThSc3VkbktwamhaYk9BVFlLVEhTSjNHc2cxMUF4dGlFeHhHTkc0Y1JXQzNPSkt4QzJHWXRWSEw3TXRoaWpwbVQ4YUp4dmRSRUppb2swb3h5eG1wWHdCOFl2eCtwYmVvckticW9VRTBDa1FOKzJZaFVkUGN1cGhtZXlPV042Sll6eEZyY1NzbXBUVVNHQ1F4Vm1ZaGR3VDRHcGM0dlpERjlrUEVvc1JHWTREaTduQWhqWHVIKzVVNzFFMUhGTXFZaU1OR3lMWHFYWnFGdXJuRE9PZFM1ZTV5aXEvRzJaV3N0aWpPVmFaYzVma2hsOE81Y1NpRURvaVJtSGl5OGlZNGxyUEo0YzhNdU9ZQ1IxTzVycVdTNTNqRitzR21PY01tQ3BPb3o5TEY0emxFclpQMnpBRWZpcDZpYStPeGlkUjdoTFNHNWRRMnk2WnpGMFRraUhxT1dMakhIUEZtWEx1cGdzMFEyMHdjTVJobGltb3Q2dVltNDRXeWxXR3IrRmd6YzZtT05rTVlBZHc5MUFWcTVpNVlycGdydHFPZjZqbVZvbU9VeGdGeFVKenlOdlVBV1lnMlR0MUR4WlZ1ZndoMmtUSEdmeUhyRW44L2tTdjVOZmdtVXhWeWp0aUNmSGpiMU10WmNacHgxTXNjUVB5em5xbkZtV09XT0l2WHFHM0poUEVGM2t6eUp5aXNNekVwSU5kUWRYTGN1b2E3bVdmSXFmMkFUcWNSSFVPUHViZGhLK0VTYldIY1RoMjNHR0x3dUQ2bUpWL0NRTno2clNzeXFxSTcvcnY4VExQTC9JL3hReHhETEh2OXd3L0xFb2c0Mkx5cWVSd1g2WFh4eWVpR0lqY040UjZQZ1c5R28vMmhheEs2bFpmbUdKT1JpeW5uY3F4cUdWWXpXU1d6bmpqZkh1ZVBQa1o4aUdOVm54bUdkNXJXTXhHc3JyL0FLbU9LWVh1S1lHdThpR29sVXd5SW9rc0VLMHorTjhlQm5ZM0hMMndhWnl2SjFMQmk4amU0Q2grSmprakhITEUrdzBrR0dvWkRCMlMybVlVazZXR3A3Z0JIUWtQNmZ1ZVB1cW1WOTFNOE9JUTRKdGdMaWxFY0V3TVVCL00rdUZLM0ZGMFZGSzcrUDNVTXNxdTlUWmpZd1FLdWJRM0EvTE9EY1Q5eGxIY2FmaDFzaXFUQWUxaWpjN1pSY3VpaU0weS9VclJST000aHU1eEhkL0FRV0Q2Z0N5cGRNTW9zdVkrNVVQbmNJZFRvaTkyVEJEK3hLWVFsZm1XQWhNZnl3TlFTUGZVL3dDb2VOcTduNnVBSFVvTVpkWTNGK2xqRGVNTWQvSmxMdURNTU1zcm91cGdja29mM1BKeDVXWmFqa1VXd3hHT3ZVcTJDRXRoa2dpWExtcHoxVU1zTUM2ajViNlBnQU56YWZXSnVweDFEV1d6VXNTaVVIYzFWbW1hditzYmVpWTYxY1FuL2NFNlM1ZVIxMUhaQ3BpeXduTnFXNUZ4VmhneWpqQlR1Q1JRbXBhUVZuR3lPRlErekVyQ1VTc1gzTERRelJOVG9tRFgyZHoreGM3Nmxvd3ZrdHpMbXlwZDZaamdOM0VXRDY1TU1IWDJsSmsxS2hqSEdzb1BKalpPVE1TWlJiLzVReVBlVGNjZ2x1WkhCclVwT3pkemRLeEprSk5WL1dVaGRUZFIxQXlJQ0ZMRW1KVEhEY01aMjFIQ2piTEJsVmhBT01aMVBIeDVidU5Lb3NORzVqbG5obHl4eXBKbG5sbGs1WnFyTCtLaGpHd2d5cFUwYnFEK1NWVWNxWmpURW4rNGtMNnVVRUV1TEhMVU1zS0psVHVjaUF2UkZScEprZkJpdnVHbG0ybUhlNWtCVU9vckMyZFA1bTcweFVudTZtU202bUt0KzRNMWFzMlhVd2JVU0VLTFZoa1RKdWNxblBVeFJkbFRrK21MZEpDblZUamhYNFpnWTQ3eXVkNWZXWkZWcjNISFZqRUs2aGhxVnE2U0g2WXR3d1UzS3hIYmN3ejhZM3hpN2FKbG5teHZTeGROc01tYjNMc2cxaGRiK0RDOVQrclV3dm4rR09PZUdmSlRLZUgvQUNNUEVPT1dGMzFQSm01Unl5NG1NeXk1ZGFKaWFmZ0xablF6SlBST0t5aEcvVTV2Q0Y4T1RFTWNMWHVkNGFMWW1RRjZ1VTR5eTNVSXR4MDFGMUZsQlA4QWNkeE1WQXVKdG9ocU9vMWtYN0lLbHo5aEszWkNpMzNNTTh6UFRxWmVMNi95ZXBvSmlGZkRpMWN4K0NxaDdqL3FDWEV2cjRkYm1WckFXY1M5c2FxWU5YRzE2aVpJaHFvYW4weTd4by9VQzBGWTQwMGh1RFJsT1dIOEtOeGNGS1VRbVp4UTdodXhuR1lwQjBNYjkyRUdpcXVPTFJNR2wrTUtZbVF0UU4xY2ZKbG5qV2JyRWpNYU5zUGN5d0NPdFRaQitPTlJtMWc5a3dlUlJwSXVXZVA2STR0Y3NtNGNNTU40MnN5Uk9xSnk5citpQTJueFFFd0dsZzl6R25IakJ4eHV5SEh0bkxHbXBpWERGY1ZIcVkvbGlqWkQ4UmZrSS8xcGhzcUdLRERVdUdVN1lSVUQ5eExJVWZBU3lFZFRhYWdJUW1wVXJVMEVYNHVYTGhDT0xPSzNPTllsOXhxTlRtZ2tGbklsZ2ZBRXRqa2pQNVZtS1FjZmc2WVlBMnpERGxuK29sS1J4Q1VmQ1dUZ2pEa2YwZjhBY3pQR1lZOEx1dHo2b0VlMHJSTWNxbGphd1lZcktlb0M1Y1JuOVZHRGNjWExVTWEweXYxRERjb21GTDNWUXk5eHl2S1BKSnhwaHlSamptVk1zRzVqNDEvNVRMREVibWxpdi80SUxWQVQ3UUdwVGN4b055OE9GMURJaENpSEd0TVZTdFJaYjZsNU14bE10aHlXT2YxM0RLT1gwK0RFbkhFK0d4amVYY01SNmR6WVF5TWJpaVhGMURQTmk3ZzJ6Wmt3bXpZREROcG4ycTVXVXdGRzJZbXZ0T0p0SUhjMURVendVaGlZOWtjUm5FSVF6MU1NcnZsT1l2R291TjZKbmIwUXlyVlRiTXIxTWkyTHFOOXJMRWc2bk9YR2NuRjN1VzV2UVMzcUR0R1hBdVk1Tkt4YnhtMkF5cmxibFJZZkRqZlU2Z2lVdzB3Vm1TaENwNjFDVmZ3bFNwUjhZWTNsMVpPQ1hHMkFFTWE2eWlXOXhGWUUzRGxIbEtVdVcxT1JjdWNvV21vYUxabDVTYllQcFlmcWVtTzQ2d2hSQXVmWjF4amNORXFHUHVkbTRUSFF5aVlpenA3dVk4dWR4eVVpVWs0cmJESGpqSExIalZRenhPbzJ4NWtIS0V5VXhoeVJKa3FVeEtqaVV5cDlhU0ExQnBpKzRzWFd6Yy9rUXRKemMvSHlTZnVHYmprck9pWXBVNW9kUXl4WVd1NEZ3WHVZdDNjQ1d1dlUvc3d5ZGtGUXRpemlmQmxVWGsvSVIrTU8rNHJidS9nWWo2bXFwbkxRVE5TQXJQRlZveitTL0gvRkRFdmM0dDBUK3FpSXhiS2hvcjQ3SWJaU01LR2dpQjdpVGRiaFRPRjlUQ3NXc2k0b3FCcUpST0x6TjZqampqams0S3Z1SVk1bjdtR2FaOGFPKzQ2OHFoeW44YVpvbzJRRGdYZ3dNVm94dWVYSC93QzJzYU5RS25jSExoUjB5dUpjcTJtWjU2b2VvdEJGZi80ekVScWR0TXlBeFFtTE1YamFhZmNvY2pjL1B3TkU3SXRNc05zNWNpSGlySGt0eTE2Nkp0SWNzWHVkS3pCbkpDZ3NuaHJMSlVvSTFrcis1a0xvbEViR0xDb0diaTBhbUxjQ09waUdXMGhYb2hxTEZoRm00S0VMbHNZTXp6V3ZpZytBZ2xNZDRZSDRKbEFxVkxBaE5XUzI0S1Q5c2R3bEZTcHFkUHkxREcrNGNaY0JZWEVjVzJJd3JnL21WWkFKaWI2bVJpYnVjcldvZkdZUURtRlJDMnZqaktEb2hmNGdwMDFFYW5LdlU1ZnFLekYzOXVwazcwVGY0aEtsZ012SDRPcGYxcU9XNElibGV5Q3puWFU1WlhPU204cDZ2bEVNalREREtHTFcySENOZXBYMWlVUVVqbis0UHdJUXptU0d5Y21yK0FsQkQ3UkNZa2Q5RUZ1R05OcEtOeExJWTdtTlk1UVRrc3g2WjMwekxFbU9XSnFvNVkvaWNqc3hpNnVvOWFJbVdZUThiY2NWbU9PVjFISEpqZ2U0NFgwemg2WlFSUHdROGE3Q1ZTNm1JOHJtT0kyVGorK3BSSGpYMU53NVZlSnNnaWZjYm5wS2xKcXBpdHZVd0E3MU13MTlyamljdXBRUzFKZGR5d21sdUxuREhKLzRSNWRhbE9DVVI4amJxcHljeUdTRVp2ZHcyaEVyS2ZaWTV2WEdLK3JoanExSWRNeGFpWDhDK21laFlvc01iV0J4R0dNb3FiTG5aVVRkL0F5aDdJRzZuVEtnM1l6U3JxWWNhamgya01HNFJJSndZSTQxT0tzTHgrTnd2bHVERSswWGNHbUQzQmd0ekVTNGtvWVRpUUJ5MHhBSzdqaVFsYnVlNWoxbEsrcUhjMmlQWkIxVVY5TXhlM2xGUVNNSWN0VDFPSitZYTkvR1BpelRwajRNOGcwRVA4VXd3dDhoUHB2dFlacTdJclZFNUtibksrcDdoRXlncExtMzFER21PRjM5bzd4U0N4MjhXR0l2ZlVVWFRLVjFObXB4Wm5hVHNuajRZamNIRGxXd1ptWWo5VzV2VkV2aWRSUzFacWZpdW9MbGsxakd3cG4rbUdRRzVxRFJjZnpCaHB0bVdXTGxxQVZUTWc5UXg1UU5Vc3pvMFF1WDZTRkQzOFk0dTQyTy9qY0I3V2ZtTnVNTWEzTElITW1WQ0IzUDhmeDUrWHluRnROMVA4M0xQUDhBek0rZUhGSlR5dUlKQW9odU14eXNuaU5La3BibUhoejh1UDBPb1kwdGt3Ky9UVVBJNExYVlV3elVnSmN4elBjYy9HRkl3ejVheFVFbVlxZmdsWTZmU3ptRm1Fd0EvdVBPR2FZUGpWdTU0amhiYkc4ME1NVWJ1MlhNTVJsMzEyUis2WHFMclVVbzF2NHgzY3gzaXNQcTNGc1pacGxFelBIOWY0cjEzY1BjOUV1SzFCT0ZQY05DY1JpamlCaURCb2hwalIxQU1yVjNEQmNnSUY0UXJBUHl6TE14dzRFd0RGTWg2OVQrZkxEemZ5RE04c25OeS9MRnlaV3JaWDRaam1HTkZ4cmxaMUYzSEZjYlo0OGpoVFA1SUpMbTJXZ3poWmZ3TVdiSS9HZ1owUXhVbVBFSVRqcUJwcjRJbFM1ZjFvaE1PbFoyemE3bXJvbGtzcVg4Ri9CVEtLVW01UlU0a0xtT04zTWhBNUR1WTVGc2FEOXhRTmR3RjJwTittSk1iU0N5NHM1RmpVc1lwVkVFTkRISUNiOU1lUjNGaGl2dUkxM0RqVU42YW9pa01tRFJ1YnJ1SHhlUy9CL2FhU0JEWHcxTGdFMWRCTWRTMVdPTFV4eXJzbkpQVTVzNVF5bDJ3U2FKYTZuS1pQS1doVTVNNXpHcXRuTTNReWdMZ3c3MHhBUDdXekUxdG1wekNEcWNvNUpjdzNjNFZRekhFTHRnYmlWODdxR1dMcGp0MU52U1RuVURKM1pFaUJEbEJ4aTFPU3cvUEtjNlcyT1hKR0dZWFJQNVAxSE00M2pNTWx5bWFlc2tTY3Nsbk5HOXprMTF0ZzRvSEF1WitReHpBajVoRVlaMWRGeXdZamxscUM5SkZaeWZjNVpWQkh2T1o4TU1UN1hjWEJVTHFHbHFXZTVVYjUxQndKbm1YWkZ1R1ZMT3UyQmpPaGhCb25LeW9ZMU0zRGpST1F6RHliME1lVnR5dWtsMUxKN1plUENvWGN0eG5QZTR1N2h2NGNhSTRnYUliMURwZ3BPMk00cWFqbDZycURacVcwc2VWNmdwM0VFK01YN1RKdktCTW5HZ0JsUXVHVGU0cGwxRVNBMncwdzEwRVZuTlpWazNzWUc1aWFZSU5rZDdtSVRBN3NoalF6dVZVN2dzcGNMUFU0ekhIbE1QSVlhTWJabC9tZVJLeERHaVplVHl2YmN5OHVWYk5SNDlrTVRoYTB5ejh3ZFFLbGk3bkRGOXpyUkg0dXVsaG54UnFmeWNwa0hIVVQ2MlRMSVVTR3JoQ3hnTG5ZUVZhanAyVEljVklEVzJkTTVmZ0psbXppMkdUM01pcFZHcGk4Y3JqazFaN1pZNXd5dDZpYmliMUtDRzFKZjRKamhhcU5UUEhpcFVEeHY5cnVGRHVZbklTNnFZcHlidVVWRitLTWl5SlFRWDFNcmU0MWpBVm1YNHVhQ2FTcGtFb0NJbUJzaFh1ZjR2K1FmNDNsY2dMcWVmejVlYnk1WjVHMkRiREd4VC93Qk9QSHFJNDRRMGJXWUxpUEZxNEZXRE9OTjNITnowWTY5ekR4MmZiVDZ1VVk1dU5qTXpkVk0wY1NwamlPQWwyZHpMZUxqamRrUEZXUEp2ZlV4TEZqNWZKbVkwZ1RpbVRWaVRnK1Viek1YSDh6RE4wNCtpYVpsVDFCM2N5OG5JZ1ZFeUlmYVlZV3pKN3hJTXF2dDFNTXkxZ2J2NENLR3ArNWM5eFlWVEJuSzRzR2JjaEl0NDB6SHg4Z1YwUnR6aDlGSHVPZVRpalVMZE1UVVc2WG9tWUx5eEtpMEVlcGpPVllWQjFOQkxTQ3diTlQzYkxXYzcxTCtGK2EzSEVENFRqT1V4dFlWd3lGM0FqWk1LeWFZNFZta3hLSWt4TlIxTFp5aFUwbW9FcWxqdVUxQ1Z1WkdxbnFZNFhPRk1XMzZ6UHpaNTBaZWlmdGxXVGpjcjRDb1ozb0p5cDJ5NWY0bFpNNHNNZFE2bUhqYzMxREVIY1FZRnl1TExHSVZNVWpMVStBMUFJNWtkdzBURnFjWTVsVERNYnVkejNGK0tSanlQVTNVRExKU1VrYmpqRENPTXFvRXFkeG1xZ0M5eWlCT3BsckdXMUhXNTNCcjFDMzFSTWRTcjNMdlZSSUFrT0o3bjFmY2FKWnFJM0xJRUx0aGc5ejdIdVluSVhHWVkvbUdtdU15YnpwS2lTbVVIL0tMWkRSQ3oxYzVZMVRodWI5VEhFWlhGaG9ZYUxtNi9Od3lUVU1sMU9Ga1VxT05seml6REVpR09NSEVJZVFuTGRrVzhZUDVsWVQvWk5NNVdWTWlEUkZHTGk5ZC9Ba0VXV0xDaGpQOEFVcDZtTjh3WnpwVGpQdmswNGhIQ0dHdXAwUXpqVnhDQ1RSQU1pZlhHeGc0M2JMd2VwaWpsMU1xOUVLWmtFNFVSTEtuR2lHaTV0Z28zSGpsS1JvcUpsc2EzT09VU3lHTEhSTVZYNGNkYWhyNHg3aVY4Wlp6RkVpY1dNWDZRZGFxSzF1Y1BjcEdlUGVkTVNscU4wVEdGMHdOYm01dUdFb0xKaXVPS0VHaVl1N2dET0dtbURVVVExTEtxcFdIdG1KaWV0VGQ2aHlIY1NhaHNsRUFMRW1JTjZkUmFaenVjYTFIQU1WV1VjZnJ1QXZlbU9JVGtIVWJjWmhnZ3FNeVJ4L1pEN3JjV3AvWWxWSGMvdGxIU2tHV0hIbDB4eUQrdjlZY1IxMndIRmJsN2drSXZEZVB1YnN1SGg4bkJ6SDZ6UExtLzZqOWlVMlN3N2xPWlo4SDJsVjhjVnFXMVJQOEFjQUdjZUc0WTRyYkVMMThVWlJPSkJ1Z0prUEpFbUJoVjV5dHdQdEhKL3FRSWdSeUhFb2cyczVQQUdOckVQNDhaWDIxTXQ0V1J5Y1RXbVpYeHh5Y3JqWDlxZ3VYYnFPSWNxbUFhNU1wS2FRZ1k1WUtyeU9wZzQ1NnhGUGNNTThjcXEvMUR5Wi9qcDdpbVNtUVRCNDZvQjlURnE2bG9KTy9qSkZPTWNpa0NINjduT0w5cWdGc1hTZGsyQnFpZU12SEp5ZXVvZ21tWHNHWTRZdVNyOVkzMTZJT1BzWTF5dTlSU0JDNWFFeXJVRXFwYmRzNVhqRHk4Y0tobnE1ZU9XL2N5S1RLY1Z1NGdEUHFZMUxNc0t1WHFvQXgxOGR0UWcvQWxkNmwrejRBbEVXdmdHOXdJMnNvblpVTEowd3RuaUM0b1pNdFdVaENLd1lhN2l1NmkvUzN1RGdCcU9SV2lZKzRHTkt5cm5FbDc0bTVTRzVZU2psQTdxRmsya3FWZHF5aVZLQ0llb2xTb2FKUUc1V0lTcFVvaFVzSVZMclFUaTN0K0x4Q1VaUXhER1VFb2hxTlhjTWtOVGprdTVUak9YdU5POTNNTWJvekdlVEFjNkp3QjJ3d0ZhZ2NkRVRLT05kd28yeGJ5bDVNdFpUZklaZ2JlYXhCV3JvaFYweFF1b3loTmR3L0RESWxrc0pjVW4xbi9BSFBjN2FpQUVWVHFBK3lJazVKQm1KbGs2aXVPVTVSYUoyN0NXSnJ1WlowQWt5ZWlvS1FwYVlvTlhIWFVNbEdoMUhPb1oxalFWTWMwVW44MVpYY3liT2RXemt0TlRKdTBsbDFaRmIxVE9iZEpPYnloV1F0czJSR0Z6SFZ6RGZjc1FHUGJMZ3N1aVg5WmEzdVljZVgybWRPbWNyK054NU9GRU1GSngxdWNwcFZtcVdVWDhZYStTRmpLTXVwMFU5L0J2M09tSEpSL0VIdmRNTTBYYzVya29kUTh3NDBCYk0xV0RVRzRmQVlwTU8wQ1ZidnNpY2hyb2drdmpFY2NMV0trRnVDcnFQNGx4cmhDNnVVQkFyTVBVT1BLYXh6MnppeHdSWmZ4V29URlk0eGRUQ0s5MURsM0h1bUJDMWpseG1TVm9sRmRUc3FVaEMyRlk1M0Z2SklEVUtaamtHRGNjanFYUkRPYzBoa1E3Z2ZucVVCWkFmVEJSWVJFbjhhZHN5OGRRRGhNV09SYkNxdVpuSjFqVUJHY1dvOXRXVEJ5OU8zdVpZQXB1N245V2VQei93QWk4c1FTSzRhY1JNcDVNUDR5NGR0eDR1bVZ1UFdtYzgzM01RdDVaQXhvVDdFN0dZcVg4WEFaV1BLdDFBQzR2S3VxSS9xR3FZc0dIanZZenJYdUM0ekJNczd6dXZkUjV2OEFJWVpQOFpOOFdEOWR3eVY2aUpsVEhYVEV2cUFocUVxRFhVQk80MUFiRDh6eUZGWE9ST3o0L3dCVHMzTCsxa1poamplUmwxS3ZxR3hyMU1Nd3k2bmJsTGVPOFkzeDEzTU1hcTRvNXIwVGszTFRLc2pVMzQ4dlRjUU1OTzRjdndIKzVpNCs1bTQ1YXd1b0lsRURkSTFFY0NyR1huN2RSNG84Ym1LWVlVQ2Y2bmp6SFBrNU45VEs4Zk5rWXYxL2NlSDhZWHU1OWswTFc3blRaSEZ5Kzg2aCtXY0V4VktJWlQ5c3d4NVBFTFp3eXh5UngyUTVLd3QwNmptdU5CZFJ5RWJ4N2lZaHFZNlU3djQybW9hL2JFNWJXbU5JRUJqYjFDcXBhbi9NRGNCRmgzUEVjMi9STTA1MmRUSlJtQ010YzBnNUpHNEMvQVJkZkcxMThGdytMeGZIeDRibFBHbzQwUTYrR0JOMUFUVDhGTXArQ3BXVDBURGt6TEdtTmhxZDlzWldwb2wvbWY2bTM0THRJaWx6anFEUlVNQWJ5WmVPT2YxM08yNHBNZTVadVl6bVhFWW53R29TeUc1ZEV2TDhhbDg0SUd5V2VpR1h4eTNEWXpGYjFPYTR0a0xsWEFvbTNxR0s2aUpwaFh4d3VjY2gwUXl5V3BTd1M2aStnNm5ONFhYVXpiRE05d0Jkc09PUFU0N3VPZlJQS2NLVGNkdzEzSFhUTncyN1lsRFc1MEw4SmxicVl2M3B4aWhrd04yektuSFJBVW1xaUxLZ0ZkUXdvdXBwb1prQi9RdVBqVzExVStsZHEvQk1jVkZpTlZDemMzTWNZQXhOUUtadTlrdHkzVTVMREsrKzRHTHZ0bE0vd3ZDK2JIeTBEeEo1VVg5RUhsbTE2Z203SXA2cUMxOTZDY3ZzbDZockpJb0NwS29FbFpyY1ZsNWdvYWxwVUhPY3BiTVZHTGVXcGJDWEZXS09FdEdEMnNIa3R3UW5jdmgzT2RyVXl6VEFTY3ZUTEtuT2huUDFPVFZFNVBTUzRNY3BmcGk2bExFV2NaeENBTUxMcG5oTVJlWmN6QzlGWEVvNDNBMkJMT1QrSldMRXJvbktYWkxBaGtZTXl6SStRclVLbjhoT1gxdFk1cldweTNESTl3ZFFRbWJxQ3ptY1c4cGhRcXNVaGtYdG5KWFV6eU9VMld6MU1GOTlRUmdKYVR1WTRpc3h4SVk4dGNvSEhWekl2RVpsckdwZnhaa1JDdmNxSXN4eXFQYy81TXh5ZW9LU2x3eUszTjErNWU2amhScUJVNDQzdGdYb21IajhtYndtZUdlR3B1RHZjS2h3VGJISVdvb0ZNcXkrU1F3SzN1Znc0dU40ekxCTk9welFwbUJ5YTZZbVhKTGlCamNlN0ptQ0dYdXR6bFNaenhaZmQ5M1BQbXRWaFBMNHZLR09ma1BxbW9FME80M04zVERBRHVJSXNNUHRxblU2bEh4U01QcDltTDdDTm9GUUVLbkZHWlJQcCs1a0pWbFRIY29JeHBJY3FyY3l4S0crNWdYT1NGaDFQSm56TVVoKzYrTDFxRkF3c2hZek5jZ2cxREwrWHhVR3lBanR0bWVHOVRIRnI0dmd6a3U2bFF5UGN1cldlSlhLaUtZdEVYSEd1TU1PU0sxY1JORFlUbHRZWWNVem1WdStNNUZmMWx2VjNHMXQwd01SbVdmUFZUSU1jZ3daeXBaNCtKbUk3bFp2K1BsbmlXY3dtWTRzekZDdXB3MGNibU41dkVIVWN0OVZNNkUzYXlzRHhGb01NOHNjRXhwRWpTeXdJL2FCY0w2WDRIRnhsOGRqT1Q3V1pOQkdGZTRnYkk1V1EvTlM3YnFPclUxTEtLajlnbUZZckJ0anAxRSt0cE84cjZtTTF5bmtjTU5ZUUtkc3FZNFBjTWdXcFhIQ2VTbXZnL3RQVVlRK3l6YXNKZTRGelVYY3R2Y0VwK1hBcmMxNm01VlFQaXBqakRVd1dtbzNEeFBreHZxbzRHTER1NDVDTndxRGpMT0RMVTdBL0UwbXZqbDZKMzhYUkJ1VjhEb1lPbUdFNEFSVWczOGFsZm1YZ0hVYWd3enlQV29QY3gzTlIvMU9NTU56c1NZdDZteUEzREZxQitXVis1b3l1NWxudWR4dzFMMVVNcGpreFBkeW0yWTdLbU9ZTE0zbDRMZ2FuK3BhdzM4RjlNb0NWQVVvaUxqL0FLZ3hSbC9pSzhXNDVkYm41dmNRVTlQNW1Iak9DckRHK21PRmJ1Y3JpQ2lFelFxcCtzVmx0amx1VW80UnhmNjVUK0xFT1dNNHE3WndPUjZuRXhFNVRJcXEzS3lUcWlaOGVPTmRrWjMxRTB3ci9sR2hUSGMyYWdicUxRNlBqcnVZWjVZbVhCUVlXdTJCcGNlNWpqK1k0eEZBc1krSnFxamp3Q2FRaVNrTHVkb3ptcFZRYlpZTVdYTVZxWVpQSmgrMmY2SXVKUWtyL3FDOVhIRVBlNXhhN25zbVdBN0lnZE1hTnU0VTdDWnBsVll5cldPTXBHbUpHWTQ4cHhqVjFBNHZjWURNUWNXMkhIWk91L2dtMG1BNFROSlE3ZzVFb0NGRTVXVkVoL1FKeERjUVc1WEtDRm54d2FuZmNIVkUya1JEWnFZT2tZNDRzUXI0NGpOWXh6eGhXVEY0em5jTXIxQkRDcHd4Q3lZWXJpc3Y2eSs1eFljaGlxVVF5WmN6eWFJT21HVGU1aGtGbFRLektLa04vd0JZMk0zZHp5WWdtdXlBQ3hOM1BGamxueWZ3U3Nqa3NDYy9UQTVFNDJ6Rng4Yk0vUDVmS2l1SWZxTGs1ZHhmYkZFc0poM1ZRT0NxTU1STHFLRS9sMVZRekU2bjhwaGdoSE93WU9EaisvaFJZbVhGbUNtTEVRZ0RQR0FwTTZjTG5rOHViZ0NxRXh6NVhVUUI1WHVHSm1kVExDa3NhbmVpSlVJYmFZaHlxRWVsbW1XdXB2OEFNUGpXNVdvTGN4QkdZdWtPNVdPVnIzRFFueCtTQzFVNGRXNmxVdjRpWDFPTXlkVk1RR0c4NmdWTWhHNVl1b0tRNDU5eHJGWVpKb2xWbHVaZC9XYnlhWWJKbHNvTFlQcGcwek50UGkzcDZsMUFBNVRIeWNmRXRRWm50MFZCY1NtQmN5YVpqZWJNd001NDFNM005ZXFtV09IOThuYjZJTHZoZFRuWUNRVmFycVpadU9kanBuamJ6N29tZERyR0pXRSs5UTBHV05ibHl4aWNXb0NTNWlGN21TT3NTY1lzZGtwV2FsdFIreHFXaExWamsrVEV4eTFPUEhLcm1BN2dVc0pqOW1LRmx3cFc0NGdpZjFuaU1YTnlYNmthenplV1ZFd0JXWWFkd0JGeXlwOUVld3FYZVNUUHg1NG4zS2xKNmlVM0JlTk1NVml1TXVqOXpxQnVQaWU2bUlCTVNOY1dCRWxibE15Ti9tQkNOSGN1WEhjMmRRM0Q5UzhwZWVIdVhmYkRMZFFUbktkMFF4S1dwWDFDcDR2NHd5NTRYbFdweGNzWXJoL3hsNjBSMFU2WTlXUWdTb0V5d09IN2dtajRxQksvVTR2NG1Yak1lbmMyM09Ndlc0WkJIeVJ6SVpIdzVzdkppdFF5WVBHZnpQT2N4bHRSZGIrT0krNFEzRkE3aFZXYmdGTStzNG1SS0RIOXh4eEhUTWVJMVBCWGs4ZVpYUktaL0g3dWNJNDhTb0ZUVUVaOWZ6RFJxWTY3WVhPSHRsMTFDMlY5ZlZ3eHg3ZmZjelBFNUhBVEdmcU9QR2NSWUIvb2hZdTRWUDhBRzh1UCtOL2tZZVl4eHo0dDFrYVkrWG5ubG5uZ0RsZEdKUVI4eTBaQWNmWk1yZ0tVRURJN0pUbGFzUW9ydUh2bERKYUM2bmEzQWNpWXZEY3p2SzJDVWxRb05UTmVPaWN0WDdnV0xFcW9sOWJsaGoxcU9PaENQNXFwaUI3N2xURERsYURxWk5kWk1XNFVDM0x1RmU1eG9ZSG9aamdBdk9HSXhNUmlBRXh4TFkwSFVLR1VNckY5VElGaVY2aWNpNmdLYUlqeUpqZUszQUJZUU0vWFVlYnFZZld4THY0eThoYzVFb3kyUThuSFVVUGMrcmgrN21YRllOZW9rSGRFVURSTE10T3B5bzZodVl6TVdBd0FpM0JzMlRUQ3BqZXhsRWVxaEJwWnhLVzUvRXROeHh5RDlSQ0dNNmU1Zi9GZFRKOVZPVXl2aUoxTCs2K3BpS1QvQUhIVUdZL3VWOFl2SFpqeW1BdHRReFJUMUt1Nkk2SlZlNEZrNHVPVjFPQ2dwUDQwWm5qb25XTE1VL080ZjZtV0dXV0ZocWRkd0hJVUtpTXM0NjdtYmxsU3orTmRzeHdEYTZtR0tHZkhwbm12a2t4SnhDYk9vQzd1QVhIQTlNd3hxaVpreEtOR3BYMjB6dkZ4dmNlNkVqZ1pHdTVTTlF4em5CNGx6aXRoTWJkY0p4Y2JNcFNQVXdNakZ2cGxYNG0zY3dSRXVkTEI0cXNQL3dCQVFHWWVQbGsxb21PQTJiV2NIeGNoUXltZmx5UUdYY3h3V0dEenBtZmpvWDNIR2kvY3h4YzhxcmN6eFJtbE9KSHg1Mm82aGdZeTRUeGY0K2ZtNXVCZGJZL3FWeFJmY0hhQk5HeUdDa2NVaFU5MzZtdVlPc1gzRU1GeHd5NWw5d1RjTERSWkY0enRYNHBKNzdqYUJjMVg0WS83bU9WSlcyTmVibzJSdkZtODVUNm1WWDM4WVowekxESWVTYW1rMUNmdGlxTjZxQWNJV05MTTJ2RFF6SE1UMi82bmxvNFZpalh1R3hXZGYxSWJ4Vm1CbDZJbU8xZHg0dVFZSzYzT0ltWGVvWjVFeHJpWk82aWprdXdaaGlZV1hkekYvd0NHajNITFBJczJ6Rk1GY3Q2bmpNY3M4ZVdzV2VZTU0zSEhxNHpFaGZLNDczQityREY3bU5iK0I5SkUvRXVZeFhIdUxyVVA2M0JTWVBMamNReHp5cmNIbE9OUGNLSmQ3SXpFcFljczhhSmsxZ1lWVEVjY3BqbTRaWGlicUMxZDdnc2JFWmp4Zjl4TWR1VHVaTjY1V1NzVFN2Nm1SbTRjdUM0bnVZcUVWZmlySmdJWEw1UURHSEg4Unh4WXE0OWFnbkdwYVMvZ2RRQ3RzUVg0cTQ0T29lNGFaNHlaNEYzTGhnVGg3aGlNR3BUWHhvZzNxNXFHZGVGd28yM2N5UlRrUDZxWEJ4aW5xWTc3SlZOMUx2Y0F1WXRPNDVGem1SYkp0OXpEREp5b2R6SVJwN0lNVGt6aFVRZ1N1SjFBV09EREhLY0tkYmhqT01NVDNIeC9iOHltcUovR3pnN2hnemd3eFNjUWdYb21PTlhiTWNUVE5tVTdNcmhkUUc1NGNzL0cySlZUSWJWME1WRnBsc09TYU5RRzI0WVZFbkM1d2hqcUdJRjNFR0NUa1hER1dFcmxPRVJtTWJwaE9MRENhTWRSYkxZWms1b1VFeXZqTDFPZStNdFpiaVZ4aDNiQnBtUnJxSGtZcXo3UVcyMldNT0ZWSGdaYVlXT2laMzBhL1UrK1ZDMEVjSEhPbDFQYyt3OXc4bmt3eGNNSFQzRkRTN2daVDF4UW5PbXVNZC9CSy9jRzVWa3BZWkl4eHVKVERrcWtBUnRtQ3kyQzQzY004RENjOVZXNXlPT3lLWk9vVmFNeHpCb0p6eFZvaXN2aVJmMUtneFFsMzNIaVJCZ00zeXFiTFlXNE00eGRVVERJcW1ZNEdWb3pHanRpd25YNnVVbHRXVGJWVGMzQnlXYkxhaGRTdzBtNGpXaURMYjdsa1pjeXBKcklsQUxVWDZnYW1OL2hZSzY1VFBITU5GeitMUEwvQUlzTU16U0pNZkU4clkrTzFwS25qOGU5dU1YQWRaRU04Y01lMVdENGd1bTQ1NHJvaDVNVEZQNDRlUXg2d2g1WDhCSFBsajNETDA1WEtYZHpKbkVTWW9FVWNaam1ZblRVY0RQclVQSDVNYkQzUDRNc25sUDRjbm9qNGxOd3dNWDl6SHh2bHlUSEJYOVR4ZUozZ2lJenpZSXY2aHRLbkRMTS9SSEhFN2xIcWNWYmg0MnBoNDI3bStTUXhhZ2IzTXZJR3duWXdHdFJVMmt4YmJZdU01NGV5WVo0ODJkcWs1NzJUTEt6NjJWREE0N1pnWTJoRXJGalNUQU9KY1dzMGRFeHh3cThiU0E1Nm94cVp2ajRlK1RPSUpaWkh4bkxsaVVRSEFaaG53MitNWTVmeUxaVWNhUDB6TFhraVpEK1Q0MlBIMUhIR3NybEFWSzJ3WEJYRExzM0xRR2NsUlRSTXFmdGpCdlVBdnNqaXpqWHpqM0hDalU2d2xDUVdYTW04WUh3aXpqUmNLU1ladURaTXF6T1dCdUdUanBQL1FKa3VUWHFjRVhKNmlVY2lYZkluR2ovQUhDeG5HODdtVGJ4Z1BqQnduOHVYbWZ2bGRSVlNlSXg1dkoxTThjVEw2dXB6Y1ZJV081eWNkNHBjMnJsbkhISnlLNm1OR2JpNDNNakV5NnFQbHljRW9xTmlURWQ4VkpuYVd0Nm1GL3hkYkprdVFYcCtNV09kSEVJRmorcGdDTEMyMmFpQkx1WTRLNlNkZmhoK2lQMngzTHgxTWQ0dUw2bWZEWEhiOGdWZC9CeGxITFRHN3FGZFR4QzVMam9JNU9XU3pySzNjQnp6ckUyekx3OEZPa25peHVadGhxZUpDMVlydWNzZkZtekp5VmRibm04NzRmOEU4QWw1VEhacVdzRGRNZE5HNWlnVXlqc1pqNDhzbnVQaWNQRmNNdVBlLzFMZVBHY2ZnTFdKQWdmbUdKTXFtQXk1dTRwRExLdGFtNjNHZHdWc2lqK29weGdyT1RhVGlNNGFtSmp3dDB6a1ZVSzQ3N09wcGdYWkFZREsxREg5MUs3ajMxRW5DY1FZQURWczNWalRCRTMzRGpOM29qZVVxWWhOcktmek5zZVFMY3h6amJsTXU0WUhkck1Ld2VRWEZ4ejExYy9VVUNZT01lS1REaURiRjVNTlpOVEh0R1dWUk1RdmMxYkdZcHVheHlHZVo1VEhBRnVhQmk1ZW5VRlFoayt5TXhhbVRPR1RqT0tUaFJwZ0xLQ0ZmbUFJdng2MHNHcFlZeHowUnlyb2d4eFE1RGNNY3EzT05laUpqTzViT0RaZWlabUpsUkNYa3pHM1NUTEhFMmR4VTBzQUpXWFVySU80Q1A1UHpNdjBFeXQ5QlV3cFdDek1SRkovSXVVdGU0a2NhN3VVRFFzNnd0Z294ekI1UmJMSTV2RmdYZStpWGNibjdKenJHcWl5b2EyczEvYTRQSFVPTG5VOXl4ZXFqVHVwZjFvSUFsektiWFJWVFVIME1xYWcyVlVmcVZOQkQ5RVFUcWRzb0lyWVMxdWRRZFV3WER2M0NudHFHQjlyeTZtTkJjdldWZTRHb05zN0dDMmFqbjllNXVvOTNITDJZd09RbHBNYzNoVVI1VXpQZFVCT0dlVFJrVkh4TlE4TFMyUjhkRjNNY1JMY21aWVlCZkptSEFZOEJhTlRsaTRWd21ieDBZMU1QS21PcW1HVnR0VFB5TnRRelQvQUpNNXVUM1A1TFBnU0sya0xTenNtR2ZscW1xalg1M09obUN2dVVRbjFtT1ZmdVpOcjlZWTIxTVBHSy9xWllHTmJqanJTTWJCdUhrYUllWkxBajVjMEtLbVBrWEMzdVlaWWJ2dWY0LytULzhBSHllRmJtR1RrM2M4aVpEWWx2cWVKL3h2R0x4YzJBcmxXaFkrSDI3aUEvZ2c4UjFCV29jcmRkUVRsc2xETWFJbUppbWxmZ1g4VExjeHB3bHJaV28xaVdUSHlISHFHVGtJRTRKbFZ4d1YweFRoVlRGKzhBWUFuVU1VeFllREp6NUpQNDhRQW1XQk1zc2MwRXFwbFYzY3piQklGVGhlMllsWnFtcW5tUjhSVTdtYThkVGRFUk5NY3VUMVVVZHdxYWYxY3p4b29ibkRLbGd1c1hSS3h4YkorNWEwckQ3VElZL2k5d0ZvZFJ5UXFHUUc1bWpyRWdOUURMZlU2dUMwenNoZXgxTGd6eWJyaEg2UDBua3JQQ3orMzRpSzZodkZ1ZE1YVTRwakx2d3VOeXRGekdzVzZHWXFaS2xrdUFhNU1kWnROa3hhbDJwQzJJR3Ardlg1ajNFMWM4ZjhUZk95aU9iMmRlb0dmYkRidVlZR2EyekVmdGZYcUhKTElObW1ONU5WQ21nT29yenNvRDFMMU53eGFGbDBzTkVGVGdlNGxLUjNkVEQ5d3N6MVVEdG1KUjNLZ1F5UzMzQnc0VlgyWUtNR0FWQTRuVUttTHVQOW01VWZwaDllMmNxRVBjRDhzR1hhNVczUERpR1BKbm15TGFtbkVaZmo1VTllNDlVR3YzUDhiL0dQTDVIUHJFN25uejUrWmE2MFRBZkdpYkp2TmNpamNTb1EzMU1ldnRNWXE0VmM0TnNNS1p1bW1HR1BEN080RlIrTFdJdlVMdlpLWWxkUzFFK0RWUlhpV1RPV2txN1JoakFJWWx5c2ZVT0JGTDFGeHVLTDFIaTlFcThwUUxFWjlvYUphcXdNcmg0M0hURVJoQm4xNzVScW1tQVVUaGozRktoQ2tnQkRoVU9NMU1RdmNBNWFJdXJodUQ2cWY2aG1HSlJPV1ZYTFUzRmZSRFBJT29ackQ4U3FtNnVKa2RFNUxSeGxxOVZIR0J4WnA3bVlaWTR1SkczZFMxbUk5dzIwUlBnRzR6azhkVGsvaUhrUm5OeXFGQXl6dWQ3SWR5Nm1XV0xCTHFGWmVwUnY2d3BoTWZ0RERHLzdSNGNXVWVtWTRudG1XVkZERmFDWGxCYWJtSzB4eGJ1NDczY3gyVzlrTWxZOThiaFlWZXBzZjFLOTAxSGlkTzU0VG5kc3ljbnZPVldQOW9QNHlZWHI3VHpXK1ZUTFVNODlKTXMxMHhQb00vVEd5QXk1ekRWUVZnSXpGdDNOak9YR05KTDlUMWN0aHB1WmZramtWVmtjZ08yWXNYN1QrVGJITW9tT2U1L05XcWhtUFpPWDRpdDdKYXRWRE9vK1g5eTBtMG5aeTl6SnFkNDJ6akFmZXdobVphU095QWFJaGlISC91TkxaRTFFQjFCdUlkU3RVVGdWM0RRdHpkcmN4ejFITlM0ZnRuSXhMdG5KcnJ1STQ0UXRRZ1pFeXhVaGprUnZIdnFkbXZ6TTlLTXhkVkJScVphZ01xaURETDBzQWxrc3h4bklaenhkQk5EYVN5Mk1HNHdBaE1mYk43cWJ5eU9VMTZZaDFjS3hVamxITnFpQ1ZEajMzY004UjJNOFdSMmJMNm1XV0pYMVM0dTJtRjdYTWc2MnloVTlTbnIwd3dSZjFQR3ZMbDZtVzh0RUgxVzRHSS9leG5EeDkzTTdIVXQrY2NYZjRqaVV3Q0ZuUk1yYVpqNCtWNUwxTWZHWkRBcktwbDRQSVlYUlV4OEJ3S2R6eDRlSER4OHZJY2wwVk9ONXIxakV3Ry94UEpuaGxub21XQmxoZUJVUHRIRTR3aXBEYkVvcEpuaDliSGNObGU0Nk5UTXNHT29oTEthbFkveEI3dU5HVVdHOGFTQ0VhU1ZXNXhLNUVUa0xkVk1jVExiM004aEd2VUhXKzV5T01wSmk4WDh4WWJoOVdtWktST1dFQWwxTnczTU12NDFlNGhrWGovYWRZNUQzOEd5V3NhQ0NzWEQxZHp1R080QlNwZFIyS1l6eDFHcFpjcWxXT1NDRVpoOXRSeHFVOFRsaldKT2ZMUjFGYXFISUlFdjc2NlpublgvR29Ya1RJeDhmanh5UzFsbWZKeUtTRlFiaGx5MThETmlJMVBhdmN4SElVbEoyN0l5cUdZN2d5aFlGUDFZQU8rNHlvQVM5QXgvVUFxSlBIaGl2YzhqVHlJZFJ4cjNCUWpZWE1NOG5DY0cxV1lZWXY2SmxqWThXWVk1ZVRQRERGdFdmNVA4QWtmdy8vUmhSeDdxWlZZajNNV0xxaUFCYk1VSUdQSmJnMFFWSi90cjQ0MlRoeEx1ZDdXS3R3d1hHV0VXYkp6YW9KYkJvaHR0bmpUZGt2SWRSNThCbWVUTWxtS3pFNDdnUVNZZ005ekxBcTdnNG5xSk9qVENpWEhMVTNka1lZd2VNY3VSdmJPdTRUSEtoSTQzMUtDaXBrYWhWVGlKQWpnK3VwbjFBQWhtWTRKNytCYVlBKzR0YWxhaHlJaWt0QWlPVjFGRkNvWXU0bVZrNC9xWWd1cHhYSmxicE5UQytkVlpPN29odHAwenU1aWtVNDNET3ZGK0p6eXlLaFpCS3VtNG5zSmc2cHhsWVYrNDVHQjFiQ3B5Q2N3R2k3bjhZbGpjUEhqNmFxY1J3MW5PTllRTkUvaUVaeDQyUkRrNmdBN25FeDJSTlJUVlF2bHFWbHhoNDNKS3FQanlWeHNDYXhObTRBZHppOVNrSUQ2cU9Ia2RBUXgxS2RrYW9EdUhWVS9GVGkveDZ4dmM4dmc4dmh6Y1BKalRRMUM4VUwxRnZTd3hNZDNCTW81MUVzc25hU2laRkVOempPTnpxeUMxQmJpWERWNmx3eE81eGNrdzZabmlDNHQ2amlHQnVlNXhKbGhqV3JnYmY5UldxSWRPdHppL0hadVVINWdFMHVtVmZ4ajlabXY1aHJkeHFyaFNSUXdnNjAvRGIxQktUS0dWRTVvSmVtRHVXcE1OczVPTm51RVBjN29qaldkZkdqM0hYeGRrTWNub21SeE5rc1hVM3hxYnllNGNoVzdnd3B4U2RFU3liVGJDdUg3alR0dGc0WTRYeGJsbWVVL0pPU0hVR3kwbks0WS9TWTd4NmpTRkVUNkRlNWo4REVJMHpGSm5yRVFKckl0WnNkRms1Sm9KZ2t5eEt1NTljL1hHWm9USEJ6emVSVXl3cVczTUtjMm9MaUpqRE5TZUFNdzVaT09MTXorSXlzdkgweEIzY0FtT2Q2U0w3QmhubWVwams3dDdtT2pURHlZZ25HWUwzMHpMRGtHV1RjeEUybXAvRG55dHgrcy9qMHpEd1dscVIvd0FZTENmd3ZSTS9EbGpob2o0a0k0TG9pWkdxbU5nNlFqaCtHWTQ1YSt1aVpYbUJZQk1ISHg1dStVNXJnOE1mVXo1OGoxUC9BT3ZLNXdGK3Vwa2VOOFI5a1o0c3UvSHlLWW5ISndVZjNERGZjeUU3WVZpQ1l5OHRuRVdjRnc1VURHamN4ZDc2bWVSeXMyRWZzMzFNc1F3NzNQb081L0dQNm5FdVU0K2xQamkyc3Jrd1RGMldSZC9xYjdtSnhpSU5HcGVPbjMxTEJkVExrNGx1b21Ka2NXSnlab2FOVEtVMVp1WTVKTXFhcVk4YVppMXAzR3BvWmc4SGxIaDVUa0FNektoWERYZndsd2FPS1JUUVFxOVI1Y0xHWU9QOEdSazdxZjNLTlFyQVlZV1hFNHY1aThpNjFLTWhHWVkrTCtESVZNNzFVTXNRQUtmYk04K1FBVVhPWldXT1RkR3BZRkozN25HbSt5R1J1RjI4V0RlZE5handjZnUyeS9Ed0hBUnFtWWc1SDIxK0luM3ltSGpHN2g5YmhLK0tUNDVjUU1ZWTdWWVZUbTlucUxlUyttRFh3Vk1hN3lpaWFQanRxZVREZ2lJd3RJVHg0M1BJVXNLd3hzTzRtOXNzNklCRUNHS3pITUJ4WTVQb25DOGJZNy9yUEJpK0R4WmViUEUrK2llVElWYWk0NnFHNGZXQ3BQSGk1cjFvbFZIRm1Ma2xTdnpLZWpyNHZWTEFJTk5RemVUTzJBSHdNckxKblJBdjRNcDQ4bDhiUExMdVlRdFpqQUlVTW9PMlZqRUZySHVPTGlibEZUcjR3MW5zMUdoV2NwVm5jNmhwbmNNR0FFR0UxbDJoUHJLcUtCREtMZ3lzY3o4Vk1pdHcrd3crdmNhZDFHKzJYN2d1VU10b3p1SEpzSWpmNG44aUlYY2NuYlUrOVRFQXVPZGJDWGxWcEROOVF5UVdjbG1lV1NoVVhLbWlaTkJaRHk0dU5WT1dRMGRUbGxPU3l4S1ZodGpoY2NUREl0dWNpOXk4YmhuV2dJZVJGcUM4RzVaampETmNaYlRjNU90em5Tck04eDNGajVGaGxaVVZocFdZVmwyb1JUQTAzY2Z2aFJwaVpWMlVSdExuSElMbk40M0RKcmVNNTAzc2x3elhjK3RyRE1QVTEzUDNCejVhYWV5ZWJ6K1QvSjhuOG1lWDJvSnR1R0M1bFRNeUNVOXBVcVlLS1Fkd2NyNmpjY1c0WEZTTjZaY01vcUErcG1oVGdUazVmQ3R0UjVNcEdySngydzZaanhkT1VERTlyRElXRTVVTVhVRXJlcDlmejhZWUF6eVZWUU54d29uR2JoaU9OTTRnc0x0RWdURSs4cjdPNWlUTHZVNDZtSkVEM0RERCtHOFg3VEREZTQ3V1BxcHlxOVFWSzZZaU01SHNZNVR4NW51R1I2aGwzSE5sMHJVTWhaMU9tTU1ad1FmaW05U2t5am9xcXVMU2tNZExBcmNjOU9wYlh4aHlGM01McUZsM00wTWNXWTZZcXN4NG5VTXF6ZW9DNDNBaGxpbVF3QUp5RXE1bzl5OUV5cEFJWS9sbVBqNTU0aW9YUDh6L0FBY2Y4SHcrTFBETE41bStXTlRKdTRNTXVLdUp1Y3F0cVlvRThSZ2VOeVQzb21KL055NHV2MnpKTWN1SVMrTFpOWm05VEZDT1QyUWNXSDRKVFJPc3FuOFNkc2NUeGh5elVlZ09vNGlVdXBpZU85VCtTc1c4ZEhVL2xHa2pnWGF4QmFqeU02U1l1RFoweHdGN0daNEhCbUtiQ0k5ODV3Y3lZZU1BYisweWM4UEhaaXF6Snp5d1YxRE50R1lwTWpFeW1PcytsSWVQbm1yV015T0xSRXQ3bUJXTlV6SHlJWlc5bFRFTVYrMWpEaVl1dHNNVkYwelJqbHJiT1BYTFJNd0VMZ2c5WE1LY2x5dVlvNW90VEx5QTFjc3VYcWRGeHd2RzU2bnE0ZmVVaUFrTWk2RGNjT1l0UWF4NHNjTjNqTVNwa1JxcGk5a2NVbUZBM0RTTXpUSXVGVE5QeEZzbCs4WWpsanRtQlh4cnIzQWNuY2NaMVV4MlZFRFBjS2JUUk1zQ2h2dVlqais1aFhURFducWVUaTlUTGlJaGVwZWh1cGZMRng3aCt4RWlIdnFja3hDOU04UU9hWmFKWGZIMnp4NFlZNDVjbGNwbmxsblE0QlJIRDZkMSttQ05lcHhYS2lmOEtuSDhiSlZkU3JuRm5CUGNveGxUUktZMUE3cUowczhlRjNVV0NwUktNQzVpOTZsZTRSM3BKcXFHQnlhWjVOdkFtV1B4ZTRRdDBXeitMSURsaHhzbkhWRUZKNHZIbDV2S0dKcTl6ejV1ZWZESCt1T2lJNzRrUDJUSEVDTkJSTVNpcGo5R2JYNDR1MFp4ZlRERnFCdWNTR085eHd0L1VBcXBWUzdJS2xJUU8rb09xR0oxS3kyd1B6TVE5ekRONEpqMU1nWVlFRGNxbXo0RWhPVitweVRvbU5CeU80NUtYQjFGTWdqbWRWRnNaMlFKVkh4VUFnTGl5bDdsVWRUZ0c3bERiUHFZekNsNVJDWlVOazYzQm9ZTm15TDFSTnBiTVJkREVXN1lZS1VUamtOMUhHc1pnT1c1aVo0WmlSeXlYWjdqZ1haMU9EZGtCTnNBcFlZTktNTnZiVTQxdkJtTGl0NXVwWnlkSWVweU95Y0xTc3EvTU9CYmszTU14c0FuSXFDYjFwZzVZblViUWFneDVjYnY0RVNrdWNaUVZSTXRIVUxUcVZyUkVvaW5HRkpHbzBGeFJJakxTRW92dUZ1RlJBb1lBQ3Z3QWtEVlhIOFFiSmxiS3lDQ3pUcElRUjB6SDJMcWN2akhGNHpGQ1pjVERheHoxVU1vb2FyY3ZuczlUUEtHV3Fsc3VKY0VPOXBMS3NnU2lZOENlOVM1Wkw1YWdnd1IyeG5EN1drZTlNMURIVHVWcWNmclREQlpRUFVYOFR3TzNKZFR5NWM4NDVrYzd4bDBRU0RhUmV5WUp5cDNISGJVMVZNVFpNY3E1V1MyQ2pOakhHeTUvd0FKelRYNW03b25QbDRUeElHOXN6eHJKTU1ySTJ5MFk1RzJQNW5FcTJhZXAxSGJMbGV5YjR6Ri9KY1B0MlZBZit5TGtaQitadTlrdUdmV3Bua2NiVGNjdVM2cUV5dGdjaEdjTCtoTWZFODBYUkNocUFYVWUrNDR4cTRiV1dGd3l4WVpLeTVodGw4bWtKUkt4bUNCRm9uTXU1ajVNbTUvbGY4QWtmOEFJL3pERHgrWE96QW9tVFg3ajlwalpMdFlFOFBCT2x6SjRzY3d5NEdQTDJKTTM3MUVZSTBRcU9SNklHVHZVeHdNaTBUOXpBQnE3aGlWL1h0bmp4TGViZGRFelMrS205MVV5UEhrWFM1QkFXNndxWkdkVXNNVTdJSlc0NnkxbEh5dVpZbGt3T1dUeVFHWW9EVGNVYVp4eElablV5eU9PblpNTG5QTXdGWTVDcE1zZVg5UnM3bVBoVlprSFJPU2FKbDVrVEhqYksvazhUbmxnNmdZS09Kb2o1S2RScHcvY3RDcWp0Rm1DNE9aWFpIQlcvVWNlV1AyZFRJdnFVcysySWx4TEtleU9OemluWkJhWitCWWc5TW8wWEdpZnNtSUxFMHN5enY2NE1ieTJsL3VZb0l3S3pXNDN5WlNUaVRacnVZbHh4aG9SSWw0Y1RzbENkL2FaNGZ1WTRwdVpXeTlVZC9HTVZINEd1NGJSbWRXUWNERExHcldQSEVNZTJZcVpUTEg3UjVMK2dnbkJzbU9PSk1RVEtlUEVNeTJwbVZrNURESFV4eU1kVmNUbkI0VzExQ3Y0M0wydzJDTGNieWFmeE1NREw2em1tTlluMnhoWi9xR1dCaDlSZ2lOVEVld25jeDZaMFI2M01lTk55bUpPa20xbU9ycCtQMGZHRzJtY2ZHWThUbFl3dVVCdnVZNmVwMHFtcDd1STl4QkM4Z21HTjVWMjNXb3dVNjBrUExubjR6azJuNWlQSmcxbitaamxuNGY4VFBNSzVhSjQxTHVaMEp4bTRUREg3MnppM0c3bmlDdHpYSklCcmxjb053b0xtVzhvSVBTeFpkQmNRVFdSSDlzQ2NTNFlscXNLTFFsNmhtN0lQd05DRWJ4aGJIcUE4ZGs3OU1DNVFRYllNN2RSN28rT1JGZ2d3UlZORU9raUtVUUdZWTVTcW1QSUdHT1M3WW1WemgyWE1jTkV4d01ocGdvT05RMTJSR0xMd28wd3l5eGFqa293V3FtSnVmVzZXY3NCMHk3SlJ5MnpFeWNXcUNIYmw2Zzc3Z1pOdldKRnk5ZFJ6ZU1GY1pzeFNkWTZJdDQxWGNBcXRVeFREVjNNUnJWU2xXNmpsaDZ4ZU1BTXRCSHRBSnQvd0JFenVpWXJUM0ZXQ2tWcUdkWHhoazF1VS9tZnRuOGxSemF1T2FrYzFCcU9mTDFIcWIrRHJYd1pVZFhESmhrbW9vMHp5N0FtT1IvMUdobXhtT1kzRkovcGphUlhHS200V3cvY3lla2ppMWNBU0tsVVRIR2hXUEpOc29kck12R1luTGtRTmNtcm1HWFo2WmtialJiVEtzR0p4YmgrK28vWGtuVE1kak1ZWGJLQWdVek1wZ2ZXRlk5ekxFZDRzYWNkVDNjOVhFSW9sUXdRbkdoc1psaVF2RVlYVnU0R1M2TzQ0ZnhlSUR0bjI1Und0bkVHbzRwSHgyemhXWStpT041TE1jRVdjWC9BTGxNTEhxQXFqTHBxdmcyUXBtYjlKeEg5VkxNZXljUjJRS2hpYjNOZE00d1RITFVLZDVUSFEvR1ExNmgxVDNBVTBSbUtseThydFFobTg3ZHpQSnlYSUlaTmJxWGx1Yk1JNU9tT2E1b2tGdVd1aURMcks1eXU0T0xqb21YSGdmbUJ5ZE1DYUdZOXNjQklZVk9KeStOcDlRbTZ2akdhcWNUc1kyak1SQ0RWM09CWEs5czBiR0diZFJXL2d5Q2VMeWpvMSs0NTU4cXd6NDEyL21lWEs4cHlxNWh4TWhaekN5cFk5VHhwc1dFY2owUXkrZ3JzbUdIa3pWcFo5bldRRDZ1SGx3QzBtZWQ0WGhNczI1bjVUeVU0S1ZNaFRhV3NvZVRiMUxLZUVXc0tFdU9UNklxdmRUaUE3Vlo5b1lPN24rUDRPVGF6eTR0R0VESEhLb1o1aTQ0dEV4b3krMHlNRlVaN3U0SEh5T2J1SCtTaHczeFhZVFBnWi9RUWU3bEhLQmc0MTduSEcrNEFUUE1YWEhxSDIxT0dPUjNNajdwaHNKWXNPUEl2cTU1M0Z6Y3ZFZldwNHNISmJhbURsZ3ZzbVRkZERNbm5rVVJMMHlnbHROd3NKaVVyNlo0dFpuOGc4WnhCZVB0bUx4OFNXVXdKa1locTdtd3FLd2g5V3pjdTI1aW5CYkxpS1QyTnlnZmR6UGpLc291MmJQWkFCaWJZU3k5d0xkVEk5UW1hVk1DeHFPSlYrNFgya3hlUzZoOWxJb2xRVTBOUzB5bUhqUE5rcm1ZOGZUTmNhSDNGNkk4WFZUa2pxWjVPYXhCQWxnVUxjS01GVnVZWjhHL3lUbFRZT3lZdll6QSsrK3BoMmt3ODJYajhXZmljTlB1WFBUSGxxb1kyYmR5ekdXWjZ4ZzhUSzRHeG0yVlJxUGN3YXU0aEI0aWtDemt6Q1V4MEU4bVp3QklPcDVNeHdNT0pmNWxlemM4SGtmQjVUTWQ0c3pjL1BubG5tN1d5dXBpM1l6RGloT05aWGwxTWNUK1ZBNzZuK2Juek1NTWRHSnVZdWtJNHZFWVo4WmkyM2ZjM1dpZE80amNDWTVWL3VjOGwzTnVvbVhVdG5HeTFxZFJ2SXFvbEhYd05UZmZ4c25HQnVVd21MYzhpT0FFR0dXOUVmSXBTVGs5RUJ1MmNMbnFYRmgzREc3bkNQNGhxT01DaWY4QUdVMUF5ejNqSzlaVGprNGFZUjhpYW43bHBES3B6bVdXVTVTeWN5THZjeVlPb1pNNXF5bGg0Nk5zUEY0M0ZmNUpYSEQ2WmlReUFTRGoyeHgwMWxwbmk5bUwxSDhLUjB5N202M2NUR2lVTVRIZ3RXemljYnVYaStPN2Joek5BSk1jTXJ1WllPRnVXeG1PaUkwWEt4cHZLSlIyU2w5L0hBSlVibTV4c2oxVVd0VEZWU0Y0c3M2dUNMMzhWOEVja1pqMWNNS0ZYdjRTV3dXWTQweEE5VEtrMXFWOVlseExnTmhLMjhvblZSRDNsTlRIYTduSnh4Z3d3MHR3NVcyQ0JLVG91TGtaaWxmcVBMTGNySndYdmNNdjdGVlVWeVdPYUFWQnNnR3hZR0oyd0M5TUMySWNTS0cyRFpxVys1ajR6UEdjT0trTEk5VkNvZ3pENmt6eVhHUEpMZ21iY01NcnJHWS80K1hqd2ZJMVBKZVRNT1hiRzJmWVk5WGR6bXk1NDIyYkhLZmJ1Y2tTR1dTc016YzVhbUgzRVNmMDFCbDZTWlpjOWU1aU9aT3RSVmdDeklibU81d0haQUUrMFhFeG1JT0V1aVludTV4eUlieW1lSjNCdDJUdnJWeE9LbDZsVk1HWkE0Um5Cc1NPT1ZzdmhPMktZd3lKNDhWdjhSbUdHY3BEZVVIOWpMWWI2bTNLaVZTMzNERXFIaU1kak1uSXhvSnl5M1pNY2JGUWczRFV0aFpqMmJuSEo5V0VjZHpLWUc5eDFtelJQRzRPR1cwWVlPZVpQUGp4OGp4aGt2Y01wYXNOa3VZZWF0VHgrV3M5a3o4bUM3MU1mUGlZRlpKTS9KYVU5RWMxd0NlUEl6d3JKcVZoMGJob2FJSEo1TXl3eVhVNFk0YWRUT2pyWlB0bVVRd2NmN01jYm1BWTQ3bmpMV09SaVVHMG1YTnAvY3B1WTVWUEpudUdXUERxZngxc2JabFhEdVpHaHFPZzdibmhRc1pnWG16SXFZNGkyc3pmRzQ2eGcxaUpFNGwzM0ZlS1k2bWVBQmNNTXM1NDF5ZUdnWm41THk0bGZXWTlNdzhSNU02V3BRRGo3SS9adVpWNitOM0JjbjdKWHFPVGRKOGUyMlVVTVc0a1NpYTR3Z0dzcmpWdXBqZVYxS0pkRTRPZnJjd0RHOTdodWZ0bkhKeHNhbVgxeHAyekZ4QzRaYWkyU3BqWmVybkZJWlViN21XVHNJS0Z5eFAzUG80WTZidVlZbWVMajFLMi9xRk82M09SOXNVOWFnMzFOOXNIbXJGMlRIN1pzd0NiZGVtT0N1T0lhbkpIZ2tzYlNIMm15V3ZiTnNOakhMS0N4SU5QSzZZNFlPSzhwMGs1OFhVeVhKM0FPbzl4VlNlMitwdC8xTDFPeVlONWI2Q0x5dFl2b21KdDl6LzlXaEF2WHFXOVNpZjQvd0RHNFA4QUpsU2RSejVacGYxbmdLemZKLzhBaEkrUWNjbFB0a3dzN0V1WFFGempRS3pJd0VTWUp5ckwrcVNpVU14RVhlb0ZkRXh2M2pPYmwyRXRHQnBacTVrZzZoRm5OOUVUUEkvclV4SGlqRmxXN2dURnV5Vk9LU3BzbUpEVVVtT09MNU1lVmd4cmtoc0dhTVlKVjFNZHJaS1BqSEtzV2M5Tnk3Z2xRemg1ZVVLaGwrbUdhV0V4ejAzdGhuMmJsdHhkM09XcGJFYXVEN1lyS1pRM3VKS1Uyei9iQUU3bU9KeHRaL0dZZzh0UndMNy9BTlRQSFhjQUNpZGU0WWM4T2ZJSmw0c2NjQXE3bHVPV3lYdG9xR0h1NHBjdHg2aU1FNXh3Y0xhMHhRTVNtL2N0b1RDNWxkVVkxYzR1Q09jZkl0azhsOFQzRjNpUnp0cGhuaWVwL0ozWVF5dEdOekUvY2Y4QWNhSUw4YzQ1Q3d5QmlLc3FBM3FWUDlPcHkvSHg0d2U1NHJ1S1cyelBLSjdpbkdjdVJES2NpcGszdjR4WXdUSE1pN1pZdXBlTkg1bVFWTUU0YngzTTIreW1EWnViVHFPZVFORTVaM2R4eXl5Ylp2OEE0dXBoNUVUVThxNStSeXlPL3dBUzY2STVQNDJUazhlb1lvS3greCs0RGNwcGIzTys0NHpGSWgvMVBIbGlmVzJwbjQrWTU0WHFWYmJMM0xJUGNDS212VU83dUdEUDhmaDQ3eXlaNS9ML0FDdmVvR00xVkxBNEZYTzdGaGpVQWJ0ajR0V01wOU15eDB2YXh2aFB4RFdhdlRBcGFtQk9RUEg4emxqeWxDeEUreEFGdVdZdjZqdDFPS3RYVTQ4ZXR3dklkTU1VbVdISTVIY3lFQ1VRMUdIdW84c2k4cGNHTGZaREQ3RE1jbkRIUEdqYzREa2w2bVAxVWhqWmF6aUswa2JBL1VISUZQYnVEVmdGUUx1Y09yMnJNc0c1NDlGMDE2bEVNK1B1NS9iTFJLcUd5YkRxWTZidVd0M0RNSi9QcWduTWRUK1I0VHVnZ09DM0xzdGdsTE1pQmxzRmhpcnFaWWcwYmxSYW5LMkdLNTYwQk1jc3plV0tFOGdpdE81aWJiZ0cvakhPbWlEdG1ONVF6dnZzbUtQY2Q0VGtidDNETEtobmk4MkJuYVdIYzh1Zmc4MUhoT0xVNHVHU1pLc005VG1WalpNdDR1b09PT0ZVd1Fyajc3ZzBwRVc2bVBoYys4dEV3OFRoZ1pVNzZhbVhrY1hyY2N6QlYzeWhsa3lsekJZOGNWaHAvSktYN2RTanBoaXZUS0xCZEV3Y1Mwbk1kbU81a0tYQm9wSU5lTEtQaXJBY2YrNTllN1NPZU9QaW83WVpPTEROeTBVVFk2ZzhmdTFxR1phcHBqajAzVnpOejVpazR1S3g4V1o0dWZCbnVWVGM2enVwMDBTbW8vNmg5OEFQVUxHTE0xcUZ2clVxckdZcFhIMUtaVnJUQUJZSVI4bHJjNUFkUVZzeEloakR3LzRtSCtML0FDZVQvS3J5K3NLaGtaRFpFQm9KUmRQY1BkUmF4Z21RaExlNDB0K28xbXpmQ29sZFRrcFZkVG0wa0NzRm1LM3lKZjJ0aFJuUHF1VUFOeFFtV09JbkI3TnpIL0Y4ZVgrRytiK1lQSmVzSUlLT3BzS3RxTHRMdjNjOFppc01UN1U5ZkJMYm1yajhlb1VQMk5IYzh2OEFIa2pnVVJMeUFudmNDODV4UWdXTXA0UXRhbnJpVEFLcGdZMmd6RW9hZzNxZVBQREh4NURqYkg2TFpLbThUNHJaUEhnWUlzZU9XWFFFL3IvajUxNzFPS2hpNjFNbHl4TWFzSWxtaEo0MGNVeldjWmxRQXprdU5ReEttSnVWUnExaGpseCt3eWowTS9qOXZVb2RZc05YUGQySHdFRDhTMUtXWTFjVEVXWGZ4aGtGemtYT1FrNm1UY0c1cU5VVXgzcjhURExYVXhWbFpmbVhrTXZLTjJUTFVzZFFkc0FkeENCaUVIWFU1Mnk2akN2ektna3NoVlJ5bGtDcFpTMUUvQkFaVFVvbUlYTWVKWWt5QlQ4UkU2UDlSS0x5SmlqMlZBRmR3elRETEViSFpNczd3THdxcHkvSkR5YlNwWVRHbDJUTnhDcDQ4Y0ZxcHhKNU14NGdPcG1qbG9tS21hV2tNcU9Ta2ZLWjZWZ1l1VE9WNGFaa3Q5d0RKbU9JTzQxK0p0VXFMTVV2Y2VMTmJnTEQ3YWxJME1wbkd4Wmg5bXBRRlFBeW1FNFdNNjBRR2JCbU5qdGdDWGM4Mkk0bFRFb1Z5ZzRrcjBTNjBkd1VpTVI1QVNtVXNaMlE0ekV4ZFJ4bUdLdlRxWkpsdW9wREZ6TEhVTWQwck80dE1NYUpnSTdtWnZ1WTFidVZhMHdQeXhmVnpIdFlOZW9aZmZxS3JITElhZmdqVThmbDQ1QjZtWnpid2poa084WTMrS2xKRGxsMU9PWFRNTUF4dWM2S2pubGw5Ykl0SVF5SXRMcUZ2WktibVN6N1RKVHQrRnlNWW9rczFOOVFESmd4cUd0em55QVNPaWZxYVNvYjBSMXFDNGx6bXorUjlseFdkNHd4NGtwYllCT01iV29KTVNaZVE2cWMxUDhBVXR5aUEyTXVwejExQURZVExBN3VZWURpL2VjRThmY01lT01NZnJkOVJEV1J1T1dUZ1l1TkJPS2k0eHhwZFMwZGxrdkZ2NndxZ0xKVlpvczVibFR2VlRIeEdYYk0vSGpWanNnRG9tSGpkek1LM0tBZ0xpaEZ5aGxsT1NpTXdzTE5zNUNvOXl2dEtPaVlaT0RWWFBPNU9PT0psTXhRT1V3YjVUUkdpMkNMTVE1UUU4ak1RcG16cGdxMURMdlV4OGk2R1laWlhRVHg1cVZYdVBKeXIzTXMvSmoreVk1NDVqWWFnNUtGeGF5Um1GVmwrcGdIczdtUGlDMmZ5WTQ0OGNUdnRqL25lWEx3bmhNL3FkVEZWKzg4bVdGL2lvK1N6UmNlcm1JSXF6THk0bWdtZGozQUloaWxNUXhuUExBUHhDc3d5eEp5eXFaWjVYc21GWmMrZXZ4Qnpvci9BTGpueXkvRWNSem1adVlDL1U3bWY4ZVhoNGwveWtBY05WWitZalFuVUUzeWFycUdXZjhBRHdod3hwVG5sN1BVOG4rZjVmTi9qL3hVWVlIckdQRk5GVEVjeGhZQmtUTEhaVUV3M004cjNVdXZnMlZMSEdjZU9PT1dLRXo4M0xDdUlRUWllb2hpL0ZSSTVQR1ZsL2NZSEoyMng4YmY5clB6QVM0WVpaRGxMOUp1Y1gwN2dLdU1MblZrQXI5ekcvY3V0d2ZveDBiWldQSGtaYm02NnRpNnFHeXB4V0ZWRUhDR1FsSnFhR3dndVZXbEV4OGE1T1YvV1ptSEhUbGM5SXhDK1JMVW1DbVFrY2xjbVVZRm5iTlZjOVhEdTR1b1lhY2xtVDFLOWt5emNtMGdLeXhoTCtpUnNPTXhiWTVURXVLVEkzWlAyeGNYY0tKUTRRYWdQT1laNGNmdEs4ZTZtZmtydzRZalBOa3ZUUEhtQzJTODcxT3RNNVV6U1IzakRxQVE4bWFWNmhsbE1tT1NRM0ZpSEtYVFV2NDVRVm02MURLbHVkd0FtbGdwYzVRTlE5eXJFbkdtTlRsVUpsMFRsV1ZzSDFNdkpXcHo1a29ZZ0dwYVRFZkk4YkNVRmpsMUZEcCtHbUd0TU85VFl0eHNzbUkxTWNTTnJVeE5seTg3UW02bVF3SVpJcDhZdkZ1TzI0TXRYYk0za1ZNTUJxbVVXbHhNU0lIaUNWMk1Dc2FyY2ZHbmNFUUFxWjVkWXNVT3NwcmxhNm5ON3htU3NMWnNtem8rT0psSHhrL2pycUlHRGl4RUpxVnBuR053NVlyTWIzY1NuVXRIVXRTWGN0TXlHRHRaV28zUkZpd3lLWVpEYzJzTHFaYkNCcGhyS2FGanhtaUtKQUVsTUdpTEJoTWVEZDlreDRqYk1IK3lNeVdyaHMrMHg1VHlPUzFjdHZiRXUyNVI4REZKcUdlTzQ1RlVRY2JJMHdmU1RYY3g5a2NxQ0d4VXFjbzV1UkRMS0hteU10cEhMRnJmdUxkdGxFRTNXVTVJQU1jMGRUbjduT3BkbHh5K2hIWkJvajFjY3VvdHoxTWFqU3poVXp3TzVqeDZZNUhLdlVBK0ZiZ0p1R1dYVDhibTZoakFTOXdDRlhIQXFiSmdscXltMnBpb3pua1dFUlk0NkoxcGpvbmYrNWlWbmVSTThjUlVoaHFKTU5XVE4zTU1pM1UyMjNPVExRZjNNRjlkUUgwem5seDR3enkwUkttS1pURUwwd0hCWVljcldjWVRzNnFGRGNWdnIzcVo1Ti9kYmhsUkJzYWhobCtad3RSeWhqV2htS0FqRFRxT0t1cFdQN3VPQUdtWTQ3RnlqaGxpYzBzWmtab2hqMU1CY1ZabFYzRXBFNmhqdFlMeW1PVjJFN243ZlVNZFQ3NDQwRmtIR3VxWmQ5TU0wN1laSnU2bjhobmx4ZC91WkRqMGFtSTN1R0tMdWVMTGl0ekZ3QzU1UEk1RkRHaldURHk2TWNmVTd6dk5tbllUTFBKUnkwRWZLVTF1NGFSSlNlNWlobGJ1T1hQTExLTkFYdG5MSEkvcWpCMGhQRm04eTU1TEZwSjFTczVtVFlkTTgyWDhtYjZpWmNwdFNQVGNMbFd6S2pwbVBnemJ5RXAvY1BCZ1gvSmthSmtyamM0SkRSVUdoSTFpRGl5M2tyN21lZWZIK042bEhUTStwcEFHWjJWY3hFeWQ2bVpqaTl4enFYUi91SEhnNHBESXhhRDFPTHRnL09MQnJLbnFKU3RNNTNqWEdaYVFKaGs0WjNITGxtcVF4N2FuTExjeC9wRXhTNGhWa0tYY29xWXBUZlVlS0ZNOXk0ZkZ2OG1wamdHT1M1YklQMWZnc0xDSExFTW1rbUdWNVpLVHlaaUV4Y09UQVFuSnFOWWNVZHpZL3dDNWxYcGppbFBwbDNqQzZxQlRiRFlsVFYxVTBtbUtCVVlZUzZaMHpKVm5GeHdHY0hJNVZxQVY5WnFtTGNWanFManhnYmhBWnhFdG4vUDY5VEpRS0xJb3YrMlk0N2RibFU5eHA5d3JqTWNkempBOUVmcXl4M2RFeHpUWHFFUnF5VlpFQWxReW5JZlU1UVpjdEJta0xtaUR1MkZYY2FGcGd3YmpRNmw3aU1JUVhHWU5yS1BjMGtmR1hwdFo0OFhIdVVzcCtLcmNjU21BZTV5Q2FTeVlCMnN4U21vN0xQam1maUtvMU9pNFozREszdVArNWMyUzRWdTROUXl4Q2lPUHVQM0lDRXgxNmc0N2pnZnhGdTV2cVk1RkE5ay9sSDhESHkzaFRqdWNrZGR6SnlabGttcjNEbHE1MXFEM0RMY3E4YmhsVUZSeXFDdHFWTzRIVVhrdHloMWkyeDhlUjJFMGxIYzRLVGs5Ulp4ZS9VNHBQNnNXVlNNNVVxd3pxcHoyNjFMWlgydVhMQ0FNWGpES3lhY0lkL3FaVVlxd3FHSUZ5NXhHSVhRd3dydktWaldtWkJXb0pWVHBsMi82bHJNT1Q0OHRWTGVPMk85ckZiN2pkMk03OVRMczRrNE5YTDlTMVlFcG1lRGdpazF5aGxZaVFLaURLT00xeGxGRUMzYlA0cVovSHZVNEU0d01TVmpmZW1jZjFIV1FCT3lBekFNb1lFQ2xQbXRialNRQ3BpQ2JsQXRRMHdTSmVFcUdKREZ1SldSS20wQzVWd3dTYkdGcnFaM2kwa010ZFFhZFFSbHF0eDF0WWlCRGVRdWlaMVdtRFROc1RrZDduVUVlNGZXeUc3TDNFMEY3anBtTnJMM0VJb0dvOWRTNm5aQk1SSUZUL25xUDk2eGJ4Z09Wa01Ebzl6aTQzVEtiR0tpakRPbThaejN2R1laSU9wam1VbnVHZjZJZzRvcXNQQ0dGM3FCTHBTRkVDbXdtUllzTHFOdlVjdnAxSEg5azQ4VysxblBQZzJ6SExNYnlkTXlzZGRNcjB6SlRVTDNiRm1HTk53REUvY2M4Y21XMytvZVRLa0lmbGh3TDFNTXNUbHl4dldvb2R2OEExSE5hb2hrNXRaWm9URE53WDNPZFo4bmY2bWYrUU5jU2Z5dVVySVZ1VmtJcGNzdU9RTU1jNzdvajRuamVURERIU1Nxc2djUkVuTEgwYmpSQUJ1Qjlua3d4RlVtT1JqZ2pGTXV1cGdZY3Q5VE00dkhxelV3d09YMnoxTTJHU1pkYWlZMDMyc0xHcGxZZFhNQzNlTXp5U3dkVExZTk56Zk81VGliZHNyVTN4aG9UM0N4cnVlVGxwWTVLZFFmcnd4cGlaR2NPSlhKV1p1Qy9VU0E1NHJacVk1SEdzaUlYYXprL0dPU0NTaFdBeE5SSlNuOXBsbTVBUkZ4MHlwcGdYcU5sRnhLV0J3SDNjN3dtTEVLbkV1TkRWWEFFNmxkd0tnUUhMSXhQY3hhei9OZHpQaXRuVEFldWlHUmhkbHNIK1h4Yitzd2IrbDZJTjVRVFpNcXF5VUl3ZFFRYlprSmpNa2M5RU02R3c0TS93ZlAvQUkvZ3g4dUgrUmc1bVI5YTlReUJlT0tucVo0WjRZMjQxY0lDV3l6akVVZ3ZTVGltNWVteURNRVZHVjNiRHladUhBNm1PVkh3aVpSVmJqbVp5cFY3bU9wNHZEaDVjTWs4dUdLZW1ZUEt3OWFqZ3VuVUN3d21RVlg0SWlibVA3bEpCVW1QN21LL3lJdzNkejIzRGowTUQ5eHJSeWpyWEtISDNreFIvYzVrRHRuSStNUzQwRUxxamIrSjEzWitwcXBobmVwcGdmYVpsVHBKVzM0UVlWREo2cU9UaXd6R0xLZms2WVhNY2J1YmhNY1JMV1pZNFRnZEVNTlF4d0IzdUdLVEs0YjdKanlxanFLd01YdVpnTU1nbklZWkIzSE1oa3d6ZVhVWGxCanIvVERMTGhyS0dTRDduS1pac3dlUmM1MHhUS0dOOURQR1pSQnkzRUlaWEN2VTdmc3pXNWhsbTRWS1JwSnhBN2hXTFg1Z2s5V1JRUDhBY3hvZ0dXM0xxV09pTkhUTDlrZkpYYy9rRWxyRE5TZGFab0tpTlR1cHZaQitiV1BLR00xMU5Sb2FxTGlsVk5CREo0eTUrN21wdEpqaXcxT3lWZmNNQ2NaNUJ4d0tLdUthSXNNdGVvWlY2SUdMUHFHbmNlcTVUUjA5d3QxT29uMW1RcC9xR0VTcGU0eXRFTlhGRWdUN1h4dWZiRnE0R1Z1NHFUamUxZ0V5T0pQM0F5ZmNiSnhLZ1UyTVc0eTJxajFEcUMvQThZdkdHU3hIaEhaQU9QY3dPUTNsVXhOMWNXbWhuSkVHT29aM05Od2o5czdab2hTeHhtSUV5eHNqaEtaVXE3ZzhjWTEyc1djaU5USFBqdkdDWEV2TzVndU15MjdpRVNiZ0t6REFWajlXWTd5M0Eyc0M4NWtDMU9Sb0hxUDJkSmN6OHFGSDlweDhtZHVTa3hNc09sWVA1N1llYkQrSThUaUNleUpoZ1JDR28yNkhVMWdXYm1WclpERExJYU5CS3JDMlpKbG9nSkRiM0srd01Rd3QvTVhRaER6Y2ZGeDRXeFRsZVR1VlM3dG1RVmZ1VUxzblRIY0JKa2lXVGdWZHh5UWw0emlPQTM3aTBhbStGcFVzU2VNeDQ1YnBPcG5uNU9CZlU1WlhNcjl3b1lZL3luREYzY0h5SDEvRXl6eXlnZ2Jkem11Tk1GVGU4WU9OYWwzdTV4c3Naa054Q2Y4QUtlOWtNZWFWTU1jY1JDbGpyTlVhZ0NMVThhWldCMUhIbnQ5U3NMYkg5TUF6Vzh3Q0gyWms4YzREeXNpN25QTXovRXkyei84QVZKVU1GeHM2aVlHVmJTZDQ2YVlXRldTMFplNmpWVmRzRzJLQVREU29YRWhydDFPSVN3dUJjdHBJR3BjN1dZSUVWU0xQZkdCUFZUZzE4RFdLMUZ2ZHpzdUc0NmgrdTV4L0hjMlAyWmtKdVltTUFMdTZtR0prb1ZZUnh5dzJ6REF2SmJ0NmpqUWNoSStQbGtXekRqYVJxY21xSTVIWVF6TVhSRUtzN21WV1hETGhpNnRZWXZHNGJlN2lKRHY5UWQwYmppaE1mclhGcEo1ZkpuNUVYSzY5UXRuaThuQXl2RWVSVWE5UVV4ZzJ4eVVON21lSi9IaWpkekl3QUJ2OHdNVWZ5UXl2VlRCK3pEZU1jdFZVZHU5VE1CQVpvSnVmOFFKaGh6YWZXNEEzbDErcDRlNDdZS1kvMWU1NWNib3hIUnRZQjdZVnZUcWY3MFRISVBXNHFOd1NaMFJ4Y3NnSnh4Tzhkd3c1V0dwalJYNm1UZVNoQXZ1S0RVdlZReXF5YVlQMTZnNmh1WVo1ZVB5V2FaazUrVEp5ZHM2bmp3eXlzeExXWjR1TFRxQXhIakcxaGROemljWUJWUXNsMGt5WEtmOEFTUmZVSy9NNzZtQll3YjFNMzFVRlBnQnVhZ0c5eXdOVEROUGNicHNoazFxUEtyV0I1RTMxTWJtUGJiRUluSWdKZGtjZXFnTjdJRjNxQTNLbFl1RXFBTHRtaGkyVktGdWE0d0xJa3huTXd3dTRmYllxc2NVOXh4M0sxUkRGbXVrZ0FOUXhyR3lPU0w3MUtjNlhWVEVPZHdvdlVUZzBidVpOT3pxWkxScU5YMzNOUnFwc05UaXU1eGxIS2FyVDhKOWVvQ0VEamx0aTJ5aUVKYjhkUGM0U3FZQnY5UWRySEZnUUFMV2EzUFJvQ0VmWktndjVsYitQRi91ZVp0eE9VNGhMRmhsUkxXTFhSUHJrUmE2eGlTOWRSVUtsL1VJT1JaS1dVd09VTVVuWkFPbVpHOU0zVEIxTlhjN2JJNklJa3hCWlMzcU5WeHFBQnFYK3ZpdEpNWlJOUS9iOG01L3VMaWtLclVPdHM5VGMrczBNOTN4aCtVbVJaM01BcmJBMzNFM1l4R0ZzV3Bqbk9RZGt5Umk4b0pGRTcrQXUxWmxYSFpFQkQxRXhmVUFMMUNzWDhYRTJ3Y2dpTDJ6MGFnVFFQMmdRMUZJaGx2cUNUSGdlUEsybVk0MnUrbzFEQzk0a3hMeW5BcGEzTXZKbHdRWmg1VUx5Wi9KOXZ6TWN6UExlTlI0SlkzTmErMEdoYTFMeENZdERONUFPcGc1R2FYcGk2NHlzTWRyREl4TmJXSExObmp4NGVYN3R4eHdWM0ZERUNHVHo1RzY5VHlyZDFheGFDMk5kem42TnNPNEgxV0cyWW5aVWQ0M1VieUNPSVowelFPS3dRSVpaWkNlcGlHV0NYU1NsWTliWVdOems1NWJxS1RyTDZ6SEoyWDNCUlJtZUppbnVaWFVNMHdBaG1ZekRpNHJNY3FKL0tPUVphbVlMcGxBbFRLc2NkTU1zUm1QbFRQSmhsencyUXp5cExxWVlJM3lqbDJNY1FUZGt6MGFaaFhGL1pPTGt0UnZGbjJ0bEx0WTA3dW1ZNVpWTU0wOGZGMU1zZjFUQzd0Q29ZcmZHRkdDM1BHWU9PVGtvblU0NDFmdUFoZndaSloxUHpiS3hZb0JIaDJYTXVJRGk5emphbDZJSlU3VzVWM0JxRlZCTVhsM0hsek13N21pWlpjbjhWTFdIZGR6TEwxRS9VcjZOYllBWUZmMmpnMWJNRUwvTUJXNForSVI0OHZ6YzhyNDh6NmFtUGljMnNTMlplTEl2RjlURFBobHpOZXBqa2ovOWhwbUdhZVZhRUo1c25MSk82bkpkUGJQRGpod2ViVEh4Q0NNenc0ZVFJUFlkRUJRbnVKZVZ2dzVLVTZJYWpzdUQ5cTlTamxZeDI5ektnT015S0JuSk5ZeWk1UWtCY2Rtb21QcG1PSC9PNFpGRkV1ai9BSDNNTWpGRk96YzVPZVY0bFRISDZMY3djUXE0eDZuSzVUbFAxY01rWmhsN2hqeW1JT0Y5Sk1HdXk1NDhUeWI1VUU4K1p6YVpoZ3JjeTVmcXB5WElHcWlPNGNIRGN5bjltTmVQUFdVd3krajdsbndXd2F4amtQWk5PaVU5TVFKamtkTWNjVm44ZkgzRTNNVmx0N2g1TWgrbmN5eVV2T0QxVTVjWnpyWk9XVE9ZSGNGamxOdTVoa3orVEpsTHBpMDFQR29JUWJVWnc5RWQ0UXJIY1dDQkdoSU9tR3RWRUdVNlRxRkdmMm1UaTVvZFIwYXltTUEyc29xR0lIY0RkWEt4QjNNUU84b1o0bXBjQWQzR3NZc3ZHb3NNdnEyYm44aWFEdU5kU3lGdnFFckdwaDVNTVNQa3RTb3FRdnFPT3RPNFl4cVlaOGRSOHR4TWxxWWxMK281MW5jeXkzeXVOT0pxWldZN2xEQWkxSEpjZjZ3V29ZL2xpYXNtSUxUT3VwYWt1SlJiQitsZkJLbmV1b2xUVEM0d3lZV01XOVRIQUh1VnhiZGtyUEhDOHNISEZtOWxXVEhxb05TNE5zR3BYSnFZSDNTWHQxMUdWYk8yWHg2WmlPWnJVeityVEhLeVhCR09UTUZZNXNjbXBaTU5pakRZM0RVK3FTNXBqb2xpVWtEMk1HQldjRURLR2ZvbDdoV0xjdGdwQVdZbFhHNXVKY042aVV4cVpVazFVb3FZMEV2RkljS2lDeE56aWY4QTRvMVdtNWhFSVNpTXgvM0hqVUFpQ1FUcURCSWdzQjNVRkhjS1laSEZzNmhtTTFvaVlwQTl4UmhUanFOaTNMajQ3TDAzTVBGbWlsQmp0M0V1QTIvSFJVejI0clBHZzFmY3kwcFUva3lTZ3FPV3RUTnpDL1RGamx5WVptRXg4b2tPRlVNREF4ZnpISy9GeEo0MU95NXlIS2NyVzJwaCtWZ3U0bXVybmFCcVpBYk10a3NUbGN4UXRscWxUckxSTXZ0akRaOXBrT1hVQU52VXdwTjlUQmJycURNTlpOejFSN2lBVk04VFVjQS9jb3FCV014eHlKbGJPRk8yNXpyR21XVXpDbzVLc3d4SExiTWtQSlJ1WTVVcTdobTVPK29MdXB4emR3VXVZcVlxd3pIdkdHdHkyWWNjeXIyUUQzTDN0MU9PSm9kcE1mQ3QzbE1YTEVXeGxaTDBUTlJwaWZSSmdIVE05RS8wekZWUm5HMnJsMW5UTUsrMXVwa1lVQm5NMUxMdUdUVXg4amlOZSs0T1BVS3l6VmFJNFloaXVURk9XbHFlUGkzY2Q0S1J5dUNPcWdGcFV3NU9VRGJmd0dYQmc2cG5Lb3dJRmpMZU5SeFFGWTc2bHdBT1UwMnk1eWNacTdJdVdSQWVTY2U0WUo5VVpoL2laOTVPbWViRERDakV2VzJZZjVENHNlQUgrNDVMbGt6MUh5WloxeTlTdzMweC9zdnVIK3RzNVVJazU1Y3JHWUQ1SGxrOVRNeDVaY2VvYktKbnNESHVZcS9XdHpmVnhnMlJQeDhCbGRFekF3SzdsVkhMVXlwQ3RNQlZMTkVvNFdPNTQrR1grTm55eWVaMWpNLzRYQWNCTS84QWxjeFhITHZVdVkyM3loY0Z2cHFaY1R4Qml2N0pnVWNtZVJic1BySFpaTGl3QzdpVUl3c09MTUNEdmNNeUttQ1JNWEcrTEhKbzRzSEkzbnNsRG5mcVVrTFNvNm1MWlUvZFd3c3U4U29DaXN0aU9ubHBuR2JpSmxjY2xDVmkrNG1BUXlKemR4ekRIcUdWRnkxK0wrRzBDT0lRSTFWUUhMUk9DTk00VVRyY0EvY1cxN2dYaE1jRWc4U0dzK1F4YkdNMnRUSXhyVjNLMThibU9RUGFzdFNwbGNlNVN6RVlpc2NYSEdHNVJZUnd0aGdjRWlIRVBjY1kwWXgzTk9sbU9JYm1OeEE5d3hzdVZwbjFHSlJyS1lsOXNmR1ZabER4bkhidVk0UEtZNFlya3NLTnJHcnNuSHY3TUFDTERJVG9scWlBUnU0NERISEdxT004MW1PQnl4TlRKTmprc3JIaEhLaUZSY2s3blozQW13cXRRS0x4VllXd0UwOVRqYnFjUmxWTVMxdVZDTHNHWTUveG1lTGlaQ2R3UytweWd1NWl3VjdtWFg3bXRMREo0NkRVOC84QW41K2Z4WWVKQW9xSURRd2xMaWsvVnhyMHhsSWlNcW01UmR6Rkp4TjAvQjB3dTRZMk1BdGdSS2pSQUsxcUZWQk1ZcE1VbklHWlM3ZFJhS3I0R3lWT3RmQisyY1JHWVVDU3JnS2JsUVNYcURaTmtjMWx5NjZtZVg2aG5qN0lVeklEcGprZFZNYlNKWHhWRVJZWXAvNkV4cVpDKzRBRTQzTWdIY3g2YmxRRG5NZ2hYQ1lxVHNZUUdhTzRKQUw3ajlUVGN4eTExRm1Ua2x6SGFqREpORXlocUFYQXBZZnZ1T0t3RzdpS1dkd2N0WFBya3IxVTh2OEFrbWVIQUtxYzZ1NXlDMm81Q2RUa2NaNC9MeFNDWnhESFpCZG5VMWtFTWNkM3VCWTBFd0V3dFVsbkU0TzVrb3RyYzR6RVhrVlpBclBxY3VET2JqdTd1VzFNSEJ5RFBxWU9OSWZtSlMya1VVckdOWk50eXEvV001cm4xWkZxWVk1cm9HWmpqMzdtSlJLTW5VRzJuMUZ5VDhCQkd5cHhZNEdhMXFjR3RNTUN4Z1RMSEVMRzJBOW1wVG1hQXFicHNuTnh3R1orVit1cUlPTzVsbGVJU3pGbVdZdDR3eU1wZ1lGdlRIMEUxREplM1U1Qm4rWmdZcTJVTTQwb015eFVFWmtmV1lnNDNQTGkxcWNWOWhERUcrVVEyM3VOTXdVNXRhbGhpbGJZYTFBM3lJOXBBbkdiNllVSmN4T1NvV1QrcnVCU2ZVaW9xRkV5eVZqZ0JZeEppdHdGd2xGN21RS3RSM2pLcG1KTWNPU0VvL3F0d0FmaEJ4Q0hqYm9KaDRuSlRxdTUvd0RFejRQay9qWEQ4aFBENC9EbC9rNG1hbmplMlovK0o4SGwvd0FMUHovNDNtRXhtUDhBOGY4QXh6LzhXWlBQbTU1dVpRUnpVeEZZWkp5TzQ2ejJhbXVWblZTdE1BY0JtYjYrQjRxM1A1QkhVdWtucWhTZmttRHd4WmZGc21LN3l2NEd1eU5ucUFqS21HVGkzRnU5TnNCYklQRlJHR1dNeSsvUlV3eGdjKzlmc24yeUhqME80YnhnOEVZN2J5NmgvSHh2ZDlFd2NteTlFdHlVT3A0bkhueHlGall2NHZwbkxiNkplNG9rTWZwY3hjZWtYR3A1dUg4di93QmY5S0poSzFiMWZjNDhjbU9TSlZKTVBQa1pObGg2bUhsd2JYQUp5d1IxMnpEaU81bitweG91SmN4L3ZObjJsNXBBYXBsV1VFREpvcWNaV1VES3FYY2NXR0dvNDhtVUYxS251cWczcXY4QTB4UWczbjNLV0JUSzJ6QlJVaXEyeHljcFNSWFlUZFV6RStzcUVNUHBkekxHY2RFRDdSY2xyVUdXU3NjZlRIdnFkRWR3dzVBM0JwcUtFNTFPZEV1Y2pVWExscUtpVkJaelpwTFpuU2ErRm1IQlc1eXd4SFMzUDVhMEZFRmM2amllKzRHNFY2SXVvS2xnd1VidURyVnN5RUNzWTVaOWNZUDVtbm91WFVRdUpqVmhOTHFhTzVtaW5GcWVUSWNNUkYxR3FOYm5pL3h2NXI1SVRQREhETnhnYVdYTlZOWFVUakRLRnkwN2k2dkdLbVV5TEppVElyNCtxN2xFNkpZUTdaWUZ6bXM3WWJXb0xaMUVQVUszS0FneENwb0NPUW5VR1A4QVdZdW1jaUdKUXhPNmowVGx1WUtXa2MvcFhIY3RMdGwyYmx3R0kzT0RPRE1RN25HWTJrQ3VvaXMwRk1EdVYrNTNPT3JnRW9oanRnQU80V25jQ3RySytNUXhKcHgrR1l3Mjdadm9Kc0pRNDZKVzVqcU5wZnhlUzBqQ3hsNVJiaXBOeHVCWGNMWlVBdnVjdFF5MURJVkdIR3BpWXNURU5mR0k3blhiS3M3SW1vSVkvd0JXV1ZCQTFNYlg5eE1yalZiaGZxZHZ4a2FtSmx3bU4ydVVjajBRMmFZWlVaQUxNY0JCTWk1ajIzRGpVODJHRGVRZFIzSDRVcUxQRDV1UFpNTXdiWTVEYVRvQ0ZUSjJHTXl6aFEyektzdGhNdlZURHJLcGsyeFArNEZPNHBMM0xwS0xpbDJrTXRPNm1hSUJjRHhhTFdJSFU0YWdQUGJGeEI1WEt4TFQyUU5YMUt5N2lDNm1WWXZVVElwUkJqUUtTdUlQNWowayt0VXcvVTRYY0FxNExqaXBTUk9RcmNPV1dIK29uRVBjc3lVcVBqeVM0UEZwaFpGS0w3am1HZXBxVzRsWE9XUHVlTExCOE9ZZU5YOGtMYkJsZ01vL2puSDBSdkUxdHFOcnNqaFIwa0FnR2VDMlM4ZUlIYzdSaDNjcjBialZ6K2xNY3JmcU1QY2E1a0hpcmhxTlo3cjd4RldvR21jVnh1VUlWTXRGVk1SNWFnTy9VRGU5eC9vUTIxRUNBR1VQcjlwZUtGRzRoSEdqUjhheFJtR2VlTnVEYzhQL0FKYnpuK00vNHpUZ2s4bUhnUDhBRU1zRWZJdXlmeXVPRllab1BaTWN6TExLN2dLVDlzUmNyOVIzbEhiRm9sZlNYR1Z5dUVQSGxsNDNMMFQ3TmJMaVZqY1hVSDJ5eDNXbzVDUVYxQlhFL1VGYzJOc3dUM0NpWVZ4eW1XMVk0VmpXV21ZT1FJeFRxQldIZmNwR2hqWDhxSHdGekR5UGo4bUxpR24zRHljOG5KQzM4ZFFYSEZtRGlOM3VwbThubEYrQTdobHBJYVB0Qnh5MWMwbW1weTUrTXgyMVB6U3I3bXdLWm5ndTNLYkJyWkRvbktaWlk1YUk4OFRVQXEyS1hWYWpsZU9wZ05SczduTUladFRubE9iSDdaWGM2YXVXVExJNENkeFlad1d2Z0djZFFtb0JFUStBdTRFcXlBd3lLcUEzcjRzSVZNYlJxWVhLb1laMFQzWkIyd080a3RUdVpEK1l4ZlZ3SmRSU21lb1N4MU8rb0pqM09tUFZ3bVZWRWl6ZmMvVEE2TVMvekhHc09wWHVxcUxxL2dhZ3U2SmVRVXk4VERjSGlLUnpYRVp0ZTVvWFU4Zmo4djhBeEo1SE1hY1M0WkZ0a003S2gvcUhqNWJXZlJFcU9XT09HUDZKencvRzVqNW5GUm5hM0dxbXZVNGs0a2NMYm5CSndZNDl3SGhSOFh1ZldIazBnV01xWHVwd2U3bkZmY2NKdWNkRENXVHFXZmljbXB5bytLc2lXUUxoalA4QWxVYUdXSHcyR29jNHJFWml6WVRNWUxjV0pSRTVJakhHcGRhcGdFNWFDNWpscUdzWlk3bW1DUnJIMUxLaFZWRTNxQUpPSVNpYUpaY0cvVVRjMzdtM3FPTm1vWXdxQmNBSW96RFV6TGwxcU44WVRjSDRESWlaTUI0dHpYQzRLa010SXpVS2lIdVdSbU9SN0lKeWhRc1c0UDdqM1hmd0xMWEdvOXdDT25YeHY0QnVKeW5IY0NVU29ZTXd6ZGxRQ21ZNHM0MVFOeklRVk81bllzdWFxQVRJM0t2RTN1ZVBxbG1PQU9UbHBqc3RnTGU0Smp1OXh5MUZBbUdkRXV2dEx4MjRzRWNIM0RMMzBrVzlzY1FOd2FORnk3TmxUU014eCtyREk0MTdnTDFDM1NSV0tYYXdGeC9KQk9YNFovSGtUbmtkenhuTEplb2puaXZSUEtwdzVaMkVkZU5leGppbUlzS1dGR2RzSEVXNFAzaGh5NjlSOFJRM0F0ZjFEcE1TZGNsbENDUzM5MStJN2VxWmhobWY3aGhrNXU0WXZGVkpnNVYrNWVTZnNnamd6QnpCNDVVZTRoL0VPUGRRTHo0c3pLeTRCTWNhdjh6Sy93RHVPSys5a3h2SnR0cUp5dXI0emJvMEVIRWRGdysxelZBRUwyRS80MG15VTVZekF5TSs2SllacEVxWTQzVVhpcGN4ZU4vdVZRekhCeU81eDQ2dWJtUGJVMnMvTEV1bFl2NEp3V09CeTdpaHFyanJaOGNnUytvSTU4anFmNG5oL3dBVHkrRHlaZVhOTXpvbmd5eThPWEp4dkJaNTg4WHk4c05Ic21YZGpxT1JNTXFWWXJPQnhOd05KOFg5VWxxUzZHRGN1SGNMeDJFRnlFV3YxTjRaRXQ5c2JnN0NON0lFL3FYQllHNkcyVlJia1RTMU1rSmYxaWlCVkpNcytUOTNST2JSZ243bUJhcnFmYVdEUEg0K2VlVklKUEliL3dCUXlicWF5VVp5TU1URktEOFJQcHBndHphY1Q0eEZqZU5reE9SWFUvNVFCWnFxWjQzYW1WUURFRVU1ZjJ1Y1RmQW1Sa2xReFVaZzUxVlhCeXEwamxYUkFjamVWUjRQMHJaN2puL3hxQzNVeHpRaXExdUZIWXhRRUNYcnFZNVZmdzN5NmhqZUt5aW93SWEyd1lzR3lJTUhFbVR2VXd6T2tsai9BTVlXUy9VeFhaY3ZiREpHR2JhRXhUWXpRczVuNG1PUURNY3ljcHFPUDdxZmFxbVAwN241WTQxSFpMSTRsVEZnYnBuR084WWFab1lJVERMREZlWXNFU2I2Tnh4eXhhcUorWUJVS3BaZXU1VGt3WEZhMUJRZHpuazBMcG5KRFd5UHI0SEg5eiszV2lPQTJyb2dqaWxWRGp3cTQ4Uk1vK1pGb0llWHlIMjVnUmJ5dnRoV3hocnFPV1hFRWdaR2tZVXN6UHdkRXhwUDNHMXBpTzRZR280OGNxbVR4L0RCMzFCS29XT1NzNU1SS3lzUmd3NytBMnhPcW41K01iV3B4MWNwaVpVa3JKSzlTbUVzbXFuTFVLbHkwaGNDZE13d0h5R21aWVkzZFJDVnI1YXJ1ZmFVd3RJcmo2dWJDdFEzTkdsbkVNZE1TOXh4dHNZWThtMkdKYkhUQ2NTa21HRTR6aXR6aXh4cWNWSmp5NHVvQ3pqRUlCTVZ1Ylc1OXNsbzZteUswMUJhbFFHTUlzTG1JUGNUOE14QXhibTYrTjNMV0JrZHNkZTRiSjlqUlA4QWNOcVNnaTdxRFdtUGNkUzl4bUN0eW9hTlJHdmdMSmx1WEtHS0FNTW5MSkppQzFscU9QRlM3SUZIWkQ5cEVvbkFtUGFTOG9MMndaV0pTN2lGcmpxWjVLQlpQUGh6RkNjV1ZDd2JsekEwclBIa0R5WHFQbWZMOW11VXp6NTR6QXUvMU9PTzFabGhsZ0g0ZWxtenVZNDM3bVJXRlM3dW9HdE00blY3aWdSeTlMTVpmN21DYnZHQmVlb2VORkh1WWdqVFRQOEFsSGxoeDJJeldXZXlvbkYrb3hOTmxzNUp2Y3hidmsxUHNmYW1vVzRialNRNUNZclpNdDV0ekF2eWR4d05qTWdHZW9aOW1PbXA0UExsZzlETXZKdGFEbEZLc1FuRjRNNkFNWmhqOWpsbEgrUGkyM2xlcWlZT1BzWm5qUUJNZkZ6d1d3bjNDejFCOGkxWGNweHgyUVhxY25vYWhsbGprVnVZdVdiY3l5cks2MlRQT3psbE03eHoxc1pobm5idWlkYXRxSUw5UkNieHhLSmtwMTJ3Y3RDVEU0amJMaWc4UjNGc1B6TWNFejM3K1hIU3NkWUUvdE9HZUNXVUpjVzgyWVk1TXpQNDhrOXd5cUhsR3h4Tno4NHBMZXBqblRxcVpmWXpralZ3Yjdqa1F5MU1jM3FjbkgxUXc4N2o0dUJPVi83K0F2NXlRcW9iZS9nd09EbXNCbFd5dmNwV3B4Y0JtVjhUWk9KYnVPMk1WU0FhL015RzJMTFVnWFUwWnlrZnlRYmpNWm1Va1FiL0FGRzdIOVJiUDNMVm1XbVd1eVpXNmhNQzh5WkhNeWZlTXhWbGgzM2NIaC8zTWdDWXY2WUlLb3pIamRndytzWGNxNWdKZzVZMVBKNXVYanh3S3VZWmNDbVBrZzZaaGlndFZNUVZ0aGlkUktkczJaTEM3anJLQ2RzMlArNHVTMHd6RHNtRHBtNjM4WERKWlhMcVZsTmtNYmw4SVlxUUFqaVFDNXhNbjY2WWVIVnJzaVpYVXB2Y1dWVVNPTXc1YzlKSEZmZTQ0Mjl5dUNrT0h1VmpBeEluS09vZktzdGxoQi9NNHJsSEZnNUJVN0toS21JSkhHWTQ0a3NHQ2NyYm1sZ1d5eXFsQlVIY3lZSkJEdnFQRit1TURGZG5VdkVZdUVjdVJSS2JqbzdKamxoY2NpMGlrMW9pVnNZSlZwTzlFUmNmOVQrVE90ejNZejZtRlgzTE1YVUc4aG1iV2VSREp0SmE3Wjl1NENsL0dPTWFaWjErSlFTNHZ4VWRMQjFNVDNEREJQN1M5dE0yeXYzS25CWWxURVdIam9uQlBVY1dwallOd3dHVUVPTThHT0s1WnQvV09ibGJ4bko2cU9TRlZCSlg0WmNRL01FdTdseTcxOHZGT29jYW1OdW9rSmZGZ3I2bUptdzUva2w1ZTR1UzFETEtaWlpETXM3SWRSVUtHR2JPVVhVczR5aXU0SWp2cUNIdVl1bytvSEpTQjNDK000MThyOFlpTzRFZEVGdGk2Z3hkVEdoVmdncFVHVjdKUmU1aUNUaUxNaVZNeHVVRUY5elJLaHNZajZtUVZVb3JVV0Jic2lJOVRFdXhtSjlsaVhoYkxxRTR0a3lNdEJBV09DOVRISGZjUEdWM0RIZGRrUS9ERHh0UndPbVBoeS9FejhKSEZQY0ZEdlh1YXNhMUxITmNTc1l1TFBGcEJqOU1wd2NkK21lUCtNTStWekx6WnRZWlhSMUhHb015enZ4elJjd2hrR2JjeHJLNEpqblNXRU1yelRIcU5Rb3dkekVXdUxIazJyTUhGU0dRTEg3TU1UUFhWVEF4TEZtT0J6YlkrTkdWcDFjZkkveDFiTVYzcGxvRXh6dFlkcXhEc21Ea2I3bVdYSnVwbDNSQ3h1WU9LTXQ5N0prWTZJWGppN3NtQzVJWXpOTmFuMXVWRW5KTENZNzAzRGlLUUJPbGplTDFMdGdiZDlkVERMSThia083aG5tTGxsdFlaMHVOV01jN3lmU1FVWnhYY0xKZVNNQTdndDJNNTRwa1BjVnhJUEZ2amR6RVJpdVRNK1lUQzBsTEVscFV6OG1lZXN1Z21lblF3MWgxTy83RVBIc2IxSEVNdFRoa3FucUplSEw3SDVtWmdKdzZxSjNNc1YzQVEzS0lSMWxIUCtUZjRsM2w4Q0xOUjZnVGY0bVhjdTJwMFJaMDNEYXkwSVdJc2RLL3VObS9nanJHWlZseDRhWW1ScTROcnFBSitHZEVmZ1FpbDlTOXpQSnlKdEp6eWY4QVpObWQzSGxuYVQxdnVmOEFqUDhBQThYK2QvbmY0LzhBajRlYisvOEFhZjhBbnY4QXdubC84Ti9tdUNMZzlNR2x4aDlkcjFQemIzRGJDaXp1TzhacXBhWlVkUk1Id2k1VS9pWXpOTWdhbVFsV1RHQWhaMHN4L3dEbzhyenh1K3B5dTFuTkgwZ1J5dGx2OGFMcG5pQjdtVHRLaHhZbFpIRnVMOTlzenh1a25CZFJNL2FhNmprdUZ2Y3ZFT281d3pMM0x4VFVzSnpoZkdWbEF2dU9HVXFZQ2pObW8xYzRFNlp5eHYzVWNocElVenlGT3B4czJWTXJHRTZaUkRIRWJuRVJZWWZCVlRrK281YjFGaGxCZHJHR0FsckZWcVhGb2dxUVpkTmtxVWZtR2pUTEszTVVDTzJZZGd6eEhoVHkvd0FvdEgxbUxVd0w3TlRML3FvUEZ1NEtpeEVORVdpb3RVd3lGV2R2Nm5Da2h4Qm9xQXhFeFd0VGZWRk12N054MkFSRnlEM0RHbEdQSGlXVG1IK3laWkoxMDl4OGdnQkx4RFJ0amFSc0ppWTJWTXk4cU80SVl0Ry9jSVl1N2lKbzBUK0pyVVNwamRSQWYzSG9YY3FoMU9YNUlwQjFwMU9ReFdxbkYvNmhkOXorUDYvbUdBTXdQSDJ0em1uUVZIS2NvWlJ6L2NjcjdZYUdBcEtRbE5YYzN5bURYaVM5c0ZDb3RFNW9Pb2JJSVRGcDZpOTFNREYrcnFIQXlTNW9MTXJaUkNybk45UTMzQm1Ldy9yY3VWcUJWN2g5UVluYmNlTldPNEFWdVpjWlJTcnVlbTRMTFRVdVl2cGlGMWVvVUV3ZUsxN21lTjVpRTZLTVp0MUM4VnFORTdOVGJqWDRncnBpZ0VyM04raVgrVGNNZnF6L0FIOEF3VVdNSUxjUjJIVU1GWTJPb0VvSXNNOXh5VWxtNFM3Z2xWQU9waUFPVDNOdWF3MFNtT1B1R1JVVUg2d0xHcGdZOGZ0TXNReTBSTmFKdFpiS3lwZzU0ekdDUFN6QlJtVGtLc3g4aTF5OUVVdXlXL21OaXp6aVVoY1FwdVpVVk1WdVlZM3BtUGlGWDBUS24xTU0rQkx5enlmclRMUmVVTXVMdVl1S3hxa0p4OXpFUy94TWdNckQxQnhNRVRjeXllS0JxRkVBYkZqZ0dOak5nd1UzUEd1UXIwVFdYdUFSTkdWd3hGYm1mOXBlcGl4ejBqakJFUVVuQzhkSk1UR244eEU2SmpqWmFUQ2pNTW1pZVRBUEt1TG9tT3M3WVlpczRZN3FGcFZ6anEzc20wZFFPQU9MdVpZNVlveERkazVhcUxyY2NhWVdNeDNhdTRGYWVwcFVPcGw0c0h4bFAzdWNjckppWGlvNmhXRHRzWXI0L0xlSk1YbTVMVU9TOVdUTGtOZW80b0NUeFpHQzVHOGljVnpNczYzM0V0WUZYTGVINmlMdkdYd3hOMnpVUEpoaGlxMm5VZlBubnVnZzM3aU5RVW9oaVpHVlF5eUZsNVRQTGtBazRwNmxVek5ESTRxQ1MxVXVKMFRJamlvVllST0RwbU5lL2pJSURPbGdYREF1ZnhCaXFrMVFFSFREWk1qODlUclpNdHg0dU15ZnBWUWVXRXBtTk9WTSt2TjNOQXM1ZlM2Z0wzcUE1SmpkM00vRytOREtMRCs5TFJVTjJCcUtjSVpGditwdFlQZEUya3hQZ3lXS2tLblBMalJNSEZ3ZVhjOEhtejhQbHg4bmp6Y1BKajFVODMvbW4vTy93cy9EL2xybm42V1Y3UHpIRUZsSTB4T0tES3BhZ3RkWEJxUFZ4QmJyYzlRLy93Qms1T2U4dlVlNFdhdVp1UzJzUk1TSlRiSFpaTWN6aFNYTVJHWmxGM01EOVJ4b2Irc3JCVGNVTHFHYW1tWWkxZVVjTERFeWo0WEZwWndoaHBXVVZSTVRwV2FYc2hvWmpuY2VYY3l5V0UyVlVlNXJoY3VweU1YZnVPV0xvbDBUbWdhamtNTXdLcmxQSi9XWTZOeGR6R09tTU1rSTUzQjAzTWVXTWFQOXkyYlNYa3h1WXRNdW1keEdvQ1FMaVRmb2hpcnNpVktzZ0h3WTJMQ3EzQkc0aGljZWNySDNiSHhKanlyVVZyOFMxOXpKM0ZPTXc2aHZVTDNZeHlBSXJ5SmlPV0xicU9CNDIzSW1aWlpERnA5VER4NHFqbHVwV1FSeVhFSVVEYzJPb0RnN0prWG5Nc1VKbUVvS1o1S09HV01Ea3h4NHh5Q2N4aG1ocWNoM0JqYnBJZmdZNG9sc3lBeWk0cDhDQjFNTWVlQy9pVzhZRnpGNDZHWktpd3QxVWNXdTRFYW1vSU12OFl6ZGYyaTVBVmxjeFgxM0FYS2FtYmdHTzI0b0Y2bk9jcjBtb1pGcENHWHhvbURaRU9VUk9vZkJjMnNNV1V4TlRkUVVtQzd4Wmx6S0dHZEV5WEpBSmxnbUZzUXhKZU1lUHhjdzQxM2MxOEhIM09jdktHaDNLYWdRYWdNQmdDTndyajNQOU1iUzR1VU9Yc2w1Y3VvcVFkWEx1REJtTHFOK3AxTWRNeU54U0pxNFkvSEZaUWZCZU9Odnd0TXZjNVRISnFtQkNoZ2J1SVhOZm1LMVk2amxsMlF6ZFhNeGFwaG1naFNrOGZrT0s1d1RJMFRGb1c1OXFGbE53eFZtZURoR2szTU9LZlhiUE40dHJNdkhkVERESlVNSWVIaTd3WTRCZ0I3ajQ2Tng0KzhHWVptT1Y0bXA1TDhpc01XcHduQkdQS1lxV1JYZjZqbmVZekpBUzdpTkNFNFpWYWZGNkNDUGpaamx4MTZsT082ajVPUlU4WTVYaGZVNU0zZHd2S09hYXFBeTlPZ21IRUZSaEwxY1BOaHpyMUZ3TDlxNmk1R0xxWjV0QTR6eENtU0VIN055OFRxT1Z6RGowempqemVJc3Yya3pwcENPQVlZTXlCZHpBTHlHWW1SamN5eEZqZ21JNWRUR3dhTEdVWjVLRzhTZmJiT0NZOGI3bVdORUJFS3RZK0t0L2xpT09hSHBtVjU1djF1NHVSOVZtT1BDc3VWeHZMUGNTbEQ0eDZSaDFVeHJ0SVA4aWhqMFF3Y25qcVBKVXFvZU54TGZoY1FMbUR4NUJNTW1Vc1JXWVlHUmt1ZXduQlJqNGtjUm1lQ1pRRXRtMHVLOFRsUGNZc0RrZFRpeElWN2dCMU04REZBVGNjVUdZMFRSR0loRDh5dHhkY1pqWlpBeTJ3SHVPTGZVUXFlcUkydjJmVUxQNms3dys5OG8ya2NsZHdhamp5ZzE4RUw5UytPS01HdEVyTHViZDNEYnBZN2JoaXB5bUJTNU15ZkZqNCtmZVQ2bldSWWd4TVhPc1ljVjMyUTRoOTFoUmUxSXVXajFNWEhucytzelM2eC9yTWdHb2dsekd4M05USXJaRDdGc1g3Vkt6bDhoSDFMU0d0MUxIY3dkM09UYVJOL1lzbWJobFZZMVh1WnVybDhUVXV6YkNwa3JObFRsTzUrWm5ZeXhxWWxLeHpzam5jdjlUbXkxWm9JTzdsWHVhcUFaRlQ5UXpSLzFNUEorWWprYTZpV3BFZ3owd0JOemg4azlzdUw4RnB1WWxPb1k3dGxZalpLTXB6WUpHRnBPVXNIL0FITjlRUXNsSFJCeW05MzJiaDdjdTRCYk1mNnpKYXk1T3BxcTJ6Z1ZjcmF3UWhsbDFNSFBGaG10eXZTVEYrK3BtblpGeXlxQXMvM0ZlSUFSeXlhdjFOK2dpNVhiQk0ycW1JTzJ0UkcwV2htSTh3Y3RFeVB0cVkwWld4dTRrdmxwamlVUURaS01SaHdNZnEyL0RVd3B5TG4rU0JuL0FHbVNRbHpjL3dBVGpuNUhGaUhpenp4WnR4MU9WeFZibDNOZi9pZ0F0UWRNTlJobEJxNmxzTWU1Z1FNZWU0bUdSUXpQRHhZMEc4cFdJUUNPSDZnZnFjU2NRSndsTlhjcWNaWDZtT0NZMVVEYzR6aUQ3alMxdUorNEJpL0JXdzdtWGt5ek1UTC9BSWxFR284VkZsWW9rMFp4eHVJRURHWmtHaWlZT0crVVZYWFU0bE1yVTVFTFdLa3NtVHNtVmRFclVxeVpLbFFENC80Vk1icmN1WmNZWkZFYWhSak1WV0dJbTJWOXFNcDVNRUlmRkZScU05NmpZeXZ6TVRISGIzNm5mYmNIU1ZGU294YUpmSW1HaEdXQkJ2R1paTFJFMGJoVzRWRHVjbFB0Q3NwUmpmVTZ3YUkyS3BDeHhVWmVSbVYxY1hNYnVaZVhQTXQzVWN4QjRRL3NYalU4dUhqenZiTVBEaFZ6RDY1ekoremNXOEhJamxla21mbE1zTVFPcGYzUU5YTWpJSElxSEsyNTYxRTRlRUgyd09TaFU4Yi9BQjVPaGplUXRWTkdKWk9CZHg1R3lITDNBdTdqblFZK2lZcTY5U3VMK3ZnQnREcUhLQUxBK3lRMWltVU83eW5sOHlDWTlWTCttckZtSGt6TVRDWmZiY3g4cFZNVEkwSlROQWtjcktsekZSNmhTT29HTHFZWU5wNmxaSEl5eHVZR1hZVkdGTU1neHFHRldqM0hFSzVLTTQ1SXNHNm1PU2lRY2cwVG45Tm51WkowYWc4VGNYVXhPVHBqbDlPRmRzekRITGV6cUlZSDA2Wmhuamlya1hNMHp5dkhVRFBEQnlHMjVoYThuVEVNZjNjOFdJNTBsQjFNaitQcDJ1NXhja0pXV0dUVE1zUlZ5eHBxWThreW92OEFmNGhlWGpYbGFIdjNDQ1l5OFRCSUppUXh6UkpndDJzTVRia3hPL3RNdkx6cHpib3FaNUdkVkFMdGhybE1DbmNVcklNZHc1UzNGMjNDMW9uSXd6Y1V1QVBLaXFtTzE1VEF4NEw3bERMSytHbGxXYWx4R28wc3lZa1hVTTZSZ3ZKeWVtYUdqM0dqTGpMNUpIM1J1WWJHNVRnNkl5d3gxQmFwblFud1A0ZzAwZHc0dURhOHBkTXZLUDhBWFR1WVpPR2ljdnRNK1dGSHBncHBiR1pQUWFUcGpsNWNneHlyVXdlT2ErNWROcHRnUDVHQld4R1pmeDhSSGN4UXoyYllwaUtSaStwMkJHcGQ0dy9yY3IzT3l4M0FBL2NSQWEwd1hjeHNaaVhpekd1VWIvNmdPOGZVemZXNmpqNzlURXg3WFU5V1F2cVhZZkdMYTFGUlk1R2RUT25HeUY2K0tsdTl3akQ5eXJJS05TalVDblVyY0g3VEl4dlV3OHVXTkIxR3NpK21aZFdTMFlMRCt1NWR4aE90dncyU3JJQlV4NmxveHlhUWhscUlTcVBnKzN3RU1EL3VXa0pkazZqMXYzUDRjRC9DeTh0bk15Q29ZdTJZOFRURzh6UnFaaHpvMURPam9TTlpNNGcwUUVaeWFSUFU4WnFIRlhrc3dBZE8ySmRrNHVwaGkzRUtZQTc5UUZ4WmhnWFhPWkdPT3JqeEM2MlRpNWZvWnh0L1JMMi9pT1FSYm5LeW1jK0pVYzBka1hsRFF3MlM4c2d4MUV5eGFaak1EOHpOcC9MS1hkUk9KOE56d0xoNVRMM1A4bkROejU1WWQ5VGNFNDFMZ2JXNGNhVnhtQVlsczA1Vk1jSEpvSVhnN0lGSFdtVlRNZ21KM2JESEVUYlA4ZjhBeE0vUG00NFlxek13OEdMNDNENys0Z3M2SmJOMTNEZnVNclRYY3d5eXJjRmNYY01scUxMY2QzT2VXZVg2aExibmNGT29EbDdqSEJLZ29yTnZ3M1UvUk04ZEZkeW1JczQzaE1iUDNNaTI1Nm1yMVBVdGhjb0RiTCtLWERjUXJrUjNIaFhiTWlHTWRNUGM1T2hJd3Q5YW5FTEh1V1M5Vk1RdTdqVC9BRmxUN0xWeGwyQitaY0xib2x6NjNwbkRsS3h3TnRzT1JhbGtPclNwamdaRjNQNDNpOVJJNHl2MUtPeUJZa3VzTlRqazdKWlV4RGU1WDRnZXlZam1LekgzTXVoaGxwM1A1RnNKbDU4ODY2T0pVWHE4dXBYSTFsTHFZWlg0KzRYejdsVW9zTVhEeHUrNStQemM4dE9qdUxXQmpmWGNveHdFTFdZZ1h6S2lZMnpJdlV3eGMxSjFpa0VlNE9EbHVZK050bGY4R2hsNFk0OGF0amdEMnh3UHo4NlZtaDQ0c3dPT1F1eVpYeXNndlFUSHlmbWVUaGVKZy9aSlVNbTZUcU85c2FXUDJUVk1wdFdDbitvMXRKaTJVdTVZWmJtT1ZMcWU3cU9VL2xUb2xpM0JPaGxQQmVSZm9obWNKeDc1VEh3bVZ6SHhWZ3VxaC9qcC9qZno4alRWVHladmszRE9zQVlZK3VtVVlZcTV3VXZjeDM0Kzl4cktZNEdMOXBuaDQzR3gwVEgvQUFzanhZK1VUamwxdmNPQjRzcjdHZmw3V2VPcVlCU2U1aUJ1dXBpQzNkWTNNc01jeXZIdVVaWlV0Vk11V0NDOU53Y1hLMzJibWJnT0xqa3VwVGxrZW1PZVRrMjJUbFdqUTZZWStIREIrM0xKTkg0bmp3RjJrUXd5L01NREk1T28rUVhqUEhsaGw1Y3NjOHFBMURqVGEzRjVqYkhNYW03S0lOak5aMXg3SnUwSXN3SGUyNFdaVk1obUpaM3VDamMydmRYTlcyOVRGc25Yd3NEVzU2K0xZVUtzb1M1VkZzT21CTU1ZbGJnWGxjTTZ6MGRTMXN1cm1HUmpoeDQzbEZjKzJBY1lGVDBiWnJsR0pxNDdTb0VTWUxnM1dwa2psY1hIbVJCRklLNUZ5NE80NVdzd3BXY2NzdkVVRkVEQW1XdWlZaGxXTjFjejhUNHNxSGxPSi9Hcmw4T3laNTRaWVlnYkl1T1FVUWhqOUhPSDJ0ZW90TVlOZlJsZlpJNDhaam0xUk9JUk9XTlF2Qm1Ua3JNVnJqa0VjYWZxRUE0MHN5NGNScmNBbEQ3bXNNcGt6SElsMnNNdFZBK0tuZnpxVmwzOEF3THVCVVFjcDA3bU9jVjZpUWhscEg0WVNvU3lDUXlURmcvRERXaWJZNGZXektHUlpacWNyeWZXUHhkUkhJZ3VXcDFCSU01NldaZVBIK0hESXoybHBPVTB5NjBNNWZzWnROQk1oeHErbWNPSDJOd3lJbGx6RXlPbW9qZE8yZXE0N0pUNkp4bzNsTVg2TlRlUVFzbU9tWUx5ZFRKTGlDVG1CcUtqYyt6MUVMN2pVS1NGSXl4N1djdng4TERKTWhKbm1aWnpSdUNNZGt4L0RBR2NRaVFmdzdHWm1YK1IvakZaZjFKa1VoQXZMVXJUS3hpNGhVNWZTVzkxTWMwM01zbkpoa3pMZlVCNnVGbnY0L3gvODN5LzRtSzRKdVo1NVo1dVdiZVQyemx1T1Z6dWN2VUJxREEwN1pWYUdWa0hjL2pZNHR4TlFLaGtSM0FQY0RHWWhjb1hUS3k3bGNPNWozS0ptRFVzeHlxTkw4YXFZVmJPSXJVQVlHSTdaY3NyVUdWRXVPSVQ2M0ZKaGlPRHVVVjNFaU5TbVZLaXRpbXlmeVBrTHlLbEwxTmlxUXB4Nm4xTXFuSEdpbUZrV0g1K0UxWjYrTHFYWlBIZ2ZaV1pyQUdiZ3NNcjFMSWg2Tk1yWGN4ZnJ0K09ORndIaW43bFVzd0JHY1FJY2d1WXZHNzl3R2NheXU0cmswT3B6TFNCYlExREMxYnVMam5yalZFZFhSUEhsbmhpMFhjd2VBd1hObGd6UExMb0lQVFVWNVhjd3BXMlpaY1UzcVpiM2JLeTRhbkZTWHh6am5obUZHNWpUbVlNVEVVTGFnV2xLVE1USkdPWEhEUmJETnN1SVdKTXNjZlR1WW1ZRHFwNURsanJHRHZxWTRjc1Z2Y3BHREs3cFljYnhQYVJ4NFdYQnl5L3FRNU9PV1ZSeEhFZW1WOSs0MXZiRGl6SXBzbi9BRk9HQ2Z1ZVh3NUdJM1pEOEV5ckhwbDJTbjh3eUJocFdZWkdJck04ekpLaFdEOW5TVEpFNDRzendmclV5eXlNdHRTOUNibWRMZlRFeDZXY2pMRDluVVhSK1laOFZFSFVNdkZTWkNOZXBodzI1bW5xZjR2ajhlZmdmUDVQTmlQamZyZ25jOC9tL25jczN4WVlQNHhKbjRqeCtFODJQa0ZYcUdhRGZ1WHhlVVBmN2pobDBUd2pocTZXWjhNTE0vN01jaEppVExqellaOHNlS2RURXl6TXNjQ1kwNFU0V0RIREhqekgvcVkwa3h6REs1bGtaWkpjeU1YRVNPR09Qak1zWDdNQjJNVkNEQklhenM2bVB0bjJCU09xaGxXU2pVRWJYTGNiZzZpT3B0bkVHQlMxRm5jcWJyYzBtb3grRTNVckcrNWNLV2NUMHh0ZU42bFlrcXJZZXA0cytHVXRlNE5rTlpUa3B4cVpLdTRRYlVaNDE1cE5DOHJHZHNGeVpsVlViWjd1b2RKQW5IVi9HSEN3OGk3UFVLdG8xQXpCTDA3bnNnbDA5VExIQS9vck1SYnAzVVRWTXcwdHdkb3c2V1hWRXhZdklpOGRTb0l5eDVMQTFkN0k3dzdMbmovc0RQSlJuUTJReU1lNGxrOXNTYU53RG5kUTJKVXhCVVNvNEE2V0xmWktXVVNyQ1ZLNDlLemF5bmM0UHBoaXV5R01UR2MwS1pwNmxOWGpCOWtjOVF2dWlQN2pRS0VGVVk2eVlyQm00U3dFanFqYy9VdzlqT01Pay9Qd1R1QXFwRlFsOGJsdkdyZ3RWTDFVb1Q0S01xbEVyY1VxZG53UElsMHBBREpVdVkrTEhOZlZUcTZMbmsyRGNNbTZtT1UyZnFHWU0vazltcWhsKys1bm1yVnovcTRhamtGd3pLZ3ZrRGlkRXh5Tjhtb3VIUFN3UHgxT1pTQmpjNXVXSUxSRU9YY0tXTThZTVRFaFJCRG9pdDZDT1A1UWpqWFRBQTlMQ3YxUCtEa2NaOWd1b0RrS2xRYTdqbGo2dG5LSE15dG5pOHVSa2dGTTgvamNHL3pNVjRReHZTeXJZeC9yQzY3ZzhTb1piWU54R0FKREVXY1QvY3p4TVF3T29uSm5Hb0NTa1lnUXMyVk1RRzFJWlJ6SGNjeDdBcUhsSDBCTTY3bDZtT1Z3OGxPaWN5RFhxQ2VpWTVVN0ltMm9aVmM1TE5qWUVWclpISmw3dVpNTXB6M1JCUlNXalJNWWlzTHFCVnowZFJ6S21ONU15ZDB3TGhqR3l0UWNRcW9aVElac0plcHlvbEkyc2JRbUtnb0VMSXFrb2F1VWNZRWNWWVdGVkd1RU11UElUc2dsUUJzWllGUkxibHBDa2xmdUQ2anFVckc3cFkvSGNzNFZjR1pNeFFLSTdFQ1VwVjBTckNZaURiTWFSWUU2eWxic21JM2xiTVZ3R29PVTVOUmJmM01mcFBxeXAxcTlUVldibkt6V0lUZUxwam1wTERDaGIvRU1xTm00clRZekhMb01aamkwMzNNYnd3UmE1UThsZTFtWGxjbVpHVGp5cVY5ZDl5dmR3eG90WnZKcjFLY2RaRFU1NldDR0prTXhPU3R3OGQ0NWJuOFdSc1pqUmp4UzM4d3d5ajVzZ0tDaVlHS0lMaXl6ZCtwaThXNXRWbE1mb2ZhWUlrNldteU9lUWNTRE9PS1h1Y0JKdzBqREY2Smd1K1dCRGIrQ0hjZkgvSUdTNko0UEZpK1JDdFR5NG9EWU1OcjNsQk9OVlVxMVdlWHg0RlBqZVV3T3o4UVBiREp6c2VvNDdvSjR2SG41TWNrUWNkZ3pQREx4ai9KNy9FWDcvUnBydVVnZE15eUxxb0c1L3dBdjFPZkhMcWNzYVV0eW5EbDk4alVyRGprcTY2ajBmaVpBNWt5TnROVCtUTEN3YXVZZVo4UjlRYjFLTDVNdEdlOXd3L2hEUElGemhkMVJITjE5U2MvdDFCdFdFUVdZWm5CeFNEYXptZzduOHRZdWhXWkZCT1BqNEQweHUyVlpCNDRWTWJ5WW5xbzVVR0tCQjB5dlpCQ2F2dGdjYjFDaGpNZ0RUR1k0V0srdmhLbUtCTzFTWVp5OW94YkwvRXJjUDJzT1A4ZjdnMURDOGJjeVlwZTU3MUFkMUFUUEZtZVk1bXRFeVJiSVdTenY1SXFrMkhWeFFCT3lEUk1YTGxyZW9XdTU3WnFCVFl6THlYcW9LNW9GaEg3TndodFpWUXNaL2FZNVgxMFFycytDWW9aVEV0N21TWTZxMlpaR2F0YW1Objlwbmh3M001aWlUWFpNYkVZV3Z6Y29DNWlaWkhMUVJTcG9aaVczeUNLZmJkei9BQ2NmRGovaC93Q080SDNSNVF5b29pck5rZjNIUnBobTRqUzB3WUFrUkoveHVLY1ppMEJIMzhCUFZNeEo0OGNhYm1YbHJxbW8zbm55aHZLRy9jb0h1RHFMR2JYVFArSkg0SDQwemp5VGdiaXRwN0laTVdvT3RFNUliZ1FMdVY5Vm05ekhrM01jTXNSL05ScFRtTnN5bzZucWNqTEdFNDQ5ck1FdGZ4TTBaeVl0bkdsaDEwd1Z4ZnBQSHp3dE1qY3MvamJkekR4alV5SzhhRThtSnh3Y1FtVU1SNmpoOXJKbDR6a2ZhR0xqR3hqRGxQZTJVWlFRNmgrVUk2c3FCa2xjWjltWTlVc2RMQ2xqUTlzNXExTUZjcUo1VEhQeDRDdDR5am9XVVRnZGpLSHRqZ2RyOFZBUkdJalJPU2R4eUtuTW1IYzh2ays4L2R5LzNISlR1Y200MkV0aGFUSFJ0aXFwRmhVelc2Tm54akhJSml4NU1QcVR1SElkeWxXVlVIVlhNczAxUHN4NUJQVXhMamlZKzROTXkvSk1YaXd5aTVUQlZibjRFSm5RekhMMU1jd3U5d3pnZnVFc1paY3VaWnd5SlphUnp1V3psWFpMQmYzTGh0amtJa013eDNPYngxRE9LY2UwZ25ESnl5M1g0aDdRaG5aMU1VWHFhcGdXSk9HSkFMcW9tSkFFaWIweDcvY3I4d0dVeWpqT05HNWluVE5FZEgxNzl3QkxXUEhHcGx4NTZ5bGQwemo5TFdkOXc3cVVKcGpoKzU0L0htNUlNRExITnNsNzVWSDdRQWl3VkVndkRqVWNqUVNxZHhOeTZZNURGVXBZSEVOekp2UFRPT1FmYVltcnFXT1lFcGNVTWpVcFhjS2JuSnFpT2RnYkdPZkk3bms4V0dJVmwzR2hER1V6RGxqL0FHM1BKblFVVHhENU1xNHpaanhUM0RpREg3VlJPRFR5aGl2Y2N1SlJPV1JVejgyT1FISGNvb1lpdEZrUEdCMno2NE5EZW9aOHpxcGh2UGZSTXJjMzhRRWpsNm5GWlFLTS9reUJ4ZjZ6dzVuUDZEZFR5NXJSVWNPK0xNQVU1dWlPSVk1bzZycUdpektwbldHQnNWbUwrWW90RTVyanhQVWZKd3hVMnMva2N4VjNYVU02VllOdW5VSzNBcit6Y3g4aGhvSThmTGxmVXh4SE4xS0R4dUUwM2lrenlRQ2RwVUFWNWRUTXdPaWVPaEZQck0yc2tOa1JHYzZkbGtXMEZXWWREQzNHOGlpVmliTnh3ZzVYUVJxYnlmeEh4SGpEZDNNOERtVE1CbVZKQzZKZTJicXlEZmN3eTR0NDlrKzNrdk82Ym1abHpMbUR4d2J4SXJsNnFZWTQ0OTdtcVVKeWEyUXFJWEdzNDNnWDNFc3VHNDlURW82Z0RORHFCdFpYTEZSbmc4QjVqTnlhb2pWWCtOVFFOeEJxVnRsVmhDN1pqZGFaV3BoaHk4YitvWXEvZ2lmaGxFQ1VvcE9McTlmQ3BrVkVWdUg5blVPUmp5TlRrTnMxbEU0ekUrM0tOWGNISVdHNFRFcU9Ba0NsbFQvRzgrUCtQbXJnWmo2WXRyblZjbm9pVXdMSnVZbFpmdUplTzlNeFB2eC80dzdjT3krNTVVTlpOeXhQMUV4OU13eEtuZ3h3ejhwaDVNK09EMnpNTmczVHFmdEttS0dlL2krUkY1YWdWdS9pcjNjeE4xUDg0eDhXWGp3eC9Fd3pNTTdTNDNYS2I3aDR4OGVTc3hHZ1lZS29NUEZ1Z203U3VwdWNXVU0zRmwxRHFhZzBmQktDRFU1ZHpsREw3VktWZzdUNHd4R1puR1U5c0FSbTZocG5peS9peWVabUhwbTgxY1JwOXlnc3VjUUJHWFB0RWFJQ010Z3pCQmdlUnRGanp4eURLVU5qTU1ZSmpvSTRMc2ozUmJBenF1cFcyWFFYRE5vUmw1YlZsdVJVcmlPaUZjZHpCZWhaa3ZDZVRBd3d4UjJ3MmJDNEtNOVR1WWJabTh2ZlVjaTV5YTFMakNwVmtEN1ZNczNITGlUTEpPbWZaUGdtV0FZRE9PckhjeFVOYVlaTEREZE1RNVpIeFV1eG91RHZSTGZnWGxjZHhtTlR3Z0t2UVRQTEZna1lDc0dsdVpaTTQrN2dNU0JVSGNaNm9uUTI3bU1vWWdFREVPNHVFMVdtYzFtOTFOOERxQjltNDQvYnVOUk1VN25FNDNjeFIwVElGLzFQVEd5b2Q3bkNBdHdFWlV6THFIajNjNDFBN3VJOENiM1hVMkVKNmRTck9tVnFHdHkvcjBTMEpuazVWcUJOcm9nSTNQZlVYR1kvcTViSFBVTWxobXdZWjA5VEpHcWxWTnNidVd1cWkwRXNaeEkwWHVZZVRHN21TUy93U3hoeGU1eHd0bUdJMmt6d0Y2amlKQUNIdVlaajQ2WWYyM0NuS3JpWTREajduL0NHYjJRZVM3OVJIaFV4Smo0UnpOekx4M1lNYkdEK21iYytnaXhpVnVOZHp0N21BOHR0a2NTMWwzaDI2bi9HeGlXbVFiamh3ZGp1SzhtQlkxTUFqcGQ2bGhpMUVtQ1ZITURUUEhsWTg1a1k4dHJVd1VWd3pSOVQ3WXJrcXNjblBZVk9TRnd5c2JZWjR1VWE5UVB2dU41cUJEeDVCMHdFTFZqNVgxTzYvTU1FdUcyaURoeGJGZ2VQTjc0ekxEQXlReXY5d0ZkTThtSU9PUTJ3RnRtQi9HT1lTdWI5bW8rUXhPQWY5ekdnV3BqaVpBak9Bck9OaFJhelBCd0M1d0daYTBSOUV4ZU4zK0pSeGxVVC9GL3hmRjV2SDVNL0w1ang4RFUxZVJqcy9NQjFXMllZL2RMSVk0bVZYMUFIbE9RR2pjeWMzdVU4TlN5dTVjRmRkaERPN1pXbG5uUDhkY2Y0VnV0eHdEa3dkQXkxS3ZVd0RpaDNPOGJ5eWcwTlJGQjdtUTFNdFlndW9zeHp0YklidU9MRXRKV1IxUFNQY0V4b0lzeTlNdW9EeGxkVlBFRzdsbkJ4aG9tMW5IMHh3NWRSd3lwbXphUVJsa3JIZ09yWVdQVUhhUmVMTVBKbGh6QS90Tm1OUWNHN2xDa05YRnNnekZRbDdpbGtFbDJzMXdobHFEamo0OUR6am5ubUZ3cmhQVTVQR1liZHN4Y2dSYkpSeGdGRUZ0SUx4U2NVSmRrNklzdzhRN0c0WU54QVdKV0V1bUZVN0hjdTVkVDFPQzVIckltWldITHRnZmhzbUJpYmVybmtUSnlxWXVvdU14eG83bE5iNlpVUm1GWlpWazFLcUNIdUo5b2dhdVluZHpxWWZiekJjLzhBSitRei93QTFEMWlUa3JTVEM5ak9HV1BjeUU5Nm44bUpQNU5xYW5qOHpqN0dmeTdWaDVCZFE4dUIyV3pIK056c0ZqZk5FcVk0Qzl4TVNmVklaZzlSYmx4c2lyT1BlNXhiMXVaZ2RTZ3l0WU14NytDWkQzY3Ywd0pqd0E1U3pzUW1mK1ZubjRQNFhvNm1LaFNUU2t4d3UyR0pVNktLbDY5Umd2UVF4WDJFckszcGhpbmpwYVk0OG0vNUQ5RVdzcDl3R3dtQzdjbUdiazBUSjRhSVpQYnVHVlhFSEc0YndJd0Z4c2o0bmhhd3dVbml3eTV0SlBEaG41Zkx3eWRYUFB4d2N4eGRKVVBKOXJNVWptNWRZTUZyWk9vMWpsWXpBeHljbFpaWFVCcGFnMnR5dnJIR3B3cXBqTXF2bEZER1cyVnVPaTJPUWtIb3VhRmdLdTVnTmZ1WkNwVS95djhBQS94L0IvZ2VIeitQL0x3ejh6L2ZBZGtHQ1Mrb2RzNVRYR0JIYzM2bEtRckhCcjNBTlJRMEVjVDh3QXVGREtNcFZFczQ5RXVNdWlZMnNESmY3QktwMkVMZndRUDNLeU10a3JjWWdrcXJucUUyTTJsd1QzQ3FaWjFNVUZTWkFBM3RqMHM1OVJkemtrNTBFNVJaeTB6RmV5T1V4MmtjMFUwazV5OXovUk1iV1dtWHVWS0VxNFlmdUhqNUtMUDRuWmJaTWNmeXpCcGR3eTFETDlTNFM2amorNFlzcElQNE5rZkpCbHdiYUlCVzJZZmx5SjJUaEhReklPSXdUSnFPV05WWHdKRnVEUlRDamNzeXY3VGZIVE9PVjJKR3c1Rk1NWGdNY1JlcGtZY0F4YXlpcXVyWUxVelMvcnVZNTExSE5TcHZqb2dLRGNMdC9jYTRsTnNYVUJTN2pVdjZ4ZnBzamwrcDM2amlHUDhBWW1MVjdJN3hMU0JocFJtTGhrM2pvbDg4L3ZBck5DTjRzTWhHR0J2azNNL0g0M3g0OE5zNE9KTWNad0h0cVk1RlJ3Y2xHR0dIaXh0T1NtcTlUSnl5dFVTR1g2bVhsTWNhcTV5eFhVTWNiMlRIaVpWUDhqd25pTWVPWm01RnRlb2VSRzY3bmk4K1dMbHNTSEh5R3RzUEZUUWJtV0dyNVR4anhMajRreWF5bVZIMUMxbDVHWGN0SGFReVltaFp4ekM4c2RKMHgrbmcvcWJtSVoyekxNdzlhbks4ZDJXekVvc1JqWXpCek5uUk9TNTJ4eXl0aGxUTE1jNWtqTWNidmN3d004Z3owZmxtZExwME14TWh0YUljYUdrM0Z4TWFNYVgyekw4RjNMclZURUhJSFJQSWNjcXd5SEdjZVdLakN1UFc1WjdKZjBYRXQvRXdMd1Iwd3hSN2JsT04vbVdtRGZjL3UxMFJ4NC9VaGpSWXR3dzNTa3hwWEJTdnpNQVByYk9PRDQ4clVZbXZhUUxtTE1kckxZY28yVEhEbHVHQmFyTzRZd0JLWi93U1lGUVpSVVdpWE5QY3g4bU9PTEFNOEhJWmsyd1RaVTRnemp5Y2FHWjVJMUxic0prK3lBaXF5OTZtUVNvalhHQlh3aTlTbkg0MVVFU001aGluR1d5eW9ONHhQcEM3dnF2VTQvVzVpT0kzTVd6ZWo0bzdtTXlXcWcxTUJ6MUViNHN4NVkxcXB5eW1VZFliZ2tzaEVKNDg2VVNaY3NzcldtNWllUERITzgxbk9pWStYaUl6TEtINEppV3FrOVRzRDhUSVFsQmdPTnY1amJCTDNjUTdJWjFISXU0dDdocy9aUDhBQ3dQTC9uZUx4L2xuK1ptWi93Q1g1RS9OUXh0M0JNTTdHWitWelc1YTZXZFNvR3BzaEs0c01nYkprcUsrNGtRU3JpbzZobkI3bHhXR1ZMTGhueEpkeHBDZWlZTzJ5ZHpwTGhqWXR4Zzdpc3h2SXFvWGZ3WlBNb3ZjRXBjcGpTYWpjQUQ4d1RwWllQZW9PT3FoYzUveVBUQXJPalFUeTZmN3dMeDAzS1hEcVkwU3pwaVJLbUE1TkVjWEhHbWlZbSs0WlpZbkdLOVhBem80c01NNlhtVC9BQWpQSFBQeUJZRTgzbnh6OHk1Ry93QVRuamk5UThxbFZRc1RmYk9OeDhZVEhIZTlUTU9oaG5Ra00ya3FMYy9rL0pjNXI2WmhvWnl1V3puT1Z3anFEY2JDRHlkTk1QRzhMdFdPSGUyY2FKb25Fb3FJa1U0eThTWXU1eWJZWkpESjVKK1o1TEFJUkI5eEs5eGE3Z2l4MURLY3BkaE8xM0M3amt3Wi9adFprMGtYOFRMSmNTRGN5cVZFdGR3Q2lVU3lXVk5NYWxSS2h4ZTJVTHBpQVRpemw4QjhZanVITEdWTUx1WlNod2djWmRtb1pJVk1mdExsVVhBWGJMcmR6a2l0d2RSaGpxRWNUSEdZWWtNWjJ3cHlwaDJ3S1dVaWFqbU5vQk9KazJ6Qk1aUWpBT0VNSGhjNVpXckRKM3FDY1ppQ3NNQnNqaFRESEp5MU14R21heXBUUkw3UTFLOUtSeEF4cks3MHpQQk1rSWVIUGZkTTQ1WUhaTjR0d1EzVVVjNFlZcnJMY3k4TGlka3h4eEpzd1NjK0pVNU5JUzBlNFpvVWtlS1hjd0I2eWlQdnFJZXBqbTRpZGtzeVZyVWNxNm0yWUhJVDNEQlJ1ZnFZUEJZaDVMVnFZMWNWeXRtU1pKVS9WekhGT21QSUpqa2RjWldLYkpoNHh4eUxRNzBUeW1HSi93RFZtdWk3bVMxeXRKL0s5WllzY2h4bUJqeGh4Y25WU3E2eW4vSytVTWdPNWhoL0w2RDl6eS80K0lWZ2t3d3lNcWg5Y00wek9SRExmSmo1ZEd0VHg0WVo0NVpyVU0rSTBXelBBdzQ5TGtUSWVVd0NxV0NGanN1R2VkSW5JSm5nNWVJOVRLOGRTd2E3cVp0MUZyQ1dkVEtqRFRCZVVmS09HT05UTXJMVFBIeHQ1VGlMSHg2YVlHaTJjaVc1d0RodDY2aVZsYTZtVmNySmZMR0kxY1VNRFRjT1dlVGhpVnFjWEE0dmN3cGR6ZHJqRE8vOXpQSm9BM0V6OHFCUitXZVE1SVdXVExETHRicVg5bEIzT0x3SWxaRnoyekdoWmlhN0xubHdjUGR3RklaYTRoQWNkZW9IMVNZbDR4YVhVUnhwdnNpVmU0UTdtUVZMQ1h4ZTRvSkZBV2NlV0ViRW9pejdPTUQrTHdQN0lOM0NMTFJIMUVtOFZLaGU0VHBmZ0Y2SmF0eW1GZkNYS3FKRU1keXVUTXJHSXdMSURlbWNWekJ5Q2k1bG1QSmRyT3RFMi9HQUFzMEpEV1ZrZDVUZC9xR1NLNHplVnpCeXlNVE5LSWhrcFlUaHlXbnFMOUc0OVZDaW9wT1p4eHh4S1o3dW80R2Q1WEhxUDZuYkJ0M01RWFJPVk9pY3hLcXBqTVhWU2dHUGlNV24yWEhWZ1NsSUc2U0oyU3RRR2Y4QWpRUDhyK1UvL1YvWm1SeThtYitjbGhsMlJWbXUyV1N1cFJYY1JlcGl0Zkh0OXpIVXl0bHJjRUZsZnVFNmhOeElRN2pWM01jYkE5eHhjZFYxSHF5ZXAyVHJIVXl2akFyYVN6cXA0OG5ISmdxdHNwbUhMRnVIYTFNYmJJbjBwZ1pGY1loeTNLTlVSUVFTWTVtTmdpeTAvVE1kck1zYnlWSmdJVERraVhFWnhRbWgzT1dQdHVXOTR4NVpBc1NHT05tVnM4ajFVNVprd1ZGV09aNHY4WDZyYVM4bmFBdnVPQml6SnhyRXJxZnlDVlUyTWVydTR1WGJ1SnVDclZ6RUc5d0F4WEozQ3VRTU9MaXh3VEZTSUFEdTRVemdSeDFxRis0RjJYRVRxTGxDeHVvWkpnaDdpVTNjRnRXTzVoUU15ek15aVoxVUgvMEtjamN6ejVacUdpWmJkVGp1N2lTdVVmRzRzUllINmxYSFp0cUFOemlteVZ2N1J3bFltTUM5U2tibUg5RzRsZjhBY1RVM1V4Tk1BQ1ZxNGJoMGtwN0NQVUxKVEsvVW9JR1NRTjdtV0pjcXZWeWtZaGNjS1Z1RlhEaVJyam9tV0tzcDRiaGlqQTR0RTZibXk1VjVUL3I0eXd4cUFNeXdyZHh3dnJLSDlxZ095NGxPMjVncEZ2MzhEUFF6Smd2SzkxS3VOaEQ5c3JFM3l1RFpIUFZCS0hHWWlhbjhUdWZVUkozYU1JTk0vdXNzNFV3Zm9nNm11VjFGb3JyOE16V3ROc1BMbjFhQlA4WFBBNXZsT2V0RThwWUIyeWp4dFprMEx1WWxEbFl6SExNSFV0TVM1eU50TVFaaFRRekR3K0h5WVo1OCtEaWUvY0Eya3E0WXc1T29aSUl3eWVTSlpETXcxVU1jV09ISC9sTXM4Q3VNNWlkMUt4cnVhdzQwbVZ6SVdaYVFDZjhBRFRLQkVMaGlaNXFhbVYwMHp4bVdUeDVUSmNWdzEvdUQxZGt4VEE4bU9PZTZuRnpCNWJoZy93QVBLcjNNL09lVExGY2FEMU04eHoxcWZ4NVZadWNmc2kxREVmWVE0OVYxRU9BOTNENkhjeXlmU3pCR3J6cWVMeWVQQnpjc0x1T0FhL014OE9lWlJWRXlPTllzUlc4ZW9ZWXBicENwd0N5NGVLcmVEbFBKZ2lWaThaNGZNL3lJRS95OHNqanllTUN4TG5qd1hKL1JIREY4ZkxsVGZVcXRPeWNhZ1dGV3NWQ3dpWk8reWROZkdJNG5jdDNoU3NQRThMbUdDWThvcGlQRjduMWNjUjd2dVo0cnQ2bVppR1B1NWxqa096Ni9tQ2pqcjZ6UHlQUFFKRHlCbU9MdXBmSXlYc1pqdHVHUUNEQzhtelVQNmJka0VwYllKZW90TjRmOXpMemNzREhqTFFnWHRtUUxwamllbUdJMnR3S3cyM01jYzhqcXlZZU1ScWNVWVFtV2dCbVNxRWNiellreGZyL1dZYnU1ampiZGt5VG4wVFRNOFhSNmdvSkxBRHVHR044c3ladU9ib29KNUhRWHFCVU5RTG1idWlIbEYyZFMrVnpacG5VTFlBNFh5bEpIQnc5UXBpL0N3L01XNVUvWkEzdU5NNm1HWDJuazd1NC9naForNEZ1NFBaQW5zbldjOXN4bEkyNm1IM3kvRXl5eHhLajVBd3F0eHlOcEwrcUU3d3VmOEppNjJFSDdiSVRQeTR1QmlFenlxWWxFMjZOSk1NYndXdjhBYzUwUVpwaFBYY3ZLT1RrNzlFY3B5Z054dCtNUzJmNFJ4OFhuL0dXRkRQTG5qampRYmg5b2xzNldET0gxdUd4amxXT29Ya3dvZHhEc2kzQkdOTHBpUTNLNHNjaEpUOFZMZ2dSWUNmN2dxYmJXT01xQkNFcUlTcStGSnphaG5DMmZaaWZRM0xYRHJjNXZFSVAyM01NYzgxTU1ZME5aanlJZmJQV280Tzl6UVhESkdGN2p6QTNESGs5elAvSGZIbkxBYklsd0xoUkFOVEtoc2hlZWJ4bm04M2t6OGVPSEUxQXZDODNxYzhFMWlzRnF6Q2ZZN3hJN1ppSVVueG5rVVJiZEV4SGxNS2N5L2J1WlplSTgxMW9LZ0M2MExFK2xPVTRtclkxQVdVbndZeEpuY005VEdaNUZhd25UZVJIamsvV09QN21qVUM1VzVWeXVMTlR3NEgyZnhIUFNCL1ppSWhEeHppVHg3UWRGenlIRHlOTm54aGNwbVdETWNWWndSbkM5c3FvRGJmVWYxSEN5NmdjWW4zR0o5bUpVclV3SldtVWtCbHZRUmdYRlJnM0Q4TnhLTlZLV0F2YzRwTmhUTXBVQUdZR1BGbmVBU3FZbVdlb1laWmF2cVk0SnRuVzZqYVZPS01NTWhuSGN5RWxaVEFVeUp3bVdBVlA0NmRNNFdYS2NXSVF4aGhjNEZ4OEE3NVRnbXJaL0czYXdLdmxDdnhIRWVpWXRIVXlKVURwSXVRc1hmVU03MGxER2pxQ0xNMndjWVVsUSt1VlRMYjFCeERjVVhVd3c1cmFnRS94ME0weXhOazg1azUyYVNMbGxtT2JMVEozQmFnNU9weWVybktZdVBiT2ZkVEhrNmx3N21UWFU4T1FndjVubDQveTVWMU9SaUJVelNjcGlMcGdUcllTMzBRY1JxYndKenpCVW1LMDZobVlKcTdtUG13eHM0VE50V3FtT09EYTJNTVhnaWFmY3Z5WmVOT0pSTU51Vkc2aGdoYXpGUTB6RWVDUGR3NEY4aVByaXorSHlaMmxhSjVBeHJlNXlkNVJ5K29FdkhINjVrTUIzaXpESGtnaFBKaTc5Y2VxbUdROTNjdkkxaGxEREplTDNQTDRudzRDWmpjOGJrNHZLWmk0NHZNUDFETVVyS1p0aWNpZUh3SDkzSVo1MytUSXB1cGFMVFVlVFZidU9ILzA3UVpnQ09QTG9zbHFOekN6R3lZNHJnNU1USXVuVVJ4QzV3cTQrTTdXY1hCTXllVjQ0S3UxdW9aT1dGY3RFS0crVXlmUzl4LzhBc3dvNkpnRmNuWVRMeVpQaVZkVERJeDFqdTVrWTR0enhaT0dibVkyVEJ4eWMrUlN3VlhERW1PQ3FPb21QaXh0WmkzRUlER3NNcGxrNTZTb0ZFY2pMQUk4UWhSVEZQNWRHcGFxQnFZWk9BN2plTDlXWVdpc2NubEJ2VWNYRU4zQmk3VWpESjQxSEZ4Q3pTUXNJZ2tDdFFwSWxUQUxtWitXT2lpQTViWloxS1lkVEd0M0R1Z204TWJjb3E3eWJmZ0hsT0d2anZ2NGFPcGorNHpERlMxMUF4dXgxRjNRUi9FSDRxWUc5dlJNZ28zSzk3aHFZWXJobGtscEQ4OVMvdEhLOHFTTE12SHhNVXl2bE1TaEVscTB3eDNNTUM3eW1TR1MxRnQwVVJveVlsR21IVlZNYTNjSWFuWXk0RDJzeEZMbmk4MldHT2VBNnk3bUpqZFpPcGtXNmRUcWVPa2xZMjJ5M0hKaTB3akwrS0tnSlZUeFljUDhBeGVXZi93QzlVVzI2aCtvR21tQlU5NkpVR2hob29seEFMbklmSFFmYUN6RDJNcnVIN2hoTmNwWnVHVEVmVE1mZHhDRXlOUXFvVWFtRzVsZ2p1SFRLc0dkRnd6SEdaWlRhU2xZZU5xL1VvbGc2SjRoZmRFeUcyczVqbzIzREhjNFZiTTkxUnVlSHlIaDhtT2FUL0p6dzh2bDVZQVRESDd6TXg1cHVjUHJBRFpqY1M5alV5ZFR4NVVXNm5rY0Z2RHlPVCthbGpNYzhhYWcxc0NKZTFtT0JieFp3NDNQRGcrRTU0aGxpbTdtV1hMTlJxY01PTjhvb1hSS2VKdUtNL3dDb1laSXR4N3BZZFF6Wis1N3NKZktxSlJYVXo0aVZISzhXRlZZUWd0TTNLeWpqcTdqY3VpZUpYRzJQSjdZdE5UR3R4QkxoVHRoaVhwMUsyMHdHUDIrTU04c1BFL3Y0VFF4VWl3cE5pd1FZKzVob2p4WWVSQ2dsemxjVUNWY3VtTWM5YUovSU9IN25Mb0plTDZqQkdHUVFSSnp4NlNjaTZyVXVDVGtCbzNGdDFDdis0TnNDZlhxb2g2WmxGZnpMRzdZTlJtRkpNK2dnRXVoTDJURnQweDhrUEpxa2lxM09TVGJhc3d5blBmVnprL2lpR2JGb2o1VnhwZ3pCeHhFWlZ4eEV0WmgzdG1iaVE4bkxTVGwwRTM3WmJlMlpaQ2RYRC9VK3IzQnhobmlSNDVkVGg3STQzMFJPS3hGNmhicUt4YW9JV1N4WlRlbXBiZFZjNDVCZFE3dDdoNUhtUHNubHp4OG1Ea2FpaUVLWVZNc0xlcFZQVWVGRlRMQ3dCbkNCbGY4QXFXMnpHL2N5eW8rc1YvakNxUGFSeDVZYWR6K0pvRkxtVHg3MncreTZnSURIclh3WSs0MytkVCtYbmh4QzViVlhvamVxYnMzTU1xUlNaanlXTnAwd2NRMld3RmR1am9saGlsNlo0RGVRZmlPQ0xjb0k0dVdWOG9EeWljTVJxWStUZ3RYdUZMcVllUU1IREltV0psdlFFeFA1dHVXeWZ4OEYzY1J6cDZxWmNySmlaRHlpSzJrOGZrL2pWQ1k1NHZsdmpNOHdhTkV6eisxM1pQRzR1ZXo2eHhXOG5SUEJsbDJaYVBVODFaL2JvdVpZaGsrN25qWEhzc25rK3p5OVFlTkpvalhINndjc2pxb1o1WVlwSEZVMTFQTG5obVltT0hHdTU1UExvY1FOVEg3WU81bDVubGlQUkc4c245ekhDc3FlMllBNUpraE1yOGdqa0tkVHh1V040ZEU4bUo0ZjZmWVlGZGxqUEg0bkxsaUlVWERNZm9rUDZ3OUxQRGtqeXdvWi9LdWZMTTVIdXBrNFcwYWVpUGtPTTVlblVOQVhNNi83bEU5WFlqS08vVVN0ak1PVkwyZTRsVTFST3NuVmtxT0JnRzdsME5ROExuZzVtV29ERFVSN1pjc2V5WjR6UHlaK1R4NDRyOWNkRVdZeHl0dXBlSzBUbHFuYkhNNkNMZnFaQ1Z1TFRZd1Bzc3R5dVhMQmo1SEZ2SFVhb2ZjekNHcG1tbTZuTFZSZmdudjR5eDFBL2NOTEQ3YTl4RWFmZ0ZZampNTVJ3eVpSZFFjREI3Z2hUTVMzKzFRUHN3YTNGWGM4R1poNVJ6dzVFMDV0TkE2bGNsbHQzUEUwcmp1UExMSzVsaWd5OHByazNDYnFJQkdETGxmZW9HMFdZWkplUHFkUnphMFhCZ2QzQnAxT1NmOEFHWHZjMjcvRVMyNWxESkdidTUyVENpZjVLK1AvQU1kaWVsdUgyTk13ekRCd1RiQ2lWb3FHZFRrWlN4bkhWenBZMmtPSktDUGlsS014SnNZeExqaEtvZ0xsTXNKVlRiQ1ZET1lobU5zNlVDNXNtMW1CTXNzWCtwTFp1R2VUOVlzb1pqWjdsWXcyMFRvM1A1TVQvY2NsbkhKYllIdUlZWjh1Y3pYaXVtR0QvRmNQWmRReUFwSmlZMDNqUER3ejh1T1BsYXduK1RoNHNQOEFKY2ZCbmZqaDZzZ1k4WW1QOFZqTWEwVERBVjdKaGppK1RlUzFQUDU2OGZBSWxrNFk0K01iM1BwZ1hrWGM4WVVpTXk0K3B0SlJYOW1aWTRoYXdxTkdwc1laT01XOVhVeDVjNklxbzVUS3VMVXl5T2o0dXNacHhJWHlkL0JjcDNBYWdMTXNhR2FJZmlWUkVlTmhPTERGZ1pRTXFTWnRlSUdKT1dxbG5CSm5SWCtvY3ExSyt0czd1SEl4bXU1eWx2eGJCenJxWGt4c3ltNG1pSExHTnI4R053ZDFONHdWWmF4eXlXbzhpTjJRVzduS0M0czU1TEJWajFxUEtGY0VZYUxuTWZVZklmaVljZTQ1UXptSUxhOXlrVklEQVpqeW1JdmY1bkxhU2xOUUdaQ0hjRFdtVVJzQ1ZaNmpoSzVGemhQNHEvMUh4NHc4Y0QyeHh4WldJVlYzT0FRd0YweDhjTUtPcGw0eE9waGhpVCtNdlRQNGswTXo4ZVdMdUFyTWkrb0JTVGlUSEQ2Mnd3N3FQamUyT1AxUDFPZVQ3Z2hTKzVsdlA2eXk2OVQyMTFCZjZqRVQzRnIzTWYyK28vMWl6RmNWbUdlMmM4Wmg1TVRTUXc4YmxWMFFCdkV5MU1zQUFJWUl4d1RLQ1luVU1oSFU0TmZXR0tGTVZ1cDlqS2sxQU1McDdoMWxxSThCSVlDMHNSWFNWQlZxcC9IbTJucUd6Y01ES2VBckxLdlJGK3lzRGttcGlvdW9iYnFpWlhhM1pFZU04ZXN5WlZ6WTRnN2RURXNUSHFZOGwwemxtWlZNVjRxekh6QTNrYW5sOHVMdkUrc2M4VW1BTHBuazhEd3RTT0Z1b2MwNGt5enlxclo0c1F3TmdNeTRqa0d5WlZpYjZaL0t0WWhxWll0Mk9pV0l6aHp0eDBFQjVhOXd3eXh1NFh2SmVwazIwc01LOFhMTW4vMU5PeUlaS21YVVRIWDIzRU1rUm5FYldZR0I0MnU1VFdTYm1OdVZlbnVQNHZVeXhUS3NFL2N6dzZxcmxNTHNndDBRT01NK0dZMWNzZkpiR251T0lLUUxKNHZxdDQzUEY1Ly9BSXprL3dBV09SbitUcWVSK3orL1VDOEpqZUZnOWt4VlFka3p3RjIxT0hMSXhHWjZ5UWlkTTRtQjNxYzZzbW8ybFJDa2pobzNPaEZ1RjR5aExnaEtRZzZwSU5OeDBYRE5HNmhsYTNNdU0yTThtUnh4NHcrQ3NtSkV2MzhVSktVSmxRa1lQeFh3QmRXck1IK1BOYzhCczB4TlFRM0hjL3EvNmo1RFBMbFVWeHhxSk5wOGVKT1ZjYmpYSkNaNDhJNHZDNTR2Sm40L3RoQjVvWlBjemJ5M05EUEVWaDBFeWZURHRDS21vL0dFeEJ1TU9vTmF2WlBHMWxlUmN2QTNpVE1icUpPaTV5c2c2KzB3M1lUNjhHNG4ybFRNbkdlNWFRbUJlcC81VGlZZjR1QjBlT0RGZ3psdmxHdS96RHVvbG1vT1FTdmJGU0JSTXErbEhSOG00dTRPNWwvdUNmbVVUUkUrQnJEaWtFZTQ1QkdnS3FLOXl4TndHb1k3MjZqV1BVVzYzVWUvN1Rhd3BuUjNjdThicVk0d2NobzZoWXhiZGtDa3JVY0JwRzJJODVpQmd4ekd4eEp5dy9pQnhZWjFpNHVNeFJ1TFQxTXNsU2NxSXNVYWpUN2gvdVlaWXZUc21Qa1h2S2VITThmTFZySHlZOGw0UjhsK281Z3k3WVpvNmpra3RKem5LWUZzeU51NW9tUEdOSFpNQXAxRXhldFNqakFGamlRQk56aUgvS1kxeStLQ1VyREY2dVlqaXB6WlZGamJHM3VIVUxTR29EN1oxN25JNVdFeC90KzJadDVaTUJmZzZWbkhKT1JMeVd4Z3RRK0tFZ3czQTJrQmxOZHdHNW1ucVUxWXhPN1laQmpVOVhCTzV6cUdWdndXSHdpcEduT3ZST1FURkJzaG5UWk1uTmdmYVlaQjJFNWNNcUNDc3RyakJwYW01ZGt3TmJXTmVvWk1NbEhVNVpjTHFHYUVNLzNNY3J3ZDlUSHlISHE0TE9kVGxrbW9aK2t1T1pkY1paQ3c3MUhJdVhZV3prWW1tR1lPbTJXOUpVVWRUSHlocmpNY3NhUnhRaGw0K25sTWNjRjFsUis0K0RTNDdsT0EyVEhJZXgzUEhseHNWcVlLdVFaYUlaYmg1REhLd3VmeVkzWmp1TkxPV0F6OEJsTXhWdkdZbkpaL0dpcXppcWRVUXlLNFJvL2N4QldWaUEzdVVLNm44ZU5QMTNNaHh0Y1p1djZ6SnNQckV1NmhabWNwbWZmVEJjY3JBbVJsZktHUEtYamljVTNNWmtqNmdUL3VZNDczYVQrWXh6c3hFSjVjakxZUUJ4VXlxWVpaNEJUWlA1MnRZVkhNeEw3aG1LL1dPV05mMWJobW5iUXpIZ2RadzRuZVVNTVF0V1k4VnR5S25rNDVPVEN1SXpIQlRXUk1jY3NQSk1pc2xuanl2L3FmVEpVMHc4bVFPUGNLUTZ4VDJ4eW8zOTJDcnVMamptSTZuZlhjOGZqcTBtUERISEtqY1MrbVpiMHMzZ2ZxYzdFOVRMRGpnSWpMTG1QbHdPOFZabjVjVnZENkRNY25QSkJ0bURqamJrUk1YeFdhbjFHWHpRcW9tYm4zTWFidVlPR3laNXpIN1dyVlJ5dlFWTWthSGVYNW5GY3BhTlpibWtRL013UTVHcGVuRnhncUJqdXBtbWEwVk1hNGxPeUdWZGRSQmZyTXF4RWhpRlpMcGkrOFpoaVptU1VJUXcrcm42dUR5RTR6UGVBZTUvRmtrclVUUXJIdVZ0YW5OU1BteXo4WERMSHJwamlORDMrWS93QVkwcTBhbVQrUmduT1hwQW5qK3VDb1JiZ0dTUXR6KzVxZVV4NWZVbG9haS9uNGRURnNqazVvMGFpOHdPdU14OEdXV0RtL1hHSFh4eklNeVdGWEtGWTNNaUJSOGh5TitvL1lTZWdpUHFDOFNQNWd1Ukw5RUJZRnpPNnBJVVZ4V1YrN2ZqWXhnUXJGMEZNeUxJOUNTNWJLOTJ6RFRPZkpwbG8xRTQ1YmhnQ1RKdHQ3Z2NzcDRzanBtZWVBdEU1WCttT3N1N3VPNVV1c29lNmxEamN5OGJoUXZjeDZaajQzZ3FrdXVqVXJGTHlzaGpXVS9zVHFGa0tobFZFOXk1Y1dpRzJaWTlWdWNXZU5NWGxQODdMbDVUSC9BUERqVTZJVjFPcmhmR29ZMlFoTDFCVW5jTXFxWkxrZWlpQlUxRjBoTUtyZnc3T29COEJLV0I5WXF1MlVSSzlYS0c3S2hnVjNBTHBuMVhWemlwS25DY01YWk9QdURPeVZxQXQwUXVCREpYcWNwVkZqdVk1WmJnck1nc24zb3hzbWFBSEsyYVFxZEtYRmVVeDhkdmNLNXBLTGR6R205UzhTOVFjZlJNTWkvd0N2VEh5T0s1VWJqNUx1NXpxWE1jcjdKZGJDY3IweFhjSXY0SmhncGN5SEhPbG0yRUhMTnFZK1BQQzdadTl3dUdHVDFQdEVaWjdKb21TellmR0dWTFN3dTdoa2tXR0dXWDRsUFJLZWp1TGw3SUdTZFR4amxsVkU4ZUlaNXVYL0FBbEh3SjB3T1doWlRpVU00OXpvZ3JIcW1BSnBqcHFYQmVkemxIN0hiTUI2SlFRNUd1TWNWRnFVVkFHNWlVSkQ4SkZzMFNtNXM3K0J2eHVvMGxrcmZVQ3hLaWNZbjVtaGluTHFXWm1qY0JsdTVpTVpqaWx6QVRHMW1aWGZ4aGF4NUVWdU9OekVNY01xTzRMUkMvYkIya000TlNtM2NORTUySk9RRnptdVBVTTl6K1RpMkJjL255emJ5WnpDSGxWbUdhNm44aGswaE9lSXc4cFRURHpaT0NOTlRIUHh1Rkp1SGplUHBHR0owdFREeDRjTkJQNDhNVnFQang3eFpsNGJJK0E5emp4V1ladUYzc1pnamRkenk1ajRzVGdXU3lZNG1XZGpBQVlIRlJCV0lYc21aeHlFWm41OHM4VlpWL1p2Y3d5VVNYYzU4RnN1NVJtbkppQWxiaGhrNC8xaXRBRUI5RVM5cE1CVlNJNjVOWE9QSGZLNFphdUdmTENGL3dCYmdiZGpVOGljeTRaRmxlb3JsWG9tS0x4cVVjM0Zmc1I4ZEtyTThXcXJVTVByWVRqbDNrUmJhVFV2VkV3alJoRGdCZDNCUEk2b3FKdmlkd0l1cGh4NVRMSFhmY2NPSlF5ekhRVEZ3UkluSEpaNHJtVlk0Smoyc3d5UzdnUGtHc0ZtR09ma3ovanF2OXpNTU1rN3FZTGdyTWFjMXlka2E4YmQ5a3hwek9ld25tOHZqUElmeEZFTWwxVWNqK0xFQ1pISExaUHRXaWFBUmI5ekYyeE9OczhkSXJNTXNUbHFQTERNWEg2dXllU3N2NmtQSTRZMkZrSGhrTHNtQ0dhczQ0aXRRd1VHeW9EZVZOUnd6d3hNbEc0NUoyVEhyOVF5NE5IdU83dVVwY3lSd0FsamVQVXdNYnBhQ0daZVFZenVpcUZqampqUmRwTXNsYUNZOGVRNWRIWkVIUFJxR1JndjdtSnpLZFQ2N3hNdnF3NFlaT04yVk5pc1hQUEFXY3FkekJ3YzFTWjhHbkgrc3h5dzl6UnNaenlUdUF3ZHY2anh5K1ByVzVvTDlFQmRCM1A0OFBHVzl6UHpaK1JCYXgvRUJpMHgyZldXaDFCbVE5ekRXVXQyc1hWTXZWTTZtakdjdGFpVjEzSzJMTExaY2NwU3N6RVlOTEFhc0xscVFGOXdKay9DVEhka2NhU04yelVXQ2pMZU13ZDdtSVpMTVZGbVQ3bmRRd3N5Wnp5b0FoYms4cHlDNWpUQzdsNDhkeEtKL3dBb05LUXhUR1puVE1hWmZlTnpqeTRZNEhSUHRscWVIL0d6OCtlUUlBVERCSElObVBiTVF5eVFHY1pVRDlmQkxpd2hsV1ZrTXNtOXp4NDhUeHZkNVQvTE9mOEFtZVpuRjZnSHhVdzl6aktxTjM5ZW9iV1ZDamJHazFPTFVTajRCNHN4UHJFZFJxNVZibktHZUlPbVk1RE02djRIWHdBVEJLeXVESHFZc0ZSQ2ZZaGRiK01VcUMzRE5GM0MzM0hyKzBML0FEQkpaVUVwbHgyaXNNL3RjeUF5RTNjdk13NHNNZldUM0RWMTBUTDB6ck82bW5LSGs0aUV4elUyVEdhd1g5emt4dG1PMk92Uk9VZXU1ZjJpcXpFQzU2MU9pby9hb05Yb2x3bVljRGJDRmM2Ym1Xc3BjcGhpczRjWlVxT0U0UXhEM0F2STNNemZjTnNPMGdwdVdMRE5KekJwSVVlSm83aC9hUGVvaVRsYy93QlJWbXczQXFXUnBJMk0yd2FhbGJuVWM1ZnVvWjNDT1gxcjRIaVFWemR3TVR4M2U1ejlWT25jNUVNbkhCeER1R3luc2wwc3lhSmp4eU5yTWc3STFVNUExOGNrTzRQN25XUnVWcHFJWUF2YkVzQ1pUa0hjSEVobmN6WEpzbHFWTHJHWmJ3QWFqazlWOFUvR3lDc3BSWVlyNHVwV1FRNjNEanh1b3RhSlRVNVF5WjQza3R0UjcxbE1jdVA3bjhtbEllWm1IbmJNcm9tWGw4ZVhaTWZKWFFWQnd5TG5rL1RPV0JnYnRpaUJWWDdsNERNenhwVXg4WXJUMU1zTEkyUUw5U3dBTk14RlZXVTVDVE4xVFB0alNiR0l1RTZ4bDY2cW83TFpqZHhIdU9lZkE1M1V4ekFtR1Qyazh2a3l6TU1PQjllMk9Qc0VtWGlzM2wxUEVlSUhrWE1zZUMxanFEajduOGhpTU1zSHgvaG1Rb2JuaTFkeitVZkdGZFF5VGMva3R0N1lvNHphUytpZmtZZzQwVGdrcmpxdTV4WTRmMTNCclNVekFXOG1ZcU9wbmhrRy9jS3JmWVF6NWdwcWR2VWNOS0d5Zi9YZ2RmWklZVi9xWFRXQ1ZGWDhkencrVThaa09Kc2g1SEYwcC9xUG14VDl4OGhpMmJtZmw1QlJNckl0Z3BISHQ2R2VUeFlZQmtQSm5nWEMrV0pQS1g0OGNpT09lbEdaZmhiaHhKZUo0bjY3bnJxWUNYTVBEZ3Q1OU10Vk1sNEJyY3V2cUc2M0Z2eDhDTm1GT0c1amdwZlRBYnBMS2p4NnhKV0xnYSsxd3lTaDlSYmNrbVY1WVRENmpmY3VsWStRNGxRZVIxRGg3N2cvYWJIOFMvZDJURlF5OXJES1hWTXp2blpONmxXeE9EcmNjckJUY3M5ekxOUURxTThRNTVVR21aNElwK0k1UEhqUnFjdFZNUTR5M1VTc21kWkg0bDNra3JjYVNwNDA4ZVg1dVpOWTVXV3p5WW1YZ3dRM2NGbGtDaWI0dXBWT3hsOGJJRkRNR2VUYk1mZ0xpQjhNdVZvWm53Y2ZyQ0xPOXN3elFRWnZKaHE0dGhUTXNpalRjYUZpYXVZczhlL0pVMjVKQXZVTGxOd2didVlweW1hTDlZWTZaWUV4M2lrTGRqT1Z1NTJNS0dpZE1ROXM0UEhiQWh0bjZabmdGVmxjeFJZNDNrTVZ4eWRvRXk0dmpISERPL3k5VG1tTHhVV2VITFB4K05NWCt4U1JIVEdFR1luTmhqdXZnTGFZZ09scU5UQTFVOEdOK1h4bnE1L2xvLzVYa2YzQUxXMllwTElJUUFsbHp1YkppOFliZ2xWRUlreTF1RXJVM0xRbGxVRnNWbkJncEw3dVVRQmRSS2IrTkpxWWpjdXZqSXFZa2JoY3BXQmNjS25BbUo2bkJ1Y0VuSDZ1aVV3d1c0WXN5eDJOTXhTazR4b3BDTjhibVpqbGdhYkphUFdwWm1BK282MHdtQlY2aFVIVmhMNXU0WWNjbUlmakpnTy9yTFh2R1lvNGJJbktaVUsvSGNhRHVjcUwxRkVaUVNpNGFaazA2WUtSVmJpc3IxQWVwVEN4Umc3cGhhUkdZdFdJTnlpTGo2SVU5a0tKZExITDZ6bjBJUzdORXh5MVNibm04ZzRZWWhMc1k0b1hjVDZqZTRhVW1JRnA4TXVZOGN1eURpTkpxZjZ0SWQrNDhialVFV3BSQkNjYXhXOVRpb015NHc2dVlVOXhBYklJVGtNejJFM01icVV1bWRFM0JUUXhweFY3ZzZpMXVweXYxRUkxVXNjZ1NaZ2FHWS8ycGRSL3NvOVEyanVDYkkyN3JVQmxJVEh0bVVzNnlJVmxxY0hEOFJuV21WQWJuODRmNDNEZ2Y3amx1aFlzWUNsUktLWWIxT0I2WngvY3FpV1BvSlNReWNUb2JsMnpISmRWT2U0WjFxYS9LVG0zVU0yOUJQSjU3OFdHUFNUbVZGT0N3eWFFZHM1OFR2YzUzMlREUDc4U1pBNUJScUlEVkU4Z0FCUEw0MnJxYnh4QkpoaTdGbWZHcVBVeXhOUDZtWFNFNEZ6Vld6RWM5WE1zQW9oZkRjRkFXWXFpUXd5TGhseExTWTUveUxjendNTzZuazhlSERETHh0NVBZemR1b2JaeGVkc2Nmb29UQW52cUF6eDNic21PVkN6bVhpMU1zOHVUUkRKdXQzQlhLMTZtWjAwYm5pTUwzNmliMjNEeDUzUmRROGVaTW5MbFdVUmpuanhBc1NZNUFMYkRPc1UzdnVienhMeDZOVGlsZ3oraURIRU90czRnZFZ1VTVXNDNGc0xBZW9ZQ1pjbUhqUTVQVXNkekFjN3hVQ2F4RVc1a0Y2Z2MzSFFBVHlWaThjY3BqNUhMTU04a3hKbVk1NVdKUEdIMjVwWkhCVXRPcjFIYlBGNGNYTnZ5UThUbW9ack9DRnIraVkyNUtyc2g1ZjhBNnVIQXUrNHVSZVdXVzVrTjZobWw3ZVV3eEJGWDhzd3gvbGNuRk5UeVlsMXlnTjhYWDdtR1RqZXhtUTR0dE56REx4MWx6Ry9WVEhqc0RjcHdkTzUyM0t0NmdOZGx5cnk0eWluSDNPVjZxSTZtVFREYlIxSG9Jdjdqc3BZcDB6Vk1iclU4T1RobUl1bzVPV2VTdTJjNjhmQndQOXpqVzlRTzVqbVZUTW5keitTNktoMmt4eHBWbDJMK1lLTnNjMWJoNUZ4NHdTQnZVUkk1TGhRMFF6V2kyWnN4ZVMzNmxnVVJkd0xXRTVCT1YraVpwVlJkVEVxREVPdWo1YzdLbUxUUEZuamlvNFhNaWwxUXk2ZFJ4VEF5VXRacmR5L3BDamJNTXpHOG9zeEhIYk9VVmNpT21FeHFJeTZtTkp1ZTJLR09wcU9DSEwxTDFjY3JDSWxYVUJSM0dZNC9mdUxXTEF4dnBoT1dpWWZ4WllkNWM1bi9BSnViL2dIK00xcHZxWFV4eW16VEJjOFpRRXgzY3hsL3FZRnhucUFUdDFQOERGei9BTXJESC9jOG1RK1ROZnpMSzQxRktxSEZpaXlvMG1vWXNZREFDZHppaFRLdDdqaUJHREVaNDhjRng1VGx4Y3d4c2ZpMmNXQnB2dWNkVEhIdEorYmxNTVp4bkdHT3FsVzFNTDR4V0dMdVl3dWNWbTRkM055ck81VkVGSmEvODRJZDduTFd1cGhYRll2SUNWeDdaeXBtVGZaUDRyTlNrWUR5V0VTM1U1T09GYm5FcnR0bkN5clljOGY2NWtISjk3WTR1UGJLbTVsVTFFQ0hFN0xtSmlqWlBxcFJGd21WQ0pNRnp6Qm1kM2xMMVh3OS9HT1dVVzQ1YTYzSGFMQmJRbTVwSUN4YW1PenVaM0F1UGRTOTFMUjBUeEx6dEo1TTNKYWdwcGpqdlRjNHFmQlBjVFVPSU1LNmdZbmR5dzBYTlFBMU9SalJWelRuY0MySVNyMWVpY3E2ZFF3NVd2VU1XWWxUTEE3dUdON0lZRlRSaEYySk1DMVJpNVNsbTVUakYwRTBSRk80akVsTjJNYnlqdG5qUHZ2WlA4bnlZWitRZkhoUlU4bWE1M3hvalp1bzVQVTVEMHNjMWd0d1ZXUEptT2k0ZWJLOXpNelN3aG56L3dDcGZLNEx4MnppaDNNY2JGdVdsbHg4V1o0dWE2dUJacGhpcHRnRlVNTVlhWmR4SmlXVmNEZ3U3aHRtSVFveVplNDVkUnpNc3lZK1RkRS9sdkp4eTFITTZJMjR4NVhxZmpLNXpWdVlkcWR3eXdxM3RJSjZZOTFkMVBKNWVXRkV6Uk1ZWkRsM1JNZDhzWndRMjNYd3JLZnhNY1B2M1VBNE85a0dpbVlmYVlKZEVkM1RENmpzVm1lV3FyWkh5V1VrTmY4QVpxWVhlMk9SczQ3aTdnL1FKNnVaWTNzWmdGYkpqaDMxQituR2p1TCt0RXp6OFdmK0tZbmovd0R0diswZVBFQVRQOHgvQkJ6OHVJRDFMY1dIa3BJK1l5Sm4yYjFVZXl0d0JKajR4UVNpZVh4WW1TR1JWdzhkRFRiVXZ5NXVPTjFSTVR5NG1aVXh6ZVZaVEh5R09lZVNhOVF4OGpqenl4eU1aZ1pJMHRNTVRGNDVNUU1GY1dZcGsxbS9XWnVPR2FZN0phdDFEeG1XY2VWMWlYUEg5TTA4aFZIVTgyZmljMTRWcVo1bVdHQmpoRnBLamg5N0VpQmhibHVDWTlCY3lYbmRRY3ZFbkgzRnROLzZqOXM5UWF4aUM4Vm1lTGo1VUpUeFgvbE1NMThYRjdZNUhqdytvNzB6REVSWHVPRFYzSEJNVFU0NzQyN21mak1jc1FGMU1hbWo5c29HWkNBM09XUEVERjV3SEZWN2p4NGo3amg3TW9aMGJibVdaa2sraVd0SkhiVVFBbXBqbFZsWGNHc2tZWk5wREgzSHU1bGhqNC9yZHdNUjcxQWNTeWZ0UGp4ZUhsdktlUnd4eTQ0eDVPZStvWW5GcjFCWDRBZTlmQmpjMnpKc2lVbFJmcDFNYzZ2VXlxaGg0OFV6eWNxUTFPLzdRY2lCbDNLNU1meEhDaTRNc2xlMkh4MHptQ3pDN1dLdmN4eHVidmN4UXk2dVd0ekZLcExaeDdJNDRBY2NyWWdhNVhMdWJHS0pQeEVtM0dpWmFaak1TNFljcUprR3k5WEhKY0hHOWZBQUxOcE5oTWJwK0syUm1HS3MzaTFVT1dieEFQM0I3eDl4RTNNRzJPbTRaSXJMcUVjYTJNRm1Oa1ZsWlZzakJuL2ljSFAvQUQ4UDlNeUs4bVkvbU05empCM1ZmQ1FsVER5Y0hMUTJUVXBHVzhZNm04MmlPREFTSTFjMlFVbU9UY2JWanlKYXZ3TFV0WVdRdmJMV0N3VWwvdVlPbmNSZ085eW1ZalpLeXRuSEtBck1TMm80b2FnZTJhbkFOd0JabzlUREZXYk0wS2xaTnJVY0s3Z2wvVXNtYUc3cWN5Tk9kd0NhSW9KdVplUXpXRGxOcmNiZzVPVzVUTVhNZXBsdE5rU2xtTFRTV1N6ZTZqeDE5cDRQOEo4L2k4M2x4VEU4WmFMS09nMmQzRm8zUEh4RW1XM0tJQ01FM080dEVMZW9EZTV4bVJYeFRXMkdJU2lvNGlRS21XSlhVSGkzVXUzcjR1NFdZM056STJNUWNuZFFmM01RV3JqaWNuY3JIMHdGYWpRd3pIb21UTFl4eXBoV1R1ZlVkYkpnaXBGcm9KYWpNVk1laWNtY2d4cDduL2NjZVRIQ3RERFpLSytNYy9zYXFpR2RpUnkxcUYrMk9jVlVydVZrdjJpWFN6ZTREeFppUkpzcVlYemxvS3dySmJhalRybExLN2drY1RCUmxQUXd3c3ZGaUY5d3djdW9lSkc1L2hmNG4rSDVmOERQUHpmNVNlY2ZyaFhjL3dBbnduanlRL01zTWRFRW5JWmhseHVvN3RuTmNPTnpGS2x4b1ppeXk1ZzRxeG9uSWdsTnpESWc3MUxWbVN0a3F1MktzTk9vb085czZ5dUdXVnpIT2hXT1k0OUVFY1ovSnh5S25qRFBKSStLaTQ2RW1ZSVRPbkVMaHBxR2VZME1NblB4WmROTlF6VEQ4Rnh5dW9xd1FaaG5pQ1ZjK3Jqc21CNHc3aFdPV21jcXhhcVo1SG9SZy84QUpJdU9XZGcxTWQ3dnFZZUhsZytRUzRpZCs0Undhc2d2R3BnMW5hUXpRZFRMZHBIRStwK1psaFdkRWNER0NCVU4zUk1NVXdjanNuRExNNm5FNVZPeWs2WVo0dUZKdjFCNDVCa1hyMUdzc3dQcFBKVmh5dWlabUdmak9oSUZyVFA0bng0WDJ6N0NxeFVIcGhsbDZMbmo4MlFmYkpyOExNemwxbFV6eHd3enhjc3ZVL2t4cEJVbms4aHhpOHlGOUVET29jL0ZrVG5qNUcxMmRzeng1Wk9kMkVlWDlqcUI3WlIvM1BMNE1zTVRuV3pVNnoyM1pERjJYTVBKaGdaOGhYMU9MbDQrWVIvdE5KTlduNjB6SFBMeHFvTng1Q3NERXdWYXltcU9UT1Z1cGp5dzJVeitWNXNvUnRSWUxtbUE3L004dUpnR0hiR3pMcW9ZNVAyN0pqbGZxRGlYbWpNY2pMTGNmS1lOR0lrNC9UbmZjOFBpNS9Wbmt4eC9rZUoxS0VtcFUzbk9pakxjNU9XUEJEVzdoajlZYW5GcVh0bFhMY2Y5UTRwTURFRzJaNTVaSDZEVXh0RnJxWnZPb3RUeHJqYzNCSnVweUljb3RSVjZtVFJVQ2p1WStQUGhsc1pqZzFEdHVVcHZVVElMaTY2Z1RML2NKUnl1Y2hJSlVTYnlZNHQxSzQ5Unl0bU15N3VZN25kbHpGTUxLdURZa3E4akxFSmlXb3h4Rm1TcUZkZkhxY3BpbzZnaWZ1TmpCUmxidG1oSHZjOHJ6ek1qRXhDT3lZRzY1YWhSZGxucjRxQUxoeWFJZ09WTm5xZW9Mak85akMrWlRHc2J4OXczZHNOS0VOL0ZXeHM2SlNtMm9EME0zMURGWms1RE52cVdoVS84Vm1IbkZhckZ1WjVLdis1alRNcFpaTkdTa3JsOFZLWlhHSUdPb1pNSDZ6R2syekNoaU45L0YyZDZna2M0VzlmQ0pNYzcxQUxoUXhUMU9VTTROL0NuVWVQNG1nNlp5QWcva1lFQk1WdUI1SDFIbVNrTGxXVEVUR0JsZTNVZHd0RzJHYWFqMTJ6RTFibWs2YkpYS2oxTThjbG9JZVBQRWJKalRnOG1wUmZjUXFPdW1aWnFGTXhvVnpJVStxamJEa05Pb0RmZndZVmphc3hNY2p0bjhSVGM0VUVNTlVUTEFKNGc4ZVhQTEF6bVNlVjhnWThEUDhUaXYxUzZOVkszdkhxT0srTzhDSTFLVzFKWEd0VGpBWnVGM0ZiWmFoY2JZNDYxREhKRzRXWlFOcXZ3WVdhdGlGekpJRkRBQ0pqVlNqZnhrRXcvMFRLdFVTZzJ6UTlSbVFnUUkzK0pTUHdsczFUcURlRTY2K0FySmdHSkhqQklWZlZ6SExkRWZyTmhPRkJCSVFyRlJaZHNFSWd6WjFPVGU1eTdLdWJxTDlmZ2R6YlBHWDVOTWJGRmxXL3NuREoyWTNQNHNqVlF3UHlUSU83R0FMcktMV2lZekhmVE1lUXJIeVpEWXVtNTUvTG41ODN5VEo0bWlZWkhzZ3RyV284WDFVS3BoamFWT0cycC9IcTcrTG5FN1dZcGprcE1zaFB4REd4cEpoWC9BQ21Kanl2b25MRldtTkdPa1dObTBqczNxWllxVVQ5M1ZmR0Jua05ZelpNY2hFWVYrWjQweEVxTGluVnNNcTJUK1RMcjFNczFtV1R6UHhPTjV1NW1JVHcrWThPWW9aNnJjd3pUUG9JdVA4Vm84cm1MdVo1Y0ExM0V1VmppRGN2Nis2bjZwbjhoekFGS2djakpORVZDcDQ4TWtiU29MaXVQR0hISE5FMHpQV1lZcWZxVmQyUlUxQXlTK2lZSUtMRVlJR201dzQrSnlUdWNmUnVVNGwwTEQ3akEvVzRJWWRsekRIaThxMTdtQWcxc1prbVJqalZKUEQ0L0czenpDbzQvakdEaWhrRkpNZ3lMcjdRckx2Vk1wY2xIVXJPbENYbGdZNVpOa3p6eHlQM0RSUEQ1TUREUFZzRTVWbFBHNEtqL0FOUnh3eUd4c2libzBUTEFNZDdqamswWXpHK2szUEM1ZmJXaWM4czloWVR3NGMvNUhqVDZtU2h4eG1LdURoUDRuSUtMU2Y4QXg4M0lzNGZ0bUJ5VGxzeHN1Y1N0Q2ZwbCtKeEgvbitDWkpqbjAwUmRVTHVISEFEdW1MZ0FIY3p5dGE2SnlNemxNbHhuRm9OMnhyWXJESGp0eFpqZmh0eUdtWkkra25rMEJqTWNuSFdNMWVQWXgreThyV1lIMGFhaGZHcGplWDBFU05GNDFUS1NCcmo2SmhvdkR1T1RiVXhUanRqNHpIRzczRzdqYlZFd0R4MnROeFJXWFJxTGN4ZFZLT1RIV29ZTDNGNGdCR2tvN25ISGp1NEc5S0VUZTlTc1NKcUt5dmpVeFVtZVl2VXBqdVZ5bU5sbDZobDlxTlRNQktibmt6ejh2aXg4WmhSaDdtR1lQMnRsck1oQ2JjSVloRHZjc3FnbTNHSVdSb1pnNDhvNHUwbU9PV1haRXBoZ0lXekk0NUlSS2hQVTNpUXMzTnJEVEhBL2l1RmtwZHpIVVJVaXhsd25aVXhhTXRURzNJMUEzdTdpOG9HcHBKY0lmWnFvWVpZbVgxbVdYWEh1WkdWWGtReUFiZ1hjUURGR1dzTVRpc0VsV013cnVNRitMS21HOEhWcy93QUhGd3g4cU4vV1psWlFXWkRBK0Y0NDJmQ1RCb3RuTEhLQ014bUcycWlRbVVONmhyVVNwcG4rbVZVeWFtS1hMTGw5d2ZyTEpkd21ORVljWXB1RU53ZHdYSW1PZVMxRzRYRTZxUDhBU0U0dkZZZjBnWDZuR3JXWUJrUndiQlowVTlEUEhoeWI1VFB4OHNOWjlNenhBRTJTeDlUTTl4QzRZV3dNV3hnWThkeWhmckNyMzZtQ2N1bzA1YWpqVFN4TWNXR04zYktQYm9tR0F2ZnVPTXR1cDFPS0F6Z09YYzgzMDhaeFlSd0E3K1IrS2pBcHRZbGtzK0hHVWNmM0VZZU45UGN5T0tuYkVnNDlNd01lVytpSzNvbHNWVzQyd2x3Ymp0NmxPUFpGeXloY1RKRmxzTTYxVU10N0ptbm9tS2hRUnhuSEVPNXBJZG01MHU1dW9ZdktObVlCN2l0dXVvMy9BTXZnb2wzSGJjcTJJR3Jsd0ZncDJ3TWtoZlh1YlpzMVVCN1lHUDVZY1A4QWpjTThmUnVPZWQ2cWM4NlRsTHk5NWZHTnhtR1BKM0RWaitmZ3FBWExicWNlUVZFUm51TlM3eHFWN0lXRTFMcU9mcmpMcGhUL0FNb2dlN213WVVZd2NtWUpETXJaTWN6L0FKZFJVd3FjL3BOWXh6czBkVEhsaXJ5N2hrOFlzTVJoZ1Vnemk0czVhbUdlcnFQa08wam1KMU5GeFhzaG02dU9SbGxxWTBnWk1FeWVQUVROdDAzeG5PNWppSlN6RnA0cm9qbGZVeHp4Nm1HWUdSTDVaSUZ5Nk9vMGJabG1Pd21IazR0cGM1dVlzcEd6Y3Q0ekU0NTNsTXJjcUlHbU9HVmYyVUp5eW0rYk1jc2dZWjNrS1R3R0w1OTlUekx5ZUhIaittWTIrTGxjQnkzR3NNTG1HNzNDekd2M09PWXFNTVhMVUNyWmhnQnROekpNdkZ4bkF1MlpHSHQxSHh1R1lZOU15SEhOOXpoV0I2Wm1aQUVNY2pPazB6SVJvTEpqbnh0VHVZaG04WFh1NEdXR0tUREhqaGVNOGVXV1hJd3ZVend5UHU0WkJsTUtObDdtT09YMnl4aVo4RFBPNmhuaU5Zck1zZjVCcENvNCtzVGNBY3U1NXZLS1ltTlRyU1grNWluaWVUamNYSDdaa004dVYxUlVGeXVtY214NWYxMUtxLzNGNVkxTG9PVXg4dUl1TldUUEFLZGc5WEFBM0xUQ2hQMU1QSmxqaFdsWUF0Y280MWRSOGw0QmdWbEw5TTFpWDNDOFMyR2N3YWlxVlBGeXl5LzFQSU9HWEpwV0NVckNMamw0K0liaGdtNEc1YUdvRG12NW1Yai9BSTNGelJ5bjgrRDRjOE1zZnN6QTVNd041TVpzajVNZUZjTFNXTmFwaVU2anQ2bkJYdWNXNVZiaU00bzNIS2F5U1paQ2gxR3lBVXNibUhtend3Y1N0ei91WVljK1ZOVEoxeGdGYllVTzUrNWhseFprczVmWDl4WHRodHVlTHlCWWtmSlZrQ3hZNUdRQVZVYXRmakUyM0VlRmhGNldDdlJNeHh5ZzBzV3lwdXBpc3c3VjBUazBzL0RGRlVJRnNFOWJsdUdVdXhtR2VYaXpNaUdTTDVNdC9xYXUwZ080RFQrbUZOVHlISExpVGx4cXU0WjUwaGxkd3djZEpUUEk1T05YY3lMU1kwS1BhUUhpMlF5QXFweFpqamlkdy9SRTFSQ09wcDNjTzRadUswVU0vd0RIQS80MytWbGZXSk15R0Fsa1JsVDZoYVhOVlJDQll6a2NhZ1FFbS9VMk4zVXVaRDhYRUN0eDdTY0djQ3BwWjJMTUtpSEtBRDEzSHhBRlpXUndDY1ZoaE1jUm1UeEVxZXBWemhEQ2ljYTFNZUkyVEUyb1hNdmkyWTVQSCtzWDlUSHFYcWlWcTVuY3gxcTZsODBZNDVKb0t1WWxYY3N3TlhUQXhmRmtyT0s3cUo5S3FBM0hES3JHSGp6V2ljTWlKUWpIQjQxZFRBVC9BSkVRVGxjeEduVW82U0xhRVVtS2pLenl0RHFBMFRJcnlWTHlaaml1ZFRLelYzS21RY2JaUUIrNXg0OXd4dktHSXJBUnFjVjFmVUFjV3lZT05NREh1bzFNSStQaURZck1tQTJiNm1aYXAzTzRGSTFQR0ZaUmRNU2lkTlhHaHE1aUdRN2xzNU1LdVpPeUdYMVpqa2h1WStYbGhrRXdmeXh5dDBReW82bU4wdndQSnE1anhXbU5YTVd0MUhNam02am5NZkltWXBkUzF5WDh3YmRzdXFLbGplb05lcGpMUmZjNUZ5eVlwYTl6NnIwd2FmWkx2Wk1XNXpkeTJ0ektrN3FXQk1zV2JwZ1UvQmdQdUFFZU5NUzhDc3FTR3hadG1JelpGSEhxWWl2ZXBqaDRzL0YvK2srMDBLVE5tVFdKTUxMU0NVeXFMWml4eXFDRzJLU3lJdU1wcTZzblorSmhabkhGVzRZVFBETEhSbGN5TXA5YWc4VElaeXhhWmJhRE1mWXpBWW5FaVBhekJSZlpITEhFNDkzN2dpMFJMRU5Td0dQa1RTMlM2WmNkQlpLcENVNHQxRGw3bkpHNGZZdWN3NmloQlFaNEhrc3l4WEtaWUYxTWNlTjIwUXlGcVpGRkRNVThlMlk1YjJhZmNNaHkrenIxTUw1S2RFTVE4ZkxuZCtvcXg4ZEZzOGJrS1EvcHJiTHl4NGs1MHRreHlhMURIV213OVRuOS93QkJEZUZzeWNjVUJ0eTcvVXp6eE1hNVFhQU56eEdUbUlUUERnNUNidnVacFFRM3lyVlE4Wm4xcWZ4YVJlbzVjdjhBbFZUQXhIbCs1NS9Mamw1bE1LS2g1Uk9wNXZJSUFWRE13MTNjM2Fka3djVHhaY3NWMVJBc0xhSjR6SXk2K3NGOFhKUGN3ODdsZytORnZxL1V3eDEyYW1OT0xra3o1bmk0dlV5OFdTOHNPanVHUmV2VE1USVZKL0UwNWV5TGxmMmxtSzJxVEoxUmJjVkxBaUtGdzhZNTRpNm1maXh4elNWanBHZU1WbmtzeXAzR3NzL3hVWG1LencvNHVmbThlZVZpWXh4NC9zSmd3cHoyUjZtUndNVU81L0d1U1hNY1k1WloySHFGNjNUT1VPNHF1cHh2YTllcFZsckhVeHRibVZudlRMczFIQTF5YXVIa3cvak1RMlRQRVc5enZPQzRGa0U3WlEvZnJmVWRCQ3QwTXd3TjN0Z1pERloyUWJLQ05reVhqYkYvY0tZa1RsLzFMU1dPTkJFb0M1YU5rTXQzVWZjcHI5VExpaFJIVFV3KzBjZmlwK21CQjNmNGplV1Z4eVNpWUp6alZzNlNwYVpURmVFQ2xPNm1QU2tWdTM1Tnh5clJCVTRvUzhscElXamN3S1g5a1RqcjlTcTJSekVDRXpmc1YxT1ZreXNRaXJxQ0dqWmU1azQwOEkrMWdlNWllOFk4eCt6Y1MzVHVIaU9WTDZ1WTBOcGJCWEIxRTNjNVR2T1laVlJMMnpGMWNkd2NlcWxFdTJwL2dHR0grTC9rcTlrYWNsSUpqb2huY1dMeUpqcFl0N2c2bDRrdTRMN25URk1tcDlTWkM0TDYrREFjVzVVeG14ampGeGpyUkxsZ3dieVNZWk9Oa0c0TEtXSWpwbmZ4cURERzJyaVBPZUtzYzF5TlRMUGJ4S0psYktQYUV5cWlzaVk3OXpLcXU0SDFnSkQ3RlRHc3RUaFdjZWQ4VEhVdlBBb3dKV1J0eGdPUjFVd2NURGk0elB3Q2FqNHQxekllSTVSd3hDbGdVM2NkT21MYkRIRjdZSGoyRE13eEpSdUdPSlN4ZnQxTzJNUExsaDFLVEdXak9XMmVMSUM1a0JtekZ4Smx4U3BlSUVXKzV6SzR4Wno5M1V0ZDgrNHJWRUJBbG8xTjVSK3NNKzI1aThweUNQNllLZjhBS1hkMnpJTWZFYmJZNVMzTC9RUlZ5bkJ5Yk55N0s0MUFMbjFHV1hGRW5LQ1VqS3g2eHZjR21ZZU95MW9ZNTRnaHVEbFc1M0VwSlY1VHBZWjFqT000NmhpSkJxRERHeGxNd0hjQnBoMFJkekw2Ymc2dFlhTHNncHUyY3I3WVA3bW5xVUcyS1pUTkpxdXA1VnZaQUs1YkxoRVNGUW9OTTNWeFZJdnFYVThmbG8yUjhsdlV2VUtDWVlsL2dqaUNvL0RzSVdRZVdwbFdEeDdsWERFY0prVWxUYkEvTXQ2T29XWXh4VWdtSnZHWW9DdXBxcnZjeWE2YmphU3dVdUtBbmNBWUFMRzExQXl4WmxrcnRnOHltZEZlb1pZa0V2Uk5xeTdmVXJJV3pVeWRWVVU0NmczZ0RQSGh5elJ6MFF2TFRsb2lxUDZnRGhpKzJMeG5abzJRejE5aU5ZbW15WTVHTzhZWjVPcHp3eE4yNVQrVU1HOFJ1UGszMUJNOGR6SU1zZ0hSREtyRTFORXhXMHVhTHhaeE0weHdsV051eVdtYXpCY05uVEJwYXBaaHc1M25NNnhYaDB5a3hzejduSTRxdHN3OG9GUnphVXVJaGF1NTRjc2FydWMzeFlpWDNQTDVYUEt4amsrOG9lU2wxY00wL3JCL2t3ZExEODhKOTNKL0JNNzQzTStTR3FKNHNNbjl4OFRqdktOanJHNXlUVkJGdGVUUEVxN3kxSEl2dkdjbm5NQlhKaU5PTThGK1h3UExzbVFmMXlIRzQ0WllhekE5a0hQSlZhcUY1WURiKzVtWXBEQVpuNG52SEtmeHBrS2FJdTM2dzVMcVpMZkZMWTQwVEhEMnRUREl3OGhscklQVE04dVhsVUFIOFNnMEN3enl3V2xCN0NPWGo5VGhxNDROUkVLOVRrT0gyWFVTaThYVXRTcm1Yai8rbThaMWtDYm5HRnVkVGp4VkdIM1luRFVLejcxUktvZmg4TGpnWk5DekpWcjhTdnhGYkprUS9jQzNVRGxsVTZ1SElPb2JGZFMycHh4VGNUVnlxZFJ4WHRsOHNVWldKZzNCbnVZc1dHcGszODhyanNqanhxSVBxNFpjVFRVTjk3SVZUOFlnT3laS0NYM0UxQUsrRHVMWXh5T0xadXltZEVxeVdlTytMY2RsaFV1RGZjOXpZNmdEaXhNWEVnNU9jK3dvc0RKSDhFeXlGRlpsc21PaUMyemVpSVVsb3d0M2ZVTnF3emNNSGkxY0pmNWc0QytweXd3S3dadkhHRHZpbHl1T1ZyRHlWNVA2MlRQTmNVd0tKbGVPTXZVeEwyUUcrNGZVL2NSOU1MSS83Z013OFdXZkpzQW4rTWNQL0crWE5MdHFZWkdMYUhIOFR5QU5rc3VPMDFSQUFmck9mRFR0WlgxdVlaWW5pUkx6OU1DQnBpczJidUJ5amprZFRkVXVvemsxTVZZS015eWNpRnNjWWtyN0c1bFF0dC9CZE81aWI3Z2I3aGoyOG8zZjlvVVJTVU1NY1Q4ckRISmI2bVNIN1pqK3lEOStwazdxb0VNNFpaZkN1QVZ0WmVRTThWdWJFRDNQc2RPNGM3M3NxVTF2cU9HVm4yRWlZN1IrMEhOYkhSSFBJenIxT1R6YWhrZmtHR040M1pjNVlwVmJqcnRuREJCOXpIaU5NckZ6bWVSMU1mSmlZMVA1Qmw1WEZUZFR4cXhXWVpIVlhGZzdWSmh3Y01yVVpqblp0V0tMTWxOazVXU3prN2htVXd5TjZuTVNxZzNqVVg5d1Y3eWlzRlpiK1oxL3ArR1lLTWVNd2J5TlRMUDdJekkzQjQzSE9YTWIzTWRhclpDSTErNGxHdHpqVkthbGV5TkZNV3owUXRMWUdOT29JR2o0VHBZaGh1S1RWYVk1TjFwaWV0RXgraHNFbjFaZ2VzV2NjbFNBNFZGVmVNKzliWVB3NWZpZFJWeEliRzQ3WTRwS2QxTnB1ZlhxcFY1VE54NGt6YnlYdU90cEJERmFsOHNiOXloSmpqZUx1T05HbVdVQVEwM2NUYWhDeWJxSDdoa0RITDhRTWFaeEY3bnJRRTlqcXFoVzdJVkFJY1NJSzFNY1puT0w0OFAweFlGcE1nR2dtbG5FNWFpYWpydGlZOVk5VEd3UUlXOXk4UlIzTVJSUnF1cGp5YldaSld5Y2lwdmozTWNTb1Ayc21lVlpkYWxDMFRJeTZXeUFyS3djVy83eHVpb0p4Vy90QlRBRW1rbUgxUnF3N0psbHp5VXgxK0laSXBHSlJkekhESnB1NCtPdDVNVkJBdmNjOHVPTFVUTHRnay9zR2tnWlk3TlYxSFRjY0hqei9kQk1seVczcWVMTFB4dkxCamxrNUxNREhueXp5c2c0UEpNWGlUQnh2WXR5c1RBYzhjaUFvWkJyOHN6d3p4cDVDU2ppQ3pIai9KUk16RnZBalJpQVRCeUVvcU9TL3dCc281WTRaa3k4dU85UnpPQWt3ODVpZGRrL2wralVNMnVONkkrV2pHdHIzQnZ4Ynh0bWUvSHhaam5yZ1hIZUU1NHFDVFBqVjRtNFA2dTVtWVk0NzB6eUlvQkU0c0grSERQWE93cXBtWllncnROUjFSanJXNTVmSmxuZ0FWaVJ4M2VXNzZuQmNWRUdZdVlVcFRFUm9ZdVdQalRMSzBoNUVhNWFTS2NhRmhtWWplN0sxUERXYVlEVThtZi9BTmlDYWprWitLeWN3ZjFPczdPcGhpNVl1VDFNRTUvcUdEV1NFd3V5eUJ6Rnlhcm9tUVBpb0phaCtDZG9lbU9RQmpYVE1xZkpvMU9hVUVUa3prSGo2ckw4eDVYM0JFcjNNSHg0bjJ3dG1WQ3RhWmZJWnFvcHhqNUhKM3VwL3dEaW1QNGpsdTY2anNoWVhWa3IyUVVsM0RPOFVZWWpqTjdJZjZuSjViK0d3WXVncmMvVDhlNWlHNFkvUlJncGR2d2pOL0ZzWGxodjRNZWVEUTZuaUhOVWFDTFV1bUtNTWIzQVZZZFRaRmpUakhCNGs3SmRGUkV1b2RFeXhyR3lZL0dDSkQrMzJqeHRxRm00WmNsdVlyVFhUSENzd2l3RzVhS1NxNHE3bVlLY21pUHN4NmcyVWVvWTNoSFUzY01lV1JST0tadklvbXpDditJeitYSG1vYWdLS3dKMVBMeEJCdVpZdmpycEVobFJSREx1NFpLemZjV1k4Wlg1Nm10aE04VHgvd0RpUEYzOXMyQ0ZXNm5rcDZtNkltVmw5UnplcGpoaGg0M0xPTFloQkp5cURkL0ZNeHlDS3JSRXByM0g0RDRQck85a1daRnNCVUkzelJKdzNNc0tqaVlrQWpoZXAvRVJ4Q0J1R0YyM0ZEcG1lVjdjbURqaVFROXdmdDlXT2U1UkFKaG54MHpWS081bDVuT3NYRUs5azRaOEZJZVJ4ZXBnR2ZMSjdKeTFvam5tTE9ibmdZL2d1UGs1QVlpUjQ4TE81anlDbG4zeWJuS21xbkRIbmFRdDYwUjZ1YmZVWElhK09NNDVSQTFNQ3BuZDl6ZnRtR2syeExKaVpHTnhGOWtmRWt6OFFJY3ZVTVNxdjNNY2RMQUlUaVQ2azFSTkh3N09vQ3pqa1JHVlJHY0V4R09MZFd6aFh1Sk1NY2k4anFaYnBZa3k2aFVVL0VVT2lLVEh1UHZqTU9TUDVxTHk4UmpIRnVMcG1qV1JPblJxT1c0UHdqTW1kbFZLMUJDWk9yMUZFMnhxRitwamxuaFA1UzdaL0E1WWZ5WTVFY1gzSEhpL0N5NXlxbVAyRklOdHhWZ0lFcWh1SUc0WjB6TnZHeUhUZnhkL1dWVWNhWUk0c0FtT1dBT28xREpRQ1UyemxGMUFXSFVGSmdPUTlUUHg1WUlkM0VPS09wd3lvZmpDR0lqRk1Zak1WRFFNeVgvbDB5aVlqZmNjZExBV0EzQld5ZmtZQmhIUFVHZ2p0ZFF5NGxRTWxsSTB5OS9GbVhVNU9QWFVYZFFQMUV4eTNiY3lieW9ZOGpyY3l4ek1CWjJhSnV5VUpQRzB0eFRGc2RNMHM0M2JLSEZQeE1NdGQxdVpaWktlNWR2ZFFmN1RKdlVQSDlHT1RuampqMUZhcTdDZG96TEhCdDVKK3BpY3ZIa3UzR2VMRHl1UFBRUnh5V0FnazhCay93Q1A1VkRVd3dNeXdwampod0hMTmN2eE1tekVUWDRHWTVtempPRHQ3Smc0bXdoZ09CNWJONTlRdys4cEMxU0ppMTlwd0hHNWxqWVltS3N6d3JQSENJQ2ZWcWFLZlVlR0s4WUpxVno4dkhCNkxuODkrSGdoeXVBR1JxY3RzMWxtek5NZFF6Y2ZVeWNzbmxrQ1RBeFJISnVCcnUyWVpIRnVjVHlKZWExTVRMRWNwNUg2RXpGemQvV1poem91b0prNjlSV2JXbVpWSDk2bmp3TThWRnVWeHlnbWExT1Avd0JWbnBoZ1pqY3BFbjhuMW5JMmhNYzhvQ0xQOFRBODJlUm1oUXN0dHJxRFJVQlVsSTVRRVQ5eWhXTDlZOGN3SVkwMnp6K0l3cklpTjErWTQ1QlN3bDNpZjdpVERCY01teXA0dUd6S1pVZlVoQTNDMTQzcWNjZWZmVVVkeHg0ZzMzUFRDd2d3eWFnL2VaQmRreUV5STVxdW9uVDdTWUgwV0JiQTdKMFJCYWgya2MvazdqcGhQSDVNOE9RUFpBWHJvbjF5eEFtZU80RmwzRmFuaXovaThuUGhjenljOGw2R0MrcDZnV1MvbExLaGVmUjFNZzRuR1Y3K1dHUjBrNGo0M0xsdGdjdTJxbHBvZzczRmVUQVQ0MVRCalQ0dDl6REl4VytucU9SSzVZOTlRWDNNTXJ6dzNXNXlySndjdVJjNUNQajlYY0NrcnE1NVVmTDljZU5CSHlpRjQxcW8xZnVjTWNQRTNMK0hITER0dTVqOElzYXh4MUxXTzhibitWbFgrRjRQRS83bVNxRHNoYmlZRWNYay9rbVY4dHN3dzRwbGwwVExKelcrcHFVUWIwd04wUXZsUDFjTVF5eGJuNVl1ck95Tnd4bWRWTnM1S0pCUW5KbTJFdWlvVzViWTZZN2hiS3puMjQ4YUpsamxqL3lJNDVPNDhvRWNaeG1JT081eC9FNTE0M0grTS8zTWVOYmpUcVVCL1dCdStNVWhtTU1qa3M4YjJ3eVdaNTVJMGJtSlp2VFByeWpsaUZrRUNaSnZVdkZBbWozT2ZFYVk1OHNKam1FRXQxRkxMbVRqbG9KeUFQckxISHFEa2RNN2JuMkdiZzM3bDNCVW1LNHRmbWVUSFdtR0VDWm5GcTV4VWdXUkNPR3I1Vk1RdnU1L3FBclZ3RXpXZHNjR1cxTGZnWHVGNU5yRTB6T3NmRmlYUGI4YklxSkhHeWNWbjhhbFRERERIK3pITTNpUlAyVEdpSWIyeiswcGZVQkhyVVJGWlNFeXRxT01CWng5TUNsZ1RqV0xPRlZjNEJNY2JaVzJjR3RCY1BDZUx3OHM2NVRrbjlpeG1YaFhZeitMSUlZUm9tVXhCL05UUTFPUmRSMDEyVFB4MWhFamh2Yk1zVEU0d3JwSU9QeG5NdEVBNnVYVFFUcjFORzBoeDU0NHJGQmk3MFRMclpBdUpxQnBsVVFVZE80Nzc3bkppbW94VTl6ckg0NnVvK1M4YVpnWHVKbE9LN0pTMlhVRlAzT2FaV0UzU3AzQTVPNS9GOUZuQUFtMlcreUNhV09KazZ5bkJOVHg0am45bWdqanZMamw5WjZybHVjWEhjNW84aFNJZDN0aU1iWUxjdENvb1RQZ1lEZzdZMEJBSEl2cTR1SXRFOURNZkZlUElkMzFNTWVsdzNMQWg0MUNpN21RNDlreGNuS29qNDhNaHkyd2VYVXhlR09WeEFlVXh2TjBFSExGUkNGdEF6SE5Cd2RWTWhtS3pJVGpscVk1WjJVQ3p5ZnhxY0xNcTNQR1ZtSE1Cbmt3TU0zRHg1ai9BS21PUGw0M1YxTHZacXBYTHdqZ296UHlQbXd4d3lYNndEZHM1TGlBenhaK1FFeHlwcUlZbThyeW44dVpnNExlRWM3b0hxWVBHMXh1NFpaQ2xURnZTMVBIeE15NnM2L2NSTzYvMU1QNDdUS1pjUk9BeEIzTXNtbGVvWmM2Q1o0WjRaL1lSbU9TNWNlMlhsNHpMRnhzZ2NnTG9xOVRGeTRvS3d4Y0E1enliYnFaWmY4QTE4SmpRZDl4WHFWVlpYdG1PT1NyRUVUTENwam0rT3pIM01jbitRNVRQRGo1WGkzTVcxL015d0FPVERGT1NkUk45d3dGTlJ4eHg3Wm5wczJNS1pXNlNkVEM3V0NtUVB1ZVZwNGtGSTlWR3laWklWQTVZR2F4eXJQOUU1R2ZramlLNnFQZ3gwOHBrWXJPUUNCQ3lLczQ1OGJscDl1TXh5THVhV1BkRVNDZzNOMHpIUGU1NU83T21QMlRqT281REJyS1BmY3d5Y0ZVR0JZNVQxRjFVV2hucUZ6R3k2bnFGc3lFNzFDWVlxekdqTGk5ZTVpaGxST3MrWGJNc2IyNmxFM04xdjRRR0MxVDhYcW80OE1PUkJDWWM4UlFtdjR1bVVCK3ZnRmxNU21ZL1R5WDZtVHpWU3Bsb245dFFLczl4Y3YxcWFTWUZ0TWUzOVRoai9IZDdZK2oxRUNKb2dVUndPSWhLeFN6VEhqbC9YOFRBRnJxZVVxelRxSU9Cd2V1N2xvNDhSaVdwazdpbzFIalU3Q2RUR09WVDFLOUNTdlUvd0E4dDhXSjBlTW16TDlYQlNramdyL3VZWU9XV3hhbWVkNWNQVU9rbEpBaTBUQzFVZzB6azA2aGxlUFV2WVQ4eWhMbU5BeTlKTVhJK0xpUUcyYmlEbEU0d1lYQ0xMdEdVSk9mMGwyQkxycVd4eFF1S1B4eHNJaWRFSFdqYk9URE51cHltTFN0Uyt5cGFZM1RCK3ZUYzZCbUN0c0g2NWZYYzRPZUE2STNaOE9pcTNLbkN5ZEVFdnFJcjlZajNPUnpEamNyRVg2UVFPbzYzRkFtME5KOGNGd2NnaGxXTkEvQXVPazB5OTFlcGdGemxlR1l4eGgxb1lQMlNGb3pIcFVsbDlWRDZzNnpWaFpBRWNvaW1tWTROMHMvaXJFMlI3cUpPRkhjOFl1WVdVZHpOSEtJTHFmVktaOUNxaTR1UUl5dnZCd3dVZTQrWDBURjVLVVNzaklkVGFNeHc5cVRLK3NZRGVtR3ZjVEtybjFmRVRKQ3lGTFVVcnFCVDNIN1RrZE1YRTZsMlRMTVFKWlU4ZVJqM01hbitQaGpubTU1WHhKNS9JWjVhTkhVYzAxeGcrMW5JN1dVTFl4Q0dPUmkxMVBIaVZsZVdpWlB4c2YzTXNycmJCQnVadjRuSzNaUDdHaUIyZTVoeDVialN0UVB6QUJaeCszY3A5c3h5Y1YwTmtEZFZ0bExqQlpsbFphUVNHeTRDVElhamp4M0RHOSs0aVF4dlV6MEFka3d3L2w4bFpOQkVyUElOa2NvUTkzRFdHbUdVTTFZNUZibUdYaS9jK21YU3pQeFpVSTJRdm5MUzhhaGtMRm9Lbk5KejVsVkhyV3BoZlkzSE1kWkgvWkh4Vi9XcVpqNHkxZEpFNWY4cUp3dkxoZTVsUmc0dUlJOWs0aWR4REd5YXFmM2FnVXQ3aHl5M3hxSTN1WTFSZjVoZ0Ywa3hid0Q4TXp5RExrV1RETEpySWNmOU0vaXg1dk43L0V5QUF4VUo1T2ZpcTBiZ0xsdlVRRnh1eG01eVVjYWhRL2FHTHdjOFVnOHY5a01FemVmMWljdjZEa2hiQnlaa2NUOHM1WGdmZ21HWjZvMU9XZUx2M0hNc09wbVZUZHJNSHlZT1FaWGNQRTdiS3FZK2RNSEV3QWo0ODhUa3ZjdzhiNU1vK1BBSEl5Tk0rK1ZjZEg1Wmh5MlJ3L2hNYzF4ZVUrZzVWN25BTU9XT1RaMlRmTDdUaUxaTHhzeHJmNW1UamtBV0lWY3BIKzF4enJvajNNL0RTNVg5WjRjRnZvL0Z3eis3ekZ5ajVDMXFlTExXMXRnN3ZsT2E0WW5qQVR1VjlyejdubHhmNEhKbUJhd3c1bm9wbmxjTWc0ZG5jeE1jODI5Vkw0NXZGWm5mazl4Y1E2MlF6UTFNV3hwKzBETEd0YmwvWUhjRGxtZ3NvNWJqNVZRbUQ0M0ZWYm4xWFhiTWhHbUdDN3VYVmlRV2V5WmY4bUNwQVR1RnJGdkc2bUd2OVJGblg5UnNuTE53YmRzNWFOeHFlaWJ5eFc1Z0Yyck03SzQ3R0dTM05Qc2xRYWxpU3JtQWJYWUVTWkZHSVFXM1RDZ2pSQiswYWRKTkRaTGVvbXllNVhOQ1pZT3c5UVo2WTJRcE5hWjVQSytYRUhFMUI3dWV4WUlYK0o0a3VZaXM1TjB3b1k1V3pySzVwWmxBdVhQNnNZWXM1WmRYTWMweFNXOU1KbDlPcGQwc3dUZHhaY3liSmxnWTQ0aEhBeFVuSHVWVUFoVzRnVEFXYnZZUmVlRGRGUVhFbHJ0ZE1Ea0ppUkhqKzU0Nnp4YjFVeDBYRkt1WjU1Y1NaV3QzRXJHS0pOZ1JZWmR4RklPcXFKcTU0aHo4MkIrVUovblpQOEFQWC80ZFRQTVVuSWd1YUdNOHFlUERqaDI5eTk3bktjaU9SV29NRkkyd083Z0ZNeHJsRkxqcjVBWVZMQWkxdUNSb3lqL0FIaFY3alhaSEVTQUh3VmxLTVlBelVBcU9vWVVDelB1TUhSRjlTcTl6ajdsTVJnWkpSTmh1QlpVcFBiTmlMc21OSW9WRXlKMlRpRTRFengxWk1mM09XNmxFOXM1VkxPbG1MaGlxVE5MdUtmaGk0cDB3NnFvT1RwZFRKMURQTGk0azRmdUF3YUVackxYVVNxKzA0bE8rNXNkT28wa0cxWVRRVk5FeW9wcUx5WnpyVDFNRGREcU5EcURPVjdtbVpCVXErcGdLS2tTWFpOd3hpUEtOcXd3MWF4YWVwMDZJNXd5UWdQYXpsTVdtWkowRUZyYkt3Y0NaWERLbWNyRWhZN2hrR0xMc2czQmlFb0lWM01jWHlabUpQTjVEQTRZK3BZNHpuT1JsNm4xVHFDQ1VTL0Y1VFJUTDRqakRoamRsM01zUytVcml4eXVVY1liWnhuSGNYSWdidGxVckM2alRLanRsdFRsQit4R0VhcXAwWEFhQ0dQN21YKzUzREpnckhKNmppTHZLSVZVQTlTbjVNYm5ETW1ONHgzQ0E4a1BVd2ZKamc1eXMwdUE1dWxHQnRGM0t5TFdYeG8vTXgwekpoci9BTG5NeEVaemNVWmg1Y1BKcE5zOG5qNEYxZU0yWllzejdsNHpLd2xVVEErMHlQdFV0WGlTOG5IMXFHVjZaamhqeDdnWkFWQjlyY09DMzFNcU03RzVua3JTUnQ3WnpyQkhIMUJBNVRMT2dvaG5RNHZ1WkZwREpFMXBqbUhrTXNjZWtaL2srWi95ZkxiUitwajVNdkU1R1BzcG1PS24weW1HRGpueHlSbVhqTWJkVERnWkxuM00vSnpUMEVvWUdhY1RSRmNtdnhCTG95WXQvd0RUSFBtMXZYcVlHZStEM3FtSGhyWEl1Wk9XV0c2MUZYeDFCQkRKZFNnemN2VTI1V2RNVnp5Z1pZWlRQRExXUVhVUjRDa3d6REI1ZDNLeHkzaXlqblBGai9JT0xrRmZsbUtaZVJET3FoNU1NYzd6bm1jT1Y0UWF0bk1jcko0ODhjSGxsTTgrWDJDY2x3QzlUSVJ5U1hrWWx5MjlhaUpsQmNzcUprN2FqRFBHK3RURWMxNEVmSWZ4OFVlUktZS2JHWUcxV1kwdVdwd3hKOXVlcHh5dThweTMrNHB4Mld6SERKd3ZvaVlsSGY3amloZHcvcHhuSzBIMUhDUExIVTVGVG00akRPanZiQU1vNEYwUUJ6cG1WSGtLYnhtbE9KcWVNTXVTdzh0NUg2bkREeXVXZUx3cURpYWNkem1ZdW1PZkptTGhVeU42bStMVXdQdHhabFNYeWpnaHhIdWNUaEsxSEw0WUVZL2VpZjFzSi9JNG1RVEZwcCtPNTFGbml5QytjK3EzakwzS0I1U3JvbGN2NlRmU1FGdWNkZHpEQ3p1cGIxQmpVT3R6TEYwenYyMUVLK0VnekpXZFIzVnh4SVBLWW1raHJ0bVNIakViV0dkQ2QzSDk5eWkvM0RUSGEzTU80N3VuY3gyOFc0aDFNTVgrVU1wZzQrTHk1QzJuVlRrNTVPZXIvQlBGd1Z4emVKK1k4UUN4SjVDNWpNcXROeHora2E0d3VwZHNBampSQlpkQ1QvRGIvd0F2eGZySVovbDU4djhBSzgyUjF5ZmdFWmhYaHdHL3V4ZTk5eXlVOElmMnBpbnFiUy9jT3RyTFphUXNOUzNsS0daR3Zoc0poZTRYeWx5aytMTG5HOHU0WTEyUUxuQm1QaTFEd3MvalNQanRvWVlKRXFjYllBdTQ4ZnkvRHhtZzBRckwxS3IxQktoa2t4K3kzVTJMQlZtT1ZOMThPeXhtV09BVmk3bk1vdGhYNWloN0k1QmpyM0xvb2hrUnlNNFpKM01zb3Y0bk1QVTVEam9JdktEdXBiTGZjeGdrY3hZTXVkd3RJU3IxQnlMS05SWEk2SlRHeU5yY3lKcktqa3h4NFBjQzlrNG44a3ZYOVlJamNCRm9nK2tpbGhUS1YwVk1qTExFeEdnamlpN2dFZHpSTGIwd1lrY3pWWE9UY0pjVUlaQTlRZVdXaG5IZTVRUnlQUkROVFpGaVRidG02WVRpK3BpSk1ybElTbWVMbDR4ZFd6SlcyZTduL2p2OFYvei9BUE44WCtMaUY1cy84ci80N0QveDMrYjV2Qmg1ZVpnNlNWV00yYmd6bVpZVTl3THlxbWlPVlpwREJkd3lSY1labEl6QnBobFdTZXAydE1lcDBReTFES2dpNHk2YWcwd1JhaVkwMzNCcWFYVEhFUnVHTVFwSTVxRTZ1VmVUTU1nWTVmaXB6Y1NjeVpVb2swaER4ak9MS2JqTzV6ZXJtT1dsbWJqTUFxNFY2TnpMSnZqc2hsbmdWK1lMU1JiWTZxN2ZnUm5PaGdsZTUrb2Q5emtZc3gveVREQk94L01jc1lON1k4VFlTeEptOHZoZzFiZW1ZMjRHSlVyTEhiTjludUExTWZHL3g4cW1KamErejFIRzBUZDkxTSs5TXB5YnNtSGs0RFp5R1dJbEJ2VWVIQS9NUXl1bU5hQzduUHFpbWYxSTFqa0xNUXl6K20yWStOeGNyMVBGMnFPWCtvMDlUV1JrK3lBR05zeHhjTjVtbzVQbFU5QnFwaHl4dkVqaHo2QVNZRk5OZHhMekRHK1M3Wmx5eGVINGJ1VTBzTU0zMzNEL0FPcnZaTTh6TjJGVGwrdFR2UkhMZ0J1WUdLY3NuYzhmK1I1TWNNakdtOU53eXh0TXNtd21HQmt0czZ3cU5KVkpEd09XUmJIQjR2RTJkeERIQTViWmtMU1F4dmNNS0JDWW4yWi9KaStLZzNjeE95ZVR4RDR2Wk9MeEJZZUd6dUJUdU9YSWVPcVlmWHRHNHBhQjZnMWhYR1ljOFZjVkNXSnRpNG1WekRBcGNuL1VTc3RNUElZMlYzTWZ2NUo1c0RFNzMrcG0wQmkyMUd3bkZjUnVWOUVWbUMwNHl6S1krTmNrOVJLM2w2bWJicUhiZHdxVjdobjQ4Rk9GMlROdG9tSXpETElWb1lJTjFEeTRaZUxpNDFYNG1YalU1WXM0MENSeUltcGdMbjFEQkZuR1kyUVhjOFNmekN6UzUxMUwrazlUTEZvaVZyM05rWVlnYnVHZndWVlF4dkpuR2lhQ0VSSmxTZkhSY3FpSllFeS9vQkRLWnZNS2dZODhiV3ZjODNBelh4OWVvSWJZMnN5b2RQd2J4aXJpRXFtSitKcnBpUVBqRXVKWHhXcGpqS1IzTXRDUW4rOXNNOEVsMDNNcW1LY2lZam5rOFMwbHZlVXVJMWF5cWRkZm1WV1dudWZ4Vm1ISWJtZml5d3pjRTlFOGc0cUpBYTFIdGxhUGpBUVk0aVc2WnhZbW9jdFE5ei94Mk9QODdmckJabWMxVDN1SjZtR0o0Y09lZjlub20xeXlmbEc0TGNNeWovY2EzVTFmd0Nrb0RjdmNZTlJZU2toaXpFSm5iOEFLbFRGclZReWdZamM1ak9mMVNjbXFHR1QwekhMbEhYVEJ2dWZhRHg3SmxtSnJHWXR4RjBRdkh1NWlQN25iN2xKcWNVaGpUcG5GL01LUCtVTWlxdmNhL3dEeFRUVzVRamJIREJPNGNBbjE5enNuRU1SbEJBeFdaTk5RcUFSNGhvZ0FYQ3BxNHNjRThlQys1b2pZUjQ5L0hJbVV2NlRzbnJVRFBjQU1kd3ZJb2lWcGl6Rng5a2VJcUV4ZHpxUGwzZFRIeXN5VkladFVFK3l4UXJUTVRKdG0wK3JFTmJsYnlxYnJVUDNPSTlNQ2xpdzRqRkRLQ3U2amlaQk5SbmplRGJNOGxZSDVJSVRLOFJhZ3h5V1haTWR0UUxaZzBaUVVuTGwxRlJxZUl2SzJaZVJYNnh0WURQOEE4dTRYL3dDWHd6Zk1lSGlOWk04K1RuNXMxejVpc2NaV3RTbzRKaU5rd2F5dFkyVWhjNUswd0RIT2ZTOXk4T1NFR05Xb3d4c2ltSkJJY2VMYnVYWGlyM0FqRHE1L3VZc3h4eHBMbW4zMUd3MU1WV21kTXh4YzNKL0dNRXVkSHFWZU14d0hKRm1XQU0xT0x3R1pLZkZzOWR5MjlUank2Z0JxR0prb3d4cXdscGROZnVlVERISEhETG5hejdiM0RxMWpTekxNUW1RQVhNa2RFc0NvZjdtbHBaVzJtQWhMeHJlNVFrQnFpWktIRklzVzhhbUJYallGRTRHV1BFSlNNK3ppczVZcURFeDVhV2Z5NVhTMFRYckgvdWZ5UFdCeG1YSHRuOFlZeEVCNkpqbHdSUzl4WE42STRQRGtHdmJPUmwrcW1XWEpTdHpCZW80ZnU1aGx4MkZUUHc0bitOajVueTJyMUJUUEtzakFxT1dOYWhrWi9ZMFRKd3l6ci9ocTU1ODd6TU1lZ21EZ1c1SFVvNTVJb1ZNY3NxcS9jeUZlT1BvdG1MUU16eXlSbkRMZ1hNT0ZyazZqUXVSc2xja3hDSGl6eU16OFRPc2NTSVpBWTllNWxpUFc2am4xampxWllQS1ZzQmxMN25CeEJjcmk0OGJGTTMxUEpuMTJYM05wM2N4LzNFMVN4elRERWNhbU5jbUFSek5vN0pRNERhek1OaFBJZVA4QWhESEw3VEhQRERISTdaa0VjZnJ5NFMrYUg5Wms1WlBIOFF4eXlPU1ZpUjN1WWNLWEtKbGY2bU9obU8xV2NkMk15NlZuTDhZMHdjblFUUmgzdURNY2prclBxTFVGTmpLTFZsY3NpaVpkOVF4RzJjYTNjUEd1VHVabjJnb014dTl3eHhMM0I3M01XdFhxWFloTVNvQWlQY0JNdndSVzFoa1RueXNuMTRhN21COWxZbmZHSW1tZjBkYnFlVFBMeXBrNnFjdnNNeXk5c3gzRlNOd2lJS1QxSzFVNC9GczYrR0dpRFRPVnM2WjRmSHpGNUdOUkE4bFhFdk5wdUR2L0FGS041TW92VUc1YzMvMUxnY280ajlwZHQvSVZDOXhpZTUwS1JlUUVwYmhvSXdKVnM2TnhvM1BEaXFvMUZHeXVwaUVmdGRNcXF0bUNDakRFdTU0c0RPM0xKdWVYSlY5ekJCM002Y21jZEVHWTNVY1VybExMdVZoa3I4SGJQOENzUDhmeitSaXZaUEZpQnp5TlR5NWZ5YnVMR2RVa3p6YzgrcFFZU2g5UXd1SlZrTUt3bVhscndZZ3hWbU40eHlXRmpFMG96aFozRDZ5N2w3bHQvR1BFWHU0RzdxWXVOR29PTnNlNWpQY3VDWERJSW9SYklyMUhxYUpoa0dUTEZodG5MaXBMZTJYZWEzT1V4eUVTVVhIRWhpUXd4U0dMY3lISEpoQm5JRFpITnRvMUw0bHh5V1lZaTdtZkVKVnNka3h4amhVVGFVdjduS3NhcUM1RzJFZEUyd09NY292dVlNb2JZczVSbURXYjhPUmNNcmRFQVIrTEVsYTNNcUE0a3l5VUNvT1F3enlCZ1dST1BpcFpoamdZTzRBckEyUXJGWTU0ZmlHQWx5L3RPVzlrNUJETHVIdU9TbFM0bGt3V1ptWmxWRURLTnhWMURHY1ZhQ1lHVk5rRkdibHJLY2lBbnVjUk81azFnQkIxVTQ5ekRHbVlZWTRlTExOV1BmMGFJR25jeDVibFpkekt3ZzVUSE51T1ZIS3Bobnlka1dYOVkrUzhaamxqdVlvczhHSGlmT2Z6UDBtUjR6Tk1MNFhxY1NJY1lhS2xNM0Q5dzB5NXVvdEVNNWkza3c2MHlobFRpK21DcVZQdFRiTUt2Y08vMU9IUE9obXNjcStNam9qaHJVTkc0bkFHYUdYZlV5ZmMxeHVWTzQ0eHhTWlpmUXhZVkZFaDNLSUJjZWlaRkVHa0RxY3RzTWhtZVhMVWJDMzRLclRNSEJ3UnU1VXd0dStpWGU5UThObDZ2L2NjT0JWakRNd21XUmFyQUtzYmlLQk1jM3hqaWx6UEo4bm9vSmlYa3RNcWhOaE9HRlJLM01jbFdpZUp3NWFOKzU5TUZ5eEZJZWZoMWdPT1hwang4clJqUVQrTEQrTEplNEl0TUE4WSt5ZVBOeVhHcHhmc1FEb21QSVdvRHpvYVhVejhSNHN3d3p0cmN3enl4OFdXR2t1SXYydHh4cnFheEVDWTBBckZIWTdnWlk1VzVYY3JJcm5qWkR5RDQ5WTFCd012c3M1R1BRUk04MlVuUk1rb3JTUzc2bWVHV0J5VWdYaHlMY3BkNDliSjRmR2VmRXhvTXNTNHVQOEEyUWFIa0srcGo3bU9iaGhUVU1zR2l1MllMelFyakV4ejhMaFhUM004ZjQvSnFjK0tLV3pEZ2puNUIvVWMzb1o5Ris3RHlnMDlUSk4wdFJUaDBzTVdraXVLRU13eFppbE1MTVVuWmVYcnFiZDNNY3VDWlRueEhFQzhvSHFjTXQzTWNITHFlUHhMVjZ4bVBpeThubFBIZ2NpWjhQOEFGNStKM25sNy9FenNVeW5NNVR5WkdTQk1kYW5ENlErdGpQclV6eDVVblVvbUdSaDQwMHMzS3k3ZzVVc3h5cTdtT1QxaVRQeHBIRjNNRFNYRVJucSttRjVTdGtlMkx5bEJNU200L21Pay9ESEFvbEI5WTRjU0JUSExGWmpqSHFvM0ZuWmNOa0dNWmRVMUZXWWZSdGxpck1jK0kyWGNPa0NEUk1OS3BObHMvcTFCL0V4MlRnT2lKV3ZnVUxaYnhHQ0xNa2RCcWFNWTFxYUJpd0IvM0c4ZEpNR201aTQ1NVBKb214UTNVRkdDT05XREJQOEFaQUtZVmY1bU9JbHdMYUhjL2w0YVE2bWVkdDlTbTRsWk55bWljZHoyZ3pLNkxibUtibGhLVXMrUEdKLzQvd0FqNnlTcDR2QmxtYzNXQjdubHo1ZEgxSi9xQis0VU01Rnd6bHEvcUNrTWtqdmM1dlVkbFRXcUdJd0poazRiMC83bmw4Mzh1SjlBcjhRYlBneFp3cVk0UHNuR1k0bkM1ZVRMYllyOFVWQ2lPQ0ZwcGxUVVM1VmZGVktOeXlXVGxVZTdoZVdnbVlHeGdhaHFHSm5IQkdHS2paT092eEFTWmJSU0hiQUZsWGRzeGFxWGhmVVhFNnhyNGNod29Jc01pcGpsVS9sV1BreXNJOTNDdUVzMXVYT1VVbU5PVXlxcWdnVkJoZ2tLZFNyWVZ1RGpiRnhDRzRXRFpMbktqZU15ei9VNTBUSFB1Y3JXV2ZtWUt1SlBKa09WRTZiOVIvVU1MVzhwL0dmbG5IQ0tjYUZnRlRJbVdORW9ocURDOTJSNUJZVERLcGxtcmR3ei9QdVpNWFF3eWd2S1hVdlg3aGt6WkN4dElva3N3dlV5OGhScUdXMjRLd3ZsSHlkNEVyTEs5U2pqTDlkVGxBNWU1aU5wTVVtT1V6TVFzbVhGQnZjR1lnM2NLeHhmckV1QkFYUm9sWW51Sk1ZbHNwUGc2K0IxRktnbGFtRGpiYktmVWNWZ01TV0FoakxBcGdiN3FhNHppaGNMYnVZQ2U3aHRZOVRFN21zOGF1WmVOeFRrVGg3T3BqNDNiMlRnV3Q2blVjREhmY3JWa0hrWGZUTWpkcENtNWpoKzVWTUJXT2YxTVhHajh6eWNYR2gxK1pWVU80aGhtbnFlTk1YZXlaYmZxUnFPWm1BekxjQnhuajhtR054WFBBK3ZFWmptaHhNYkk1bmZFZ2xXTU1YeUs0NVN3RTBwTTB6d0FxNVNFd3NHbmxQdGtxNVJPRjduTE04VjQ3amt0MnpBZWd1S2QvOEE4U0dWNWZXR2ZISzdsNmRnTVFyR25SSEpGbU51UU15eDQ1bVQ3NmpmQzdveW1Mcjl6SGs1WG02bXNzbmpESEwxTE12MGs4ZVNlUnpTNHJtdVFVWDFCY09TbklmVE9HTGdVekx3dUdLclpBTWRPaURiV05rZVE1Zlp5NGs4SDFPYmpZRlZIR2xjOGRzTkZ6eDQvUnl5YTloSEpXN0FsR2RCdVlaZVBINjVZMGs4MVpaZm9tT1JnMlJCZnJhc3ZNenljR21jeHhCUCs0L2ZIbGRWcWNiYUJabnd2UTlUSFBDOHJIUk1Ic0wzRCtnWXFiN25uOFRqbGVVVzM2bHc4bVRpNHV5SXVmNGpqZVFKREhpdDdoaVV4NUJoVE05S2pETHRZWS9WekQ2d0RML3VQaEJIbk1jYkF6eUNvNVltNktsRk1QRnlIOVNrcE95ZU5lUzV0d2ZRVlA4QUYveGZMNXpPaERIdkpZZjVXUDhBamVGOEhncHp5N3ptZmtNMjE1TjdsOXh5eEt2VXlmd1ErMlpiUk04T09CeHlXYVI3dVdCVE1jNkdvaGxpZW1WVXhwTXBieFNITGpSQmcwa3lzTk56SWRRd0JWblBpUlYyOXlvbExISFYzRU1PMkR1Y3QxTVd5blI4T2NQc3pOVnFIdUNKMXVYdlV5MjZtVnh1WXNxRXlmaXJQZ2RiSlpCcklIM004WERLckVZa2R0RU1KajRsOGJrWkEvaGxxQk1QSGtlTWJqckt5RHRXT1p4cW9BdzlrMEJSR2paTWQxY1Q3L0ZRQzlNMnNvSi94bUJ5L3dDNW1jTW8vd0JabGk0WUgxN2cxam9uS0xoeE9NOFdPTmlzeksyYm5rVExFK3Z1TzFScU10bHBsUHpVRmRKRGZycUhIR0tkQk1YQzZ5Snd3ZjhBeFA4QWk0MVhKYm5uOHVPSStMeGRSZ0dVeDB4cjRyY2VxbUdodU53QWF1Y0I5ekIvaVgyVCs5cVVUZ2ZtY2NSTGRReE04NjVVUkV5UzdDWWpuYWRFd01XWTQvdVArNXpvZHd5bTdkdTUwVmJNZE80aFVDSDJPQmhiM2NYZlZUa09samtWcVhST2ZIY2ZLckhMM0RLNWVvWjRuY3U1aGxiUDVCMVU1VnNuSVdjMTlUbW5xSGtmeFV1NGVUSUtxYzFuTEp5bktLck1PUml4VzROckZycWNuSWdFUld1cG5qbUVwcmNBTVlZMFhMSDRBU3B4bkVsTTRDUXJIR2Z1Y25KbkdvWXJ5bUlqSERjSlZNZHpIdUJ6RzJKVWFqdGliWmlhaGp1R0N6QU1GeWptVHAxc2p4Wis0RERiVTQwczlJUzV6VW1pR1VCdlh3d1d0ZkQyZkRjeHRnQ3RzckVaVTR4dVhXTXdxbS9jUmY4QW5PL2R3dG5GOXNNUDNNdjdTMkE4SW05emlrUm5GeDNCYllPbURaVE10c2JpUEhVTW5Hb1pjbDRtNFpPT1RadUhrckZham1Wc21XWnkxTEt2cU9USHY0dlU2eGxkUVM0eW9NNVRrWW1vdXBobndFNFhaSEVsRVI0eFV3bUdWeTVjTnNvcGJtTnpMSlcvMUIra3g4alNIVUM4VzQwRzJaVXB4bnFlUStoVXB4aGlyYzBWRVhPRHd1SXVIYzcwc01ISnUrb3RyOXJ4Z0lLUmJTTGlZbE1hZmNNRzlNekg4eTcyTU9lWUhMUk9UalpPVDc2aUdKcVl1QU5pTlFhWDhUTEhJUnhpWmN0c0x4WmxscmppVEx4OFEzYXh3dHE1aGk0OTdHTm1WaFV3OGVPN3l0U1pmM0RFbXdUUEdjQmRRTW5JNVJ4Zkpoencvd0NNOG5sYytOQUlSOG5pend3emRhcGova1k0OGZFYkwxTTNNelhRRFA1ZTdtR0E0YWFJK0RFd3ZrOXpLdGt3ek1mRWtNUTZmVXl6eWhuZW1LdXQwVERId0pqZVRQSjQ4TWZJY01pbWNrY3YzT2VKZ2NSbk84N2R0ZFJ4cjFVNTVLcjBST1hUVXJpUWNjY3Rsckt4eXVKaUU1dUpXTFBGbTRPZC9aWmhsM2RUTmRETkd4bU9LN2J1Y0ZYbFlUL0dwemVZcFVjemh4eHhRdjNQSm56eXl4emFBMHpEUWt5S3VvSGRzTVZ4NUQ3bk13OTJzS1N6Y3k4aDVhQW9KeEVXY1dsOUVEdkFhTzVsMllUTWM2d3dIVFBGaXEyMUt3UlBjMWpNV3NtbjFGWEtjWGpTV1QveHYrUDRQTDRmTDV2OGpNeE1EUlBML2taT1dSNG5qNDMwVFBQTG8ySHVVVlh1Q0NUTGJzMUdpSEZxZnJFVW5sd3o4SVpQVEZGbTdpck1kekU3bkdBNHkyNW02SmNMeUZmVU14MWRUSUZMZEU4cGp6ZURaQnAzRVlYMEYzcWVURThYaU1BRmZjNG83bEJ1WTRyN244VCtZNHdhWXE1TENNR1pUOFJZMEVwOVREeHZsVUtLbWVQQTNMRmhsUXdFWStpY2RXRWJidWVKdDlyS2VjeG1LM015ODFaamRxczVQQUxsN2l4aVVxYmdxMU51THFjZnBLWlpBMml4cnFlNE9sbHJ1R0xYS2I0c1AyemVKZHpIekw0M0hMZjRZWDFBMlRQZ21pZUZ4V215UCtMWGdNc2ZJTXlkb3ZVdTd1RkdNMURiUGVtWWU0WlQ2dU5KVVBIZDBzL2pWNDR6L1B5ZkQvamVId1l2OWNlNWxaQVM5M2N4RU81aVpPbzR2d3UyQTFLWDNGeXlDSVZkNytNVm5xbUZNWnNsNm0vV29SVWJKZVQwVGJxZFRua0pSTXMyNGpjVkp1Q2pZd3hVN25EbG5xT0hGcTRQSWJnQ2JoaGlTaWFKa2w2Z0N4cUdwZlNFcmFNZUZGWTB3YW5QYzVRUW5PRFJESXBtcVdEakxER2lZbzFjemZHb1lrMXpTR1c1MU1zM0pqbGxrVXlyZ2ZGVS9CQnBqRmFxR2lQY2JwWEdBSjFNVUUxT1Y1S1J5VVdwdVk0cU5IVXB6Nkp4UnBZVzNUT1A3bVZzTWJtVFdxbmNHbG5PSzhiR092RUQyejJ6MVJxWS9WU0x4c3VjNmduSWptTERQRzRKYzVndE1zbUNYVUw0MndVdlV3T2NUSWFQaHRUVTRMajNFMWNBTVdZak1UOHpjTHFLeHRJald2VXhKdzdxWTJUTGtpc3dVZGtiY3BzWmJmY0ZIdVpLc3kxMUZUdmN4VldiUmhjTUcrNWxZMHdFSW43aGx4dE81ek04YnJjdWlxanhXb2h6anZBc21ZUFVyM0szTVNtNGx4ZXB4SnlvcURNRzFsS2NwZTZJMENTMmJycWFoVFpBT1A4QXFZZVBKSEk2aXRkUy93QlRYRlRUQ3VDTUNzYmpkUXR3dDlRMUdvK0k0R1VUOFRSZzNPVmh2UkYxMXFPZlJERzczMURVeTNjZDFVb0dOWWlmbVlZNEprT1V6Y1hMbGdjUjFVWW1OVVRGY0k1WGFGUTM2dC9Nb0VKbXE2MFN3Tml3ckhIRmRrYzhFK3VFeWNqdU9RUDUxSE80UDZuUFRNRDZYREZkcm9nK2lmeWNESXJ1R1dHVGJBdmZROVRITWY4QUhLeHJQRjdtWG1jN2U0dXJoaUZaT2QvcUhsNDRPQjdqbFpmNVk4VjQ0dGt2R2djUXJxWm1XZlBOS0xoNGRONlp3RHhIMnRoa3VucTlUTEhMbnlmNnBFRUVLZ25OVTFVeU1IRVIzK0p3eXZVWElHR2VwNDg4WCs3TFJjazB3YXhNWmpqbGl1Wk1sOHE4dFExNHFPNWlYYXN3VWJxNWxqbno2Tng4VmFFV09GUEhMM0czUzZJTHZHQmlYWmNNRkxZWThjN3k2Z3I5cjBUZWVhOHFqNW54Snc3bVhseXBGN2c4c25uc21RRDlkd3c1T24xTWRLSk1NY2pGTVNHTGthSmpodWhxVW1UTXJ4aGk4RnZVMWlMbGpkbmM4Zmpzc2Y4QWNmTGw0L0plUFRFMXZ1YmNhWnB3bjdxWXd5dTkweitWQXRpM25acTQ0NUpseDBlNXg5d0t0N2w2Ylp3UUhTVEFNaThpZ2ovazRIaTRZWUIrNTVQSnoyczFjL2NBNDJzT2xscGhGYTFMeU1ScVk1M2lrTmxYY1NwMUs0YnFWbGtJbHd3Y1pwS25LTCs1ZEN0eWxuL0dBNGwxZHpCZUdVTFhiSHVmcW9BTEtxWW1QRmJoa0dLVmR3MWxIdmNNN0tjZHpubGhuMEpMck5TeVlZNVpOSGNESVc1MzFNYll1aUFWQ3R6RVA5UTA3aC9hTXliMUtMaUZFRGJCbGE1Sk1jZnAzN2pqeFRjTXQ3bUhMSU1jZmJLZVAyZC9GUEhLS09PSlhVTVByelhjdlRDakdDeFBnd3ZqeTZpSE5QUktzdWZ4NWZ4REIwYU5URGc3VHVlTVZ5N0NaaGk5akw5QlBKdEFuSGM2Zmg4WEI3Z3h0aG5uaXpETEx4RnB0Wi81UEovbkwvQkxXN21MOERSWk5zQmhxNXNJTTdOUUlRakFKeGJqamxPTFc0S0VKeHloaXZURFU0MzdnTTc3WVZIY3Y0dWljdFdTMzNEU3pHV3NjWmxkYWw1SlZSeHl4TG1JKzRFeE82OVM3TnpqdXZqakF4R0lYYzRQT2laWVVReCtyQVp3RDNLL2N4RGkyVEhERHRtdXlWWGN2WFU0MUxtRjNEYXlpVXlpNEJLbkFTeG1ZWUdOTjJUSW1OUGN5MzJ3RDh4L1RNY2U5d3FDYm5PdXNuY3c4clRpQ2s1NWYvZ25QSUs0d3ovVURKanlCbjJ5ek1aajRzdWU5VEx4Z3JjMkZrd0h5SWRUeW1MbjNBcTVkRFV4VEsxbkVSWVZFSmhpYm1PSGo0cXdQd3h4eHFJRUZMUWhSTEtvSnVISmhwaXNMY0hjTVk2SURPMlZZeEU4ZGlNYjRRWGlRdW1EVTJsa3h3ZTUvd0FXTFBVd3liaTR6bUIxQkVnRnpYTGNwcWNReDJ3eEs3Z2ZhaG1Yak05MzFISUoyd1RjdXVwUTRRS3VkekxGU2hpY1Q1dGdvMHkxaGtqc2hrWDFFK25LcHhFWndRQVlsT29WRXBuTnVHOHBpZ3NNbHNDR2VlSnhFcU9Ua1ZDNlNZSWxKTXFjZEUvNFRZS1M3TnpISTQ4WVlpOXhiNjZJM2xqSEd0TXlDcUpsNUJ4TVNhcENGNGdSQ0FEQ3k1dFJqbHZaRGk2RHVjVWVNYVBxbTQwTEJ0aWExT0dXR0lqcWROc09QTzFvaDk4MDlFRDh0a1RWa1V5NGpkd29VdWY4Tk1QdlcvVWFCSUtZOEdHWUZGM0RMWFgybGZrMzduRXh4dXA0MVRyK3ZVTTIzbGpOR1RNU2lsN1k0NG51V3V5RkhIV3Jua0VtR1hVZktaNE9PV250bVBQemJKbGdZbzFERktyZHpMbGhoanZsTWNtZVBMQVhuUEhYT3pyOXh5ZVMzQmJtZVAyeHNvWVZpTU9TQTdJQzVna3lWZUpqcVp2M0tsZlpJRytJVER4WWw4c3FhMVA0UnRNcm1IaTZiUlpsamtDOXppZng5eHdvMDdnMEdLZHhLME1ISExDbWYwdzQ2Wlp4eUhCR3U0WjRqc1lHRG01UUJFaUJSRCs3Nm1JNHJaY09mQk9waGkwOFpUVnhGMFMzTFdURExpSldvNW9sbGt6OHVGV0dtWWVRdytuRzdpSTdiaWlRUTlRck9MdWlaMEpsR3NpSnhheUdHWEhCQjdoNXZvNDFENjRsd0JpWDMwZFFNYVJ5aCtpWkgxZ200TnpsV0V4enBkVEx5WW9GUW1LNzNvaHhwRW1HSHBhamVBMXVPWExFc2h1Tms1YXBtS2pxWlF4V0tQWlB0anFraCs0aVZ1Q2d6RisweWdnUi9NdVlvQ1RUUk9OWnpOZzFGOXdoWmxkMUVPYlVIVlFhWlplOWt6Y2N2SjlTaUlETW1XaEtmNytvUHRsSzhwN3NpWGY0cVVnb05ReG5KeU9Qb2dhbVZLY29HTGRaUmNzS2NIWkZ5VlZnd2c2aGtmbVlCbFlzRTJTdVc0UnlyMU9UZTI1Y3c0TzFoNWZwd1B6RFhOZW1lR3BqbHRKNU1UR0ZXcENDbVZyR2xsRTI3WlJLWDNNTU1zL0xYb2w4L0pTNkdpZitUSC81UUxmMUpUdGxhaDFBMHlsUDZ4OGVXSUxxNGxaVHVZbktKUkwxS3NucWVvVDJqSDRJNVkwRUE0eXdZQS9vbWg3SVpVSVMycHFhQ3FnRW9sV3h3dnFKWUVjUHRvMUFKd2lrVWlRNDhZRUNCeHdZRmtXSWFJQnZmVVBGamxLSzR2cVVtUWpNMFNpWVFCbkVYVUlORGNzOU0xT1FkczVnWGJPWXhkd1p6TmhDRnptOGdncGVvOCtOaFBYWVRjM1cyUFJ1SlozTVFPeXlZWTl0UzhmUXpFQXVweUxnamtycWVQeThQSGxoWGNjbDlUa3prd3lRbEsvcUhrQnNOL21aK1RObU5zcGNySFU4U0FxVEpGbFRHcis1bFZ6UEh4aS94M1g3aDFVeDRzb3VYdENjdUkyd2NVN2lGNloyUDJqZ1ViamlBVkRLWk9PVHZ1Y2VLVXo2STNwbWtBTC9BSE9HdFRBMnh4bkpOQkJSNmhhc0IwWFJGVmFDT1RPV1FRdGV0VFpqMUhrRXhNMnd4Z2JwRStPcHQzR1VwcG5GeFlZbVhjY2Yvd0IraVpEZEVwRkxoa2pNTTZlNW5nTHFieFdCZTVTUU1uRzdDWVZrWkQzT0ppVkhKRlNLdVJBUnRZSmJCbklZTk56bXM5UzY4ZFErRVNWWXBxV3Ayd0NZOU5NeGwreWNBdTRaNDQ0RkZ2dGw3bU5ycWJ3RWNCbHJMb1JuMXY4QXNreWZaREJ6M2NYdG1WL1dtWmlKS3pWalptbkhVQmlETVZjcVk4ZGtXaVk1bFJ5THQzT1FnNGxWRHlWbnlXNWtxMjl6YnRtQUkzTThlT0poZmU3bmp3TWx0MGRUTEhFYVc0NDl5bmpwb21GN3ZaQWVCcWI1Y21GYjlyS3Bpbks4U1pTM0pHSmwzV3JoOWQrL1RPUzUza1hNK1hKcCt2NGcvVzdtT2J1SVpma2lHbkdJdmtSS0tpdmlmcWlRYzhUMGowVFdhd3N3Ylp6c2NzaVk1bURZdTVnbWJycGg0dkpobmVCMGJpdGNxcG1HSDhsdDFVVXl6REVQM0h4L3g0cW93enZFS3hHWmEzVnpubDUwdllkVGdETWNFYm5GY3ZlVDNNdkE1NTVtR0Rqb29JZUR5Wm9HQ0pNdFlsbHN3ZFdhbUYxeWR6eCtQaXFpckh4Z0pTQjFjL3lMTVRFMU1NVGx4dTRnNVVGUjYyM0RBeFRKcHVjdzhqV0pVeVJ6SzdqaGtONU15dzFwaGlEVWNReHM3Z2N0TDFBNUxEbFFCLzNMV3hMajRYeDQ2WmdjOGt5MVVDblhaSER0V2NMT3YrNWxqeHlhZ1ZnVEcxdWNhUDFOVm9oNU9TSEdpb3V6QW1PSUxjY0Jkc2RHaG1lYjVYN01jY1V4Qm1lSEYwMUVIRXI3TXc4ZVdkOFRSM09QS3k5UXBOK3Zjc0M3bVAyV3B4TGR3eGg3SlN2Y1JoQXQzbEJUTHFaVm05VXluZm9xWUhHc25aSHljdG5WelRNaEtuZUxPQ2xwQXBoUEo1Y3NrdHRKYmtRVi93Q3BiR2lHUXhDYmVwZzlyTzM5UmR3eVVqcCtMbU1yZStwamc3UjlURmpoeCswUDdmcG1NL3NzTlhjN05UbGxrY1lPSmpTVEV0dVVaWnovQU1SLzR6RC9BTWwvbmZ3UGxNQ3UyZjVYaC84QWkvNVBsL3h1WFBnMWNlcGpSREhWa1JZamV5b0MzVUxmakxaOVpnNGhXUkV4dFNhL2R3ZnNPSkRLMUlORlRKZ2lzOXpQRERoZzR2MlRjN3gzcEplUmowTncrdUFUSkRYVEUxbGJHMEFoaWozRW1pRk1wZ0ZmQWdLTThZZnpZcy84bHY4QXlsUHdUZGd6UEduWHhpTnkxbHZEdDFMdUR4bU9USEtHeG5MaVZMcUdkeGdyODN5bVBHWjBaYWhLVlo2L3JLTncwVEZPNTNGcVdkeitRdWM2am5NZkpXTVdudWZ5UlNZbytwZW9ORXh1T3lDakdGOUhjVFBEdEkzTFRPaGxaVkM3cFpsZUxDeGhaTDR6SDd2WVZMZzBzMUdhbEhDQkNHSXJPdFFIUktUTm1SMVVPV0t4TGFTVldwU01vWVlsTXkxanFYeEpqTVZsbHdkN25JZGtQajl6QkwzTHMxT1E0ZFV4eUJvM0IxRGVwNWNxeE1DQzMxTXNuMFFWRzVxb2xFcUVJdjZ1WkhWVFJkekxFdlRNY2F4aHRqV1VlTm41ajNNdUtzOGVhRlZMU2NpclNjeE9tREhOeWlvU251ZVZkY1NBckN5Q2hIUElkRTV1VFRNUFAvRmZHZnlZMWJMRW5LRGZpbklPeVk1WXF6TE1XR1NSUmNTR3MyWlk5WlJvVzRtTXdQNU1FdWNQUzdJaVRqbXhHR09XcUFJMWxpMmJqaFF0UjlVVGRTc1pxR0piT09yaGc4cG5oeElqd2dzM1dxaCtHRHh1WURVQWhqaURFbVBmSW1hdE5SN29JWW5QZlVvRnBuRGwvd0E0RGdPN2p5WU9JZlkzT1N0emtwcVluTE14amkybjRqRTJBeDhhSEpmZzV2clVNeXFoMnorVTQxUkVFbWVGRXh6b1RqM0tYOGFtV0NuSVNObU1Cb3FLclhxV0duMTFQQmw0OERKOGhhd3l4K3pVdzNsVVBIaTVweW9aa1Y3Nm5lRk0xRjNaREk0VlcyWW5EN0pjR3VwOXVEZlVlV1V5dHhOSk0wSGJESFZqcUR0Q0ZqOWxtV0lZV1pFKzdkekRFcmN4UkZUV01EaXJjTnpranZlTXhBVjQ2WjR1T1dORjJUK1Z5VUxBTnd3TTM2dWp1NWxrWTZ4L0Vhb3lKL2RqWlNUeDU0NDgrZUZ6SHlIL0FBT0pQSFJtdWNmeU9wamt1dkdVMU1jdkw1THlWRTFEUFBEeVVXLzZaaDRkWGs3SWU1NC9QL0VPaGg1M1BMbm9qNStXSEdaSm0xQUxjOFNmVnM5d0NtWjRaWXpBcnNtV0p6R1o0cTdkUXdIQldaNFY5cWJoU3pqeW94MUR4SGl6NHpnK1Z5Y1VER1l0RmU3bWE1cXVjVVE0TUhiRW9GR05yV1BVNHNNYmgvOEFvMmZjS0M1aDRNOG44VEx4Y1JIYmNjSEMyTm9RSmxlTzdtR09mbHlRSTR1RCt5SDNOd3hNYzlUK2ZMeFlQRFRscG5IYmp5aXA0dUZUajliV1laVmJpd3BMaU5qRHhyYkFGYUlZdEl6ZzFNL0ZUYTJUd1plTWN1ZC9xVTVxak9Ta3hkTWFHanFkVFBPMG5waG5tbFNsZU00cDNFSVVrdzB6S3NVbVdKa1RFeEdaRzUwZFFmVXhZeTlUTzR1OVQ4MFRFeHJXVUx1TE1RdmJPVWJWbUlzVGozQmdWa3pEL2tHNEhWelArUFJqaGxBcFo0dkpuNC9Kend5NHh5Yy9JNXJhenRqak1hR1dEcVBKN2JDRFRwaGtZWDd1WUppcmx1WkhkUWRFTzJkQXpDNllOVGNZTllzOVRERDZxc0xSYmhtd3pWcUk1dTNjZE1yNnRhaFFFeWJ5YWo0c3NNTWNzdW1XMW9oYk5tcm1DeTdaNE1jSHk0WW0xWi9uTi81T1lkbFRrVkdobVdXSk9aTVVpY2huQnFBM0V5SW42bUlidWNiN0llTUFXWUc4dnFSQmhqK080NEo3aGhqN21pNmdBZDl4QU81aWg3WlcybG00RVNZNGxiZ0JLR09KSEVXR000NHppU2lGUThRMndIa2s5eDB5Nmg4Vk9EMk00ckc2bEtFKzBQZzdCbWJUeEl6WGszampWRXlSZW9CTlEzR29ETmozcVl0V2t3eXRhaW5HUEs0R1FxaExkVXhVNU14ZGR5MFkxVTVFcU9tWWNheU1uL1V4eERCdG00WUxsT1BIUkEzRXVjYTNIaWVPWUdML0FHbmxjZEdFT0l6TGovb24xTlhQSGlaK1VxZVhMYitvdGtwdjRWdVBKSjlxM0M2U1lpUVFZMHlpV1hVU3BpTjdaM2xCeGp4Y3RSZ25kem1UbDZsemtWSFc1dEphRGN3d2ZJNFlqVTh2aC9oOGpoeUZtNWFWVEF6VlppSkt5bktsS204WmRRcmpjdVlVWEdDVGxzcVpiVnVHWDE0OG80aWJZVmFUREp4Wm1IOS96RDl6SEk2WWhsckhvbDBURGtiZ215NDVVYVpiVUxaaThWSWxTbUprSXhWWnl5ZE1wOWt4b2ZzektyaGdOeXJQOWZGY296RklvbjFOd3lpY2lHTXg3cklnQU5RdmpmcUc1aWtNd3gvNm5GR3hsNWZCL1ltV1hvaGFmb21Cazl2MW5HOHRNNHVHOU15cCswUXg5ekpHYVdwbFEwVEV4TVZaZ2pzbDFsY3dNODgwS2phdk9wM2c1ZnVjVEhBRDNCY2NuTGlUbGJ1WHhFN21KekJtQUdTcytya29keHhvL2NNMHQ5eHR0aTVPQmJCY2MrU3p5ZVN3M0Q4Sk1EU0RERlhxYysxLzFEQlM5QWFuTXhLeUxuLzFabXRUUWZWaDF6N25ld3FWaHhkN2xxb3JWd3l4OGFvc3d6dkI0d01hRi83bmxNUCtEQkMrVXhOamxvbWE5NEdtWVkrbWNiTWNjSjR2Q09hTGJVeVI4S0dHNWdyUlNLU254WXVEYUxEMmpWTXljaFVleURXQ2UyY2I4UTF1SHZVeHR1ajZzNDVkRTJrcmlMVnppY0RLNldlWXNEMmFoNHpMZDlUREVSdnVZYlc0aWQ5VEpjMFBSQTQ0dnVlUEJ5dHkwZXBuYTNlaWJ1Z3RnYVhMdWNUc25CeXgxM0tWMFZVeHhjOFhrd3dSVVp3UVcyZUwrTGZQRi9VeHk4ZU44UW44dU41WmUvMURMeUtvNi9jdkxsVXl5QnBsOG1HUmpsZVN6aGpuNUQ3ME14TXNGckxjY3UzdGhuRllmYnVjYWhpdEF4eHF4U2NDcjFPTU0rT0Jpa0hOenJIcGxKaHh1Y3NuMzFNOG1PR1ZXTXhNa21pR0xUR3ExY3lmUlBDNGNuK1NaNDcrc1JkSGNMY3FaazNLYUxabHZLQW1vSnltYUlRcW9IM21RalBUamNwbGFsM0RGcTdtOWpNUTNjd3JFeU1sdGhrSG9seXJoK0lnQ1BjR3JKaW9zYmU1alh1QVhjRUZaMlN3SnFuS3lFV3RKTGxMaXdCdzNDaHFjVGx0YWxZamVMcVBXcGpRd1RLN2FsZmpvamhybE11aVlyREdmM05lcHdlWVdiamc0S05NZGtHZ0JocXdtQXdGZFF1Nzl3S1ZoOXJYcUlPaG1PRGRWSEFjQk9Wbll4ZTJuY01SWjB1dFFwZ0ZhbmplR1ptZGtWOG1XV1QyemhYVWNHSktDQVF4RVdBVXdDV0wyd3cvY2NjYWR6RjU0VlpQNGZKbDRQNUF2QTl3Sy81ZHcxZTRmbVhQKzRYdUF5bTVUREc0WVhaY01RSlVQRzhiVWxVVENrN2pNZXFuVTR5b2Y3Z0g1STlXTXJHcnVVZHFScVdSaFVFWUdJcExyb2prK3FtSmxualpxb1pHeUxCYmkzTEUvYzVEaWlVem1ucy82bVdTK3B1SEtMbUYxTnZxSXpqcUIyUXdRYTdqaDFzbkhKRTl3eDBXc0NvR05XeXNab3hVR28wZTRHTUdKVzVwQ0Q5cnFaZVd5Y2pzWUNseTh2Znhsa3BVWUZtNVJqVSt0Nmxudm9sazhML0hnNU1YbDZXNHV0a2EwM0xlb2xFZVJqVmtGNlp4eTlFWElPcDlpOVFGeDZaZ1V0emo5cHd1R0N3REZ0bXRiN2xCazBtcHh0N053eDlLVGpER21CazVNeDhlVGM0SEtzckp4eHZTd04yclV4UUwzREVWeVdaQW1tR0ZuZlh3QjdVaWExbGM5cXN2UmMrckFPQ3dSbVp4MUtiQjdaeFpqajdKVGJNY2Z2VVZMeEFtTm91aWVERXljclFoVGc0emhrdFFFVWF1VTR4VGpZVHgydkU3cVpvWTQxVndUSW1JbVc1a24vWXp2Y2Q2SmllU2pManFaOHhGbUt1Y3plR2RNY3NYRUZna082amttVFVNa0VxQ3d5Umg1YWRoT1lyV014UWRSQm5Lc05TOGljdFhPZFkzbHMvVUZMQnNqbTROSk1jdGNvM3hQMlEzOVNheDdsSGN3enE0R0Y4c2YrN2pwZUpwbUpsbDdvaXVMRHlVOVcvdUdWN3FEV21LYzZqOWprVk9DTjIzQmNQSGtwWXpISmNlcWxqQnI5TUhIRjVOb3pJK2xHN2JnYXZKNmkxc3VwalRwUVovOWZMNnN2am9TSlFudFppS21QVEhMSExEOFpqTWpsdkdJRmx6RHg1dU5uUkh3Y01kdTVuaGpXbVlaQlJsMHh6dzVCajBSekVTa21PZWtvaC9WYjk5UUduTFZRNjNENnZaUHAyMkU1Y25qaVI4ZE5MVnorTlJjVzZnb0N4czMwTzlURHl1QWxXSjduSVErb1ZQS2VPOUR5STVPZENrOFcybU9EeW9TR0h0bUZHY3JIaldNTVhaaVBjSExpaTcvY1A1SEVzYXVQa2NjcUd3N21WS1pkREE0MkxwbjFWQlp3MGNWcUdORnorTzNpYVhvbFpuMHpLcWZ4czA1NU9kbzlUSDhFS0ZualRJMFRMSnlFNHVtWTQ1RFFUSHhGS3pOTDA2bVBqY2xQVU1lR1FsTTRVNTh1NFZ3aDVPQWNlNW41YlF4TnBiTnpGb2YxQVhLclpYckwxSEg3YVNvK09oajQrWGpBeTJmbVltOVRJdEx4aGo5MTZKbmhoN1ZJNTQ0aFdFYzlYdVh4eC9iRk1vMEFrcmRHNFlHUkE0YmltYXFCQUFxQkFjc0hxb1o4WDZKWk4xT0tkTWNJWlp3elhIWkJNamlHNGFXQTlEUDRzZkxueHhRMTdtZUY1Zm8rQlRLNEtNRW5rZkZsZ1VJejYvdTRLRUtZQTRmQ1JVS25qUWJ5SjNtdnFEZVd1b2twZW1aUEdWWkVnUkNlUGovSnZxWnB5YW5LeCtNYytKSExrUVg0SmkyMFRMRGgveUdOWFBkRXRSaHFIazlWSE9zQTRTN3ltV1V3cUppa3h4V1k5djF1YjNGZUF4cUdvRzQvWEtkdHpGUWVVcTVqcDZnV3JjY1dHaWp1ZVBTN2o5amxCYVpnRnh2YzQ5SEpsT0xSSGxkeTh1bnFXblVNampET2pST1RIS251T2UrNFpxVVQvZlpGci9BSkV6eE1PS044cFl0UzlJSFVkVTFET09lTW9obm1lSndGNC9pRkFiU2NSbWlFTzVzZFMwbHJCcWNvaDNOWkFIY2E1MDlSQ3RYTWJ1T3VpTHFFWDUrczhaNFRCdiswMG00MUxKWlBySGlrREZRbEF3VG15OWFpOXN3eUFxNHBETEZtaVZ1eVhpekowV1I0Vm9qbkwxeW5OdG1Qa1VxT2J5am5hYm1XV2pjNXBNSEpXQ1M4cmR3WGpNZDdZM2t6aXlreGQ2aVk1NU9xMFRNd3dkVC9oWkZVcVZNc0V3RzVxNkNMK0NXMU1TeVZIRTRYSGRFV1p1aUVZRlVUSnJBOGR6SHlaZUU2R1h1TnJvbVZ6MFhIdW82Nm1Ea0ZkM1BGd3pjdjVNazFyVTVnSmF3elhCQmd2VE1FM2NQcTl4eVJhWnZqYkhvb2ltTnFUVFVhb0NXbnFaY3lwbmFsVEhETGRLS1RISE1SeU9VM3lmckZmeDhDK2p1Y1Y3SWpjL1ViVnhxcWw1YXhZanlxY0dxaXJoV3RURHRKZzQ3RW1TclRMenpwbU9QQk9UM05lcmpqTUxHMWk2WHVZUExCR2NLM01MNzlFemVEcjNFUm5PTHFsbUttVjRNNHI3TlJJclpVU2w1UzI5ZkhQTThaV1h1T2VXVmNvQnRJdlBiK0lBMFF3YWRrdDRzeUZCaGxMcUtydUJ5WmlOMU9FS0JtSTNVeTd1NCt5b0tZb2tNSExHK29nbmRzNERrTnkzTkFOQkVwc2lMQ1k1Y01FQW5MVHNpOVV6RTd0aVhHaUZVYm1XUVFjV2VQQVR2cGxPYXQxVWJNYTdtZWE0aFZUTHg0OEJ4N2dQS21JSlVNa3lvaWwwOXM4WGh3OHVPWExPZ0o5ZVRXeU5IUkZ4ZWlzbys3ZHc4bEgzbG5LR1RqWU9tRDlmNlhPUTBBalBLWm1hWk5yMUd1TGgyekh4Vml1VHIxT05LbjlvTHZsTWNGTHNtM2xjT2dnZlRQVUJLc2hpNTVmakdZaGkyZFJwYmd1N2Foamk3VzRITXZjUUFtYmVCVXlMM01RV2Z4KzEzTVZHT2RNOEdXR2EzRDdsVlFUTGlaYVZnQmt0V3dEandNOXJ1WStGSEt0eitQeDQ0Q1pybi84QWhxWmVQdy94amxtNDUzc3FaSGovQU9Lc01Cd2pqampud3ZWVGxqektkbnVLWnJubTNEeStQcW1PV0MyRXd5RERKaGxXTERQTEREVU1jaC9UQWFWdHJxWUQ1RkRVL2h5eHR5MlI4aGhoV0p1R1JrWlBVSExua015NVQ2OFdZRlRIeUNJeHlPVXZISHg5N1lmaFp5Q1pWbmhIRzYzQVIxTWVhMnVwbjVDb3ZKQWpobGxWUFJNL0VIaS9jeXlLcUFJekVYR0MrTjBYY29EdmN5VXcwejlNd01zbTcwVExKeS9FNXJoU2tIRXhVaUg3bmk4ZlAxVERETFBLaWVYeGhvN0p3eURjd3h6TGZVTmRrc2cwM0hsd21TR05FZDR5N3hxWXNaVnpIK2pNU212ek1zT0NXL0d1REZCZzhvdFRGcWNyZmgyUmFMeDduWmIzTVJZNG9jb015K01TNEpqZHgyUTZsekJQNUJ5L3F4eHhlVGprVEVtUldjL2N4Sm4zT3NpV2NHMXNacnNpekRxYU53N3NpcnQwL3FKV0xPVjRCREdpMTJ3cUNMRzhvYTJTMTdnMk1Kb3dqblNRNG81YjVFeDhtQmp2RzFoOXNXc1VJWThqaU5NU3VzZGtlUkxuS1hsQzJCbEtUMUhURmxqNitCUnVmMlpRZW9jWjlDWDJEcG1KYWk2bGhOUHdNUGF4Ym5HdHNyNlhEcUQ4QkVvaWpqTWFxTEZIVXZpVG1ObHNOKzRJUml2NG5iTFoydzl6cVl5L2gwUWRTaDM3aGphajZKc0Y5eTl4TVhDT0NCa1NsZjFPTk0vNE55dlpjb3l4dGxDRVFnUlBqamlReHBsQTZKa0VPUFhiTVQ4T3lOTjNBdWNkVmJNblZrVUVpNCtwbnhpOXk3bDFCaE4xdFl0ZFI0aHBiWnlLbUdZYm1hRFhxV0FWc21TTE5wRWY0eWJQVU41SlNUL0d3UEw1T1A0N21kcjZpS2JZdXpxTmRZMlJ4MTJ6REg3MWs2bVhIbjNxV0ZrRnhwVkdXUnlJQTRxZHpxekloYTY2bFhNdFRuOWFpaHJjTXJsYnVYK0k4bVl1U2IyRU1FdEk1dUxwaG5rRzJYbDZTWmNzdkhxckorTmI5dzFISnlZOHNwU1A3aXJ0N20rQWsreXdNaTZtYmx3THh4cWMwNklaY2NGb3RoeC9kem1qb25rOHZLaklOUXN4b2hwM3VGWkd5WVZzRHFPWGpmRUppMzdpWWNneHpqZ3NEbDQ5OWtUTFJNelVNVGoxdU9Cam1FeHdFVEhJbkI1Y2JHY2N5eDZJVS90dVVxa3lNTHJIK29RckxDT3A2djNDcVJnR29ZQ3U1UVpDN0psY01XYjQwaERFWUFzeDhhKys1aW1Oak15d2xwbk1VVElDVlhjOWJtSGxEcUhseHhNcnhlUzZtSGs0MzFjSFgrNVFFeHl3ZnJtSkNxZmJBTkNPNDRaWTlBa3licG9LbUZiL0FES09adUpqdXR3UEdIVzVuVkJxY1RzTndIRlVaYUtrZVZFQWIzY09YQm1QRnl1MmN1SmJqQkhhVkZ4VFVSd3g3RzVmMWFLWURNRGFleWJ6VjZqNHcyNUNNeHhlU3d3eTJDVk1SNWFkQkxUTjNxS2ZsYmg1Y2NFNFV2N25CeXlQdkhoamt6RlBKa3QwRThubHhjVEV4bGU3aHRRU0psaUFNWGRzenB3T01zd1NiUzVoNUF4ZnFMRE5HekFtWG1BMXBHYzFaaG5pWXRpeklESEZCeHhYM09CdmVvSmp2bHVEN0dIamVmMXkxVXc4ZVJmUXpKNDBpbC8ydVplZkgrTXhEcjNPZlJ1bWNqb2hrWkpoNDFIM0xiMXhzOXpERTgrZGF0N1llSEI1bGdIVXdVd2NDa2UyZlZ6VHBqaGhoNCtWS1RqYnZSTWNFSVliNG10OXNQRXVUZ296TERFS0V2M09QaHg0cHVZWlljTWdoa0dCYWFqbmdaeC95WEx4TjlETXZLYmEzNitCNTVGdTVhWlpXd3JmSXNUMUZlWnF2eEhESzJlUEFHMXRpNGhWVEp2SVFpL1lZWVBrelFpZWpzZ0lOdXljd3dkYmlQc21BR2F6RE5MQ1Y3VzJmd3IraG1IakN5ckovR0QzcU9YQTQ0MGs0NzBOVGh6YUNmd04raVkrUEhFeTV2clZRTWVkUFV2QVdqVS9rQTZJZVNPZVE5cFBHM1pjYkp5aGs4QTFVNUdaVkU0WWh5bmxjSE0vanhROTNHNGc0enJLcFhxcGxqRXJWYmdPSXJNRHNnVXA2bUhqWEhrczJqTjhTWjBzVDZGUkNvTjZnQnFBY3FtUnRuUVRJNHBVL3RkZHpOWERFZXlIY3k3K0w0elNTekkzNmwyZkY2MGJtSWV1MmJaeE9mMlljWVpnL1diY29KZy9hZVh4Y1VmV1VDbVBiTVhpWE9tRDhQVlREeGVUTkt4MUNqQkUyU3BqZ21QTmpRekhnNHFzOGVCbjRzM2xYR1lZdGF4ZzZWZXB3NVljNmxEVE1TMlk0amtsMVU1OE1PT080WXVhMDB5bEtKbUlGNHMxVUVuYzZnTTdaVEMvWktscE1obU9KQUx1YWNsbkhjNGx3eEJaUXhLR3BsNDNFeFgzTU1UY3J2OEFFYnVWTVI2ZXB3bkQ2d3h1VkNQNm1KbE1UdFk0Q1dSeEdQamhnRU1iR3BpZW9ZOWx3d1RMdVZ2dVZPaVZ5bFYxRW5Db2tPTXhLWmRDeStVd3hPSEpsNGxrUEttUEcyQ3JITDdTMDdPNGRUaHJsNmxJM0VseCtCS2hiT1ZsZmlXUGNIWUdPNWpraTJVeGJKNDd1S3JMcnh6UE8wbFJKU2R5aVdVd2hsV2lCZmNNUXkvVTByVTRxVk1NUWF5WTFWc0hTVGlRS2w2cWJqbFdldHN4emNmRG5rWTB3MFM4VjJ3cFZDQW5iS2xibERGeEt1T1dLMHhxRlo1QmN6NDRyaU01YzkzTGZUQzV5cGJMaTYxak5oMU9MTURERWJaOVExSE9qcUdXVEhMSTBPb0dyVHVHTDdaaVFLZHM4Zm53OEdPV0w0ak5lbG5PR2VPSnVjd25PWTU0TFRNOHZST1VIN2ZxWlpXdXNhaGRYUDVJSEowUmN1VUxYWkhQSllYY0hMMlFURjBkeklBME1LWFJPUmdwTU01bGZPWTdpenlHeUFtU2tINzMweDVaTEFMU0dMcG5IYlV2RERFSmtrNFdYTWNNZVVmR0prakh4T0NNQmZkQk12SHJrbW9lSEo4ZWVRMENSMUxvaHVtWER1S3JVTHBXQ1gzVWE1YWJtWnFweFRXMjQ0WlI4V2ZodzVaK1BiTWdRUXFCN3VMY1M1VEZUSHVFcmNEU3BCcDBRdkpnT2FsYmdPRFN6VERDM1RNckdtR1FiRGN6c0laMzQ3QXVYZFRDOCtRUVF3UnczTVAzTWtjWWo0cS9jeFVPWHRpNDhFbUljZ2lyWWxRQ3RzenhjZGtDMnlZdW5STmplb3RIOXBoOXNlT1ZIN21JUDFzMU1sdG9oNG55WTVKMkZ3QjZobWVvam1UL0FJcVRaVE1CeTFNY1RCeUprNWJCaGl1TnpEeFo1Wkw2bVdKZ1k4RzMyTXp6UExkblUvano0R3RRNDJpUmNjZFlrRk4zdW9lUnpUazFNOFREUEhrOHNXUDM5bU9MTThzVERpSXpGejVDVlFUeCtWeHlYWDIxTGNSUjNETnc5dktZK2IrTzN1K28rUmF5R3BuNWVTRlE4N3c0MkpIeUtiVFVmTUUvbmN6am9uTnhlMmN3Yi9NTXp4M1piSHlZdVBWUnpWTVNaWmNHWTVMZ2gwek4yUWNrWGtSeURmTGMxams4bnVPVHdzWmVXWmp5YW1MYldXVUV4elQwUnBZWHdhbjhlZkc2Z0hLMngvVUhISTM2WjVNUXlISE0zRVhTazRJWld6SEE1UHRoNHJXSCtINU9ObUV3eHhzTTZqNDhEL2wzK0lmeENsTFg1bVRpSDE4ZHk4eDNaUHRpcXJOTGR6SkhXcHg1V2swdzR1S1JOMFRrNXV6Uk5HeGd0SlB0RExjZkppbW8rVkdaWis4djdReW1PZExMSGN3OHYyVkptcmNEK1EvYy9UMlRGM2Y0bk4zWjNEUFZFTGcwSXhDVWgzQW90SngzWkEzY3hiV1pPNXZLWllaNElNME1WZFFsMDNPT1I5bUZaWXgwUkxJVGpsanRtRGh5dlBxQU9iWFVkRU04YVoveHFGRVhmd0xEcFlOTWNsWWNzenZSTUF1MzRXWTY5czFMSWJpL0FLZ05ST1BUSGNGQ0E1djRvbUxUTWMyK3A0akhJYm1TVzhkSkFVMHpKOG1ieGVpY1dyaEtuVVhVRTRRVGJPV0o3bDNDaVhCQm1pRlZESXZxTHVEYzVibFg2U0pqcTFneTZtMzR3SnhIMzhEbEtsd0JuR3NFNVJ2ODZuaVIwelA2NU15YkNibjZKU0VQM1A4QVh4VlJ3RW15ZEVwV09MQmR5anFGUDdDVWNaUUVLbENnekxBT2xxVVFxVnE0YmxJVkUwUjBRZVY0d2FLaUF5Z1pqaUt4b0txSEM5a0V4MlFCdGR3S3dZREJwaS91ZDVmRE9XcVNkc3FtZE13UHF4TFRjMlJTS0UvNDNPWDFDQ1JTNExoZ1o4V21ZTjhpWDJ3eVhHcGwvVXhjbzFVSEFKbDVjV3Zxa3hSVmptd1ZJc3E5c0doaGt1TjBham5qZkxqSE16OVFjZXJoeGZjL2N1MFV1R1lIOVlLN3FhRzBZdUxBaHZFSmxReFNHUzBlaVpLUTZncU1iY2R4d0tuRFVBVGpFS21KT1U1N2h1NWxqcVZFdHNnWkRFcUM5MHhyU0xNTUIyNWVvamFyQlppcnIxUHJoSGM1WktBVGRkUWJXemNNaTJ5WlpHb016d0ZndUdYVXJWd0xoMDhZNGFiN2hpcEE5VGhURXlHc1hUTUYzamtXVjNBL2NDeCt6QlVybEhFNHQ3YmxsVlVlV2lQSTdOTUF3eHZJaFdhK2lZMDNpTVhFS3loZzhOUUhvZzVZVGtyWjNNL05uNWQ1OXpGNDVYSGVWMU9DTHZ1WW02bEt1bHFaSi9JYTlRWU5reFF3WUJjNHJtcjFjSEhtdzQxSGlkUzhqY3JQTTdoaWp0M0R4WkdIOXh1UGo0WlU2SXJqMlV3OFllSXl2Yk4ycVRGdUc4blhVSDNjY011N3ZHNWhpWnRkRlNneW5rcHlEMU04VGxBZWVzb2daOXh3cWF4eDRzeit2VTFsOXNwaDVYeGp4d09UTWJiRHQ3anAram8wd3N3TW9IM1VLSmRzNFo5aFpPRjQybDFITmNBbThkc3hLRGo3N2laNFp0VWpESnd4NCttWnZTZFREaXJNYzZFZnREQVRxZ21UanBDTjVMZmN6eHlLSmkxM012RGlobjQ5bGJ1R0xaamliWTNndUtOak1FNXVtNWptL3dBais0WjRtR1psZVY2bWZIUEU0UFJESUNDUXoyQk9YRzQwbktPWWxIY3N1dmM1T1hmcVpaS0MrcHlNTTdBYkpXVnIxRHl1SFZOa3ZKQ1paWEQzdG0xTGhncXpGTVF2c21lWE5KZjFtSmVNR2xKOWlIa3o2R1laUEpZRHZqZ3g4YmxtS0JNZkRoOWpMT0o0OE5BNVRuamlmWEFNcGxublU1dTZXWDlPWHNsWW0yVVppNHpMQ2krVWJ5OTlTaW80dUx1SlRNbTRBdk5odHlnT1N1NW1lSCtISGpmT0lUR3htT3JoTW1ZamsydlV5dUVxdXBlNjlSc2RkU2xHbUdpcjNLUzFoZE1PV1QxTU1OektnM09lTlhpVE41RXdZdFRCTWJtTzdtR1ZNVzExTFphN1g0MDlRSjNxWXEyVFlSK04xTWI5c29TVUtBMU9MVE9QUlhjem95cVBVeHhLdTkvQVB3ZjNqM1A0M2daSHVIanllbUZtcDlVMjdtbzRrUDZkUTJ6TERoVis1d1pXeVllSUZjbXBqNHkwV2NRbmtCcE5Tc0FDWGp4MU1ERjl4TVROcDVFUHBhVGJhTWZJNGxWTG1GTE0rTnl5cDQvNDIrVEZ3MFRXK29tSzZabjQ2OFkvbWNhSnhpVC9BRTZsZnVHeGdUaTNObDJ5eXgzS0djVm1QanpiNGwxT1ZpVkNHTDhPelRLWVl3RVlweS9Vc1RqVTRzRG5jWWRUaCs5emplcjNBY1ZINHBpTE53VmFtUkszcG41UmhQOEFCeS94dkYvbUdYK1ZpNWVLZWJQL0FCc3ZQaytMRng4UzZKeXhwb2FtVklmVm5JSWVXUGxvclU1d1dHVDFGaG1yQkh0aVBZemtpcE95WUhJMjdtV0NCY3l5eEM4VzJHVnRyUERoL0x5ZVdwUjBOeTZFTk12alhLT1pka2N1V285NmxzNUJwbkw4TTVaTVF1b3VQRFRzaG5zV1paN29qbUV1eUN5dHBscElmNzFCKzdBOXJFR2Nzc3ZHWWMvckJxMmNyLzNQRlRuV1hxWmZiTm5XbWNnbG5GNU80SVlUZHdGSmhqeHU0Z3ZjNmROeDR2VEFERUpXKzRZQXU0VVhiQTFNY0ZRaDRBOEdTdTdtSXJGeUlwQk1TWTUvWjFISVlGOUh4dWlVMU9PcHd5U3B3cjNjeXVjYXAvTXo4WER0cTQ0Smpkd3c3WndZaVNualQzS3lNVmVwV2JPTFd1NS9IbFRidUdkWWNUYktTTi9uVWJ6M2NCZE01ZG1NYlFtWGtEUFhVNW5IUlBGeUJaN1ZhWWROOXpUTUhqbFRNc1duS0RqeHB1NWh5WGlFeWFnc010em1qSFBkd3lWM09WMkRMTU1RN1l2M29TWlpKWmNOZTRtU3RNcEN4Z3Fxem5ZVEpURzFzaGFhWmJqWVZUN21BaDlpeVk1dU50L1dYbVhtZE0yMXUvY3U1Z0crVEJKaGpsdFhVRzcvQURPQlhLOXpGYWVMRE14YlFZZmFKUkhMVkJNY3FYVUV0MzdtN0l1d2xRYWFaUTQ2bkZ4Qmkxa21QVXdNTTlQazRZaDJsMngrM0xrM1RxT0IvRmh1aUp5NmJDVWVvYTZZamRKTUs0YVpaeDczK0pqVEJScG5sek10RTRGMk1vLzNCZlJIWnZzamtJa3BNTlRESG4vem9KaUFPUmxNTWd0VHRpNUlrc1RiSERpV01NODY0OHFKNDgzd2xKOVdZdDNNTjU3Nm5oOE9mbDgzOGZpQldaNGVUeDUveDlwM0ZNTXdTNGhuYjErcGg0aTk1R01jVHhyYlVDckZxK3BsaTRjVDh6UEJ3ejRaYXltZmZjOGJRbFd5OGVCV1Qzc21UeWJ4SFVISzd5aG5XZkxFR1pOWjhzRWJtR0RrWkowZHdLM3hTbmNLR0tKMVJQNzFxcGgyak1QRi9Ma1k0YnJ1T0hIUElPaG5IY1RFd1ZadHFZRjJ6eHVITzh5ZnhZK1FjalFUZ0orNXlNRHJjNWN0NkVsSERsWnl1Y3NuTUIxS2NNKzdKa3EwNm1JMVV3d3pkQk12R1lndVc0WitKZHF4L2p4L3JTd3lVcE1jV1o1N0RrMUhNYzZ4R2RPdTVodkxjYzhYSkFGSWxsM01NUU1ydUJlR3BsaGJFREFxTGcrSDhzUTFYdVpiZUpFNTVBOWs4bUtOcFV5d0RIbEErbVVjT0JmNUpmRnUyWVZqdXJabnZMZXArQ0Zkd0c2bEt2NjdoajdIVUt2dUFyVVFEdVk5SlA2bFFNcGliTGxIUHV5S0dvWk5hWmVYNW1TVGtWTU5MY0NKYzR3S0pUVXI0R0pSRDRlbWRmSGJPUDRnUWgzTEJpamttTVZReG1XODRsa0NpRU5iWjVjc0Z4b2w0eHpYVlFRMndvMlRBVVZaaU5zcWJ5Nm1CeVpseEQ5ck4wV3l2M01XWTVPN0o1RWFTT1JjYzdZMzhlS25PMXFOR1RVTngrdGtjaEtoUEdHNTlmdy83ampqWk1jT1diV05FY0dHTEtDeVcwREFYcU9tMktKQktvSlpENDVhaU5YT1gxbkVQSHp2Yy9rVW5qOCtlSzhXaGpseXNXMkJNY25GbkxMSzU5ckFMWnlSYk5zTTJXczNVR0RUcUdmMm1XUU1zeTZZSEo0M0h4L3hMRk1weTFVc3I0MUhFN0dHUjdtdTVyak9vMnpqOUpXSm9tT1M2ZW8xT29rRDlUeDVBN0lybmt0d1UvYk9lUEZQWkxFSVpoM0ZPNDU0NTQ2bUtETTg4YWdGUXJnNjNCTVNiNVhNaHFFcGQzSzNNaUhqMXBtUEUzbEhMQmZycWNjekF5cGNYM09XMWl3U1hHSHRocmNjcGlOWE9KVEFERVBqSEYwQXN5VXdxcWFnZTU0UEVmdzU1Y2dZNHRXc3l3cUFUSUJsUUp1WE1QRHlGbkZGRGJEQjNaRytKWlVNTGJKeHpKamhtdjhBU2Z4NGVQNzVKZDd4Sm41Y0x2eGdZa2ZMa2xYQmJTZnlGSTlzZGtjVkk1WjFSQi9NdXNwYU1WZTVxb21ManVEZ0pIRXZUcVpZSEx1WUhJQzU1aDdDRmhXVW9Ock1rNDZtQnlOc0x1Y3E4YU0yc3BDQzJqSDZ0ekxMa0FFRzlHRXh0dTVoNUV2aVVUbnR1R1lsQk9Dd1FOa3h6REdEalZzWEZiSm9tT3hicVVFS2NxbU9mOFFrNVowd3phaGsvSEdZNUJsTTB0b2dhM01XSmNTSXVpSnduSldjRDh4NnFZWlltT1hJbDh1b1hXbUdmLzFPT1IzT0gwQVpzenhKcHpxZUlMWlRNVmZJdGFKZCtxZzRjYXZjRk12d1I3Ym40Q0kxR0VTb04vN2luczNLUW5pUTJseHh0V28xMHpIeGlzMk8rb1ZtdGFKenk0Z2RFejBkekQ4VDNOdlRMdndtQnJLWWdOSjZxY2QxRExzN21MaXRJeGNDakdHSDFYbEJ6S0NPVGhrcktlNWlOMUNzQ21aWm9ORVhSRnljdmk3d2Y5emg5YnlqczFEQkNGN0o0TThjZkphbzFERHlKbXI5QWhtQzJXZXB2cFppbVA3dlV6UGJQQ0dhamVpTGtaQ3JRUzNQSzNKeWYzUEYvanZudXNnY1NmeVpxZ0d0YWxhRkdEazhqb21POGFUWDVtZUI0Y2ZvM3lndUdaVzVqNUhISnluOHo1ZkxrcFFzeFJ4bWVIa1BGYjFHMm1ZdWVPSzhBUHpESi80NlB6TjhVdWQ0bUlXd3dISkdaSmtHSnFjVTFpd2J5ckwxTU1PMjlUTnhFY2NvL2JPbmN6d0ExRDZzWDdUSE01SEl2Y2ZMZzVYaDRpUGxVN2hsbmE4OU14MlczRkhINmtxcWVVYzdkekJvdVk1dkxsVVdYbDJRQThYTDJzelNpbVllVklPRDJ4eEx2YkRpbXlxbVp5Nk5ReHQyVElESnFBWTl1MlpuRTN1VXVGanFaY3NWdHNZaFEzRUJsRnh4eFMvZ1J3UDFITTdtRHhWZmM0UGQ2bFZiVTVKdVpmZkhqS0FxWWgzdWZkbFBzaDQxZTZuOFlPMlBpTEQrVW5IRXM1Mnc0QnN5andmVERMRktxY3pxbzVhNmxzQjlzeUVnTXFjVUlxdnl3UGtVaEQ0QzVkRnpGKzF3dFZZdXBUVXhMaGpiVVJ4WUgxMndHQ1VrSUI2WUhHTVd5Z3FEVFVTN2dKdFBnRDFCREJ1R1FEcTVpbEp4bi9JL1V6eVBKNkNpSXpGR2JGbUQrTnhITmcwZFJVeW1QVE1mSThBOUVXNE5UNjJ6NnBLRDNNZnQ3aUpkTUVFY2psVWNScXNhdVpEaGxTUitFMVh4NnJjMEVObndUM3RvaWhvbitwVGhqTU04c2Rpd3pjbjdMT1VNbUwrNE5zRWpsTVU0MnhPTEI5M1RQNUx0eWwxYk1pZ3M3aVYwVFZkUm9McjQ0Zld3aUhCSWw0R3BrRkh3NG9kL0JzWUV5U0NidG5qeDVJT2htZUdJNmJuRHZkUWF1cGg1TVRISWNCWDNPUmY5WS82Z2g2bU5laXBjdzRWV1JhOVJ5UDhBaWIvRWNxeGRTc3EzS3lYL0FGTXNtZ0RjM01NZnJGeURrUlZaeWVOY2RmbVpWeG1GSDdtZitaNU12OExIL0dRNDR0M05WVlJKWVJaMlREeUdGM2dNTThlUzFaTEtJc0prVlVHc3FtT2VYaXJJSjVYZjUxQWM2eEpueDJiRWkxTWxTeWNWQ3ByU05zekFTbURHdlQ4WXE5TWJIOXlpVllMUEhnM1ppa1A4Ylo1TTJybmwvd0Fnd09PQVYrWVo4RnlNcldPUWdNeUFxaVlsQ2p0aGlRT1ExTXZxQXdMTzRuUlZSS2lxNjFHdy9NMVJPTWFkVlZRYXlTTnVkekhQSTNCdDVTL3MzT0tFRkdBTzduSTRKV3ozTDZJbDV4UnhaamliNUtNRWdZMTFVdjJaSk1USE1WYVk0cjF1Zng1WHVZWU5vd0EyUmFIVThmMitFSzBST2hOc3p4ZUdPTDZtVFNUeDQvOEFLSnRXWkp4dWNweXVXVEYzTXNPT05zRzJaNUpaTVlMeHVvbVNERnFjdGIzTDEzQnQxdWRYTWVUN216cmMzanI4dzYyekU2Sm5rS0Rxb1lHSitZdFk2SmF0M1V4NmYzRkVDdXBxK3BSa1dzek42WVFWZ21MTXNqS3FLam51a21ManlHV3VhOFJxY3JaZXJxSDNRV2laY2NXakcvM01IZ3VVOG1WSDR1WTVsR29xV2RqTXp4NTRGRkpLVGZVeGEwdmMxaXROemxieVlxVlRIeWxKbGdXKzQ0NDJJVHh1V0c0dlBMUlUwZHNwMGpxWkZMN2d2R0JXUnU0OGwwU25qVU5pNUdpQ1pLOUVBUnFDSGl5UGR5MUtXNWk4VHFLazRwMVRaRGVGSi8zRHlPV05mcXBlUC9jcjNXcHBoZ084NWxpNHJ4MUZPSmk3WmljbjJCN2psbGljUEhtcGwzWk9BVnhlamM1WXVHUVR3WWVMWjVNdlVVVGhpNm5rUDR0TGJQSGhlRnYxWm5raFNYTWNheE0zSFVLRnZBaGZreHBkUlJPTmJJcnhSMU1jQnhxMG1KbC8vYkx4eTFpVW51WVlaUDNNSm1qbS9Xb1lWWlpHR2FXRXc4ZVdiVFZFdlB3K2F5cWxjbmVwamh0WHFPQnlnQTBUa3QyUW1nQW1Qbk1jT0NSOGpYSEVxVzVNd3pScGRRelYxUEg1UTVHUWJnbjJMdVk4blY2aWc4Y2ZzVEFxN081aTVEeG5FNDNsN25XaGlubEM5Vk9LaUhVY3F4VDhRRlk0VVhLV3lvNFpKTXZGbVBISW44VCtFZ1BHWVlxb3pmRnBzZ1hpaVJ4UWRSMzJWTWNUS09QSEtybDg3cFdvSjF4bWVaZzI0ZHh6VnJpVCtUSTB4ellNeWJkRmZHbk8vd0FSS1dJRUtHQThyQ0hpelhseFc0K0R5RzBuRC9VL2labGhmdWZ4L3QxTVRMTWFOSHVONitNUGgybndNZmdMaHFBNWFKNXZGbDR1NmRTZ3duSFZrOWg4WFUvWkw0N2pUdTkvQS9BUWVNdTVjR0pIcTVlV25JK3N6ZGxFeHF5WklINW5JVHFZSUxxZjgyY1dXbisvam92dVk1QkxxMk5zdlZzNWFtSzlTc2lXcFVwK0RZM0N5bzJUYmk2bkxKYVBVWEpMWVpKTGwvbUdaK0p6eWlpN0prK053S3NZSy9YUkxKY3hZV2ZaSmVtT1ZZbEVkd0NCVVVnZzFVeDA5VEtxMlREeVlsaWFKbG1aVXBVYzhTbzVFRXRqbTVOTTVvVGsxWkJXWTlwTWNreHFaaUxGZUJBdTRZcXhXR25jYXF5Y29NWlR5TnkwWmxuazVhaml4RWppaGN4Vk56OFFkUlJKaG1jQkMwbVJqL1lOc0JyY00xeExqbWxwTnJjcVV6R3M4S3VMeEkrUnFMWksxWk9USEc2aWZ1VmNBWjFPMlltQTBPcGtpNmh1WFhjSEhJcWFHWXVxZHpKdk5TZURsbDVzYTF4bWVmM3pzOXd5dnNobmIrcGptaXprWXR4eXZvaVpQcWVQeFpQU1ZNL0ZpTzg1NC9EOURJYmJqNE1SRkpqai9pNEgzMnN6ODNnSGpoalAvazU1YUFLbms4MmIyeHl3Y0s5eEFKZ0dkMnhCYUdKeDl6QmxjZW1aRnBjeXhSMHkzTHQ2bGlWT01jY2lDTXZhUWFtZFlzeDI3Z2xxemx4WTFrQ0c1dFN5WmtTWkxXcGZrdnVZWjVJWHVjVnRsWk13b3hiTnNEU20yNW1aQ3JqVTI0dFR4OGgyeEZZSVhVNVpjWXFUeHQ1L2lwZFozY0ZiUjZsOGtWaTNucGh5cmxMQW1Wdno5aUJQWkFHejFNTURQS3pvaFR1TkQxREc4dFRrWStPc3A5YXNJcFV5YWRCVTNqb3JjeCsyRmFzblMzQkNaT1Y4cHZsVUZHd25rT1lYR2I2SVZlL2pFR1o2aWVpY1h2bE1kdjhBcUhXbzcrRnZWU3prYTFEZUtudnVWVEhIOXpFWTVETCtnUjNxY0RwZHppNHpIdGlQZktHVmJqc3VxaHlXb0k0SlZKTlpPNDNaRytTVFFRQmhpbmdiZCtvWTFpZmJmdVlnbFhPTlkyTXhQSWpzcWVCTXNIRjdtZGp4SVBwTlRGNzFGRVN2ZmN3MThGWmR6Qi9zWWs4V0E1L2Z5Y1QvQUZNc01UTFRZZS96SFBITFFSOG80Y0ttT0dWYXhzZ0hKNVdFZVNiYko5T1dMaHRtSXZ1T0RUYjFNTUFmdmJqSGp5MTFjeXl2S3lJNXYxeG9JV2NrTER1NWpqaWVIbjU4N3Y4QXFFTWx5NHh4eDhuaXJMT3FuUG1ROGhpVVFmZnVaQzVBdzhlV0FQSW5JcXBnZmJMMFRtNEZZWmFsY3QzM01jYndVaWZYY0dwek9Ic3laYlhkc0g2ZmJ1WXF2RUlXRnBBeWZzR29tS28vbUp2VTR0VFhVeE1zR3llVEowenRuSFZtVU03YmczN2w4ZXNwaW5aQzMzT1ZZSGtVNU9rbU9QMnR0STUyMkVOdmVvS0RUcWF5UUpqd3d5YnU0NTVaRkdNTUhtM3FVN21lSEx3bVRuOW81V2R6SThPZ2k3K3N4eVRPMC82bVhsVmVNY3N2K1hjYmxJVHJPV25UVXB1N1dDSThzVm1HQUNwbGNQRDVNbEtKL0RuU3BvbVBpaGphM1pVZkhqeEcyZnhBTkU0WW9sVXpFT2JhYWg1TVQzai9BUDR3endUKzBQTUdOQ3BIelk1OXVVYy8wVCtWTmFsKzJjMG1PZVdPRGlhSHNtb1d5bUpVRXh0WmNyY2RQeGprQk9RNC92NFZUYkhaQzJnaHAzT244L0YxSGNKN2hpa3h4Y3BUTWZFSzNQNGN1R1dZUEVsVUZ3d3hwcCtPeFBVdGFGc0lNd2JtWldJalREazJyQXlTWWNUSEt6Y0w5WlRnK1RCYjJTMUljYXZLekdHR0tXWkV6d3FteGhPTjNBRXFvQ1FGN1orWVgzY2I1ZkJFbk5OVEcrVjNNck1vd2wzTzQ5ZkJzZ1diK0Q4UUFJWmhabDFVUUtma0h1V3gxak4wUzAwTnh6dU1NK1pUdVpFWFVFeWpwbHdTWmFiZ3B1WTVjaVpMMzJSem9zaG1PRVhqa1RpNVkzSEhzbkRoZ04vTG5CNU91eWY4VXJjY2d6Sy9FdzhtN1psNU1FUHpISkVGdUtOanFHUjhFd3k0NkNmWmx1V3Z4TkJVY3RJRUZxMG1PL2c0N2VwNUMvY3h3R1ZNUXJ1SnZzK0VvdXBqa21YV3AzYjBFV0FoS09Nd1RjTWFaN1k1Smx2R2RteWllTks2bWI5YnIzQTRlS3p0bUpubG5LQWJuMEtxR1ZQV21DQ2lYQnlPdXBnK1RQVk14L3hzNmM4c2dKeC94c01UTE41TThubnlmNkhISDFVUEtwdFZpTDJ5eTd2Y3FpNWdrenpwaFhhUXlBU3BReEwxTUNpcGx4WVo2cDNGSzFQRjR2NWJjWFlkVEtzY1J4ZnNka2ZzellCTWNETE9wa2NXaGxwaGZjOGk1bzBHcGlLUjMzWkhGb1NEKzBuTnI4eTNKM0h1aU5KRERrekUvak1xZzVIanRDWGQ4U2VSNHVQR0hreXcrMlBjejh2azhyeXlRWUI3WjlPT21tNXlLcTViNmx5MkRycUZzd3hRVzlQcWUwdHFHQUlyRURwMWN6UnovVlFOV056Slhjd0kzN2dMdnFXblRNOHlqSW1Ia2NSWnkyRXlYWXR4QXhHSnlvaDBucWNmM04xVndXa2R3TkwxRTYydzQ0MlpMTXFvbUg1dVljbTlXUnhYa3NQRzJXVFBCd1hGN2l4bkpJTGt4WGxGSzJUSEtZV0xCMmkxRklaY1NHV215WTUwTTVYMHNiNmx1TkJDN1pxbzBaNzZxY3J1cGw1RGpMK2hvSmxvaG1uL0FCRVppcGdtVk1NcTYxTFVkeXg5VEhIbWs4bUxobVJaV2kyYzBuYXNzT2hsMXA2WmJqNC9ydG1PYVppRlRtWjVPZ1VuajhPV1prOHRZelBPenFpQ3ArWUJ4bzJ3VWhsVFBDRDVYazFGL2h4WFdWOVRPck5qT0R5Qm1IanZJZXk1bDVReVRIUjBFdDhtSERJM004RjZ4Q1lBWXV0ejJaRjFVY3Z2MjNNSElzTWJJSGl3THkyc1g2YXdKejhtZlhSTzhreE5zOEhESHlaL3pZcWNkRVcwY1JKeWVLdTJERGl3OFFaSVVwN2prcTVLRmFnUDhoZjJKaWNzMzZnRVBKaGdaWVpnMlRvdkZqbUlCcVhWaE5GeFF4c2l1VE1SaWFXcm1HZG9renl5ZTlFUEx3dkVWSllxcERQakVlNDRYR0VUREh1WWhZK3BuVzJWV0pVL3JNTTRabktYc1o0c203Q1pCZ1UxdU9OT2txR0JNTThQSGpaZ1hNdkpsbm1zKytJcWt4SFM3WmtmZDVNUFlzeHdRYXBqaTNyY1JNVU1jcmhoNUhmMm1QamJYaVgrNWtQYndJOE0zYUZmaVBERTA1c3Z4ZDBNY3NML0FLWVZQNWNNZC9RajV6VGIvd0JUK2Z0WEpaL1BsMmFZL3dDUWhRYVp6V3F4cGpsbGFpem5ua0pjdHFyM0hrWHVGbTdZVmU3M09vdTZQZzMwTE91eHVPT1QxaXorTHlwWmpxSHZjeHJpM0FUM0F5elk0YnJQWCs1d3RhU3BVdmR3dkpZTkxjd2R3cTU3dGpvaEJSWnRiZy9pWlpaZVFyVU5kelZNeE5UalNyT2ZLR1NkRU1yM0Zvc1dIbDhuOFg4UzNpdHhSYVNDVFh1UDZJazl6RHhsM2NUbk16VERXRXhReFYzTW5ITG9sdU9oblpjdkpPTkNROFdMNHJxcGxoMkVxaUFnc3ZVQmxZd3h0Z2R4M2pPaURLYTdtTFhjN0lGek1waVVRUW5MNjNBNUV4bWhsaVRnY0xFV08waCs1UTBUVGtqOE00NU9PbUd1NFBLQXYraVdZNDJkeHhvZ0xjd2VMMUtsS3NxOFNieHkzTWRzcTdKWDdobGZmVThSZlV6eSt0QlVIdjJ5cnhtSzRwN21MS3Babmg5RDdSSmtnQmNyNkxMTkZwTStHakJZVHJPTGpacWVLK2VObGsveU1zSE9nblVQc1N1THFHMjJ5WTVsYVdKbHlVNllOTUZjbWN1V0RqWFVMeEpZRFpCTWtKbGJuQ3hndE13ekEyWEZ0MFF1MmNsc2xzdHFvRmlRVUFqQW91Vzl5OGVDa1J5ZTl6clRCQi90VUxkRGU0K0R5NVk4akZRL0VNVzdieG03Zmd4dng2bVArTDVzdlZZL2xqNC9GNHRPVnMvK1RXS1lZeHp5eUx5eVhjTzJLMFJVNmlLYm1IRU5rOGdEVjZtT0g0Nm5BWTlwT0IxT1V3UXg3dGxQYVZITEhvSWsxMGR3end3d1V2bkhwSVpDVEpDYTRXU3NlVzVSdW1aR05RS0liWGt6eDJxRE1NemdqVndtZGNwbVljaXZ4dWF3R3kzNFhXNWpobGtiWGpGTU5ZUWVXNHFQR1lHSmZLMW5IYlF3dmxiNmhzZFM2L3FUOWU0aVRicUZoQmoraUNMUEp3RTJPbzB0VEhSUjNGb3FyZ0REak04dVNHSlFScHlBSmhnYnhXZnhZdUJ1SGo4YTl5dHU1bGdxVXdLdFdaWWdGUnlRMUt1ZFZUTGFtRHdObmM4dTBZclA1Rm5peThsSU9wNGhCY3A0L3dESXhNbm1UUFBhOTNISXVpQXJPeTZsN0tqUXhSbHRWQkEvWkRJMjVHNVlsa3lUZ1JSbnV2Zy9OekpxcGx0WnR4b2liMXVIWDdoUTdtV2ZLaVgrcGhuampqbHl4WllsZkJnb3dyR0E0bGt2SjJzN1k5SytvQzdqK0NETmNGWUMwajNDOGMwc1prbVdLVXpGY2NYRVV1YzNpWXpGbzFNQXRTRHBXVXU1eDVCV0NzTWNyYlJQeE1Nc2NCd3p3RmVtQm5tY2wwUWNzUnBobVl1OXF6TjZxZmRISlo5c2RzOFFlTFArVE9rcnFaK1hIeTVaT1JYVlZISjN3VUltTHhCMzd1WUdreXlJWjhjYk5Fejh1S2ZVUi9NOFdHVDZXWUpvaHBibjAxa0x5ajFiVEh5L1pvQ1lZWTVLNTlUSUR5bE5FRHNNcDVDNjFjTWJLd0ZZb2FUYzJicVpGd3crdW1jWEo3bTVnNVorUk5CTllHUXc4cWpPNHQ1VjFDc1hiY1dpdnpBWEw5Vk83bUpSSEszb21WY0RVL2pVcW80VWhNOEE3U0dPQnVQbHhIUkR6WnM4WCtSV3NvZWJBN2Jobi9JMWd1cGpraHZjK3Fhbml4RElVV2VZTXQ4QUpqNHpKNUdaTWZBWmNuTGMvaXh4cHkwVExQeGo5TWNXWitmRGw5TU1jWm41MFA3VCtkOXR3OHdYUkh6WlorNHVmS2wxTDQ0eFhPSmlOV3hEMHpHa2Jhbkk1QkhiOEw5c2N3eWZ5Qk1zTTNKNGpVdzhHYU42aDRVOTR4L3g4OTFuZzM2R1Bod0NzczVoaDRBLy9TWlFQOGZ2bm0vOVF5OEp2aGJIeTRCcnhrL21UK29UTHkrUjNSSHk1elBQS3BXUHhUTURNYkhaRzg4bHlibUdJWTB4eFNjVWxZNDlMTkwxSEl4eXVvTnQxQ3VWTVg3VEgrc0djVUttV0RpZjduVTdoUkhGeHdtRHhQdnRZNHZMVTR1SWJuR3BsMEV4YVdXeTcrTnpRVS9IL0RjZXU0clJiRk9yWmpvVmluSnI0NVlwdnVZNU42bmp5eDV1T1M4YWhsaWRES3MxT05QRlNralJuVlhCdVk5ektZd2J5ampUTlRISzhVbnFWWkRwSTdqdlZTam5HdWlBazJRSU9xQ1krNmh0TFkxT0FZOTdZM0w5UUtHV2tkRnN4SmhhSkVCM0RHOEhKOVRFeVNqVnd2RlJobGVFM3RaMUw1ZHdLblpFb21LVzNEbC93bkxKSVRHRGdMeW5Ha3lEVXhhdFM1WmxNaTJ5V1hGZW80bENUSVVoMyt5TnEzTVlaVWE3aXVVYWR3VVdtWU5ETGRVekNzc05hWmxvUzRaekFNM2hMTWNYeG45cjJ3UzZabm1abnhaakhJYllyS3lxWWwyTTN5S245VnNOd1RxVXRoQU40dW1HTmt4UXlna3gyOGZURU1Wd21GcmM5RXlDK1ZFd3djVnl2dm9tSCtSNXNCREpDZjhBeXM2KytPTE1mTU9kbmp4cVlmOEF4dk5tNTVsVjJFZlA0Zkg1SEx4NFhqTS84cnk1WWNSckdjOTBrTTkxV29ycmlRNUZyTlhMTjZtTnE2aFZVanVHQjQzN2pNYk9WVEQrbTlSM3VYOUlnRTBORXRTbHVaZHN2NmtiQWZsZlV3TEVaa3RCQS9ETVRJVTF1WllaWW5wbitQOEF4dWYvQU4xMFRMZVd1NERka3h4dVowWWZzaTh0eHlKbXkxbkhrV3RCRnl5OGVXT0dpREFPQ0Uwc2U5YmprMzJ6WTdobFZrdkl3MU9PWE1ZRjNLWFBVd05KRURHVms5TVREK0VwKzhUSG8rT2RFUHhmY1A2eXlZMCs1ekJhSnljc291WUpXcGlGZDdoa2RQY2N6aHJ1WVdzeHlES21WaXM1cGdoVVg4eDRjUHFLekp5TWFkUHFLMWF6RXhmRXZ1RlAwOXp3WVB0bWZscThTZG00MWlFbzVhalFXWmJtTCtIdnVjZ0pYYTlTc1JoaUNMdUl1elJGSVk0OFZacnVPSXcvdE1QOFh6ZVR4ZnlBY0lVWkoyRWJjcmg1RElxdHhhWVdFRm1TTWZKaml1cnNLbUpiYXpKVnE0YUtsMW1URlV5cnBuVHhxSTVFWmRrRzREd24vTGNMeDNPVnpDM3FHRmY3bXdmek10MUFTRk1CZDFxWUFZWmZsNmhnMlRCNFN2czVFS3pkblV4OG1PT0RoTWEySjNFRmdMTWNsVEdlY3BKZ0dUYjFEQXRGaThTcGtMNU5hbVBEd3Q1bk9meVk1WnVmSDZmaVo1aXVRYTlFd3pjVHRCbjB4OFp4MngvcVpyT1dQdUFEUEhnWm1TenhZNVpxVFAwVEhGRlZnUEsxMU9XWjVWOGJ4WURuMzNlNWd0bU1jZnRBcTU0c1ZXK28wbFRHaG5rYnlvbU9XWmhtY1RjQU1iWGN3dzU3V1ZVeXpzTlFNakhUTVBGeTIrcDlNRUp5OFI2bVBtTkhDWlo1ZVc4d0RqQlUzMnNBRjVRUzJWaVdnYklZWkplTmpNZkRsa0Y1RnovNDlZN1lDUDFXZUpETU1uaCsrNC81R0JtbzNIL0wzcFpuL212R1lmNWdIOVRjUDhoV2hxT1hOKzNrbVJ3ZVdLT01jOE84Y2JqNWVlWFZNeXlzMmt5RGdJM01lZjhBeHhuOE9hMjNjZjhBSDhqMVZROENOY3dqNC9HRy9KdVlIaU51VVh3cnlSeUpqbDRWdkhCSy9MRHk4Y242RWZPdldJVCtmSkZ1UGt5L0xPYTQxYk1jVTNuSEl4enZIVWUxN2d1WUZUQXljbkdZWUpkek5IR3FtVkUzREZlMmVVUk1SalpBSWc5UWd5OUVWZ3dmMFRCTFlvd1RxQVdzdkdvVkVHUEhsMnk1alRhK281SGRRUm1mbDVWK0NYYzdoQlBjc3l6ZjFEdG5MS0JPbVl0elVLc0pxZ1M1NUhHaWlOWFBIbVlacWdrZHY2aURhYUoxREZXVUdsamdZWTh1VncxajJNM1NNUk5zcXdTVWx6RXVKWVN2WjZoYTM4QVIwNmhEUkJMdU5LcHFYVTNrc0dwempjNVRwMGtLM1VLU21PSlgxbFZ1WHlOeklSMUFhdFNNMjZuSGhOaWIzUHp5aXRFdWtSSnhNMVpoZ21XNWthL00wWEdDc1Z2VXM0d0lYak9EbGlwMFNnRGN4MU1pM3VpWWcxeXorcEZRczZ1V0tycUF0MHhBSWJtT2h1WXRFMlc5ck5ydVVreHhWUUlscUZtVWVScGdjdGc2bmo0N1VaeHUwMU1ISUluMkNVMGt4VG1XT29uMnlhamprTnd3YzA0azJNZkhxN3U0WXZIaVRId1p4d3lPOHlWeFoyck5KZTJWalVNa2YyZFRNTThlWFdjdEk0eGNRZzBRTEx2YzhkcXJVeHJMOGFubDI2ZHpQRXh3d1RKdGo5c1dtZXJtR1hGdjFQM2pjS1cyeVh1WTBNTnZaRkRJR0prWjAzVVNtWFYxRThSL2lnY3p6Y3JYMU1FeG1lZVhsZDlFYkVCMnprdHJETGNkUFVvZFJPT29LYklQZjdpY1VMaTNPdTJHN2xNd0xKN21scVpjSE1NQnVVbUJqa1V3Y2VlWE1VUHhDbDEzQnBtSDFYSUo1c2pKRUV1ZjhZbkkvcXhFUW1XSmhoZVcxbTNDb1h0VXFZNERFTWJKa1RGQlgzQXl0R29tKzRkTU1aNGM4TU9UbUxyVXZqZjdoWnNtRFRjQXpVeTZsR0JlRU1MV2NLeHNOemNiNTB4M0FlRTQ2R0JwYWltZUFWVlN3TGpmOFE4aW1GRlJ4eFZ5dmJPT0o3R2FPcFRjeUlZanFHRTRjVzhiR2NiYmR6TUVQcVNyNm5qOFdJYjNsK1lHR016MnRSeG9qWFRMQmxIRzVRUWlhMTB6RXdjMXlIcWRFUHRNOGExREU5eXRwT2lZaFREUE13Y1RMSUpncFA4QXFjbTY2WU9yTzVkZHl5T05qVE9rbVRpd2RRTDJ6SDdMRFdqcWM4dVNROGlGVGtVNmw5enhsRUZkRVFHcG1XVmNBR0ZtV3B5L1RES3hZcFBlK3B3SldScnNpMEYwUzF6eC9FdzE1dU9nZTFtZW1zYW1rU3daZ1k4M1pNZUdkRk5rZUFKVVNwZ1ZrdjRtYjliUjNNZ3NRYVpYM1ZIVVhHcG10dkZqaWorWTZHWllWMnppdUtUTEpNYXFldU1LWFoxQjVQb0laT0tnemY1b21OTkZUeTBPbG5LejNjcDF2Y3pIR2s5d1RHdnpGZTE2Zys1dkhRZHdLanRwSGxNOGN2R0E0eitQeU9KUjNQNDNIV1NFTU1BMjMvcVpPSG9ndFVCZnFLNVVxQktiYWJJNThhQ2xpWkthRmo0YzArb3p4ZjhBaHY4QUx5OFBQUUxTTTgzK0kvNDNrZkc1R2FmaUhpdHZJbjhZQ1VGd01CK3lOVFB5K0F6RERuLzNQNWVLaGhpL2htZWVYRXNDNW5rbGx6UE55NHVYK3RRMTJXUXl4eDlUazUyRXI4ZHd3OHIwVGhtbTBJQVljWHlsU3ZGamkza3YrcHk4V0Iwdis1L0xnNVdlTXFmektvWWhQNWM2OUUvbHo2YzJaT1Zkeit1NE9QOEEyeWthdUF0R014Y2NMeHpCWjNrM0tOd1RnbFFHWTNNczhsQlk5czdoWTJNdE5qTU0zM0RKYkFtY0dYWk16ajd2NGU0T3AzQ2lMRFo4T2RFdjZjcklzSU9tRHBncXd0em9tb1pJM0tXMzRKNG5lVnBOekl4L2pLN2l2S1BVdkVGblFhamxxSHdMZWpWVE44U0hIdmpNSmhaaFRIeGg0bG1XSzdqaUJGcEFoQ1hLWVpIQkg0cUxjSGpUTGNuSjlTd0ppdUt4d3pDMDB4TW1PRU1iRlk4bGpraEhQQnJYcWRaMzZtWGRrc1RadGdveTV4TlIwMU1lTkpsM01jTVVmZ2hpQlpNcklCVzVsak1PNlp4MHplTXU0NjJSRk55dFZVNDRtb0NzZG0rNFdFeVFsNHZ3RlpTdnF6R1ZPYWVOeHg2WldvTGxCNW5GSS9UR3FsMVBPZUk4bUdRWHJaS3NhS2xYUkhCOURNUER6dE1XSGc4amFZVEQvRTgyWjFIL0FBdk1PZ24vQU1UeUp0d2gvakovK3NDWWY0amY5OGY5M01QQVp1V0RuanFZK0xnMXl4cVBoRzBjWm40TU1pMUQvVXg4T0JYMmo0L0hkTnorUHc0ajk4cmdlTWY3c1R4WkQ5MWdlSGo3Wno4ZUlPT0JiTUhubVlHRzQrWktDZnpaaXJzbU9ZNU5yS0haTHVKV0ZzN3grc0tyY3lLUmhibGMzL1pOTVNWWTZnT0FXZHdqcVlXaXpEQXo4a3plS1BZRXZsdm9qVUlQd0h1Y21XTXR5OWJobDVEQnNncWZCRFlqTWN1SnhtR1JkVkhDOEdpWlZxb0M2WndvaVhWTURKc3MxRVRHUFlzSVZjd05NREp6WUNZc3h4NUFucnVaNVllVElyR3FJWGo5cXFlWE5mQ1ptVzU0c3J1WTRaWXF6RDJwUExrK041SFRNOCtUYzUyUTMveW5NZzVaNVJXYkp5Mndmakhic2pueXkrRUppYWhWTXo3Smd1eWJtRkdWTXpRc21KVDB3TU9kWnFFeTRHc1Jab1dHV1BGbG5Hd1lOSkVLN25ISEV1NFVlSlF1NGRVemtZeGF4NVdXejYxSDlRSzNsR25vWlpFYTdqbHZ1WTVZR0g1WmtoKzdtR0JCYVVuS1hjR0RCdlBxWjU4OHFNWXJPVzJYREsxcUZzd3lNUnVMV1FKM1BFOFcyR0ptS3RNc1dVVGlsemcwTnpqWC9LSGoycXcxY3NZR002aXk5ekxjTW1xZ3NQcnVaTjVRaHZGbU9VR1k1VmhVRGxIRUM1N2lYbFJFY2NhdVlsbW9KREJoaFpQNDhYSFdVUEdjZXJZMy9WOGRWS0hCRjRzL215Y09EUlh1VzZxcFhhMUNqMHg3ME1veXhtd1FtSzVCaTlFY3c5em1LeDJwREhtMWpEeE9mTkxPSk12R1hpZVBhbHN6MTd1RFpwbkhPVnJYWkZ5bFlPRzJtWWJWbjVualZLbWZpYUppY0ZHYmhtbW1jWEp1eVpGbXlZK0xQS2poUlA0RHg1bDViZ1lYa3VVeXJ4K0l5L2ordnJLWi93Q1Q1TXNwbDVNc3NiNTlSdHBaWW4xaGcxU1d6eGYrUC95UE9uSHhzOHYrRjVmRDVqeDU0OGN2eFA4QTQ1alpucC9VUEIvajQ0amtML3VmemVMeEgxOFdFZjhBT3l3ZnJaZjRKbi9sWjVhdEgzdVorVmY2cTdtZVdWLzJxR2Q5dHpKeEdPUmxqckhaUEhtbVlvenk0K1R5YnZST0daMnorT3NQdG1SUEVHMW44bml3L3dDS3orY01mcGhIeVpKckhjWHlZN2M2SXQ3NXJLR0Q0K0NQY3lUcCtBeXhMbVRaQUl4Y1hHbUhDcFp5WWVUc3hpSEg3ZHpseVpsb2dLNmlwcVc0ZHlybWJvQ09xaXpBOU0xb25pek1ES1hUc3VaSHVaT2laSHFYTHRnNllNTUwzRTFDNFl4MjZpVktHSS9tQ1RKaGdrQjVRUVVtcjB3M0RiSEQ3UTJzQ3o4UVpVRHVLTWMzTEhpOUU5ZHg2UGN1cko3STRtcUo0eHU2dWNoVk1hbzZnNVpQR3RUTER5T0ZwbzlReHlSdkZvbkhLeXNXWllOMXhaaGcwaE5md29ZN3VCa1hxVnE1YWRSMjJ5ck80WUtUaCs0WW5SUDhQL0RmOG55dko0NFk5cy96dkw0MVBENFU0WVJLbE01S2dtaVpLdWliR1l1TmJJVWpNYnV5ZWJMRTQ4Y2Qvd0RKbDJxdXArL1UyMWtSeTV0d0NFMWRURFhUQmJtU25aY010YkpnNG9zNFhTRXl3MU1qWlpPTHVOOEVnS0ZSeVRHcGRmdURpbjRZR1dWM1dpR1NJTXpGV1ZNUkk0b0xkTUlEeUxsdC9xTzhXalpEQ3pUVXh4eXVxbjhYa3NyQldQOEFpK1RNcCtyRC9GeXhieXlOUThYaGM3eThrZjhBNG9yYXBQNS84ZkRGVHdxdy93QXJualdHQkgvSjhuaHNBRjcxUDUwZHJVeS95TTIzbTFQNWNsdTFHYzhxZHNFc3NsTGt0emxTcE9Ua0JMMko2aG1jSDhzVnhxZVRKY2NXTjdWbTJDa00reW9KN21HbXhaMmpjYjVwYzJNYlVKVTI0YVJQeFBzMzZnTXBwbU9LN1djK1p4WFdQVXlWM1NNQjR4ejhtVkNtb0Y5TzVtQkd6Q0dENC9EajVQV1VXbG5Ia01jdm9ZdnFHaTVqaXRwSEU0M2RNNmJtVzJHb1paZFRkQmVwakVEWkF4NU54WGpBU0pXeGhrc2RaUzdSbmxDeXZmY01qbFhzbkVUSnlhV09YSXFaTlQrUXJxWWhtWFlVUXlhaHJKbTY2dUhtNVVCd3J1WmhuOWpRRTNsZzkxTXNmcGlHbUE0WlRDM0J0dGhnNDRYYXp5TlljYnQ5VGlqVVNZV0M2aXNMT3BWNDduMnhncnVZMmkrNGNtTFJTUU54eUYvVXBxK01jbm9qcG52ci9VNDVPVk1Na0xTWHUyY2h3VngzT1RUK1prcnhydjNGWVpBc3F4bG9CRmcva3NucWdwbHVBZ3psTHRnQUs5d0lsRWVUVzlSRTFjc3p3eEFxYSt4VGZxY3Z3VEZVVXFZZU1jdVV5endDWlk1QzcweHNoZGFnU2k5d2d5a0ZpcUdwUmdoRDYzK1dZOU1jZERNM0pwL0V6YlAyeHc0NVl2THNpZmVqcUpNVHZsQ3czTXR5MW9JNDBUajlDdTVSY2NLTFpVY1lZMGJZNWZXWmZuMTZuaXk4WDhXWDhvdVZhbk1TNm1QdUY0MlFJa0liWmVJdTlURVYzTjNBKzdjeEVKWXFWTUZMSmlGeThXdFVYRjNXRTU1WlpybGxNeDVXNHRTdVQ5VFJBNU5tb0lMUXNjaDFNY01zOEZOcEZjU3FxWVpXVStvNVpaRlhHeENIdThaNDhNbTNVWExFVEhSZTVsNU1xVEZvVGNGd1RQRjNVd3dhNVYyd0RKMEFIYzVYbllhSWRMN21Hc21KNzlRdlhGaDQ4dS9VME5rWHBOeHdYSlhHb2VQTExQYWFtR09HYWI2N0pubDR3UXgzSHlaVVZXcC9LcHRiZ25Qa3J5ajcvY2M4djZjbmlkRU5MVUM4VW5GR2cxUEQ0blk5TVBMNC9CbmpualRrVHcvL0FKbThYZzhLUGl4Y3AvbWYrU3ovQU03L0FDbnpWVFBKNS9MbG1xak9lVFhOMUhnNDFpVDgzQmNzVnFHTGVoWWY0K2J1UGk0THl6cVY0Q3R1Y1BQNC9HS2VGRi9MUDUzc3hDTG1uTG5Nc3NrcG1QOEEvb21WWnVzZC9EYXdZNDNCVUNwVzJwZXFEVXIya2FHNDdtT1hIRkFoZzVaL3FPemlUUjlleWZlcXFpWVdNVDdSc2F5SVk0MkZ6aGc1YmFuOU1tbUNOakRhd0ZZRkxjejJ3MGtWZ3ltcHVydUhWM0Y1VE8ranVBcmJGblJVR21LLzFKc2FnTUZiSmRReXU3bUFMdG9sQm0rNWsrZ2xPSmJITnU1YzhmajhmbC95RHg1Wm1HRDNuUFA0engrYlBIRFBuaU9uNHJLRDkwV1krRXlGTW9ZWXBUNUFxWWVNOStUQ29lREJ5UDhBN2lIaDhZUC9BTnhEdzRYdnprUEYvam5mbXY4QVJNc2Y4VWF2SmhsL2lqVloxTC94ZDhjTTJIbThYdndrUDhuQXpFOEdIR2VML0pITlR3K000elAvQUMvRC9BWmZ4WWM3MkJQL0FKaHlIK0hHUCtjOGw0aCtTUDhBaytUTnNBUGNQOG55SlZGencvNW5DLzVjQm4veVFML2l4dG44dmhRNWVJaGwvaVo4cjVFOHVIK00rSTRlU1lmNDJGNzhwVXkveHNEN1BsS21Iai94Z3k1ZVM0WS80bU9kT1djenkveFhFTU1mSXp4ZVB3K1h5bU9Qalo1dktlSEQrUEdZK2JHLy93Qm54bWYrUmovL0FNTUNIK1VEL3dEb3NZLzVCazY4T01QOGpIRTM0Y1kvNVBpeS93RDFSUDUvQUcvRk1mSi9pT08vR3hmOFJ4K3BtVERIL0Z5d1RZdzhQK1AvQVBqbjhmOEFqMXZKcUovakJYTEtwZy80ZUIveVdZK2IvRzdjWWVYL0FCK3pDTDRIZkdKL2ppWkpLL3cwNnpKajQvOEFIeVVNc28vNDNpNlBJUS94VFpqbE1QRUpSbDFQRi9oZVB5ZU5jczQvNG9EOTQvNGVpdktURC9ETXVRK1VuL3dIK0ZUeW5jdy84WDVYYm1NeS93REcrYTNqVWY4QXhubk1SUW1YK00rTXpGeGNtSCtGbTBDV1RQOEF3YytKZVlURC93QWJtdXN5WmY0UGs0N3pDbVkvNE51L0tkZTRmNE9MZi8zWUUvOEFpZUxCckx5aWtQRC9BSTNGZjVKNGN2OEFIOGJtRzVmakJUQVpoL2tyNUVQRGlhbWYrWDVRUWVLZmlIK1Q1ZklMbm1xUnl5SGJObVJPMXNnbE5FeFVMeHVjbitaNXpOVlgxSDErSjR4Tms1RnJHK0pxRzduRU1ZR21vRllMRjBKRmNtZUorakVPS2t1cGNjdFFxdHpsaVlTOGFHRktwTURuZ3d4Rkc0RGpmdWVQRWI1YW1YdVkyR3AvdG1qcWVMRXpYZkVqazd4NUNUQWFZTHk2dU9MaG5qWlZ6S3J0WW5QTUIxRnk1VjNnYUp5RzdobHhZOTVRUkl0RkRFc29tdVFFNEtzUVNmVXdwN25EaWJaNDBCR05Oa3lvU29DdkdKd3paUi9kZTRwV3BpYXRsUlZKYmpNMW9lUTNNR21aVXpQQnhoMFdWS0sweDQ1Y2YwVHg0NGNPVG5UYzhuak51TGN4eXJMRU5uc24rUmxncHdLSWlZWVpFTXVXZTU0VThtWmk3UDFIeW5oLyt2QktmelBLNUdhQ0tmaWJkdDNMWmlGTjNQclU5UWZ6TW80MERDeFozbHRpZzEzRmNYK3NybTBGUjVZNVZ5NmduY1VsWXBibFRCOTVUTHhJQW1tWlo0NndNZXBpL1ZHQTB1UHFCWmEwekhQRXp2c0o3V2t0bC83ajNMeEkwZ1hVY1NqUGxjUVZZWWxNRWxYSFJDdUVVbDQzQ1lqeW1GQW1VOGZIRGRXUnpEWWFZdDV5MVVZd3VHUkE1RE5Ga0VDb3kxeEliVUlZanM5U21VOEl2cWNkck9QTnUrb1lyVERCcGpoaHlLeXVPUlRSMU1jcmllNEZ4VVdVWTQ3N3lnaC9hSVdKMU5MTWd6WGZVeHBKV3YxS2xNR0J1MkNTdFg2aDNPMXIxTS9KaG1sWVZCZzNQNmx3VmxmZnVEeGF1R2N5NVpYTU5GTFZzT0k2YlovTjVFNEJ5Wm84ZDNXVStwaGEvYVllUndlcldHUTJzTTNDM0ZxNDVyaTIzRFJ0bUw5WVplTThTcHVHZXJ1YzI5WlJVTFp3ZUpuNlo0OFZ6UW5QTCtpUnhNVzQ1aGRFeHlXTWZIay9XWWY0K2Rrd1R4Q0xjY3ZEMXgzTTgzR3J4SjVzMWRaekRNeHkrNzZncGx5cVk0Wkt4RUxqYUZFREplcG40czZ1cHh3Tjhyamxoai94bk91c1o5MC9Fdkt2N1Jqc0dHT2JsUk1mOGJQT3AvRGsvWEpDb1k0WUtjcm44bml3eTNnc3o4elRRR016OG1YQSsydjFMenlRdGlHR2Raem5XZDQyRVZYYy9zMTFNM1dKTS9ybFhaRnlOK3BqNVhhRU16WXd1NDVnOVhETUhjenhMNVl2MWhveVNaZVE0YXhqZEFzZnhETDBReWJqdkJScWVQRWNyY3RIYzRZbVNuVXk4bWVhNitrdWpVTE4zREsybDNNY1RMSnQ2Z0RZN0l2b0lPNGFZV0MvT1AySDR4Rmx2VThQaUh4ZVFmVXhBbFIxbE1yU0JML0VPSzdsN29pT05mdUZqY3RWbmJ1WlVzeDNsRTNjOXQ5UXROZHpiQm9tV0s5UUtOdzBXbHpMeEo0VHpEdDFVczQ3N3VZTTViZzkzRnVwbGszVTNURTZsczlsVEh5Wll1VmY4b1dHNWo1TVRESTQ3bmo4R1poaGtKdWNkSWxSeHlIVE1qTHQ2bUdmSHFYZUxBaGpjY1pxNDhwaXVMYnVjdVE2aGNYSjlFOFprNThScWZ5Ly9IOFNZWmJaenl6VzIyQmxzcmNMM2N4LzNxRmpmcUxsMWR5cTliaHNZS0RxR1dvenZVdmlsc3lNV1k0bE1yVEJ1aVkzaW9WVXh4c045TXp3eWNtb1dHMk9UajRkTmt4eXlDeDFITEkyTS9sdnBZcWdzRkZncGU1aGxrTjJ6eCtSY0Z0dFo5MWFXWmY1R1p5eHRKYTk1V3pNY2NETXlobGttMW44bVkwWk13enl3eFZ0aG5sK1l1Uk9XV1RIa1FuTXNscHU0c0doSnZSRUNWOVA2ekxlUEVOekR5WjRaRGpMVnhzOTNQc3JRYlkycVFkYTB6R2ozdWVIeTVlSlN6N1RJTFM5eFNxZ1ZyMUhIV3B6K3RTbklsY2FHWjlhNmx6SEcrVEF2SGN6VExMVTBaRW9xc1k0dGJtQms0ekxCd0JuTkJJWnVPRlM3dy83aXBETDZJbHpFdlFUampocFBzZkdPVGNNZ3pHT3h5Z2U3MHpHc01YTWR6SzdqbXk3bGxWTkN5NFp3SXN6SUZrMkVzZ2t2bGhVTTNES1pHK1VMR2VPTm1Ra1c4R3U0Q2hNc2FETngxT0p4NVBVeXRYS0ZsS3hiSnZWanFaSlJHOHBmcG5qd1VTUGl5TVVNaU9DWkxsaEZ2eFludTVUaXR6eGViaDFNczNMTGxEeUIveDNISnlOb1M0TENrUmwxMU1USEpibVRyaU15UlNaY25xQzA3NmpnWGpsbGpaTTgrZVJXTlRkc1d2NnpGREZzZ0xxVnUveExGVm1EL1pQY281NzJ6TGpmNG5FeUtuRTR5aXlNUTQyZHpBK2lwREY0ZFRBT2JBWHZxZlVVcUEzdnFKZjlZdEVMOXNDbzB6SERMMU5uZTJZdDltNFlQSmhqaUR1djFNUEg0Y3ZGNWNzODZ5QTRrREZWdUFxaXlvRk1OakMxbWRtV3B0N2xZY0lZUEJ5aGlKWjNPSHVLb3c0MEVTT0lrTU5YYytvYlo1YzhzOGNMWWdhSTBIN2doanNJSitLbUdmRzVsNUJ4QXhtR0dlZXpHWmc2eXhwaWZqcUdPTG5ENnFTcWh2SFh1SlNUeGZYTlptRnFFNGpTa01RWDQyU29ZbGZHQ25VdFdJdlJIVXBoNkZqNDNTb1RQZ05kckZycWNzMWp5dW1XOVJwREdGanVVTHVaR05JVE1FcGhvckdJQjNNVER0eHVLYzlZUXJFZnhEZDAwUVB0ZUt6REZSVkxtV0hreUVoNFVTODV3d3gvc3F5NmJ4ajVzMGhubGw3M0hONE9KTWRCY1VXS2NuM0E1ZDR3d3Y2MXBtQVk0b3l2RnhYTGtzYzhOY0RLWmVUTlNzcVpoa0Evd0FnNVREQXo4bkFmLzhBS09HZUdUZFVOV1Q3T1UvanpDaG9ZZUU3NXdQRVBheS9HRDlJK2V2TlVjcytUY0Y0TEx0WVFQSGxoM3VORFJ0Z28zQjVGc0NzVklaY2RUWFozSFBKeldZbTE5emROU2tweG14Wnh2VEIxeGdnVk1OTFUyTFR1T0p4cVlpWER1bWNUcUdLc3l6RkNwdmU5VEN1c3VwejRxSFVTSmtsUUpWbHp4NThCU085UTkzTlJmaktxMTNER2kzNHhXQ21VL3gvSTQ1NVRMRzgxak1pMzRPcFl3cURISnZjdVhHNEpVSDZ4L3BjM1lNeVcrcWhsTGpEeTZweGl4dDF5blJhUUtqcTRkazZMaXJscVlYU1RQUDZoVUlZN3RoUmR2OEFxT2VvTmlNd3pXaTBDR3p1MlpNQkJHQ1ZEcENFekh3NUdPZWxMbVdXRGgyOHI2aDVGbmNQN2R6WlpjNWZBcGtUSjd1QmJaM0F5NXFPNmluKzVrRmZpRlZTNmgrb0ttNWpRTnplNmFqeXhyM01MYlpUR3NpRmozT3JDSnBDVWxUeHBpbDdKNWN2QzVuOFJxamNWTW1EUzZ1V1lINS9Vd1YvNDZtaXdMSUkzV21HYWxMQUdjTUZWWWdQY3d5UFVQSTRHVlBjM2t0dXljVi8xTThheTAzai9xYmdNYi9NTmRUK1RMTFVETHNuMm5pcm5lZWllVGdXNHh1NHMwc0h0ZW81V0VjbmlZbmM1ZzJiWms4YVdjOGVPSEtXRnVQVVhGYkprRjJiSVYrSTdvL0V5eS9VMWsvQXQvcVZqVE9MVThlMTlrY004OFZENmtvajQ4akdZWEErMXM0M2NQcm5PRGxNc2poVjFIUDZWZHpFdU5PUnkwVDZuam9iM0FzY2ZjenhjRUdZNmVReFZ4NU8xbmR6M0dwa2xBUTJoUE54QXhxYzd3LzFLS3U5d3Rab0o0c2pBU3JINERUTWRGd2JpekRGVkR1SmtrQTl3UzlUa2pkUVhJaXpGRWcyRlIvc1cwVG9RTGwvV051T3NvT1hHcVdmNzBSOFRmSWRUR3RUUGtqbVl2RDh6a3FhbVBMbloxRTVac3l6L2h4REY1TWNzczFWUkkrVE13dFllUTB6THljN1hxR1VxNFBveGl0N3huTWdjVDlzYzl6REo5a01nekxJWlk4MnlOY3JxY2xZQkZ2WExxSVVVc3hERnQ2Wms0NHYwYnVhWHVZNVk0TWFSVHFlSUhOSHFJYzZIVVpTdHU0NFpBUDVnUEZqNG5JSEFnZmRpYmhobXZlbWNVd29icWJGV2M3d3h4SXBrVWxKS2VOa3RHWHFnbUlEdUFMSEZXT0daTVhobmJ1T2ErVGs0ekwrOXVoaXZPWjA3N1RxS01VK01BdmMvSVJxeW1KOSs0Q1IxQWVONWFtSVhibzl6TU1mZW1jZGdRQXN5Z2ZodUp5SlhxOVREeDRPTlovOU12aXFrZnUzTE9kSlBKeFg2ayt4dG1RZE1MOUdnaDVYRTQzVnpOckx0WjRQOGZMeStQTFBRWWQyeXR6TXAxTWRzSEZmdHFXbHB1R1ZHeVZ5NmR4L0Y3aGdUTHBJbjBnVEsvVTRUeGdUR3JkUlg4eWlyN244ajZKeWRyTWJTc2xZV09VKzBCcFpSazNlb1ZSRkRLNDVXekRITmRWUkZESWkyT1ZSRjJOU2xKajRtbWVML0Z5elR1ZWYvRHgveGNPZmxPVjlUUFBDN1BxUThtT084UzUvUFp4NDdabDVCYUxJYXk1WExNc3JjcGppKzR0czNZUU0zc3FvRERDbmVoTGp4eEJ4eGptdHpESUQ3WlM4T2FyRnYzQnlXOFJxWStMTmJUYzRWaThzcWcrSTl4OHVHR0hISEMxZTFtWG15NDlCTVR5ZVpieTBFVCtPbEZHZGlrUHRpVEljc2hxZ1lvOVMwS2pyL2JNQlZFcVhRa0JXWkJ4bFBpN095Y01IeDhzWGZzbkZTK014S3oreEZUVXJkM0N4ZjNOWWxEdVpZQUNzeCtuN21mNVltcDQ4c3dvSXFaOG90NUtUa05GMGU1bUdHZGpjeWJiQ0hjckhsSFBEY3NjaStvb1pLZFZEZTM0cjl5N05RR1ZwVitlNWFUR2NVTHZ1WTZabTdzbUxlVnd5NDB6TjNaQ04zVXlucUZHdUU0VGk0enNLSTNNZmU0UDdaVnl0Vk9pVzVYbHhqa3BDVnFNTy9nZU9mS0JrSFAwelBPNGc3aHYxSFdwUlV3UW1XZHdZWDhWdXArWmlISWxISjRzV3g5eTlWTmtNb1VqY2VTN2JkRWNjakpscE5yb25GVUtqZ3VvWXpqOE1MeGU0R1hKYmdSSW9vUVpjeEZnOWtSWmhrNFN4dG1KS0dBczJOUHhqMU1HM2JIUzNIaHhPSjhqeGw4VzVqNGVXTG5kVEJMYm5FeUJ4bmx4TGdVZHh5ZXJnM3Evc1F6eUh1SGt5WHVQa21PZGlKTW5GcHJxWGprNjFNTUJ2N1F4VFdPVU1jelk3bU9PZVdXNTVBd3JWekozL0FGbHExUDZycW9QTENmWExHNjZsdU9GamR6SXhjRVNrZ2t6aHMrUDlSd0I3bTdoMXVXU3JpWThlb0V5eWJpcE1QTTRlSGllNE50Vkhrc0hpZkE4WmlybnVXRnh1bEFobGowa3Y4U3RLVHVybDBzVWN6bkJRUUNaK053ZURPT3BqNHh0dUFXZ3d3L2N4d3hHMW1iaTVMeVpWNklsRlFLemxhWmhBQko2UVlTNVRNVjNVNXZEak1yZ0pzaTVlNEpVTTRPb0VTWWxpd3JqRExIRnRKaDVYeHQ0RVM4NGh4N21CeG1lYWVEZ2RMdU9BQ21SVUFDeG1MM2JIY3VydjJSd0NHQU81bmhpNnVBQkFFdUpYVERGdmJFVHFLM3RuRzhidWN3ajVDNCtUV29YbnRaZnE1aGpZc0xMaGRUSnNxSlROc3hNZ3JqT05GcktjTjFkejkzVWNWOXdLbVdXdjlSVTZlNXp6T21PV1hGbTFobXBQSDVPQXhUTnRtS1hMeTU2SnliUmhsdVhiMUhMaXVpWThwY00ybTU0K0Q1RGxyYzhtQi9MbHhmcVRQUG0wZXB5KzIraU51YngvcE1MNW40WTR1T2JaWXcwOVRySWFtYURvbU5kcE1jc2Z0Wk1rU1hWVWJtT1k1UEtaSExOcnFmWlpqbDlobWJlY3hYSEtmbVk1ekRLczdlcFk1TE1hNS9xWm5iQjFGNm1kSVZQekdEazlUK1ZCRm5QTGtCMUVlVk14L3ZBY2xoZlUvd0JTa2JJTWZoOGFGeHhhdUFrYTdtcGpER0M3SndyYkNHTjVhZ2Jaam1qTXZLNUZZa2VTRXh3bkFMbUJERytobkhUOVFuK0ovRC9Ma2ViZG1vZUlWL042SjRzZjhVd1hQeVRML0s4SGlQcGp5ZjNIL1A4QU1GWTBFOG5sODNtdm5tb1N1UmNZWWppc1FJZUt6cFpqL2pOeHg0OXBVSEU2TGpsemRhcWZiM2xxZlhBc1krZHlBNDlGVFBQTnFqcUhpelgrdmMvZy9LVkhEd0hiYkR5NFlQMThZaitabjU4NmVQMS8xT1hrZHJmN2xPVHRtVFJyVXBXWTRMTjlXaEt6OGc3ZU9NVXFZZm5GcmpMWEYzQktJa0hMc2xyaU9UdWNmdC91Y1hmSDBRcW0rNWd1Y3g0WVhiYlBKbG1vRXR4ckpibVRqbjBTZ0NHT0xseUdlVEk3SmZLSXZSMU9MVVZ1R1ZEeFlaZlg3ekhQYUJDbkpHY2Q4Vm1HSzNXNmduR0FnN3RuRVRadUpyOFFvZDdtSmR3S3pibXZ4RGp3Nm1IOVVXTldrTWd5Q3JuQm8xSFdvU3ZhUWZ4TnhzWTF4MUtvR1U5TE1jYkdPbzRaZmljTXZ3ekxtbHBVd3d5bFBLSzY0dFF4WHVvK1BoamZJaGhsa01NRTJNLzNOUXQxeVRHT0laYjJRSU5FWGNXT3lBaEJhNDJ6OU1GSmprbUNHMWpqT3NxbkJhaWNHcXVKQyt2akZET0cxV2VBTXNxbVpUTUQxTWo3eXk5L0taRWN0ZHpGM3Vja3R1ZmIrTG5aTXZKcUdVRldJeW40eGJPcGR5OTBreXBiSU1KYUVLTXBadUxvK0RaQkIzYVN0T1d3Si9iWk54R3doaUdSZXlaNURtNUE4VDRScVpGTlMxbVR4QjdJdkxDOGVvN05GVHhadUNYdVpZbmx0QW1YTEc5VEpQYzU0NWVJOFpnY3YveCs0bGZnbmpDbFVuQmJiSldKNCtYSnVPWElsN21PUVE3VWd0MWk5eHZCcTRaMjdabG51WTU0M2JNbkhMTGM0WWY4Vm5Hc0V1Qng4UWFXNW1jcVZoNHhnV3UrdTQ0Zi9oYitCZ0syMFJiN21lS29rcmV5SHNCaGZ1TERjQU1sUVpnM2plZ21KVjVpSkYxeVdHNWRRUkpqMFgvWDh6UFBGVXJSTWZzb2RUbGlXY0NQSGlCSExTRTZ3bmljVEpjdlV6ZWVia0ZYT0pjTUhiY3pFUzNUT1NETVNVMXFONGVIajJ1NVRLUmdhYmR2VXBHNERFVGN5V0dLYlRVSDB5L1JPYkJhaXN4M25TNm1XS1h4WWZ0ajJ3U2NrQ0xsamlPbytUVXhzd2Z3ekZicVpZcGpaSEI0Y3ZmNG1ZRHJjd3JsOXVtVlRwMUV4bzVkekUrNmRFY0N1VEZ4dlJOcXpIRDlzWEEwRnN5dGFaL3Z1WitOeFE1Q3hFSmlFMkV0dmN4NDVqY3llT2cwVHRkUjhOSkhFUDNPSW1sSVlsRXN4RmlPSjAwKzRPNitBV2Z1SFBqZnFBWGJGSHJjQ251Y25KTkg3WmJ2N1IyQXdDa3FaZUl4OFJrS3I2bUJYOXZaTWR1bWVUL0I4MkdCa1lMaSs1NURJeW9PcGlQL0FDSUlPZ2xaT2Y0SUQzTVFxTGc5Q1RRdFRjcmM3ZWlHTHU1bFpnNU90eDFUTERzc21GVnRRWlZLa01udTQ4dTVZR0tzekx5dkZ1WktnRVAyeXduS3l6VEN1MTNON1JsckhGRXIzSDY5ekJMdUphNUxCQWJnMnNCTFNMcmpVWmgxYkswNUV4TzQ1Z3BPWmN0TjRrdThLOXpJOGZIRGhtdVh1TXh5UjYrQ0dPU0xpZFRCNUlPcHd5QnkxVVVEOXdRVGtTKzB0bVdML0hkVkRIUnVPQnltdVZRWXJCY2FtV1hKdWM3eHJVeFhDL2NGbmpCbUhqMzJFeSttV1FJd0NyV1Z5ZFRaZGtQTDVNZkg5RXh1UFk1TnMzanVjY3g1WW1Tc2ZIbDVnUEdYL3FaK0x5WVpVbE1Sc3VZcmFrTWVKUXdEWXNEREhCK3pQNU1kQmlNd3l6eXoraVlRVkhMUE5YOEU1RmRhbk5VNGxRd3l6dEllREpLVUp3OFFGNUNrZkpqeS9wTVBLWWkxM0hOVzdaall2SjFQYk1QNDYrK1QrcGxRL1haRnJjeFkwOXhhQ3B5eXRKanQyUUVVT21lWEVBY1pnbklzMHpCRGxxVVFmVU1TOXM0WEtiSmVmS2ozM012SHhyWWt3MWY0bCtORURaREpkNm1XRDFLcGk4ZTlrczJueHhRdVlaWUdGVjNNL3IvVHFhcjgzS09xM1BWVXBNZkdQaWZKaTcvRXNXMlpHQmpwdG1HZkRROXpnZG01bXJsckVKYmlqY3R5VjduWk1QczhUdWVRY1Z4OWszMWNPNlk0RlN1MU9vZW5xT2JSOXVva1lyUUxBNnBsMWU1bEM1Ym5DZy9jTlJ1Mk54WDBzVy9HUWFGZ1Z1NEZzV1dWREo5S1F3WGR4WXBCOVIzR1A5SlVEVDhZOWtXczVySmlNd3grdjduYS9EUng0c1J5OXpqZnVOMVIzTVgvQUl5cVdvR3A0ZFp6SUVkVEFLZFRmVXl4Z1RIQjdtV0luY01aeFdjWnJoRHJaTVFqSDlNNTZxb0dOc3hRbDR4UjNBeG1vQU1helVKVmJsTXFKREw2ekVZWmhqbGpsVlhNc2VKWk9GbGp1WW0zZlVjZFhPR1pnQWxNMlJHWmVQTndNbkZxNW9YWFRLb2NtWVpuSFVUVWY2Rmt6ODJRVmd6SExQSXRqMnN4b3ltMVlxZ0FhaityMnoxVEIxb2l5eXBoYnFiRnZWUlhKdFpZbFJFTFRVeTRGVVMzSkFpSk56ZENSNUwzQzhWM01jdFVrOHZsRVA0c1ExdUtzeE1iNmc0UmNicjFBOGJuU3RFRERFYVdJWGZPR0Izem5IRC9BUEZPQkhHWThkR3VvWXVXQ0JxWTRJMVJVZkZXT1dZa01WTnpScUhKeDRlaUk3SVlPR1BNeW1KYTNLKzBBcGJuQyttQUVMTWJxQkc2L0Z4b3hCYllvRUw3aGo3bHBhdGtMRm5NL2pRYmY5UlNpc3JaYmtNLzRFd0hLNDlYT2Q0OFVsbkppQVdTaVg4R0tOQlRMYjI5U3l5Wmh4MU1DbmNNdGFpdDl6L2loUDVGd01NMG9JS04zUDVkZHptOVhNRWNFcmNmR1pZQmNSR29ONnJjeit1SEs5ekxMUElxNWlQUjNERXhmdk0vMDZqYlFFODNnenhDMmNQdWNuVThOZUxQSTQ4bG1ieXlvSVZvOWtUazNIRGR4d2IxMUhISmdMcVltYVRBN0VpY1JodXBqYmFtcGw1TTg4REJxc1pYSDR3RXVZWUdUM3FjbmxSL1VqbExUcVlpckE5VGk1NWNQSGc1TUY0cWt4dExDRGtyZlJPOG9QR3doL25lYzhIOFJtMUd1WEo1WENyKzExS3c1TXg4eVk2STI5NmhqNkdlUERrcGN5TlRaWHh4ZTVtOGFwdlpNeHl1MmQ1MHJBMDNkU3dybEhJTG1nams5UmRRdXRTcXlqaXdtM29sVGRWTU1jaG9TWThoeXR0bkgydHdMZWduL0w5UnhIdnFMVFVxSSsyWTRhdmxjV25qTVRKSzlUcjNxWllESEVKaTduN0pqckUxdG5QSVlXYllXMnpqTjQ2eGU1MWx4bU44VVhVenlQSmxkVUJNNnZVWFVjc1A0UXhWbU9JOXNRdXBSYk42b2pobTVCMUF5ZTI2bUhERERLOGJzbUlJUXFGVHB1T1hMTzJ5UFFudUFyU3c4amowd3pjcmhnOFI1VCtSZGV6OVM4aWpMdVllWHlMUnFmOEF5UEpnTmdQNjFIUExOY3N1NXozMUhvUW1kVWJsQjdobURNVnpXaVllREsyUGd4QzhzNm1MNE1OYnluOGx2MHduODJTYjFETlYzY3g4YVZsRjNVZnNhSTJhbEppdVEvcVpabVJPQlFqM0tyMk16TDA5azhlSXhLWnhIY0VxNyswM0IxSyt0czF4aDdBbUREandYM0RXTE9Wb0U0NUxjd01CWExlb1JITmExUk9zYWNhL2NlSmpaQjVVbW1aUDJOV1JNVmE2aVY4S3lpcXJ1TjdFbFVrRHUyT1RqalVIZWxDQnQ1Q0VQSGRwTjdsMlVUaWozTXRKWkdHUEh0bkZ2a1JzTFcxamhsZ2wrNXhLMXVGWE1wbm1aNEFGSVF4NGsya0RUTzJKYlJETVBId2NOeC9SSzFEVUw1V1QzTW1vckZ0Z1hOVlV3WmpwWlY1VEpESGpXNFhWUjhod3FveElETnhucVVzNHVXaVpZOFdrZzFNZDRyREY3bU5pS1JhV3BTc3h4bnVCTENPOGRSS21NR1lheXVIbWRuR3lZYnRMbklWYW1XNVFFd1hqTWlKbk5qTGJqVXVGMDFNc2hxNWhqejBFNFo0eTlyQWdTb0VRdlF6Z3NBR0tJblU0SmhwbHN0WDRNeXFTWVlwczhmSTlqSGxpdDlUZ09GNHpqUnVlTk9XK280aGtVNnFVY0x2YzN3NXJQOGZ6L3dDUC9GbGova09kMTlRWjVYRjZLSmxzSUZaTThmTE1xcDVjcXdpN3VHZVFWVXVDRDZZcXdOUXlvbDZ0M2MveHNNL041RXhDZ21RQ2lVakFPNWdqMGIvTTh2WHFPOTFVenh4bzR0TlRsa0J5MlI0bVdvV05rd3pmNG13djRZSVREYmFURXh5eTJROGZIeE9XUWhrNm1SNCtCK1lDK051ZzlNeUFaeGNobzZuQjQ4aUJXT3R4SEwwVGhxY1FMU0p4N0VQVVNZWURtRjFiTXZxdUk5VFB3NTRZOHJHNGlZMHpFVHBqamN2ampjVDdGVGVpb0xiRzZoaFpicVlMaVphdVVNSFZaWk5TOFREVnpscmNXcFY1VEE3SmpaNDluY3orcnhxcGRaaEN3UWdab29HcGlvMnkybWlja0tGaFhHazNNc3ZDK0RpRHovTUVodHFOQ3krUUZiampTakJXN3lYNUZiQWdXN21oYTZuSGVweHBMbVZrRzVrVzZOUzBZSzRER3NTeVlqcHE0K1BGVnVwbmJueFRSRGViQk1jSjVNMUF4SUFpNVpSemJvSm1lVE5BR3c3WUR6T1ZUeVhqbjlIWDVtaGFkczVWdEppN2x3ejdLbkptM1pES3FzbUNjOG5jeTNENnpseTFPc3FxSzM4RCs1anBaeW9RbUhwVzQ2Wlpqak5MRHl1Ry9IbGxpL2tZcHdTOXh6VHhCaVYrNDhnMUZBMUJZNWpqZnNuOGl0Unp5ZzVyTHhDTGFzTkxiTU0wYUFuRTVXeHFEaWxYVE0vS29IRWlGNm1lVlJ5cmJPZW81dWYvQUZMRWJtT3p1WWkzRU9EK1lQMElYK0pqc1RMVVJxRjdtSXJPSEhLOHBueHU4UmdnZ1h2dUpTMU1mYk1RcGpDTHZzWTQzMjZoWVhqTUF5ekhLNjlzemNSVEZhaTR5c2VHbmNjRmo5bldJVkRIcFdDRERpLzdpcnBtQTdTWWNhZVV1WGlNVVNXMVRNR2o4a0JnN2JsRUNCTU03eGRYVWNNLzhqeFhqaFhFbmk0NHJ5WlRXNjR3VXhaZTZKL2FZNm1XUzZDWXRGRXd3Y3h5VUVqamN4OFNKREVPVTRZNDRYZHNmSmp4R3J6bVdXYUs2amwxZTRKYnBKZHVvYzNRTVA4QUd6TjVvSDduOEhpeEZ5OHBrZmpHZnpmNDU0cXc4TjVmbGg1SDBCSHlaT2x0bVprVmJxWU9PV2dJbVdQV1RIRldZK085REM2clVPMzh6SEhJQ1o0V2FtZWVXV0ppNU1TbjRNZ2JJTnJrOXN3endGbkp0c2x4SG9OeTVwUXVab1VETWFUTGNMZjFIdjhBMURHb09rUVlYajZnWk15SHZWUXlPcG1uL0JtV2RsTWNpNkdYTjR4eHNzaGp5Wncyelpnd3lxc21jblBjWGNyZHhZTGR6SmNpbDFDenBZZTFocC9UN2pwYW5KcEdMZEZ3eFhsTmh3bVRhQjZqbXVkTGN3emNibGppdnVQeFp4Q2I2bnVvWGV5ZEt4dHhsMHpUSHRxV1loVHVPOXpKTGxqY0NIVU9tRTdJYWJqZVRjQ3JaaW1RanFBUmR6UmpCdU0vNDFMQ0M5aUVjOHNtMlloVW9MSmh1T1gvQUJxWkZGeFlDRnkvck1aUS9EdGdmajQ4V1BPWllPR25GSm5ueFBwY2RFdGxNd3pEVXlMSWI3eWc0aTlzdHVMQmdrYm9xWHh5WlUya3M0VU13bDdnckxRMnpIUDlzQnRiWTFSTVZjbkYxRXl1WWtaL2ltRC9BSk9IOHViamd1MmY1bkh4L3dDWDVEd2VWejhUMHdQKzVndmp3c2c2KzBBQy9Vd3pKNWNNdkQ0eHZXUkIxTVU3ZFgzTXNzTWEvaXlVZTduR3pSYVJweHRJR2VHSElkTXk4aWlNOVRGZU5LTTYwbHdMaFoyZkdEbi9BQ0xrV1JESi9GdzVZWGxoWWtNUlAyL0c4UUlndmJPckxnZExEZHBOVmJEcmJVM3haenRaaXhSWm4vRHd3NFh6aUorYmo1SGh3eVZEcUM5TXgvcE1PQ3ZLT1J1cjJUbHh4cmM1cm8xQTQzYkdsbk90TjFNdkp5TjNSRjBReW9nbUlmWVY3amJqZUszSE5kTXhIZXV2Y3gwNzNNc2gzREhKeURIdGhlSzNBeXg3eFRrVG9pbDhxWWVUTGRkTUhUSzlNeWFDcGx2YjFEaWw0RzRhem4rSmg0L0o1cThxbU5kNHp6NUprWTk0SFRNc3IzTlhadVpKNjdnb1BkTTRyall6bmtGQ1J5U1h6MjIvNm4ybU1YSjZJUzBaaXJtcnNJT0xkUTZoMHpEa2JDWlpSMkVjdURETjhuazJnRVY1TUt1SitHY1ZnOW5xR1RsVmJxZUxNeEc1bm1zUnlMZFJ5ck9HWDVKeVYvVVFycmMvcnQwUncvbWZHRGlYM2tzOG1HV0xuNHlzazlrNXBpRnlqOHpUS3E0YUdOd3VGa2IzdVlGQXJCT1MxQk1WZU5rNVh1TDdxWW94d3NpSkdzQWI3bGs4MzhHT1llRlhHdDNISWFBREdDWjJKMUxKcSsyWTk3Z1pOajFQSTQwQnFCV3BsMUJBbDRvVVN0eloxOEJ0MFNuTGRhaFYyVFZ6Q3Bubmh4QS90Y3p6Y2hYUVExRnVKWkRSR3NPdmNQOEFXcGlZRHNZWGI2SlJEQXh3WXRCTzNxNXRXY2FMTWlINVdXN3BtenB1RGtyTXNISEFUTVY3STkxQ1VmbjQyTHFmOEFxTkZWRlMwTlRpcGRrYjB6SHR2R0Ntd2pmRyttSTZuMUZHTm45U0lkdTRyeCtzc0J1YzlFeTIyUTFPenVaNElXTU1tNnVBMU1mSG43S25ESDhpRWVPZXNNT2k1L1A5RXh4Qmo1OCtQSDBrT1hCREtZY2VXUE4xQ3J5NC93QlpWNk5mdWZ4cVhXdnpBbU9EdHBoaDlieXlKOUFRdUYwY0JLOXpMUHk1Z2M3WStFeHgrK1Y1ZmlPWWFJdWVWazQ1dERjeDhSdGM1eThaVjJ6RkxlR01mSmxpOTFGbzN1NEhISGVwMjBmR1BFM0xNOG0zVUFQNnd2RGVVTXZyVU11STRuY3lQR2VQRkxjcFV6eFJQdUpVY3JheC9FQXJlMlA2bVE0dTJBTTBSbzd4bkdtSGQzb21IbGVleVk0bVhKY2dKbGdGTXh3eDV0eEFHcGhuWTFNRG5ndjRtUllWUFhjeXlhbzNNUnBMdGxocUhGTFlZMDM2bVpiWXk4VDFNaTl4ZVJITGpqVU05UTFkeHlyR3F1QU9LM0tqVUl3RzZZZ0ZtUXpISkhjVzEvRUJ6d2lOZFIxSEdrWnk5ZFE5NU1zZGtOc0ZNdHhTRGJVY2FaVkF3eXEyQ3JHNVZkczN4K01TMk5OMXFYVDFFbmtBcW1OVGpBcU04WmZVUnhYNC93Q0tUamxqNHpMSTB4eHZHZWtqMThHRVB3emlNUXVMRFpBaEtyM1VEMlhNczROa0pkc2FHaWJQampBcGxZdUdwNGhNVkp6enlwYlpubml1c1pka0pqaHlVR0dEZTJPQ1h2dVlnUXE1cVhxQmh3djNjMGxTb0Z2eGp5SVlxMEVjYSt2dUdLV3lzWFVTMllGTTZIWktBRm1lV09XUnhocTdsRGpaTzhiaGlXdHpLa29uank0K1BJNDdaeWFCSVk4YjVkTVBIWjFjZkZpRkV6YzhuZzJwMU04TWEvQ1EwUS9SUEw1TWZLbkRIZzF1ZnhJWFUxL0UzMUUyMU1Sai9zSmt2WGNObFFVYWx0ejJ6MjNQRjVQNHN2c2NqM0ZPZVNhdnFlVERMQUxyWkJqTEk1V1ZNTWs5UlY5UXkvSVFkTU1qcW8zTVVNK29KYTFETExheGJOemltRVBINUh3dVluRGxYL2NZUzl5OXh5RW1sdU9JbmNBNnVmeDRXV3N5d0wxTVNtWVlXNWI2SURjY1BKaGhpajljb09WNmxjb0g3cElZWkt0V1FWcmJSRkxtUDkwZXBadXBxN2psOTJMY3BYVEJEcTVrYTd0bmh3eThYamZOWDZtV1psaXJMWmI2bTNLYUZKUmZHVTcxRVVnb1RkOXdHQUJheklCc3VvbUw0Zy81M0YvanZqdTRab21wYSt1eUk5d2NncVdkUU9RbzlUSHJaRzhaYkZoMWN4RFNPMmVUeDVlTHhHemJNWGdzVld5R1hmS1pMN2dhM0Q3U3pGVVJHSEE4SEJQdmQzSE00Y1VtVi94NEl6WXVReCsxVEJIUGMxU2tGU0hFSTlkU3F3amxxRzJGM3VQSGcxL2FOaGlaZTVRTlM4ZW1kYXhKU2xYQkFwbVR5ZjBUQnhWbUpqdVhNVTNNQlZmVTF5WjBkN2hrMGw3bkxsak9qdUNaMytpWW9xVHBRbHZ3NVVReVVZY3VMaktTR043WVplcWhqaU5zNS9aNnFLWDFNblZCRTFQK01iNDlRVGpMNU1WNkppYjNFdjNBVTNBVjAxSEpaaC9HNE56MXFLc29BcU9BRjN1WWs0dHM5VVF4cUppT3hsbm9tV1p4cW8rUzBvbUJ5eSt6TWNMOG4wai9BSTNseE1ESUFZaGdwZHdSU0p4WTVpQjBrMmJZckFqK3B6UXBKcktVaFU0UERxR0tGUkVhemwrTTZKeXluSjViYmlpVjFETFBucG9qdDBUanZiQm9RbUl2cWNIalFoRHhHSTJ3ek1LQzAvRXg1NVkyQUUydE1jZVBxY3dOWXpGenkwRVBGbmsyMEo3dXBqNDhkdmx6Wm0rRC9pS3orVnhLQUlaWlpyZVU0NWJ0cVlnSmU1Z3F2RW1maHlERnlRdVdYMWRUbmJ1Y2dmckUxRjlSQ1ZGTXlsNmk2MDlRKzJOM01lbWJvaEJlaWVRWHIvdUdDRCtaUzA1UjAwVGQwZHpsbDdMajJoQ2dxWEJXQTVUaFc0ZHl4c0poUVZ5aFpuOVlsZlZnUWF2NjdnWU9INHlpdlVjckRjQmJDWWtjdU55bnNsTTEvRkZ5UUpueEowWFVyNlhPaU5RSTJPejQ5RWNhbHBHL3kvR2Y5Qm1TTE1FZE1RR2lCcGZqZnFKVXh3eXkzRnREUHFOQzFNZG9TMEhFM0xJS1I2bUxYeGl5dVJVeitsREg5UUdMQ3Bnd08zdVdMTVVNdjlPeVorYlBJci9qTTMrdFRvbklZcEM0ZDJ3ZFA0aTB3MnlxYmxsM0JRaThtNFovU3BrMnl0ekpBZ0hkemxxQ3paT3BUeUkwRkJQRHhQM2NYSEJ5eEorWnNhWmxRU3poQktpeEhzS0o0ZkZqbjVLeXpNRDhzTVFjdlpjNHJPRndHM1VCSVlwNnU1eFJZbjBtTHhGTzV0TGU1aTRuY1U1MlF3cHQzTkYvV1l4MzlaaVV6bmpzWVVNYWNISEVxQTg0Q0t4YndQelBEZmtaNUhIUHlHRlVIdWVPN1psalc0cVpyaTdtV0ovYkxMY2ZHQUkzTWZJNHpCNVhrNVREeXZibFBMbXZ2VUI3aFkyeEw3aXZRVEVibFpZNVQ3UFJIOGU1bFNnSFV4aGpidG5FUk1zbXlIY1FDSXpSakxoNURIdkFZNy80a2NUb241S2laS0lsRXgzbXdTbG5JWnE3bGFGWjBjREw2cmM4ZmpmS3BoaTVVTDhCZWRPbzBOVFJNY3NPUllvVFBnNXFDREFPVUc4Z3VjVlZHQ3JDekxicVozam5wMUx6Y0E1V3p5R1JsV1pISnJVdTZvbkpIUzhZWkxkTVB0YUhVRnBZT0o0ZVB1WTRPYlI2SlhKZVBjNHRibU91b2ViRi93QWM4WmhXWTN5WUIvSUV6OHVXRjRjckp4c1ZJaEFuQ203aHB0aFZOcnltK0ZNNDNqM0xURUlvcGxGVmhhMWlSNVhTYWd0eHh0VWxJVEYrcFAxTTZDZVRMSE91SlRXNXl4QnhHWW90UkxXY2FodGdZbTJMamFtaUJ6TnJFUzQvUTd1R0Nqa3BVTXJuV0tzcE9pY2VKbzdsYk56N01US3BWTk1xcGpWUDVqamtOMXFCUWx6aFdEbE1ETEpHOVRIRTV0K3BtMzBRNVh0aGptelBRWXh1QTl6TERaWlBzTTNqY1ZaVEFLU0I3Q290dHdTQzRrYVM0Z2IrQ3l5UFpIT2w0bEZURGk2NlkxWitvTnNvWWdFeHgxVVg3UXhjM1UwYXVweWVWVG4yVUpITEg4USs5VVRleElJYVpVTStPS1ZNRU95R21YYkMzS3B4Q0NJM2R3Mk00YjE4Y2FLbnNtZW1pVlJiQjArcGdjM2J4UHl6ZzNwbkIvTVllSXBlVUVMdVpaQmtWTWZKYnJEcWZ6NUd6QUpuNS9ONUs1NUxYNWl0M0hLemN3dDJsdy9pY01uSkJKeDhPZUtLa1A4QUhjdFlJelB3ZVh4SmVOekcxajQvWkRDdTJHUmZVUEkzcGphOG90MytZSDVTNGZ1V21kaFVVY3Z0TUFWMU9EZTBKV0E3YmpRV0VQNkR5RDlUTEVYZWRSenhUamZVSENtR0E0VVk1MytaVGoyaE9YanI3WjNQNU1MMGFKbjVNbCttaU41S09USG9DM1V4eEM0ZlozTmk5VFdRUStyb3Vja0dlYkxsNHZHRGJVVEs3TlRncGJEaGdKN2h3eFRudXlXT1NFRWlpekF4M0x4Nk1idVhXcGpZTU12cDFPVEJEcTdnSTJUUEo1TFVjcUM1ZU13cHpMaVpISUoxdFlqREJjWnljV3BqNU1pZnlEalZiaUpMTWhvcGhvaTBWc1lYa2NvTTV4RHVDLzdJaHFZNUp5Q0x1TUJROURNZ3h5UzdxWWltaUI5dHZjeTdxWktsQk9iVk01WThKZGhSSzA3bk5jWVpUaTVSeDRsdnVCYk9SaU5sem4rcFNsUUJkeXR6Qng1UExWVDFrZFhGdVk0d3JIZHorVEpMWlZFdmJNUWNPY0dsWUp4YmoxcVhSdUZSZmkyZVZLTFlFdzBNY01jV21aRy9yMU9pVzAwd2NRbmlzT1RpVVR1NWlSaDNLbHczT3RSTCtGZzQxTFplcGpWUklNWnJpYXE0QVVRS2hqdVdYVWNrWXRoTWF4eG9OeEx4Y2pzN25LamMwd053T1dwaWhxWGpjeXlOUnJKY3ZVeWRsVG5ETEtHVGUyUGtIS0NQVEFyYXh5Z2tHUEZUZTRsS09VeC9iTkxwbVFhamlEY2NvTzd1WitKd3hNK1kzT0tRd1ZJanVtTThlZVdIVERQQktOc3g4dVB2VThubUhNeDN4cVZnWk1vMnU0VzZJbkViaG54Q09lOU5UK1JlMmNqOHpUN2d6a0xVNjlUKzJEbDFDdnpVYnFGQ3IzS0ppWWdxL3dDb0ZpdzdwbVdORXlkREtQN01BZW8yWVZWL0RjVExIZHp5ZUY4WGl4ek03NVRpRE1jUnNpWTQ0eG1LSTNNY01zaFQxdWVEejUrQlh4b0tiR2Z5T2JlVlhIZTVpY3BuaVNxbWZxOVJLZFp6RWgwc0Z1NHF0TTZwWmxuaXBRa3lienZiRng0UXZyb21YRTFpM0FRckR1V2Y2L01zUnBoWUVjcXowOWt5WEFwS3NtSzB3WUtUL0dBeWM4L1JNa3l5c21MYnQxTXpFeSt2VUNMVXV5T05FdFN1b1VaVTVhbkhFV215SkRaQlRxS3UxbUppNldZaHl5TDFLS29tS2pUTWJjbzRJckhMQlVTWVlOV2JJREdtTzZJRk5RVmpjOGVlR09SY3p6dnlaUWVUQlFSWUVQRTVrcEZxTnBOY0pzQWdEL2JLZmtKV29URFBMcDZtU0V2NlFRd1lNc245b3JPTGxUTE9MTndjbUtPZHBGTGE2aWt5eXNsTUZpbDZoakcxbkZ2OVIwMThMTVZ1RGM0RmQ3bWFwUGMvMTdsYnBtL2paMHpwT1V5RmJHRFRIOGlRejNpNGxNN1d1NHBMb211Tms3SXFUanFkZHhESTB6RXhTYUo1TS9BK0hFOGVLWm5iQkhKQ1hVNUt4YjJUSHNNcG5pbTZ1ZVBHekszNm0yWTVxQ3ZmVXNMaGxiVWMreURiVTQwMURHN3FCUjltQU9lMlpuNG5HNGNnMWtUamJ2Y01jekMrTTU4bTJ6OUVmS0JwZis1aDVMZUppVHlZVTZabmVnSUNiY1NZbCs4Q0s1WjA2Smo0OHJUSGR6K0o2VGNwS0VqUmp1R1lsY1poNU4wbW9obG1wZFRDZ2ZwRnMxUDR2TG1YeGg0aXZ2a0VjLzhBSDhlRmNMWStiaWNzTU9OUS93QWp5WjQxeUkzdVBEaUNiWWdURm9tcGRYRE84YURjM2N4Um1WaEIxTVFEdnVHdW1acndobG5tUSsxcXh0UkdOaE1JQlBjTDdKZnYzQzBpSnE0RFV3eXFDOXZVODdocHhobDNPT1JoelNpQ1plUUJua0hDNllEbmxPZTZqNUVsYTVWWkw5MVJMZHN4VmhvWmZVL3UzSDZOZW9vejNCbnVaT3dtT3IvY3d4TFhLR1A5cGw1VkRFUDZ4SGtzL3dEMElPRGF6TExtbXFmY0hFNzdZdFJKWUV2anNsSjl2ekdBM3FaYTBzenB3TjNxWXRFN21BQ3pQKzBINFJFZTVrSnROZkN0YW1JTFRLY0d2aGNTMkxZQk1FTzR2TEo0d3lyVXU4aFljTTg5YWlHT2FkN2pyTmZVem1ZTGpCMU1mNzB0eDBwSzRzVmdSbUsveHVGNlpkUW1WZW9Zc3NoSEV2VXlRMTcrYm1lT0p4NDViVGNFdEFpYWdGVE5IVUQ5WE1LYzZ6YUpubGRUR3pLN2puemFXYndhRzQxY1VkZWllUEU4bUMyNjlSNUlUTERWT1dtSlU3bkhqdUdJU3FGaVFlS0ozQ3NsdnA3bEc2alhBZmN1bDFPRmVJeXZiQW9oaks1WXNvN3EyWWVMbjl0bUg1aUdLN21GRlBzbmtlV1hKcGZnMHpMSFdPU2lNeXdIWm9ZNHN3eHFCUEx3ZkZqd0hsN2dxdFN2UVRJUjR2d1pKSHladU5UUHlaUGp4TlF5WEZ4RTR3cW1Yb2pDZ0hJRWdtN0tQUk8vV3ByRTFLR3JLbG5xWStOenlvTFpkUEhMR0dNZGxWT0pvbmtBWlViaVhEQ3dZaVRJR05wTVFqZ2pVeW9CR0E1YmVvNWZHYThvWkpNT1dSUzZKczB6dTZobUFCaWxtMk8wVW11V2lEcEdBWTBqTXF0Z3RhUHQ2SStTOE9GQitTWWhUcVZnZU5SZVU1Y1NoMUVzR0Y0eXRYY3h5RzJPVGtMQTF1R2E0VkFDVzQ5UldHaitzU2lJV01jdWUzMFRNQ2d6S1kxaXpFdG5tUVRERjA5ekduWFJLeEY0NXpWZHdBMk1TM1RBMkUveURIbThPdFZGOWZCTVV2NHBwWTU0UGl4TWNheTl4VllaaGd3YWRNTWViM3VjVEV3T1JiRnRjVmxsSXN4V3F2WHd0NURpVkFTTURVVEhBNzVySGVWMTFNczNJTGhrbnhjTThoYWRRYXgxN1ppY0c4aXljekorcFJNOCtZQVVrMitKRStwMHpWU2tMV3BpRkt6aGs3RFhwbkJEYmJNU1ZlaWNLTk55Z25waG9kUXZBTVR1VmRsYm04U3lHYUMzS1E3Wmt3eGxRUGdBdTRGbGt1dTV0TmRUa2pkVElIR3gzS0txNEhFQVljY2M1ZFoyelBlNWw0M0RBMzNNTUFCWG9uRG5pNTNOWTNIUGswRlJieS9KSEJ4cFRUUGJVR3BaRm1OWTMrNWpSaThpNVgxM09JWWFnbUpOdVd6VXMzVXRTOHNkUSt1eVl2YkRqbGtCT0l0QkhCNkNPS1ExUDZrTW1Ma2pNY3MyampZVHorYnlmNWVabG1GNGdIRXFaZjQrWmh6eXhaamhXMW44T0Z2SmIvRTZnQ0V3OGVPL3RVTVBFQ3Vkd01FNnVmWEhWRU9COXNzUkRzdWMvQzc0TVBKNDhHekhVejh2T2tFRG9sNC94bEcySmtqYyt3V1dUSHp2RGJEeVo1NGVvWlBCSVlqRUp5Y2ZkUzl3TnF6TGo2Wmhqa2lHTnorRHlKc3FZK1B4N004NXk4SjRtaTM4eDhsUDBBSWViUExTNmpVTFcwakFvMURNOXpMTllVcXNQNnNzK01SSjBRL0pNaWo5VFFTNi9xVEJ1MUp6MGtORnNRb29xYnFJQkwxcVlrNlp6OVZERnozZ2FDYk1SWldTMkVGNFRFT0Z6bmt6QWUyWjVDVmpqVWVYOWJlTUs0Mzc5VHNscE1NRnltUXdVZDlUSWM0UHBJRmVOUWd1N1l6RmFaYmtiM0h4OGNPWEl1ZXRNYkVuYnJ1VTIvcVlwd1JQc1RIMVRFKzFETkgrNXZxOU1NbkZtUDJJSDVZSU85a3kxdjFCNU81bmVPcnVXNVVlb2Z1S0RSMUViM3NtUkMzdUlPZ2lBVk1XM1pxQlY2MnlyTndlTzVrdVJIR0pxTVZmakVtajR4YW5jTEwrTllVOWpHbktaUkFaZjFxcGhsbGhuek1CaTgxbVNyVUNYdVZjTlhCdGZoN201eGhMU05QeUUzZDhZYTNMbDBUTjhXWGhESCs4UkdDR1gyM0ViSmhaY3g2VkpqYXh4dTVqbm1OWWt3elI5RVBLdUxHMHRZWkV6UTBUa3B4aGQ3SThZN2FJaVNxSlZheGxWalQzTWNxdTVqVER1aWJ1VzB6czFxbzVPUGc0T3QzR3JOL0dPT1dlajROc29zb1puVGxlUFh4b2l4MWw5THFwNnM5emVHMkErUlY3aDdKbGF4dnFPOFc1aFZSNFl4ZC9GNkxLbm4veHZINHZIaG5oNThmSzVHOFEvck1Ia0psb2p3eDYzRnNibGhNY2tieGFaYXRyQlk4clJuOW1aTm54Y3gvTFA1UFFRZDdaY0dYZWNjMG5vQmhubGlPTVdaUEdtWmREK1lKbnFVblU2cTRpWmJLMUJLMncyOXpKQm9sZmFCc2IxUEs4blhVdzhyNHN6TXhGSm5rNTU1WjVZZy9xT2V0emw2QXFOcjNPTGxpVFExRUxoZktQVkVCV2NYcjRyMnN4TGU1dHlxNDB2Y3NwSU5ZTVRwaSswMHp4Qno1dlJNMXlsbjJKanhKbndTeVdWQ3dudmJETEVFZDB4VExKWWhVS0M1UzlSbUxtdFRERExMTUlBWk00OHJtSGlEQnpacFprNDlXdVJDNjY2bVRnK29CNm51Y2RkekhESGtYblVhTTZNcmxLcUpLOGVHV0g4Z3VEM1VwWE5Pb1hXNFljbzRKT013THpxY0thL0VUTElWSVkxVkV6Y25XTXhyUHhaQzllb1c0OGtwSjljejc5eE9aVWVRR0psMU4wc0lDZXlXK01URjdnWkRiQ3NqTGxsVmRTeTNkc3ZGenhNRkptZlpCbU90TGNTdDlFVmZjVVpzSURBZ3U1eWhEQVNKRVB6REZQVU1IbDFFVmRkRXhRN0prbVVDeS9VeGNENjVOdnFPZVhWYWw2cTZJSzBZeFZsRk1jK2RDdW9ORFVxamZjYStPNEpkckY1WlRuMlFIT0o1T0hVNElGbFRQSm94ZW9KRXFDR0trdlAwVG41QWhuNU1uWXplUFJIUFBMWEdjUEprUXh6RGN4YzhIUlBINXVITFZzL3dEbGVUSSsxOFllUXhYNkRjLytUWGo0ZnhZUDdxZVhCc29tSGpjZkcrVElzSnBGNm1IamZJcGlXVkJvb09wWXV5Wkk5QktCdE5UNjVkRTFsK3FpM2RkekxGSzVET1lIRm4xSmhsaGhoWmkzSE56WUxpd1NOWlRIeFpkdWljZkdKZVgrNDVlREUrcGJEL0pSK29FeTh2a3l5M2xVNTd0M0RJNmVwUVhxWW9RcTV5WXE1UWZVcmNzanVZbUtvc285U2txNHNzOXdWZnJLZmZVQ0R4S2hmS3Z6TXh4UWxhZVhxT1k0MHhhbUYrVEtpQm45ajhSNWZIOXNweXpkWWFDVUtjc3AvSzRyeGRUeCtYSTVhdUdYTWh4Y1pSK1dMQUtsY3BqaDlIS014eWpneHdicG1WK3Boa3BETndVbUlJajJ5NnhjV1lsRThlWDhkNkdaNUM2Q0V5VGtRT09Wa0xHMktKWHVVQVFRV011Nm1XTlp4eElBS011OUJESFlYTThFMU9Jd0xkUkhjMXdncDNOMU1WR0Z4eEpuaHhRdWRGa3d5eDRPR1hiRVRVNUlUYkZqS2doRm9nY2huNmxTNmdGTTNVb1JQeEN5WjJ4c2YzOEVNY1V2bFBlbVpYWWZDNlBpaVh1VmpsYm42TlEyWDdtNTZoTXR6SXNvbEFRYUliZTRZMlFLWmxNWXNyNEtaaVhON1NHS2l6Qnp3NlpnSEs4M3VaNCtERUZ5dlV6VThhR1dtT1ZZR3Bkd3hWMlJjcitNdG9rQlM0bDNrd2QzY3k4cjVmN1BVeThkWVdRdjQyYkppcmQvSDFseFp5VHFDa0JJTTZZckUxZHltQmtQd05uYlBYY01GSVlaWTBNTUE3WStQeHZqanBTQVJjYkt4aUxtdFRPWGtYVE1hM3lZRVBEa3pnNDV0d0Y2SlVOUitLdVV0cWRTdVdZMXF0elBZMGFoaTkxS2JtQTRyeUtHWllCa2NXQmVXamY1bWVDNDQwbW80Sm5ka0ZxbjRadEdCVWRNN2plV1dQT0JqeXlFdGVwaGo5TXZTVExERUJ4M3FmN0lnMHloVVlZaVZVUUNxZ1lEc2p4bFhvNmdLOE1abjQzQjJ6aVFJR1F3eHlHeUdlZDJkd3hCM0RCTkRwbGNaVUFqakJ3eEhsMjlUREhTNU10YXh5MmVwa0dPQmdmM1lBUnh1VlRjVGtReEJoNGxIT0FiVTNIRE03ME1EYVhPalUyd3haeHBuSUdwNC9ML0FCUE0vdE9TdVdmNW44dVZzNVhPWFMrbzVEQ3dRZTVTTU1qQTMzRnR1WXIxNm1KdWgxTXNkME9wZVhoenBtWGt0dGcxeWwvV1l0TnhSYklyTG1DZ3pCQWVVM1RVVnh4dUc5RVZvTW96R2w3am1xL21Xb0VDMlZpTGZkVEVGWFAwYWpVS21xaCtScGk1WkpiQWIzTWsrT0pVNGlReGZjSmhVOUlNNUZjU2NQcmIzTWxUOXhpSDhWbmMvRVZ6N2dPTnpSNmd2RFVQM0RhM0VwK0M0b0NUSDhrNHJPT1pzSndjdXlBbjVtUGpIdTQ0K2duOGFZWFdwa2k5VERONkkrVHk4cGViREMyOHNwM25wbi9HbVBEVXdmZkxxWStYaVpKMnc4b2R4Y0Y1VkRQeFZlUGl2S0grUmhpVStFdGo1ZkhsbnZBSmsrRmRqWDZua3kveFA0Zzhaa1plN25NR3Nlb3AxRmFvbmtmQ2Y0MkJqei9sOXJGU1k4ZUpjOFhtOG5qTTN3V1dVeGRtM1cyVzFGK3NINnl3eCt2L0FITzV1cXdOMVBKNWZKNUVjM29DSi8yekg4TTQyYXhtUGh6cTJpZngrTUx5Wno4Wi9UQzQrZFJQNnM1UHRoUWt5aGF5NTdYaFUyd1E3Wll0a0ttNWpUbmJDa29qeUlVeW00VnlaWVM0VkJMcUxUcUZZVEpWamdwM0NqM01zbEFxYzlKY2I0aFVSSURQSGcyL0hlWEtYUmxRVEhPc0tTTkdKS3dDeUFBd0NZZmlaSmlBTXlLejAzTFNBMDA5VEU1Q2pUT09yWUR4dUhreTZqbGxvOVNyVWhqSDdhZ0JqTXpxQkJpVEhFMms1aHRMWmlvdnFQMU83bDJ4bFFmaDNzbVdYVWRoUDZzWlRNUXZjRElYaXdOMHhSYXFaZDlRcHd5WFdRd0NNdW9kdDVReWNyQ0hlNWxTRXlwbHZHaUgxampIVUNLMVUzVWRGck1NVElXK28wcy8xTUQ0dXRFMXp4V1owNXRLZkZ3MUF2S3BzYnBZcXI4Rk1zampRWlBUTXFVZlV4N3RoaThPVmxUR3VPUTl2VTZqK3BzMlNpY1EwL0FzRnY0U3VvVDNOM0NEdW9QWkJRYWxMcTl6QWY2dTJaNEdvaGdmbUkrNWdVM1A1cXVjbHlpMlRFZUxITExIRm1DTmMrbVpJM1JLOXM4THk4ZVF3czcrZUc2YnVvRllmSEw5UWlURVdLcFVDaWJqRVlEU2tNMUtteUNrVG0yUk1qUXhjNzIzTGFobkhMbVRHMFVORThYMkZKbHBZOXozT0pYVTZPcGJWd2J5M09YOGJEVEF1MlZjQm1PR1dhOFRxSWdrUHNndEV5eHdyamprd1g5cEFYckJZdGdMWVNtcWRmdVlwd01QK0o3anZEcnBtSmh2a1J0enFZWU9TaERIYVIwYW5aRDdhaGhwbmJET3NybkxheFoyMWMwSVRJcG04VHVNMHdRNjNPVmt4c2JtVHpidjRNTDJNTHVtWTlUcGhTb3VvZ2ROa0NOM1VTY1pRdFFEcTUvajRsdVRzSm5XVGN3eFg0ZUtmdU5URW9haG5rYTlNTzU1T1dTMjZJWW9HcWxWOENrRzlzUVdHSzNYY004dUtWRkZBN25URHVHRngxMHdnMld3WjlWMTFDei9BRkhISGpkMUhKeWR0c3B1bUlRcUFiSmhqaldwbVJ4QUdPaW9DVEVWMUVYVE9LSksya2JEYktvdW9pZmRoc21CeHhWbk5GVWd2Y3l5ZzJ4emNYZlRCZlpNTStLb1JUSnFaRGkzTHhjYmc0aERNQmpuUDVkMFREeUM3SXAzQ0g1V1pEbHY0cFJxWllZb0l3cHVPUnhJVytpZFpUSmZSREhLSGp5elpqL2o1TjE2aDRBRlpuaUhjeDQweng1NFlqZUVmT0swQVQrZXM0K2R2VS9seWRTM0taWlpjSEhsTUd2ZXBsbngvckRLeTJlTFB3T1YrVExMSDlCSE9zME5semZLd21PZFRKN25Pdlh4Y3VmeU9McG1IbXpGeVVXUG5jOGJhaXNiaGorSTRIUTdnc3Ztb2pSN2kxKzV0U3lpT1BFc3VtZHRtTVhKOVRPeXBScTJHQzNxQnFlSThtZVpoaGplVFA4QTRQbDVKbTRsZDJ4L3h2RDR0NStXMzhFYy9GajFodVArVmwwWWdUTHlaTSsyZXJpSm9ZbFFaL3NxdW9aaVJ5cVdyRnkzYk1ReExpL3FWS2lmYlNNeW9DSFpVZTJFZEpPUU1VbVdWaDhDWE1XTE5xUnhydG1PZUdIaFJMVjdtQWJlVXhaeS9jdjJ6UkIyeXVsbWZFbkxUcU9XTmEwekJzTDJRcHlZR25ra3hvWUl3Y1R2ZFJ6d1JRM0Zpb3grMkhRUXlzMlMxMU9MYVFMMTZqbldTRUZqUnVWWkFFM0dFTFpoaC9KNDNpaFhkeHYxMFF0RW1tTFRxY3JocnVkTUcxSmdVc1p2MU1zM0txSS8xdU9UeGliSU5LWHVLL0ZpOXpEanlWWUFxekxGK0NoVklmRlVibGFtaVdNNU9STzJNd1FkekxkMThiNkNvMFRHNm1CWXIvNk1yNEdZdTVhQk0yMk1DaUJGc0NQY3ZVR2I1YjJSWnJKcGFKU0JXeU8ySTg0RXVFV1pOSk9kelZUZ2Z4SDVqanhMbDZseTRXaXp4cUEwTXB6dDZoZzhHMmFqbTNxSDJ6bUE4L2pGY21ybVRwRnR1SkE1Mi9IaE9QTGNzVjNjeW9mZzhtUm5kUzd0clV5Y2N3VEdtZmYyVHFYVU1pS1EzRitDblZ4eHIzOFZNZXFoWXpraXNGamkxY0NWdVc0aU1LVDZ5K1VHcFpESkZ2cUQ2WVpCcUdXRytZdUV5UldycUJiRXI0T25iUEY1RER4NW50S0lyY2NYQXRPNHpuUldNdzgyZUMxbE1XaGE3amdHSmJkemx4Nm1HU2xNeW8zTWFTNWtjWnk0dW9MdVlXM090MURwMVB4TXdtT0pUQWJXWVZ5KzhNZWVmRWFpSy8ydmpCV0c0WXZjVGkxUDQ2blV1bGlhbG9TNXVEcVdRWDRPVGxQczR6bFdNRFREaUZIYkhMK1B3bmo5c0lab2FZYUcyRGx4WFVHWFROM1pEOXh6RFJqTHlVdDBSUm1HWmc1WGlObW1EazYwUSs4Unhaams0dHh5dGpSa0xMdUZFTXROU2lyK1BWTXhOVVR4NDc5VFB4NWJ2cVpISEFqM0t2S2REQXNXUGJNY0RIRGJ0bkJBaDZUMUc4OHVURERIZ3E3SjQvcmhjNVZYN1l2MmprWk05MU1ubDlSZzZNWGNWRkFxUDllNWlmbGlqNjZtZlZ3eWZ4UDA0OVJUOFRLZ2hVV3N2ek9JNFBxWWEweFNWWkszY01TQnFpVUVySDMzQi9VNWJqbHFGemtrTTg1eXVHVlQrUjlRODJYU1E4cVQrZk1HSG16Q1BrVWhuRGtqTHJxRzJBM2RYak9Ia3h3L2x5eHJGZE1MdWJkenZjdVhOSzhsbFVTNWNXRlMyRU1zVGJjdzhtT0hrNThCSjVjenk1T2ZHaWNzVEc4U09kNHpGR2VQTThhMktNTTZ6dVZuNWI0Qy9vSmgvaGVWMW0veDRuWXpQamptNDRvaEJtZWZNeERSVzJmeWVQSC9BQjhqYm5mYzVPaWVYSGlZL3VHSGlNZnM3aC9rR0E0NHpZaUZYUEYvazUrRnZHci9BRE0vTjVNeDVaMjVSek93Wno1UmFZSXR5M2F6blVmTGNOdHd5M004em9oa2s1SzZqbmthWVpVemxMWmNNL0dCeE56bjdaN2pNbXFsMUZ1VUJ1RFpVZE1yYkRSTzJaYWhzM044RS9jY0tacXBqU3pNL2p5b2JFaVZxRUc4S21WU3NXTkVvNGtISGxISXZyNEJDb0tUWjFOemt3eXAzQmFWSVpReUZ2Tmc5MUhiSGJST1B1V3NjbEtucVVHTTVKQXRxNmlsVVRZV1RIZWszSHhKL2FvNHQzRlZ1RjVUZzhvZlJwamN2S1ljZ2FKdGxlb3pDaHRuVUlZejNNTlpUTEl0aEZydUdKaUxYY1N5VXRWTXhoanhOeHE0NmpSQ250amxjeG1KY3pRalhjTmpNZXBReEd2MUtKa1dzYmQvQkQweHllTzFKYzZZd1Y3aHAzR2grRGNHbVB4Z3JycU5yTjNFU0g0blVOVEp1ZEU2Z3d6OU1PS3ppWHRKajRoeFc0ZUxEUFhNR2Y0MkhpdzVZNXR2cXBubmlNVnl0SzFPU3R6a2Z4SW0vVUdtWUpUVWJ5WWpkd3htVUd6VXdXZUx6R0ZyamJFRjVBRWFseHlTTFdPdmN4WFE5VExQRnlUQlhIMHNwaE5RSVR1VWs0WmNlVzViY3ZIajg4dEl6bmgvRld1WHdCMnNjd3FvMEUxeG1EZ1psNklPR1Y4YjFESXVkaWtzYXVQa3d6ekRQSGlmcWEyK2ljM0w2OUV5YXlsWHNpMFFTWCs0dnA2SjIyVCtSejhlM3FEVDA3bjZMSU1IdjNEYlRjYWg0OGY0RE15OTBrc0ZDNWdkMnhiTnc3dUN1VXh6cGFsMlF5WnlKa3ozVXRHdmpESk1yTi83bWhVN1pxcGU1aG1MeHpVSnlMbUZPQ3EzY3lqZzRmMjl3K2Fod2NIL0FQRkFQZndrd1VHQThaVWRkczhKZDVaRXp5dk5aZmNPS2ZBMWdsc3ZVcURVS1JpTTl4SWh4UzVrWVBoQXJtUTFPMlZIZnVHUDVZZFFGWUhBL3JOYjB5b0RxWTZaajJoQlM3Wm45cHBkeFlaVTc2aTJ5bDNITEU4WitaaDVFeU5jajhNekRsaTRlelpGQ2Y4QTFtUHVaNVluanVmM1QxVWI1SmxBSWx1clllT2kwWWQ2aHNWN21Ia01YZU55OGNzbGRmRFhHWGVKNnFaS3F3eXVQSllISEs0dTdodnVVWFJNZUtJM2NwQlllcHgxWlVEbEhCaXFFMXgwdHlnSDQzdVlmMVNGdDhZVzdKY2NwamtzMnJDMGpjcUdNeEVHZXFuanhjMmlXbGtmTDVIeDQ0T1M0ak04Y1RqU3F5NkpWTnJHaUxjeHkzT1Z0eFFaeHhxeFkwTVhFVGpMUmxrcVlpdERNaEYzMU1RV3BWS1RBeHZjckdJRS93QWYvd0FsNWY4QUc4TGg0cXdmeWR6UHorVE5jc3MxV1paaTZ1ZUxEeWVVeWNjR3NlNXp6NDhTUG9aMGhNOG13dTVpbE53Sm5tb0Rxb0RNM2xnYU5ReVVxVXdGMkRBNS9xZGQyemJPUzZjU2NlUHVGSmZ2NE01WkcxZzl6VEh1cFhjN0JHS0kvcUwxVUhlNTVNc012RU9OM0xwZzMyUXBHNE5rWWxGd2JLWmRSYml6a3BSRmUyV2syKy9qSzFJUzJhaExJRlJxT1JjYzF4Q2lwaktuUzdsaHE0YnpyYzhtSjFpTTVyanhaVmszTGd6cktYdG1LeEc3bmNjRUJFbGkwMU1lTG45dFRGeEZtU1dwTHNzTnh5LzduS3lMS3M3WVhucUkxQ0xDdzFMNHNVdTQ3dXBWRzJFQXZVTGZxZHlreVJnMlJKaUl0elBjNVBIaXk5Vk1WTGxwZ3l4d3VhbE16dyszMm5IR0pqVUNobU9oSmVJUE80bHVvUEVaL3dBWUcyRm9rWGNhNUl6dkdBaEFiWmlvRXdWM2thbVR5emEwVEhGYiswc3JjVURVVlErTlRINFh1SFJPb1pibHZjL2F3YVl0L0N4TWY0ajh5L3RiQXFYYzVNc0djcGdaWkxXTmhQRzVBMUZXWVdydnFaSytxaXFUL0g0ZnpIOG5TUkFYak9TRE1WWVpTK1VLSmY0ZzZCbVdMaDAzQ2toSExub0lsazExUE5qNGVRZU82Q2NNQU43aHBqcUZwQ29SRmlOVEhEeEl1V1NaVm9nWEVtd25mOWllRERMenZBQzQrREt2N2tQQmxUZVpPQlJzbkJ0YklHWlpxWlk1NEZwRVJvS1phR3FoaG1lSGtuMVdjcGxseW9qWnBkUWl3alozTmRreDI5U3JPNExUQXU0WGtSd3l3eTJ6UEZ4ejB3Y1RkVG1zNWVrZ3pheXkySUpGT0VJbUFXZHl3bHhUOFRITS9FNS9iUk10eWt4K0Ztb0J0Q082aVdzOElaNWhNOFhEUEswUW1XVi9tNXoxeHFERmdxOVJyMTNMT01DVkxRbFpWZnBnUUxhbWVWWWNKeStvVER4NXZpeXl2R1loRW0rNm1JNXVpSTNFbFF1SEFHNVpMT0xSdUFWKzRKN3hsZnFvVEh3Y3NNOHFYaHVhczFCNHp4NEhsTTZheWlKcm5ENUxoZkpsNUUyd3gxRVhPQXRxYWgreVl0RHFMWjFDK1RxZVBLaHM3aGFOa2ZxQlZ6Tk9pZXlhalZhaHJvU0srMkZFNHZjTWc5UkxiSUpVUzRGSHh4aGpsTGFwSnZxRTYvM0VSQU5zT1hKR2F1by9wbTZuTEphV0pXRmpCcm9sM05ycWJJRXo0bXNHS21zVFVXTXh1NTBzTXRRZmlvT29kTFV3ejRZdE5NdVhEaVVzcXl6cU80a1poaWJnUUJaMDZkVEp4eUlCcUo5bjRDNWo5WFRMN1Y3bU9TTmhCVlZJTjdyVUZhMXFieXZLWXZMUCt0d0RodnU0WitIQVI4Wm5NUDhBT2ZGL2o1NFllTEU1Nm03dVdMZnVHdDFaTStCVGhHRmpFZVVhK05rMnpraFF4bzM3aXNHb1VreWdBYWpzaitpYkQ0V0E2bnQrREZ6eWNjTVhVQTJWMTM4RjNEVnprdnFiZmdLR1ZseGxXYlp4eDlNOVRIcGkxQlRjY3JpWGozREdtRVZHRFRmNW1lR1FibkhVeVY5UUNvV1FaU0RCMU1NcXhTWFVPS01xWUdPMVVZdHd5VDFjY21iQ0FrQ0xjc0NGM08ybm9ubDRaQVlNZSs0R05zVzVsY3V0QlB0ZzdLdUJIVExHWE5HOFNlTU1sNVpKR2wrcmRUUEZQc3pBTThZckdkRXZsRXlNT2RRbThjckhjWDM3WTZtK0hLTEFlNWUzNEJRaVBVRjZobCtwV0I0WExsOTVTc2RScFlwMFFmdEdzbTR6REhURHFZdkc0R2xtUkZnN21jSXM1VVRCeDVQTVdZOXRFVDR4TXN6cnFVM2NRWit2aC9pY0doNVhNOTZDb3cxOExaVU5hajFVVk1hSmh4T1Y3WjZ1TFJOL21KbkRQSUtncnRsak1ITWFHaWVIQ2VYQUlZZTdKbC91QmJNU3M1b0kxMUNnbEU2NmxRSnk1QWFOUUd0dnc0L1hUT2o0dEpjZHhtSmNmeEtsaExmakRBeXRYWkFwU25jcUNkUndNZkh5dTdtSTRmWVVaYk1oOU1xaVl5NDVtUnRkUjhtRlJ5OGIvV1ZXSDk5ZmlXRXVEYks1VExVS2p1V0VjektxMVVTcllSWUZ4V2JacXFialIwSVFsVFlRd3VjcUhHdmdqaktadVZiTXNFMnM5dzNsVXlQUkhST3dZU21WQWJtSDF5MTdtZTJ2eEVWanQrS1Y1cFdMRHFWMi9BWGhLQ3lHTmtGNnRtZ3FwNGh4RjQ2bWQ1TE10YWhqSDZ5Mld3eVN3WTNMWVpsYmk0M3FaSDFQaTRQdURsT1RjL2t2VlJ6UW9VSHY0V1lDdFk5czI5OWsxdTVSRFF6MTN1VXVOckRxWXU2amRVVHg4bDR6SngvajRjVVp0YTlUQ1ZiUmErb1llU2w0M1VjbFZTb1ZsRktkZkYyOUUzTFNjbTZtTkMzRERIak1WNmluVlFMeTFGTVZFaFlyRllTNkprY3ZIWXBNVjlzRyttRTQ2WVdidHVHVVVCaFBIVnR6ck5sSUN1bUtHZXJxT1JsaVRmTFVBeWp4NHdEMVVFSmtFQWR3NE94bnFvNE1BNmlKcEtsTThZSzhpYTM2bDQzMUtKaDRzczJpY0V5VEluS2lxcVZCbGxNV2lEQWxXUUFJY0gweXNTQUxOV3d4M01UN01wUGl0TWNYSHhqQ1k2ZUpjLzJ4QlRpeDBnM0xDd2hCTWNLbWduSXJaT1pVTnNxdC9tY2NuV0JQMU1DcDJ3b2xrMXlpNzFCV1k0bVZ4UndBK0JzK0VsWEQ0NTVZdG1WVDg3MnlqRFU2Z0VEYkJyVlFLV1ZZd3pyQ3BUK0xKb3hyakgraEZwMUxadDFLQ01KajkxK0FuSjBLc1cyYlFqUFdwdVcvRFhHRFArTEJKWkd5WXNLcHRoMFJ1RXpjVkF4bUdEbUtkRTBNV0FRUUlxYkp6M3VLc3lVamxsbHZ1WklreGNUc2lZcllSQUplcG5sNFhESCtLK2Z1ZFJ5VXFWVTNGamtMTElaWk9GZkNPQnNsM0xncVFhdTU5cFMvR3hxS3hnMC9CbFhwYVo1czhmSm5lT0NWR0E1TkhjcTNlcW52ZlVkNU5USEpxbnFEM1c0UzRzYWdGWEdwbEMyV3pGK0ZnZTVqbTQyRSt4RE1sM3VWcS9sMTNDMzVHWGJGaHUvVEV5NldhNlNlVGhmMWxhbkdFSml6L0JNTXM4bHpxcDVubTZlVzU1RXVnbVppZUlURm4rb1AzbTBKNU1ka2RUdG44ZVIzcVVrSmwwVVBVdFFLWUN6RVR0aU55cFVxZFIyeTY2Z1hNUmNxSWpobldaU1JNc3Nxd0pzN0pmR1o1NVlVcHQ2am45bzEyRWNyS21MT1c1cCtiaUhHSlJLS2hMSnFHb0pYY0tlMlVmbU90U3B4M0g4VHFJSkFBK01aaHgzY28zTVFabGhUcHVIVVlpL0JySUpuTWVXNE9WczdaUTlSNmhxRFRMVW1POVNvZHN1WTd1OVFhamFyZmNGR28vcVVjVnZjeThobDRzZkdURXNvbDFxYVg0YjA3aEtuSFlGdHp6ZVhFOFdIaXhkakg5UHlsa1dCZU00L1d4aGJpc1d5RkFrdmZVR1UwM01EKzF0RW9xT1RLcTFtSWJZamtRMDYzVXEyQzR0a3hheGI3WWNSTGJqcG5GUzJPQlhLOS9pRFoxVTMxTUg3czVMaHc5WERJR2hzbWJ5eVhVeHdhdENObVZFd0tkem5uanl4eHphWmRhbGNZdXRMUFlUUEhJNm1GMU9MQzFVSWUyNE9hUkF3MzJ3eVNEdThwbHRhbGFKMU95WWcyTE1uam9ZRmtNREUzcG1CUktmY3hMWmtCMHlweFNGblVDOXNBNkJ1T0wwczRrMk5SSmdZcFdVTWRwVDhYYjhjUUhqTU1iYWRNZE5YTkRydVpPVHZOZ0EyeGZZcE9YSmh4SDRISWpwWFRERlp2MlQzOGFXZFN6dTROc2F2dUJVWjFqS0tzZC9Bdk9lcW1RbU10RFpESnl4UjZtT1RVTXNqY1lsNDYweFBwaTJyQXRaeFIzc25KV1d3cDduSGJER29hV0RsZ3VRenR1TE5jUDNER1ZLSENKcUdLTlhNVExCcnVkUStWWWZCRU9kR3llTHhaZVJkNkkxYWRwS3Jkemsra2wzR1lsREJRbGlRejNpUDlaa0RsbHd2djNLQlJqbEhJUGp2NGJFbUR4V2QvQUZxd3lKU1dwcjR1dXB6WXF4Zm9IR05yb2dTcGlZanNsRlgxT1RBVS9jNmk2S20vZ3NiaGtsbU5sekUzMWJNaklka0VKWS9GaDNMYWdsekhLMm8wTk1NNXlzcU9vZDFGM1FWSEd3Z3cydHhheGdueForSmlvVGo5dHRUUHlmeVkwbFY4WGN3VEdMelpzbFFLR1hUSFJPMldUTGV5WWxNQk80bHd5Y2NyT3lXdHJBZlVEYmNxeUdLRVAxSEZEWkVqQ25VMVViZ0pPNVhzaHU0VHJDdmg2Z1FLR2NjcUY2akxxTjlzRzU2N2pNaW1kSHh1NDNVR1Y3dWFDT0RoUXpRRUtDZjZuK1BudzVDZHpKeE1NYTdtYWNFOXJNbHg0NHJMUVdWMHp4NXVHKzdJcjdiR1k2ZnRPSTVMSEsvenFEZmJLM2M3K0JSWUs3bk9rSm1neTZKamhpaXJQR1lPYU1hcHI1b295RkdMZVN1N2d1TFpBdUswbFJGQlc2bVBqTFFmM0FZUVNGTXhRZHpTL0R4WmtGemJocVBqY1F0TnhPS2U1cEg0UUNIR0dYakhjUVZ5eG1WYnZ1WTRuZHl0TzRZaWR6aVhWeklLQWdmV2FtSmlibWlDWTRzM1I4RFh1SWw5c0RIaHl1WGJFM3luWmR6bFJQK1VOM0Erc3dqdCtIQnd5MlZNUEk0RGlsM0xlRTIzVTNGR1ZDY2YrVWRLUVlNcjMxRXFHTUgxVTVHY1NxU1pUd2pqNG5MTHYxRlJkV3oxZC9DOHlZR0Q1TnRRY0J6bDN4M0hJNDBSNnFZWVgyemlHcGkwUUZhZEV6REd6RnVHZVdPQ1VNRGNmcnVjcjNDK0xCY01TZUtneVVoeHBaMk1jWGpNUlVtWUVWMEhVd3dGYlp4bEN6L0FNYi9BSVhoODJibi9sTGg0ZzdDZjVIajhPSG15L2l6WEM5UjQ0cnhtUEhqVE1paXVUVTR0MWU4bzR1SjNiTUdpMGlHZTVYYk5oTWR0c3d5TWxGWjdZM01HaG1xaDladTl5d2l3cU9BcVhxVjQvNERqL2E5empLbEVDVnlhSTR3M0tSaVhpMlZNcU1DdTJPS0FqT0xNYkNGODduSzcwekV4VjVTOXhTRlZCRldLRDNMb1lUZE5RdkoxM0JtU2RreVZoRVVnSmpPQzdJYmRzU0F2cWJGbm9WZ0dXS2tkWXc2bEc1aitQZy9jU2NiS3VWTkhYdzRvRU1EbXJLd3BGbkVoQm1PUmZ3R21EcXBTUnVWRDQ2Z3NZZmhpNytMdUJSVnpwai9BRnNtU1pHTlEvTXRkeTRaSXVwelYrQ0h6VERMTEd3ZTUvSHgzY1dWTEUzNmpyR3pGZzNIV2hnYWlSVGpwbGN0c01kd3hNVDdkd3FtR1FER2s3cWRTc1A0M0xudVlvSGR6VXRNYXJYNW5FclVWU29MYzY5eFhMYkFnVXp3Wi80LzhTWkc1NUFNMXhxcGpUTXZGbm5zSFVXNE1kdW41eDRvdVRIajBUY0QzT2l4Z3FiWnhFdUM0K28vYUp1TU5mRGQ3bFEwenZHNGRYQlZ1SWk1UXlSbnFVcExGaVFZNWw2T281V3luNGR3SlZmRDFEQ0lNQWRSR2NkUkdHTjd1ZjhBY3hxNlpRWklUVUVobFZVVGsva2hrdnNqa2pISWpNZHN2Y29XTnhsWDB3c1p4UjFzbU9ITVc2NHcrTGpwcUhXdHNYTGlHVUdhN1NYQXVPSUUwVlBKV1FQdzFsVmFpVjdqRWpWY2FqRlZGbldQeFZPbUMzM012THpRQ2tsdDdKelh0dVBVeFdaL3c1ZUhCeE9HV1BmN2xCQkIyWE9SRU9VQW1pWXM5M0VNY0x2dUY3K0tlV3lLWEhDR0lZMk80S1FGWnNZWXZQZlJEWTRoN2hqZVRQRjQ4czgwd0ZxTDJkSkY0NHdlUHFmNm1YSTJrT3V2aEFDelRBd0p3eFk0NCtweFV1T0hFTjJ1NVRsL1pnQnNuRnBsTlRhVGpLS2cwSVF3NVd3TnlxWnhSZ0R1ZEZrREowRS9qQmJsRlZERGxxY0thdUdMMTNVeXI4Vk9FSExFYkJ1QnJmd3RnUlFLQ2Y0cDQzejQ0ZVI0ak02UExtbjlib1owYW5NY09OYnU0djQxTFV1V1JWN2JoazFXbUJua1ZGVDFEMm93Z3pGMzFIUFNWTHQrRjR0RHluSmRWTCtOL0JsNlNZWVBsek1TZVRNSGpmVXU0NllFdUpMTUswT3R6eGVUaG5rbUEzNmxoQmhWOXpMaXBQSGg0OHZEbGs1OFU5UkxaUUxVUzQ4YUVLWVlLTTROa1JEdUs1VVgxTjAyeTlRMFJjb0xDMVphSkwzTFd4WjQvRVo1VXRFLzhwNFBEL2gvNEhndzhIK1llWXpQc0IxS0FUTGY0bEZCQndGS3RuaXg1WjBzTEtmcjlabGx6ZW9yMEViSU5kbHd4eHp5cTZnZHV5ZXRNb2NidVk5eEFGdWZXc2Eyekkzc3NsZlhsZjhBMU14clpVQ3A0OFlpZEV1anFJa2NISHhjMTB6Z2dMb1pzSmhsRmd3Wms1NUhaUktjOVk3bkd2R1pIZjRsb3NNc29ab3hVR042WXJETDJsMU1WUnlyVTU5TlJUTG9qczZtS1M3S0pqbmlPbVk4VVZqUTZacTRBbExNdnhpemx6eTNNaHhLR28wRnkvaXZ6SEdHRGpoY3FsRnVBRHFLdW1VRzRvWXd4V1VFb25Ta0RXcHhZRGZjVlhVYnkxVXBJYm44ZFkzY0FsTUx1b1VYRVFJQ2l4R29EM0F1Y1ZsV1ZLN2dlNFZkL0dPNHBWRWE0ekhlWDZpWWw3aUZSb3grQmhsdG5ycUJxdmk0eTlyTVhkSmNWTlZDY1ZhaHIxSHk1T0hGQ0trOVRjQ3hXSkZVbzFDK3FqK2NtWDM3Z2xXa1FZR29KZXdaanJWRXlFSXJsZ1kzTUdsaDJrQkwrT1NsL0I0ODgrc1lmNG5BNWVUTXhJWWY0bUFybStUL0FGcUgrUmo0MWZINHRmdmN5L3l2TGs2UUdPNHlpYUlUREU3Wi93QTFKMmhER3pMZlVvWWFZck9jc2htQzN1RmN1NWtXdFJZTngxNytLVjZnb1YxY1RISEhlNDVQSGpLRW5SRm1KcGdxZk81YktZWXdON21VUUNaVTRtcFpCM3FYTXNtV3BUT1QxZnhaQmIwVHhuaU1jbkkrM3BqVjZZRWR3d25IVmtPNEFreVlhM0FsRUN5SkFwbS9aQlRSTFNYR0JVYmNuVXg1WXdUUEw3YWpna1VQZytBR1ZLbEl5b3R3SXczOFliR1ZFK0F1VWkyd0o3R1lBak1Ea3VGV3l1SW5zK0xoalpmS0V1RHFZbTRBcktjWmhrV3FSeVFtRktMTTh2dnJyNHYwelJGTkoyUnlXWFRDOXRUd2VmUHhLNHRUUEpWYjNMc21LY1c1am1tUnhKNVBJNTVMa1V5N25kekxDZ2IrTG8rTWNnR3ZSdVhpc3NpQk5TeEtYcVZnZU83M01FSXBETEVpeC9qRHZjMTZZVkJBalhBbVllTGpsamxkeHlJWlRrWTVOTXhCYnVXbVZqdWR1NWtZS0N6TThmRTQ1VDJ5aVpVRUF5RDF1WkFKK251WVpZanhka0dNV1liZUwxUHFaVjZsazNNYlBVYTk2Z2N0REVwcjhSTGcxSHU1UXppUnE5RTJFTWJsSnE1WHdZN3RuakR3K0Z6ZFpaVEp4ZHBNN2N0ZGZCUGNDdmluc2R3OERWaU5rTUcyNERERmhnSnRqZHJLbkJTWDZtTGtQSDFGUnFlb2EyeFYxQzRyZFNtZjFCbjlTejNLdWNVellDc2NjOGRFZDRoYmNWdW1ZNFhFNGJsdmNRZGx3N2FseGJnaktwSGxQUG5nNFk0NHZxY0UrNTBSeENWTnRreHd2aURVeXhjTWtXeWFvQ09TNlpVTEp1b3JVeGJtV1NZVjZKbjVYeTRBdG53NEJPTTlKREVDZUh3L3k1ME14VERNRHVJeXJWSUVjYVdIYzRobTA2bDVOazRvMU5rN2FDWWdFRjZKaVlsY2lDWThnSlZOMUdrZ1l4UGpDT0FmN2paM3VkczA2bkRjNHdqbGs0QjZ1V2NmalZSRGgzRGMzTXAzS1lXYUp2NE9wMDkvSjhiK1I1bkdabElETXF3LzUzTytzcFh3Q0tqTDAzMnpHM0N2akdHb1JJWkJIYkxxZjIxQjFPNFl3bTNxV2pSSFJNWmtWbnFGTHVMVHFLM01ETExKM0FaeGZpd0ppeFVnd1J4M3BnNVhIMUFXNTFoTHVMQ0dtWnVuVTJvUUhCYm1IRlZXSVJZRi93REM1elI2bVhsOHJxMGp5WGU1L3dCUUZLSTNYN0ppTEh2NFJodWNtcWhxWUZLemsyL2hqLzZWdVpZb3pkOVEyS3lqMU5HTXEySnhLZ3RzMjFOM0JnL0xEVDhaSVoxVTVqWUVNcGVVTFpiY1lrNWFyNEp0K09WaVFHNWxLaGxNd0M0SW5VUGZ4eFdkUHhVWlZrV1ltSEk1dkVpWVdnNmpxeVdRelhGRmxNcHFZWVhReE9LanVJc0ZIY0Z2NEg2M012Z0FpL0MvRi9GRTVDVk9Dd3JGYkxpa3hhSVNpSUxVTVlFY1VsV3dIb25peXo4VHBtYjltWTBzdnVwNmdBMUtSM05KcmJPbW9VUzFKNm4vQUhxYVdZWWppM25BWWFaOXF2VVN6c0lQb2lJT1RNYys0YjdobE95Y3F4cWN3cGpqeEx5YkdIRTZiaHczYXo2VU5yTlQ2MUNybml6TVRJOVBjWEZkRkU4L2dQRGtZWGRsekdzbXBsaVk2Z1lzZkhnWVh5dGdFYXVaY2JLSXZpY1B1cGw2aHg3RzVnaG50b2luTnFHUjFUQnhkUm12eERDNEpkMUJ3RnNsSElaWVpPb0krdHc0M01ndGdFK3ROemtPTlhPUFpjeE1lcFFIZndWYXNwcUpxVmNCaVU3ampjNGJpSXN4RTlRd1R4NXFVeW1mYVVoY2VwdTl1cGxpanFHS3pMeFplUEt2ekRUVThPQXF1d25uOG44dWQraVV2VWNraGFSVWhhZmhtTFRjb1c0VnlsbzlzTkRYeFl5ci93Q3BoNHVlWmlKamIyei9BQ1A4VCtETUR5NDVrbzNUdUJ4TnNFR29ZbDJSRlo1TU1zVUZtd3RnNVZvcGhobHJVUnhlT1J1WThSNmc2WUtPcDUvTDQ4ekQrTERpMTlwOVF1TGVISm1JTEdoU09OQXhES0J1Qmp5MnpKTG9kU2lBY0djS080eHhobW1EZ1ovVjdJVTZaeFRwdUliZ05kekRubU9KdGhlTkdac2g0M0ljdVVHdFEreWxtaVBXbVg3R0dVRkxHZVo4TllQanhyVzV6cVk1RDNFK21pRlYvWDR4YWJIY05hZ2NkczNsYUZrQUM3cUw2V2NQcjNBL2NmOEFjb1Q5eWttS3d3QVYrUHRxbU9USEZqWUZrOVdFMnpFM0VvbHJFc29sVmwzTWcyUWFZNXduNkppZVJVTWRFZjZWVzRnVFVHbFlNZHpFeFQ5eS9VS0dWMndpdHZ3RTBPeUNKcWJHY3ZqcHBoaWkxSEdBS1RNREtsbTRyRzFnVTB6RE9zRjl3eXZ1QXBGL0xPeVhlTkV0Nlk1MGFMaXY0bU5tNFZNa09vTDZKdVlPZU4xREYyeng0R2ZKY3B4YXNaL1ZsSFZiWVRVcXVzb1B5OXdtUy9pYnJSRk1tMGlpMlJvZEU1WEdxbUl4eGNmN0V1T1JPUzlNeGJOekhXcWpwaGQwVFBEZ2JkekZUMzhJNFAyTHZxVWlMTCtvekR5T05wcURhc01vemk4T1ZQSDh4UklGZFN5REJ0alJyMUJ2RDR4VDNIdCtLdTR3eHJDSDZsRmJtSnU1azh2N2JnbHgwYW5SWkhJZzNHNFZUTVZ0akxvaXVUYktMaE1yMHJCbDc2bU43aXNzWTRwUUpNOEhEVFA2NDlUWjhibHpqbDBSblp1SndUMk15YXZWUkxKYUZRSnFMYlVabGN3QnVaQnE5eXlwa0ZXTU1aUkRLTzJXd20rVTdZcjZOUUI3WUcxOVNrWDVxVkFqdVg2UGdRSUZRVXFZZ3JjWDFVUGdoTUVCaGJPTGxPb0VZMXh0R0ZWY0Flb0hGdGduY3l5NVV6d2VEUHk1UEFDZVRXU1BaTEtodGRmQUdVS3h6cU5GemZjUHN4djhhbVZOY1Rjd3h2dUdPUEo1WnpIdzg4SFBHdFFGL3RxR3VvUVFXenZVY2RWUERuamo1Qjh1eVorVWZObG5oZ0JEVnI4T0dydUtVREI0cXdiMlFyZktjK2Q4dHBER3RuKzVmTGJOQlBvZGR5aElTdFhPNFJEdGhycVk1ZmxuRVZZU21vT1JDbGdZOHpsMU1qRnplUFV4d1YwWE12QjVEdkVJbGRFeXhhdVZLdWEvRVFsWWthK0tNZ3hoeUZKVnN5R1lSMnJISzhEMVV2VXVmeW9GQkhMeU9XVGxIbDM2aGpsVUxXcFdTMUhlb054L1R1NXl5VjNjd3hjMnNlNE9IaHhmRy8yVGMvUCs1N21RTXdZNUNzeFIyeENMcW9RZ2tZVlA0empibE9YakNqdUdUeVYzT0ZRQVpXT2JIRUR1VjdHWlpYdkp0Z09Sb1dHRFhjTEtwbVdUazhtRFN5N3hpMFY3WnZMZU1TdFFOSXlncUNJems4UWhxWERwYStCbU9JNTBzbzVQNmkxQjVGRTErTnpmdVZSWkgxRTdoL2F4cUx2YmNIVHZVd3p5NE9OWXpNUk9wbW1vMGk0enJFK0UxVUtoM0R5SmpPVGxUQzM0UzQ3S21ObjFIdnVBWFV5Qm82WlZhZmtkeGJ5bXlXd05RdkViaTZ1SGt5TXQ5UnNMZDNCUXVLc0tKdWNpWHVXM3hxWjVXZGRRYUxoVGpjS0k5eThzZGNwN0l1MkREZW8wYWk3K0RGN2dpMURWakRJR0tLelZRVUpxb2FtQmFyTzJhR1k2enRuTGJObzF1WTJIN21EZ21mUGVWYWpuUnFLVk1aNytCSEtHWENmUitNZTRVdTQ0L2lPS3c0MTltb2NMbjFMbGhqWkxhbVBLY25wZ1pXMU1nUVJuQmQzQ0lEM1BiS0hyNFlqUEhxMTNDTk1BRHVQVlRIQS9OUXhLZnRHcDlXR1lCeE5rejhtV2ZjMUJyME1UOVR4WU9mSVBVRkxXTDZuZzgyUGhMY2JaNXZLK1hMa2xFMVV1aWMxQzViMnp5dVBNTVRSSGU0WlFTbzVFeS95TXY0ZjRqSDZRL1pPb1RGQ0xicVZDaTROL0J2S0p1WmY0MUdMaTl6LzQ0WlZua0JQTGhqNDJqT3lPTXBDMlhPVVk2eG13K0JncTdpbnFIeDYrRGVVNE03RW45Y1lXWlJ0eWpqT0llcmdpN0k4bi9xVzVldmk5UktJUXpwNVJxY2lCVzJPNHNxREZtbkg0YmNiZ0ZKY3lldlo4S256M05kU3ExQnJHRDlKMFhLY2R3ZFMyb1hLZ1QxKzRUcVZURVNkeGo4REdIeFRkd2QyOVRsekYvRTVZdmp4NG4yOXkvckdEWitwOWVwNVBKbG1jWHFWeElaY2NXWG9Zcms2aGM1ZVF5YXkxQVRGWGJjQ3I2MUIrREdWTWpGbGVtWVk0bU9WOXppOUE2Wm5nNDUxK29yQ0sxSHlIQU9PeUMvaVkrVExDNjl3TW5xVmxFeXVtSUJHNm15WEZaeGVOckMyVlcxaEtTRnhoZnFHZFdmR1RCWEZadEpiS1RxQmtka3hjbDZpL1ZxRGs2V2NaVkdvR2JsUkxyRGdFTTh6V0tnYm44bWI1Y3MrYjlpcDV1QlJnc3lEU1pMVTVrclR2Y0xjZGJZUnVXNUVHeUJ1N2prZ25henF0N2hlWVNwaVlxODFsNHJyb2lRc2dGZkduVWM4aXNQUkxWb2o5WGVvTjRyN1laWVlHQ0Zzeisza3p5NEJIUnJ1ZVBCOEdIUEorM3FaK1RQSnV0czVLMGtlNkpYTFIzTGNYOXdBdUtGUTZucTVmTTNwaEEzWk9ITkRIWDVZOFBIckR2MnpIZHJBT1VzeHltWVZqbVpHL1U3dllTNjZLbkVjYldZMXU1WGQ5VHhaNTRPZU9EUWs0dktyWEtGNCszVXlnWGpCQW9pTUxEdWNrL3dCc3B4ekQyekt3L2R3TDZKbTI5VGxWWkV5eXRWbk5QRHdORVo5YVBocmRUamp3M2x1WW9UVXlSaURqcGhZME9vZ0ZEOGRzU1lKaEhLMjRvN2hlNWhsUWpQVit2VWVTZnVBZHBMbzBTK1h4WTZsQWFsNmdrdUQrSXJGK0RUdWF1NWk0VzNERTNiTmNPNXJqTlBjMFIzTC9BRjhVM0c0YUptT1dBazRtS3VVMVAxSEFTYU9wM3QrRS9FOUh3V1JHdFJyMFRFdkxjMXNKaVVKQVZvbVJUQWloTzQ2eGhWUy90cUF1RG1HcHA3dXB4WVZvZ0FyQjQ1OGlPUTVYTExod01FUnU0VXNRSFVTb2VKY0xoZ1h1WkFURUtxS0dwZU1GR2dCWmJ5UzNYY1BjYVlYOFhUTzV5cU80V0ZMRDlFOG1SbjVieE9Pb2Y3dU5aRzRWY3hlRHUwWTFrdGFJQTM4ZFRBcytDWDdqQmNYVTVMM0RRbnhzSVB4MlNqREFWYlk5MVROUVNxaGE3WlRqS0FXWU9wemVpVTFDNnFhbitvWXREeG5pUUZ5Z08xaVFaWWtHaFoyWEExTk1Nd2c3Y2lHYjNNZk5uL0lQSzV5Y3ZJdVdwNWJjcUdPK21GSlN4S2F4ZVVjRTFVVUhjcUh3QlRMWlI4T3B6b24yNDNIVlRGeXhwR0lxdnVaWmM5dlpCc0pjdVhQY3h5OVF6eUJHVUh4bFRFcUVBU1lTNzc2SjVNaGJPcHVFVDRvaVhCZU5Ud1o0WTUzNVM4UDEzTWpIbXVIOVBWd2hUSFQ4ajZ5Z1kxcGlrWForSUl2NmxXUUt5MVArZFRHc21YalVYZGtON2o4ZVJFS0srSFVJRGU1WHlUWkRLUFVJZkdoRDE3Z1g1T09KOVo1TWVzUSszNmxKcHVCdTJlUCtPOG5QcUozVXdEbHRac1dteUorNWRGZHpEZzVqbWZYM011Sms4UDYrb3MzeGg4WXdWV0dXVmR4OG1XYXE5VGtReVZpb3h5bUhMTkFtU21TSlZURExYKzVscHJsRzJaWThUY3dSeHA3bXgrTVBIam1LdEpPZGE3STBMVW9ZVE1SRGxpdjZaY0c5VDBwNmdMZHlwalY3anhsQlpCb2d0M00xZmN4eXl4NmxhWmlES3ZwbUg5bStvWkpuTTNCenZCWmpZTzVqZGR3NVlPLytwV243RVFPMll2TFpWRWNrdElLYmprMUJaL3FKY3lQSHdPQzh5SmU2bU9UaXNMZTV3WDNQZndsekF1TkJCYmw2YmwwNklxdTVhRWQ5ZHpBeXpFQzJZK013YlRjenpmSy9kMGRReTJVeFZ5bDB3YWVSTHRYM1BVeHBhWVZLUHpBMXlpMzFQRDQ4czhWRTFNczYrbUwvQUxsaHNiQ1VtRjJUMUxLbkpzcDFLVlZZTFZzMm1obGNvNG8xbE1lUzFCeXdieGR6Tnl5enUrNFlzWDFCMVRPTUFUdWVidy93T0JZcVdWTU0zbWVUZHh5eVZ5eUJ1WFJab1oyTzI1Mm1KT0xqbmJISVZ1NTlYR3B4SWJLZ0RqWU9tUEVibGpHbWFXb2dkTW94SlZHbVV3bFNqYXpHTENzaTc2aFFYSGVwby8zR25abHFmVTFjS1BnQWxGYVpVY1RqcUJxWTR4SDNFYXFCSFV0cWQ1UkxkazdJbEE3aGp2Y3l4cHFCVFh1QXhHYmlveitOY0wxTmxBelBMbEFHRFNsTTVUOXp0K0xxRGJGQldETjl6THlMNHpDcGFGc0JDMkw3Smprakx1N2hrMjFFdmN4WTVhaG1HTXZkbnVmelpZNFBqSnpVUzVubm5rWW5vK0ZmY1RpUzlRdCtFYlYrQzhoaGs4WVg3bFhuTXNVenFBcS9xWXRzUWR1c2lXZ3AxbERRd25LWXR5cmpINGNybXd1R04zREY2Z2JRbUp0NVRwUVpTbE0rcGpXTjM4VmJVNGJRbjlaY3hSbXBZTVJsbFY4SFh3RkVZcnFaYjJzQWxCM0FOMzZsM0FPUmZVb1Y0OVRGTFprcjhJVk1Nc0FlZU5yRW9OU2hLWmZyNHFGR1V4UHZ2cVpoeWNTWTZnL21hWmRSTGFKaGc5aEtjb1kvYjdNUHF2dmNzY2VweVZzMUhON1djYjNTeXpvUGpaR0JaTU8zNHd4NTVwWk04VEhLaGcrbVpKZXhnZ2wvMWpsU3AwdzZsa0N4bE1DVnVGMlZFdFZoRWxmV1g4V2VvTFVEMS94OXp5L3hoOUxtNklxNFZVS08xaHVxbmw5Sk85RVN2aGRmTEdISzQ2ZnRIREVMeGZoaE1TNGdNSmdPVXpNVEthVHFCcVU1TlJ4Y2ZpaWJZbTdQaTJ1TUx3S2ZpNWJNZmZLTCtPdmdTdHpFdWNjc1k1Y1BGeDlzOFdiajVPUk0vSmxsazVwS1VqaUxQMFFMTGdVTXQrQ1pFeEZJNkp5K29UQis3YzlzNm1YR3pjQlRLalVTYWdEQkNZdStScEk1T1N1WmF3NlluMHZVWTVETUhFbTFZNGxhK1BVdTdZWWZXVlYzcVZqeHYzQ3BjeHlEREkvTVQ3Ukk0NDhmM05Nc21xbENmQmN2NHBKa2NHc3ZxL0ZUVWFDR3kxbXJoeFBza3N2Ulh3UiswS0paT1AwY29OVmVsanF5OXhZTXBqRHFjcTJkazcrenE0Y1NXZkpqZi9LRGJNTVB0dGg1SERScWNzN1VpTmJpekhLZTVsQStzUHpEYmNZWU1ISXc0d0tJWkpvWnBlcHdlSFh1ZDZadkdWZnFkUTNNUWJ1NWl1SW02aGRYU1RrMXR0aGxVR0VNMjRkM1V5aFVlTlZGNWwvalJBMVN4M2pDc1VYY3lSOGxnaERLdHhlVEJDWHVHWGNCdUdXV09MamZjdUx5SU5WR2xXVktvdVVtTCs0UzV5bVE5a1R5VTFPR1lGdHgyVUZUa21OUnlsMnlpcXFCOGdNUUpqVEdHb01XM3VMQTk0eDJ3cVZDS0V0WFVYTFhVdXNsWjRzL0hoeHp5eHUyYzFYZ1VSeWZjTWhqbGF3SGhHaW1aWTQ4T1UrcVVlbzU4MHNxdmhnMFM1aUQ4ZHNZcE9SeUgxTHhjWmxzcUNHcHI0VDhtcFFJRDNPbUI5ajl6UEFNb1l1NTQ4U25sM09FNC91V0VKU1lDKzUxNmg1U3FNZHhSZHkxZzFCUmlmZnFMTG43bks4SllFVkdraGRhNmpjR2lDVk5Xd3haeUREakJwU2NoSmlYbFV5S0piVTVRYWl3Z1Fkekp2WkR5VkJkczcrRFV1SVdlMlpXTFpCbVRjeGFPTEF0WmZHWTVUdG1PTnpYSkNHMWwvRnpDZ1ppWVhFeDlTcUpqSy9VRlpqOEVjdFZFc3VkbW1lN3FZeFM0MVV3MEs0Nm5LODlhZzVZMkRDMXJsRkIzdjQ2SVk2dVhCeXFkc09tZUlNamN5S1dHNEo4Qjd1QURHNzZpUHhhc3VCRFVXaUdITVc2bDhaWk9UK0lQRWwzSytMZ3d6cVBrc2crb3RhSnpjU29neXFKVmtyL0FKeS9jSVRyVUxJdTZZdE1NbFVnbFc3WUtibWt0K0NHUUVaam1IKzVpbUsyVEtFRXBxWTEzSEsySkRRL0tURWlRYUpkL0tGTnU0WVJvNmx2cVdxVkxWU1hUTExiZzFCdG1POG80Z0lUeDRpMWswVC9BSkpBV1lZQ1BKQkl0a0tpbHhxS0VFZEVwU1dFTW1rUGZ3UWE5U21vYUc1ZlZERStMb2RNcElTMlkyd0xzampBZGdNNXBSc1NOcGVkcXpXTmxUbGZyNEdFdW1lN3I0TjZxYVBDOVhMb25KdXFnbGJnWEFQZlV2ZGgxTThuSkhQYk9VR29ORGM1WE1LeWFDajl6TkR5Y1Q0RVpheXdpenVCSHBKbjVqeWY0K1BpY01UaTZ5TzRGeEVoVTJFL0NReCtGSU91b0h1TW91NHhBMFFlUlUzVVR4dmhzeWY1TDY5U2xlTjlRNElyYzVoaDFPVU53VTNOMndJaGRFM0tidTRWd2JZV1F6c2w1ZFhxR09ybHk1L3VmMWhWVGw3VmhtdnRxS1o1bXdLbVZHVkNKS3MxRXlDMllaQU9MQzI3Z1dYSEdpRkVGVUo1ZkUrTk4rcGlvUVdiM2VUT1J4anN1Q0U1UHNtTWNucGdlMzVxQk9scjB4Ym5VSVNnaG5VYzRaT3lZa0RCdUFNNjNCZ1VSQ0ZFOXl5RGVvRzM0eEpTWEN5Q1VWS0ZRanh1dHdzWXYvOEFHSDhiU2pIRGJWOFlGTmRrWDhFKzNHR040OXpETHN5TGdGTDZtTGVLVGxaVXBxSDlaamd2amNpTm9kRlFHN2wyd2pqVlFmc2txR3ZqMHovaFVBZHpKbUdON1dPRkxUQVdCazl1aUJ1Y1NJekp1WEJ2S09USFpOa090eHo1NFk0ZXNZRzUweWhqTExtdzZKZXJJTnpMVUI3Zys0dmJNYzA2QnM5em9nWDJ4NzAzSEVyVW85VFo4WWNOOHJoM3ZVeGlFdjYvcUxqeUgwUlJpSEdZaFhmeG9Jdm9nU3lxbHBQMnh1NGszcWdLbVdUbjNPdXBvamtQa1NCeGZpcGlpby9BUEs1c0dvZjhibmt4d3Y2WFh1NXNnM05qSEtET2lYay9CWXBEYkhHWHhtMzRHaW9YREh1NVJPWVl1SmM0OG1Bd04yeXRyTnNyNjdob2g4RkN5dHpxd2hiYzNNUzV1RHhZc3VlNGNjOVBjd3h4dE1tSnQrR0xyYzVVVkR4WlpxWUNzSEVFVDdUbGJEN0xVTnhLWlVTZHRmSGhQRzhqeVdGYXFBSXpIVXk2cUh3WkIzZHdJMmZLUllISzJKcTQxY0s5ekYzVC93Q2hWZFJ6RnhlTTdoYnBqRFdOczFVQ09PeU1KVTlSbExwMU9MU1N2cjhva0FlL2dLTG1MVE1LdzdtN1djYlBnM0JDQ1RsT1k5bGtjcmJ4S0lLNU12Y3F2akRHMjJPR1BZelVOTU1CeFZaVXV0ZkFWTEpqK3htSmlYeUgvd0JESk1VUGN5d3pQSC9KVitOYXVFRW5KSFV0TnkxM0RQTEdXdTJjL1RjZTJ1NEtFdFg0Q0FNS1Y3aUhxNElUc3U0bFpRV09MTWN1SlZUbjlKbGtBQVQ4WE1UdUhWUllOeHkzdDFjelRtdU1HNTFNRU5zVVZxV1F5Q1hmVVdHMzR5V0ViNmduUkd4Mzg0MEcvZzFPUHc2TFlCVTVQT1VJL21ZRGxlVlJXbzJsVEdYdW8zTnpIRVRiRWF1V3d5WmR6YWIxTmpSQzZ1b1pQUjFIdjlmRm51ZHhvYWxrdUNUdDdKa2NjdE1XNWlmbnVWeFVaZjBaaTVKTFowaU5yTFc5M01XVkhHSnVwdWtoc25KNnFBalpITDJ5L3dBei9XTVg5UzRWWU9pWm1PT2J4YjNLcjR1b3R5cWxzWFRDNjdqZFFaVkdtZDZZV1QzYzd1YlNFMHdTeUh0bTg5WXhkbjZtNWNLeVNjZ0dGT3BrK2p1WXpISjNpOVF6VXA2aWd6SExYNXVDcTNBb3VtQ0NUUGViWDlZYUoxTzRkMUZUUTZpK2hnc1FxREJkREszUCtYd2JtVXVpYTRjWWdwRk5nUWJPcDNxNm04VGo4REYxOERxYnhPVXRTcWxaZFJsTVBsS0wrRmFLRFV6emNtMkwrT29KVUlFeUJsMGZBeFZnVCtvckRSY0cvaWsreERJeUt5SWppYU5TaGkyMGRRL1VWU0FoR0U3WUFTNVU2SXoxRFJIRkM1N2cyeHU5YlprT09ieUpjOUJBbytGYnFZc3VXemxlMld3aThwdVd6SjNOVGxGYm5LVy9EblhST1g1aHgvTzVqNWVHa3NpK1BQQyttY0lYei9VN1dwaWNuZ2R6UERMeFBETW5HNCtQSkdweFFGZy9HS3JNOE9LTUhjc0lhbHpHV2ZCUkF2cWFPNWdtUCs1WXV6Y3kzVk5mQ1JPTFRDWStmTER5L1NaTjVPVFBUUjNNVUw0bTRDalRCVTJXVFBqWnhnUTB3VG5iTzJiNzlmRENaYi9jS0hsSE15eXNJVzNLdUdvQkhHaFpnYVlrZDErb3BCbHcrRHFQVUdvRFZ5MHk1YXFWeXRsUkRVUTlRTm93eE1jR1h1R1drbUpxYUNGb3lySTZsSVF4WWpheW9Wd3FCQ0RseFNwbDVYK0xIR3BxRnkyNWppM1VBQktsa1hFSmlEYi9BT2hrMlQ3VXNNVjNPVGZVdFNHYUJNbHl6WUgybDdnNm5MS3RUbGt1NHNHQ0NrdmVwenlmcXJ4L0hxYXVhbmordWNVY21BVFJORVhVV21YQml6bDlXbytTekVxVVEyM0YzRXJHQUJiUDlSY3NNYmQzREs0UElxWjRoNHhlNXk2K05aUzRKOE05ZlBxWCtENElnd0tZdHhsL1ZnM0E0N1k4UW1XTndwSlV4Q0hGV2RkYkppWWNyU2NTRHBJa05icTRaSU5YdjQ1VVR1S2pIWHdNRlliMU5CWHViTnd0RzVqM0VSN1kzVlJyb2d6MXVBVjhGcXBDbkh2Y0JJWXBiOExMbDJ5dmdOV3NNd0g5dzl3Wm1uSS9NV2gxTU1naWgweHpVaGtrdWR4bkpEVVV5WWpWekZHSEJpL0RsT1dvWi9TcWdtN1prbkh1VUJMb3FhZFQzRFRIeUxLV2JsMlZNaXB3YVdBVmQ3bkZyVUx4VUkzZHd5czNFSUJGK0IyRlJ4b2YyelFOVFBFUEhpNHU1bVpZNGlJM0RSdVpKcVcvOVRKR0VXbzVjaTRQR21aZVM4aFlidG52VXo4dVdiaW9GWXczbXN5Q0dUM2wwZFFRVkdHSGJBYVpiVlJISGFUeDZialRBcU5MQkN4dVdWMUJXSVFkU2lMalZUcUdTNEl3Wi9qK2IrSExMTGp5VXJjR2xydGlGYmR6REhIMnpJUFVNazFMWTBoTCtMWldyZzJUbGNMbktqNHJFUDNQZDFNNmN1UVQrMGNaeHBsRlFxN2dMY3RuUkJxWHY0Nmx5M2kxTWNzM3g4YUk3SmRrSVhMeDl5MUpqU1Rsa2xTajAvQmxvajVQNUJ1VngrQ2NvM0IxRGJ1ZjFZWlVPcmhubGo5aVorVG44Y2toU3pLdVVPN21GSy9Gc3hZTzdsM2xjU3BvK3pNUnJsTHRsOFNHUkJwbURqaTVKYzhpWjFsYXNIY3RQYkhKNHdac2hmRnFMazF5bXBsR0RENHhhV0pDZHNZVGZ1VU1HcFNzTzArTnVpTGt0UUR1VUxxYkpwWjdtSTN4UzFsT0NtUkFzaWFyOFJKV3FqQjRreHgrOURNOFhCcXlHbVg2bE1MSnU1ZFpSalFTbzZtcXRqQmdYcU9IR0JCMUhMR3FTVnJVSjNMQkppYllINWRSQ240eHdjdW96WVRvajBTclFjcUptWURXT2R4eE9GM0szcU1NRUpqL0FGU2VQeDVlVExqanRuRnd6TU15Tlk1czVRbUtqY2VmUGVybkhKWndYU3d3cUFScWFnbG01ZXF2VUtEdjREOXl2dzNDbVY5ckl2ZXBnR1dlMmlhNXVOMGVtQngvY3F6VThlRmkvZ2luNDNDbFdCY2FDUEZna0syc0ttbzdob1NVTGNZUklCOEJEdW9oTlZ1TXRqMUNxbU9TSWxUeVo1ZVhMMURGUlEwUnFndVZYWHhyNGFCbGxmSkhxK2lWRFV0dXIrS3FKTWFsYjFOOUxNY0wzQWhnZGpLSUFNREZaeHh0ZHpYRFVjYXhpUUpnZU9zdWQ5YWdPcWxzeC9OUmJqZHl2aXFsMUJtcmlJUldFMngvM00wb28zQzViRVUvTXBsYW1KaWllNFlwMTFPeExnVWZJVG9nc3NaZ0QvcUVZZmxtSDNVVUNCYm9KWk9RVGwrb3Z6aUdWcTFPdWlVM0tyMUVLdUZkTVQwUUM1ZTM0UllpQU1yVVAzRXJLeGpObXBUT2piQXM3anFMY01xMWZjVForb1oxZ2tibUpmdjR4eXZWUkp1dXBqT1ZGaFBMd01NSERMblp1Q1kycEJEdll3TEx1WHI3UnBDT1JML1UvY2ZINUREK1J4K2pxNWZvNmhWUmRlbWZyR1ZlcHl4VUtxaUNGeEVJV20vK2lZMTNMWnYxMU1TUGtzNEpGOURFMVoxOEdQMXNoakt0N0FtSjN1QVErek5YTld3U1BldW9ZaGlmbUMzSFZ0VkYrc0RVcCtGMU9VcHVjWTZJOVEwUXd0ckhheXVMVVVsN2psK0NLdGs1UFRCbC9hSzNNTWpkd3o0MzliZ3JMZmtXcFROUWlUUk54SXd3NVRqRXh1aUZHWGVwdTRoYlh3K29rN2dmSXl0YWwxMlJ6RTZtKzdsRkN0c1FnSGF5cDFveDNFeEQ5eWljWjB6UHY0cUZPdmp0bS9pbGdUQ3QzS3JycVVjTnNvQ1Y5Ym04anFhWmk3cE5UVVFRbkJQL0FFdS9ocUxDTXBnTDZtUlFiZ3pWeTUrL2pac2p0c2psK3BvakdQa004ZVBDbjh6RFBMdzdOc2MzTlhKdU9SWVlSdTlzVDQvYkF1VmFyTk9GM3VNeFpsTUtKbTgwSUFTNTFCdVY5b2RxOUVQSGVIT0dNSzR6SGZiOFl0TXkyeDBUR0Q5bzFjTXdseElRczZZQXhCZGZCS3VMVTFYd2s3OFppZGt5MWhQRGxoNHZILzhBWC9kbmt3OG1PYnlabGprTUg5ZkpibGJMN2hDS2pLK0EydzJVeXB4aU0zaEVleVk2SjlyWmFNdEdmeTFqeHJjd3o0M2N4enlMcnBqWkIzTHBpczVma21rbU1Xdm5yM1BXaUQrU0w5ZXBaN2wvR1NIeGg1Y3ZHM2l6TE83YjJ5cXBSRmhIZnVvYU5NTXR6TFd5ZVBQaGpueE95WCtweUdIYVI3LzlCb2cyejNYS1o1TmNlUlh3TFc0ZDNLVi9VcFpqY1JKak1TbTJMdHAxT1JDb2lNRzRQR0dWM01IdUNWUzduUkxxWjVpVVFzdjVOQnFLa1ZJV3l3N25MOVFZdy9ETUJXY3BjdS9VNDhzRkoxVnpYR2I5TXdxdTUwNmprWjlhbUxxcDZaaGdJOG1XREVqWkFmYzRhVWRRY1VpM29qais0UkNjRWc4ZmhiUGhJV3d1QVNuZFE3VmhxTmQzcVVUQ2hqdG5VU3R5N2kzM0JDTEJKaGxpZGtjdnN3bHJETkNXc056dklLbTd1WThXWjhmVXY0RUlaRjB4TVY3aFJQMk5NK3poVGtFb2dibEI3anNpNitPVEUvTEJhcTNqQ0ZFVVowdzkzQWIxRW9sM0YyRU1YZ29hdUg0aTFxQWtNbUt4R281cUdJYWxzVDRMaHlaK3ljVjJSeG8rT3lJTXc0anRqUzZZOTFLRTduS2NiWWxSaXF5MWdiMnhiMFQxRFRZejJ2NWhzWnFGY2dZRlpSK2JsaENXa3h0blEzQ1crcGptNUZTOUl4U2huN2xpUnFHeURNUEtsMUxkN2g5ZHM3R0dWRUc0ekYvTTVibkhITFB1WFNrdVl4c1dpRmsydytENHVvMWtXd0YzTDNOUy9iRjNISzRzSFV4ZHhTRlN5WEtBc25Rd2hobndjdzBUOXNkd2NqSGlRdDdZNUQxQ1pRWXQvd0RvWTF1Skh2NFBqdVl0UmJZa05HaTVheXZyM0F4NDdaanBzbVcvMURxUFh4ZGt1ZDFLREpoeFJydWJEYzdaVE1Ebm5VZjhmeUtwalY2SjUvOEFCZjhBRi94OFhOT1RHWHY1c3dkN21WWHJ0bE9KREc4Ym1lRGlsL0ZDUUpzOGRKcUZ3Z1FMZ0Z6UEVpUnNaWVl4MEVDZXBjR2lGckFLbFYxTkh3MkV4U3d5YUo1TWNUeUppMkVOUHdORXlyamlFeHIxM1BKZjhRNWR4bGhHN2x5N1lkbkxxYXV6cU14M09pYXFETXM3YkNweWg4SmNxTFJNY28za3hOZDduY3c0WllwbDlVbHhXcFNRWnl0cUl5cDYrQ0M0b25aTS9JK1RNeXl4SmJWTExpMlJQMWNQamlSbHRSL05ibms4MlhteHhNZytwOEF0M0Irc3hwSDJrR3laR3RkeTNoeHJVTVgxT0NOT21CTVBGbGtzY0c2bU9OWmJqaVhwaGlWQUxuMDk0eDFxb1plbzVwcVpPVlF5WlkwM0c0WTExdWR1L2dBT28xYzNLU00xTlZYd0d0em90Zy9yNUdLdmNidTV5Y3B4WWxmdVhDN21Bc2NXT2FHbWNsbDVFRm1LOUxMTVcrNXFXWFFReVNPYTNBQW1PUGFNNGFhU0pVOFdIOG1aaVVQN21kaDlnSy9EY3UySkJhcTV4S1NkOXN4cjJSQzlFT3lMTWNnOGFKYitaaTZTSzQvdVkvYmF4MlF6Y2RHNFgybW9VWlM5dFJualFYbGpjYUxQZ0NwMUZNbzlWYzQwZHhJWW54VkV3QkVoZ2w3R0pWYnU0akVjZjNQc0VlUVhCZTRPUkwxTFc1eUVxb28xSEdBTHRqUS9tVVpHaXB2cVYrNVJNVzR6RVVRUGkwSmVxbWxxSlVMdmVvbVBySzVjdW0ySDJkZFJVZUp1SW11TTlRcnRJWkpnZzZaWUU3aU5hYmxWTVorbzNqOERCdUU2SmJkUmVPb3VvdHdRSll5Z0kxSGlTampNVDYvTHVBTWRSYkpnOFZVaXU0SlpaTTNhaERSTU1SOGVXYTllb3h5T05WVXgreFVwRkNVcUV5RTB6R2cyZkRjM01tOTFMai9XNEQ2K0dXb3pHRk9xbFZHWWFabXpzMnhuSS9FN2RTbzQ0Z2J0bVFTaTcrS2cwUWpENFBndTRrQXFDNUhDNDBGQi93QncrcGFTaHc3dGpVMFQvcUZNQ05RK0FDWTRLdFI3UmhRVER5NVlZdUhZekl0dXBoaTV0ZFRNY1hjNGs0d3gxSDRhSUZ6akVwaS9IYzdFaE8ybUd2aGhTUXVHOVJDNVVKbHNneTR3dVZEcVkxeXQyZmlaT0tmWERqQWM3Q2F4ZDl6SHk0aFBGNVBEUDhYL0FDUDhUUHk0SGtVTG4vNWsvd0FBOEw0L1A0cytmanlKa1FGYWdjb1RKTWtqeDVIeHlTWU5MekxuTDR4enBqbXBESmhPVXhkUzQ3TG4vQ1d5dnJjb3lKL3FaTTNFc21MR3lDak9VY2hPbzdqcXhMSVV1VEErMHlJR3BYNWdVS1RJeVNsaXhRSnlzaHVHQndXNVRVdGRPaUFBekVFbDAxTlJKcW9aRTFGbHk0MHpHaTdnRE9KZTRtSjB4RDJ6R3RxM0hyVVpVTVFJb0ZTOVRRMURGUlNDczNDSXNJNElXTXJOSURNYXJjU1ZLL2NNZi8zcHc5Y29nUXFvVk1mSTRYUmR3eTdZTTV3WHNaenl5MnN3eTN0bkpWcUs0ZzF1ZlpnUzNxVUVZcXN4b2JZL2JPSjZ1RkV4d3UwT29WSE16S3h3cXBScWU1b2pUQ05CSytzQUdhQ3BabjFxVlJNazZtcGV2aW83eGxhcWNhaGY1bEhYUFVvbkZ1RmtiQmdEOCt2aEJpYWd3dGQvTFREVG9oc3RuRWwvWFhVejQwT0lrSitVaGJBV3dMcUc3dVd3WTZMblpNWjNOb2hQVk15d01lTlpEeTlmaUk0TmNtcFVOc3lSNnhpSXpqQWxVV3dJWVZFdVBRZkpPQVkzY1VjQUNuOHlrMEV3eDcvVVZXVXhYS0lodGhkWFViZy9tZTlSQmxhdUtwQTBRcmN2OFRrTEM5eENHdFRDaDNMckw2dFhQVDlvdUtmdVk0S1NqSFI4WmNYcnVYeDBtNS9hTkdtQVlGRUJLUnRuUGFzOTJRaHV3bmVtR0g3aU9MUXgxb2hpRFVjSzZtV3o0Zmd1Sk1UM0t1TzJwUjFOWS91R0JEdUZKY2FaeDVhaHBxSk4zR2RHcG5zaEQ0YW9uZWNaYnY0UVlacDBiSTQ4TWVRMnNIYWtjcjdsemxMK09VczQzRElaakZINHFCdGxveTJiWmNJZTR2MW5JU0dWRTVTNXY0SS9JM0NFOU1JbU5hZ1ljRlhaTDkxQlJXVWhYNWxkVzZpbi9HZHMzOEh3SmU1eWxmR0dlSUlzMG1waXdkN21XU3pXdHhGNmJKc1k1eTRrMnpvbGhMRml6RUdMOXRRM2xLcGYvUnl0K0Q1N1psYktxRVAzSDV4MUxXWUJlK3ZjOG1HQm1HS3pIQTRaWlhTU24rMTJ5cGhZekpkVXJVdC96UDhBOHRBaGVCTWhDdjNEREpibmhybnNFbWFYOWNRSmlvcEc5c0Q4dzdtT0p5ZVRHSCs1dUhVWVdOUmdKRHVaRllkd2J3N2xoT3lFeDFpeXBzWmt1WFJUQnJkdzhnNG10ejJqR3dpc0psK0I3Z3ZWUTI3aVRBbWZJQytwam9RWjJ3R0pxV3lvVUZTaEtJd0NCS3JHQXNKd3N0bjFxY0lrcVVSb2h4bEhxVU00emh1b2lMT1hSVUQzY3B2NVdqY05zTW5FUVlQeGN0bjJOcEJmenVaWnFRMnoxM0c2aUJEWTFqdUZrRkc0WkxjZmpmcG5HMkhhV3hkUTcxQzRFN2pML2NHTXRaL3Rsc0JlNGpBcmJBMWMvbGFvSnQ2MUxvcjRiOWtjZFhjUDBUYzZPcGszUk5rUHRFSS8wNmdRU0hHbFM0UjBWOGRzL3dDNENHblVwOUVyMlF2NFVvaGozcVcxUlBKZ1lHTlpDc3hON21XTVAwellWY3JLTXFpNGNtbU9LTGNEM0hlamMvcVU2bG5SR3VoaFdMc3NpL2Y2SGZxWHl2R3FTZUh5ZnhLT0EyVGg5WEpoZ21QS1pFV1lna0FwbFEwejdUSGxDeFp4eTd5SmpWcE1vTE5zZnBMdjNHRXFvYldBY2RzRDRzbHFVc0VKZzFjLzdxWXJaV0psK1NaNHVPYUp4L1VKL0pseDQzcVdkdnJxZnRnMUFqaW1BNlJnRkpIYjhaZFk4ZFREeG5reXkzeFFqTnpiRm1CVWNmZUxLVVlZT09HNWg0elBOdENjZE1DY2ZpN0FEZndGRmpUUCtwak9ydDJ3MGM5eStSYWJnMnNJVnRoc2hreTdmaW1jY2tnNzJ3MnN1dFJOU2xOUlQyUW5MOEVESjdpZ1VRalpQZDNMdWVNRVQzRTRMeTdQYzhwNHorTjhkMjQ3aXJkazlseGd5dml3WnhISFRMblRaTnMyTUdESEdPTmJoRktsVHQ0blVOV2ZCRXIxTnNGR0tzd3p4d01yd01yTlRGS1ZhK0dGbTFtQml0dWlPbjZrY2FMWjEzQkFXRGZ3NlBnMzhEK29iZXBkTXVXekZDV0xvZytwbTZxT2EwcjhiQ2JDWTVVM0ZWaUlEV29XTE55MldqRWJ1R29RdWQ5c2FoTVZOeFhQNEsvNU9wa0FDWldTeXpqRTNBVmlVUkVnZkdKOWlvamFMOENYdmNVbisyRlJiZFM2N20xMU9MdjZrZVFmT1NaZ21QRm1XR1hqNzZZd1NFeFRrMldWTWJwL2NjblBJb3FvWTE0NW1jVnNwaGFUdUE0aVQvd1R6LzhBRmViQjJWMVA4bDRlYk1ycG1MWmJBYmdYN2xOemJaRGMyUnU0QVNqMUJ2VTkxOEcyT21YREhrUnhIR05VUXArQ1ZlTXphWVV1MWxjZEhVb0dtSFpDK1N4aTB4U1hPZjFvbTJlUFRYNW5XYVJ2SWJaNHZCbG0vV2VVNG5aTE1OMUxta2hOTUVHRGR5OVMyV3Z4ajFMeXBKYlVWcWJpTUVPaTJMZnFEYkxSMThjbWNnMkxLVVc1Wi9FL2taL3AzUFgyaXcwUnl1SHp5bUtSM0hOeU9MRHVNSWFiWVczbjZtV1Z0alJNakVCNXA4bi9BS0NtVng4amxrNU9JWEJyMU1BYzZkRlJ4cnFFTXFqSExFdzBRK0RLY0h0RWlCQ0c1V281YXFYTFNIeG12RXRKbytMWVA1K0ZsemxjYXFHTmtDQUF6RWJtQ0hNejJwcVY4Y2ErQ2lEYzBhWmVGMU1zVDFNY3F1V1VoakRFWVkzR3pSREgyUU5iN25ESkZPb1RkTUwvQUl5TjF1VzFVeDFucU9YSmJKbmpTSlRLL1VXSDFSSnR5VmdYbHA2SlQrWUtQNmpsTVhUQmc4V292eVpVczUzT1dlV3BUQmhGVjFISlRjSmhhejNPVU9KaE9KSzFBb3VWZnlQeGhlK044b3ZOWEs3WlI4ZGtUVXNjUXJxRWQ0eFd1SVRvaDE4ZmxMR2FvbTViRERQaHlLbTI0WGoxRFphN2psOWFpZzQ2bVdkdWlFTXA3bGdyQjFjVStMRHFPZHR6K1hJOFhIaVRsUk5IVUd5QnhmeVRQUGxvSTBhbWduYzVjU2M4a2prZ2FsWUdJKzUzTHFYeDNGTWlEVUxZcVFnOXNIbEVTYUl0NWZXT1RNcytSaVF3Y1BGam5ua0k5Zm1DdG9GUmZnaXlySWF1YlNYNmdwRlVtTENXcFV5dVdrOVQvakRUY3dPYXNTbURURmNvWVpaM1RWUUYwc1NwVVFTYmNQamJsTWoyUUZJRmlETzlSdzQwc1lOVDNNbjRaaUxHeWRzb3JjNWZXbnFXUTB4MFhPMGdRK083aEtRajVjbkRoTWVsZmpqRzBnM2lYOGJ4bUlaV3pYYzB6QWpscmp4K0ZtR1dQTDdHb2E4YThkVHgwNVE5emxwcVhlRXF5WFJEY0NrWXUxbHlveW9CTUF0ajNEeU4xVXR1V0x0bldqNHplZVc5TXllWGJzak1TajRHV29BVEMzUjJ6eU9YandEMlRQTEx5S3N0Q0Q3bDhxcWYvbGpPOFBOaFAvSmVPdjhBTjhwMXVBOGlEZTNKV1lWbmVPSTNMcExOeHZldC9BeTdsVDNDZEV1b3RDeGJDRXd5eXdFSFRQMnk3WVFDQ0Frd3RtVHRKanZMaXZFbVlZcURaK1pnaksyd2l4Ymxrc21OUkM3SVdOa01tMXpqbWhZVEh5WjRrckYveDEvNVhQdDdtWXdaY0tpdHd2MUNNSWE3M0NWdjRZMlM2YjdsbzJRV2RTNjNNODhrSnkxTEttS2t0TXRFTWdMcmMva1gvakxZckxpMVU1UzE5UUp5STVSUkxxT1gxbDNMVFh4YWE5U3J4YW5mN1NZbU5Xc0J5ZEVTcHpPa2pMdjRWZ3RReVhVdEdvc3hEM0ZNZEh4eVJzbkxrV3psN3FaLzVHWGxvcnFHWk9RNkljUW1XVjZ1QjQvYk5TaU5SU3FpR29vNVhDcFI4T2lhWndQUy9Gd1dYQm01cW9XTXQzSEpxb2YxZzdqZnFLL0d3c2cyVGsrNVdtcGdtT1c1eUxVbC9HSGt5RExDOU03WmprOFdLQlVIb21RdFZPaWNuSm1Ka3djc01wWTJ4eTZqbDl0d2FFSVpqbDFGeG1JTXN0Q2RNb1cyT0tGdlVhK0xsbHc5a3hSN2lHNnVWRVpnZ3lsVkdONG12Z2xMQ015YURHUDE3R2FpRDFDWlVzeEVnYjJ4RmRNMUg2ems1bFJFT3pjKzJPdFJQeEJ2b2hHYXh5dUxhd0FiaWpMMVpETk5QdVhqWEd0eTV5MUxJVFRLY0lVa3BtdmNvbTFseHBKcDYrQ3IrQllyOEZMY0tOUU5US1k5UTdoTXU3SU1WbjFDQlpMakZKbHVDZDFhVG5iK29nUTF1SnlJZldHMkxOck1zT01FQ2N0VkxROVRWU2toWkFYYzFFNGd3MnpaTFdZN20zNG9kd3dvdUlNeHFlNWxvMUtLM05RYVkxTzlSdnFWY3Zmd0hKMURKd3ZHWlpaSUN3YkpVTlRqTGhNWGpsWXpMSlZ1YWprc3UvZzVQd1VJckZMc2c2bXcxTGF5aHNxY1djWjZyNE1rWjNBdXhabGlGVXpJYWdzYVlsZkcwTndNdDBYOHVlYmpWNmx6TFIvNk56RlQ0c2lSeHhvZWQvcVhjQ01QamQzSE5XS3JVQytyYTdqa0xvbGpNcXU0ZHpMSXk2SmlaWlc0NHRFRDhGekUwN21HZkhPNnVlWHpPYkJTYldkUTdHZi9BSlczNTh5Zi9tRHhtSC9rODdlNWhCWmpkOGhxY25TelBOemJJNGpNL3dDSk1UeGlOYnVZWTNjdlNUMUFyY3hSSll5dVEvQXFRSmxENWRkd3NMalBKbGpuaGpXSlliaFZVVEVDZFB4VXFPTUM0RkgrNFhjWGRzVzhibmNCNFhwaXRKTXJaU3grRFVlWDRnbzZuYlpGWVRFcDdpd3ZsM0tqZGFqeVF1Q0x2UkF1NmpobWVyK0YxTDFLWmdjUjVURHI3Uy9zL0JjR2ZwU1puRjdpbnhaRm1LM0hLWnVMZ0dQZndFZjNDaVdjRTl6b0Nabmc0RGh5NXk1ams0YkoyOG1MQitGRStMVDRIZTQ3eStlU1FKVTNVTDlRWWFuY05keENCR0d1NVhLNmxJVFJpa0lUYWRrTVZIWnFjU3U1eC9jcVhCK2NVZ3hZTnN5bThlNFFhSnUvaGZSTU50V1RJVmZ3UzRQS0k0Tkl3U0RIZEpGT0pNc2VDV2xQNGxGM081aXFnVGkwdGtLTnd5djJ6WTl6SEhUTFNaS3h4Qk9EM09DS1RZZkJXMktPNHprNTR6bGlBYitDaTdKanRkVEdoYmhVN0dtRnk1amp5TkpLcFdEREp0SmU0NVFTV1M2M0hOeWZnb2xDcVRoSzFPTXhOc0F5eTFsVWZkdHdyOFFLTFNXNWVwaG53enVMZHZ3Q08vaDBTaXBVb3FjVWJaaDR2SjVXc1NqOHg4Zmgvd0FjcnlaR2VjemNWY2dxNEZ6M0tSMUxVTGdWTHZVcVV5bVczcUN3eDdTSGV5TlhyNE53M0dxZ29TN1NERitPTGtVZHpkdW1IVlJEdWJXWmE3R2JNYWdNWGNaYVM1VXYweGd4UllvWWxTNEtyWVJIMndsQmxLdDZtR0ZzeWhqa2tCcGlTMW9xR0tMTGlRS25xVmNOUy9ncUVjdHc3dUNMc21SaU9ybGZJL0pCZ1hPVkNId2JsejNPS25ZVGlZNHU0MXBtaGwzQUdMV3B4bHpVc3JVTml5NHVyaTR1Snh1NWNHZXBiOFhaTVRrMTdsRjk3SmRmR2lXVHQxOEdlVnFNdTRyUWs3K0RjcUJFb20xaTcrSEN5eUdONFRTL1UrQ0FKdUIzTGhsOGNjc3RwcWMvNHgvalVIMHdWVy9qRXB1Y0M3V1k2VUdIa3p3dkVkTTU0NFkxZ2Y3dVdiU1lZSEJXTndHQ3JLRHVNLzhBQWY1SjRQOEFMVmFLbi81bHk4Zms4dUhsd1JsbktnaVFOeTduVTcrTUdybFJtRnJLbWlYU3dDcFRNYWkwd0xZbEV3ZU16ZWN2UkYrS29uWkNWRSswMStaeFo0Z00vdktYL1VvNHpqY2RZd3h1NmdwalV5NC9IcjQ5U3FuUEpFaDNHZTVxTlhNZUgyV1l1Tk1hbUNERjFGZ1M4dUNXd2ZnUWdqRWxDZDE4YWxqRXFVTzVwTFlBNFFOZk4vSWZBY3BWUitEVUl0RVBnSjcvQVBRaVhBcCtEVGZ4UlRVSS9rWVBxbzQ0NEgxYmhrK3o0cXBkd0plNmdrTXVLMUxzM05IdzVERngvd0NNYXNtcW5qNFg5bVlmeDgzbmZDWmhiWFhxRWNiSTRoZ1RnbVAyTlF3M3BuR1ZFK3NFcW1CVEhHSlV3eEdJRUN5WThnU0FtYzIzbDFVY255c3JocVlnV1F1b2d6djQ0emxCKzFSUGpjRnFYTFZqWTcxSGZ1RENNdU1TajRHTUVJdFQ5czJhSnRJSE40ekg2NW9SM2MvcjhWdWRNTnhoS1BubEJoMU9TeWtkL2lVWStQbXBVTHhMMXhZSTdJNXFVd2lmSFJEUGN6eUhxZHNIU1F0TlR4K0xMeXNQSDQvRVczbmwrS25rOC9tek9KaTRucWlQaDhqdHh5aU9PbUROUlJtWFlFWFVNU29aS1hMYXI4eEFoamk0NzFQQ1k1K1Y1dWdpbnE2aFZRNytleXBnOGZ0SEc4SlZGWE1TT29aUk1BNWl5djNLbFRHOGRrWG5tcktHQ0VVWnltbWFJZ0V1V3pjR1hNRUxXTzU2cVZGcVk1VE9oS2g3Z3VCeE9tYkx4eGxJN216ZHgyWGNXc1paN21ybVFWcUdpTDhCdWU0NklmWStHZG54bDhYT1U1RU12ZzBmTlg4Q291dFI4bkxpeE9XVVFsY200dlA1dmxLdzRNQXFHcHorSHVvdGIrQ09vRVlNRnV5Zm00c3V2anNTYnFQWHhoaVplUXhlcDU4c0JNTWZVSlZ2d01HZjJnN2ZoaG5SVUZDWXZGdWNUTHhMN21PeVB3SVJwaERPaXIrTG9sL0RBaWZQTnF2Z2ErRmxsUXp5d1ZHZVh5WjUxYXN3VXk1TTJmR3ErQ2FvZ0VIamN6eDFjRkdMVEF0KzBzRm1LdU9wMFFMSjdtcS9jUHNiZ3VNN3VmOEFHNG0vaW9HcGt3V0tyOENoTG9tS0JVR1dScWk1MDNLNVRQR0FjdmFUK1BJT1QvMFIvRlIvRTROWENzUmxXd3NZN1poL0hXWE1mMUUxYk5kUU1haVExbFpGTW00MDlRbktWYkN2Y1NtNzB3NHVRWFJIUzRqWkVYNDNOeW1WOGlqSDQ0c2JsTldEQWF0Nm1uNC80LzhBb0ZGeXIrVFpINElyRmxxVEJyKzAzZnpxREFJNVZCbmZ6ZFMyV200djZta3Zxb1VuVURjTTZnekhJdzJFU3k0TWV1bzZKOWVGQy9DbFZFRWhhYjZJdHdxV3RoT3Nkc3lZWFhVVklialoraUdSK0dhbUtBMDl3cTNjU0V4UW1XVjVNcU1wUzUxMUJUYzduRWhZeWlXUzJwcnFZMWlzeXlNcXRiSVZPaU5KQ29tSTZ5aHU0dC9DVEVVVTZQZ2RSdjRHWVlPWTdxYXVWWC9wamp2ZndCS0lIN2wrb1dSeEQzQ0lzTWt3clhjeXN6dTQyczl3eFlHNWNZZkN6RklGbHdveUVqbmN4L3lNc1Npby93Q1I1WDJFL3dEa2VULzhiTXZMNU9IOTJLdTFtTFRNOC9RSHdhM0Z0aE1zVWdhZHluS09UVlEzT3VwMFFqYmxHeDVNeXk1N2RTNmhmVEF0Z2NXWGR4SUgxcUF2ZndFcEp5YVNwaWFtV0pXcFVLZ1V6UjhNYm5Pb1FaVTkzTnZVSzNiSFJNS0M1M3VEVXVjaVhCSXBVdmt4UlpZUzdqa1ZYd1B4YVM3V0RSTHFYcUN5Mld2d3hTWHVmb2lYaVZHZFFqTUMyWllWa3BCNCtpVkFVZ2FwbWhsazlRMUNZbDRaYnFwWUcrNWtHbVczTWZ6Y1o0OE9hL2NLSmNKbHZXTTQvdUFFcUxUL0FPMU0yYm1lSEhERE16TFk5ei9IdzhPWEk4dDM2cG1XTktReFQ0NHlxK2U1aXpWVFI4Q2sxS1AvQUVOTWUyRHY0eHFQeGNJYlpaZW85UlZhbURSRmlrdXlwMHh6U2JmZ2xhWmlhWUtFdTRJWXR3WDNEYXMvY1hVeUVEVU91Nmd4eXI0NVIyd2FtV29mMGliZ1JjVEd2Y0FHZnVHNVJjRGR4Z3I4R0MrRnptRzl4Mnk1Z3dhRmdCa2JwV1pKNGN6TXk1SjZubXpjMXpxcmxMTXNuL3FKK1pvSllFcWJTNjBSeTd1Q1FmZ2lRYUVnZkZ3TFlWZlZ4UnlkVkhENjNjeEFZazF4aFVVbnY1dXhuTEp4N0lnWUR5Snk5UXZjTTBKeWZnajhIeGRGTVBqR0xHSHh4eEN4MzhId3M3ajhBc3RDb3F5MW5LaUZjWTV3eWZnWVpSUm5KNjZpSEd4Z3prZFF5MGt3YWw2dW81dFN1VUV4WTFkMUdvSlZ3ekhGSllsZkJ1OXpTUnIvQUhPZVFhbW1BSFNrOG1ibUFxVkZ1R2VxcWJDSk9vUUtscmRFYk84WlRVdENDNWY4WnV0a1dYTDB3WlpGT0JNdzFxRll0M0hLODdLaXF3T1VOckVzaGRSMGRud3k3Z29JZGU1VkZuVVUrRFVhQy9jeHZXNnVKYkdFSFVMSnlDQ0l3cGlsTTQ0SGpzZHdxdjM4QVRmWHdIcGowV3k1U1MxMFI2bHoxQ0pSS3VZMThkNEtURVpUTnlrR2JZd3hpWEVibHc2K004K2Z2Y3BleW1LNWFkVCtwVUNPb3R6cEoyekwrbFJ0SVphclV5ZFRvbDJUVlM1eWkwUWx5MkNnMFFXbG5KQ29peG8rQ3ZjUU1HSWdTeU9KOGR5L1h4WEdCakd1aUJGNC9OUVFoVUtaVFV1TlRMRUNWUkJDV2ZOTldSTnA4TUtENXNuY3FWcVYweittSkdWS2hmeU11TFUzRmxKOEgyWWJhajJrTi84QUdNUDZ5LzFPL1V4TU9UYldwalJGQmhNY01VMnpYUk5hQ2NZd2lRaXoxT0xVQTA1R29PbDlQVXhRcjh6TnZLNEt4aXpKZ2ZCT1AyK0FXSEZsM0VtTVl3bHluSmhSSEpmVUxOek5lMGwxTFZpem9pVnVZcXh1WWt2YkJHTFI4Q0xQVTd4bmlmRWY0M2x4ei91cFVMb0dQejJUakRldlUwbFQzSFl3VUNZL2JjWUZzYXY0cjNjeXhxbXA2ajhjbkZnanRqclVLQ1l4YWlyUFV2VU1wZzFqbEExY3lwbmlaMVA1ZnlUbGk1WEhJZ3RmREtKNm1McmN1cmdYYkR4NjVPVWFXVVZONytNTVMxWU5jcHhVbUJ4ZHhiWmpFMndGbVp3THNaaGxVMXhsUWwweGJnN1orWmlTdmdYNDQ2K0xoWFRQVXFHOXhtT21aVmRrRC8xdW9IWUUrb1J2MThYQ25LT0czakhITHh2YnVGa1BnM0d5WEhLeVlyTG1qcFlGRnN4UnpiajFVdmNNbmdpVEVPSzV6U1FXeVVxeGg4aktQaCtCbDE2K0FyR2Q5eWpuR0YvK2dWTzRUTjVGd0dCUlBjeWRTM283bktiWmNHR2ZGbHJCU1h1NXl1WEFJb1RHa2d4OVJTY3Jsby9WbUdlUEpjeTlSYWYweXFsMnlpRFJCMU53bitMbjRNUFBmbng1WVYwVEp4ejhtU2YwdjZrWWt2VVBGbGxyRXRabUloVkV6ejVkd1gzMUwrQm5Rc3ZrM0dNQTR5N2xFNU9KUkJvcVcxQmd4aS9EQmpCanNtMktreEw3aVZBNVJCbFJheGwzRU1pT09vUUtuYks4UmlJN25NeWw0MHl3SFVNdVVhWUVFbVZSVWxqRmwyUldxZ2pxTkV5TThNSUMwc1RiTGVNVmc2K0IzRVhKWWpjdWlMUk1OYnVlOXNvbFV3MUY5dmNZZkJUUDZNNWZqNE1WMWpPTytLUkdVL0JDb2tHVkFtaUVBdUVQRjdmajFNUEhrNE9YSXFaRWY2bndYak1YZDVTd3lzbGpsYk1mSmhpMjRXVFBQSFBPOGNhbEhjMzNCWU5UazhPSjdnVWZHUnhxUHNtT0xubFZ4eHBqMUNOenFHcHVlUDY1UEtIYW5YeFRMZmpaQVZsYlNCVXNxY3IrQm9tSGNlMkRDSkY1UGZVQU1lVncwd0dybDFHWVBISzQ3WVM0NmhsRE04ZlJkdytvL0dER0NrdTUzSFpVZXVvUmJJTUdtZTNVRko0enhsdVVxOG5qMUUwa05RYnVMdXZnTGR3eURCRS8wd2Jma1dYZXBpR1R4dXFuVDhZaTJFV3FJZFg2bXVwVkVDMGwxb2dFeXllbnFZbXJlbzlzQ0p1L2d4NVRZeWxpUVVoZktOYitMckNlb2xNeFlZNTVsaEZRNm5JcVl2d081a25aTWtTY2lwZGt4UFVGR3B4OTkvcVhhNnFEVEhJdUFOeHFjVDUxQTFaREhUZmM0cTFPSmFlNG4xZ3dKeGpneXFJRUR1VkRHT05mSEdJcktuQjRjNjFQVnpvbVhrNTBoVkZSc2o4WVlPYkU0dExLZ1N2Z0dGNGo3L1U4djhUNDhmNHpkYlAzQ1Y4WWc1Um9lT0t6UEpjOXJLc2kvRnprc0VsL0F5cm1Tb0ROUVNhU1hSTTgrWnNsaWJLaEM3WTkxS2YvQUZ0aGk1ZGZHNFdrYTl6R3E0NU5FeXNsTU5EQnVLMXFlbUVCUmhHanFHOVQrUDhBT2lJZERmd3FRYXk1RVRrckxyR3ZtN1AzR0F5eXErQStBTDNEWFVXWXZjQ0VCNWZxQlpBM3VMTVFuRVRURXBpNzFCYnBJd3ZsTmwxQmcvSGk4dWZpYnhhU1pxOGhidmM0SjR6UGpwbXh1WExaeGpEWk9wampoU3J1SjhCRUY3bkNBQkVxRzQxQ29hZ2NvbE00dERFZ1VYQkVaeGdVMUwrQW5lWDZqUzFENjl5aTd1Q1VrcCtVYnFwMW9KK2RUR3FiSm5obGhpWko5V0ZWTEFnZTJGS3pIRjVWMnZVUDJRcll3S0k0NDhPUmxiK0lQNUl0OUVWNDBzdVplMllObTUrZm0wdUNzQ0o5WWpBc1NvYm1YMW5lNWlLOFF0bmtkL3NtQVhhNjl6M1oxSGtIV21WUDl4bHNGcXgzRi8zY0dzYW5MWHdrcjRkUzM0cXlVWERHbTJMc3IxTXMzSkdLTUdVUk5VUkdvSjhNR005cHlpZ1FwMFRycGxMOFhHTEhLNHAzVnprZGt2VXVaWWgxbEN2YkxKVis0V05UcFlSZDYxT2Iwc3VZL2xpd1dLL0dpR1kzUkhNZitOVEk0a0dMY0lNWUdIRkR1SVl0RWVwWDdoaVR1TUkvRzJjZU1PcDE3c21wL1h1ZTUzTnpSQURiRnhtdmtvZHgvdHE0TWFZWDBUL2c0eXBqN2pPejQ3SWZOd1JtSmw1Rk1NZXAxMlRpc3BIdVVHMW4vQ3ZnaDNQU3pIcUJaSEpxV1Y4WlFJRGdzSmkvZVBjWnNibVpxNTNrRXl4cCtIT3NZcFVNL3B4NlNBcEd4akNiR0h1NVpHY3A0c2pETzJPVjVyREtpRGM1REJJQi9FNUQ5b2JJVTR6WEZtdytFVENYdUZxSXk4bFZseWpoY0g0emZnbHhaeWl3STFET3B5bk5UaFdyZzZwSnlJZkhiVWFKamhqd1c2WUZsc09vWWtyRjBrY0FJQUdtQ1NvRXJUUDFQTDRzZjhmRURNejVmaVlxYUxZcmZ3NHM0d3hoS3VjWnhwZzBNTzJHaWNaaVNtNVQ4YWxRTlJOMzhWQnFjdm0wZmdtT2JnN0plN1NZbTRQdklzajRBT1JIeHZhMUFicEdvNEpIQmhpdlF6K1BMcEtuOElHOG9mdzNSdVBrNGRBUlhLQlJLT003bFNpVU05UWFQZzNDVnVMVEwrT3A3aktyNHArRXJaUFZ3dG5UdVpVdG1pYXFCV3lQNTkvSmlCVndJRXI0VmpsbFZlaVhjSDRvUGNNTHdhWW9oK3BRN21KdnViYStIcUQ4WTNFaHFQVXhxS0xNVTJNZU1JNzFER29ZaU53d09Ba2IxY291cWhqVEZxR1N4RWdNVlNxZ1pFcFpWc3h5QmF4dUYyNUpGK0NEbGxlTDBTMHFPNVRHaWVQeVBpejVZem5UeVcyTGxsbGFrYUNYR3JsdytPWTYrYWhMM0FsaVZHWlpDVVMzUlBKbjQyakFwaW5CWHVZSXNNbkhMa1JNOHpuRm5aVXV0ZkN4L3dEWllmT0hqdkROdjFEc3VMdUgrb0orSU5rTW82aExwbGxRWXR6SW9KY3ZYeU55cGlBczdXWC9BTzU4RUtKdjhReG9zSVIwUzRmRENWOEVaYXk5Vk1NV3N0enZVRGs3ZXBWR29FQ0pDRmJnZHNOOXdUSHJjVVN6djRkenBxZS9sKzdPRlQ4a3hJcWhFdkx1QWs3ajE4YVl3MExLV1ZDSTM4ZFQvaEdVUURsYk84dE1CQlp0RklFTlhMdVBVeDZuaXNzR3AzTmtxMllsdEcvZ3k0K3JodFppWTh2czBSUzB4M2orWmlhbUxwalJGdlV6OFQ0dU5vM0V0aExWcjR4ZmNOdE02bDQxM0Y5VHhCdFp5Y200UllZL0NwakhQbExaakhaYzAzTUFyYlB6Sy9CT05aSXcwZkFVZkFnZGJaVzREdVlYN080akM3MzhLOEtnYnRJWkZxRlEzaXc2MzNHQkUxRmpaamRhZzZ1WEg1TnRUREVjdUt4QTBNOVI2MUVBNytMci93Qmk1aG53djh6azJxL0hYd2ZGc3hFMnpOeHI2bTRUY0g0Vmh1Qy9CTHNpaUJVTVZISUpvd1BiTHVHVUpiY1hjZW9OSFZ5eVhPNWNZUmZoM0tLWVZqaEsrRlhHUDZncnBZWnVKRHo1MVA1c3YweitiT1BsemZjTXNxZHdUZHR3RDRUOS9CaVM2SjdMdW9oMFF4T054SmpYQ1V3UGcxR1ZFZzBiM0g0VVRlby9GenVLVkJLK09wVnZVL3FUY0tDb1pFYVd5aWN0UWJpc09LVXpnWmVKZGFmaTlWQUdWQ0RVK3BocGhVb1ppVWorSXQ1WlpQdjFQVXFGazdJTmtjWTlWS01UNEl4M2paTVhpTU10ZFN3Mnh5NWZyNHl6VnVvUDVZMHdVamxlb0tUazdtS3hzWlR1VmpyakdBVzcxTG5VY3JsSHdFMTFMckZ4S1ovSGx3NVdVemorSi9HcHFObW1OWS92NFNOUUNKQVZsSXRrUitCN2l5OVhDT3VwU3pLRFVxZnlaY09NUHQrcGFzMk11V1d6ZzU5U3BiMVVMWWhjcUVZUTFjWEpoQTNOWEVQVUhHcXVWUkwxSEw0R0tKOE1KcUNFTjdoQllyOGErR1g4a1lmSFU1UFh3YStHbnFFcHVNUGd4V2I0c0pWRXFHT21BemlrSjZoOEJNbkc5RXliYjZpTXdCR2FHUHdIMStWcjRWZi9BRW9KdWRRV1g4WDhiOXMxQ05WOER5c0lmMCtOU29VTTYwTU0wd2NRMC9DL0NRZ1IwYWxyT2Q0Y1NGaHFFQmozRFg3Sit5TFZTNnhqMUQzTXNlbmJFbUdybnU1aGpkc1N6bEhxRzlRb2FTWkZ6UmhVTkVHVkdEWGNhZXA3anVFd3o0OTdpQzJScUY4WTlSWVRHKzJMOEdEMzZpZHN4dkUvM01SSmxLbHd1TndtSXBydUk0djM3K2JsUnpYRGlkWEFERXI0Zm5kbFRhck1TMkFZcjdnVXJLK1JQZzFITVp5WVpTN25VdlZIdzFVcUZQY3dNUzhzbzVLckt4cXp2LzBJNmhyY1VXWFpjdUUxTjhhdjVUUk1NTUgvQUI4czhzdnNORU1rUGpJK3NMTG1SWWZCMC9GUHdFSWx6MUtsazFGeXhCVFdVNWVxbW1JTUFxR21MR0Ywd0Q0WlR5dWNxWlNISzVqeGQ1dFRscEwxUDM3bHpYR05CRXlFNWRKcURSOFg5YWw2bDJRK0UxTll6SEhQSVhqWVR2Y2JZSHdtb0VOd1RJNFZzZ3VNNUwyemxSRHUyZUhEK1V6dy9WelNiUDZ4YmdjWmNHbTZ1Y3FVcnRuVFRMdU91cHkxQmxwQkF1RzJNRm5mZnhsYjB4R29YRjNaSEtKN1l1NDB5MGx3dWU1WkxnM1VUamw4RkpGcnFLTEg0SVpSZGxNTTB5bXhmM0d1aU9HUmp6VDZzVjZocHQzRDRTcFRWa29xL2Z3VVlrNmlvZDFQc3RyTXFtNmdvU3gzTWo4UmJJWkptSk1tMXRseCtEY2ROUW1UeTZsT081azBhbXF1WEMvaTZkVFBBeEI1YmU0SkNtVjN1b2ZGL0FmQVM5VktRZ2tZU3k0a29Za1RVcVZaQWdUSXFwdVZFWWtZYUtnUHhRVEUzRWwvK2g4TXdtWGRmQkNkeTZqaXBkL0hFaGpPSlJEcVg5R0ROa01wM0g2OU10ZTVqVU1CRnVxZ1R1TFdpRXFMTVE0TzVqNm51T21EeEkzZDFMK0RiOFg4TUlwWC9xZkhmd1RqOGJwSmpuaStGd3I3WENNZjZ3NmhCcU1BWi8zRGJ0MUhUcUV2NUQ4d3h5UzZpekdsbVpDcW0zNFd3SWgxRFJVNk80Yng3bU1GR2pxR0ZZcmYvVTlmQXF6eGprMzZsMnY2aENpWk1lcGhUazNIZWlWQUlJNTlhalhPV0RFTXJxVndLdnVKQWdUS2RmV0V4ZGR6a2s3Z3hkZkFYTDFYemdwc2R4eWNtODIyWEN6NExXSlJLbkxHcXJjZC9BL0NsSk1kdFNpWkU3SnVZWW1XZFpORVRqa2hzL1B4YkE3djRQZ0lEQWlWbEtXWTRMdG1UTGhMK0NZNmp0aE8vd0JRZFZLbUo4WTRLMEVjTXNPL2prcDhDZ3pHMG5aVS9qVEF6dlRGN0lzNWExRTRsbTJYTGJsL0JZekl0K0F0cVZ1b3VXVkMySFVXbU9KVUJOVkJwWU50VkJ0VDJTNFpXMUFyRllVN2prWi9GUkZLQzUzcVBWU29FQzRrYzNJREp1dXAzRmhQZnd1NGZEYVE4dWVHS1k1SmNxQ3Z3ZkZKN2dwRFd5ZFRHa0JZNGxOUFV5aFpzWTZTTzlrMmticUJQN1JLQWxicXo0eTRvT00yUVdwVnl2aGd3MFFxcC8zTDJ3QUx1ZjZaOXY4QVo4ckdNR0RTd21XUndOVXk3Ymd6c1RjRHAvT3ZuM1BjcVZEUTNPeTdnSU1mSTU0R0YxaWVvL2FBOXcweDB6L2JPU1JZTVdXOXN5eTV6Qzl4WnlibVdhYW1MVFA1TGVNTzBtTHhHTnJIRnhqTGhxTnBNRUlEakRqeWlEbnJSSFF3WmNWaEVoQUlrcUJiVS95UEQvOEFHOHJncG5xN0lmTjE4TGNJTTNMU1V1L2k1Y3laajhYTTREVXBoY1VjYUNrZ0RLQkp5YmFKOXF0MWorWlVaYjhiV0pWVEt2aHJHYVNiSmU3WlZ3eHcvaXU5eDFCcUlzR3ZrR0VHcGwrb1B6UjhCTVFZbGR3NllLa0tYNEN6NHg4ZklnOFdFV1liZDdKbmxlVkVxRDlVU0JyVU5FWmN1bXBaT2xyY3hMRzVkRUdYOG1VZmc2K2ZYeGZaTFBnK0tsVFI4bS9naEJobGxnVjNNalRPSnh1WWl4S1lkeDFjclZzMWVvWEhiSGlkVHVEVXh5RE5XQzJ4S2hzaG53d1Q4eitoL3VZeGpDNGxseTArQStPTWNBcktaZE1xOTNDeGpqOVY2aHJHRFcvakVTVU10SVIxTGl1d0poM1ROYklud1JKaGl2NG9pdCtvVXgweGpqVy9nblRMSVN2aE9KZHdYNHVtT1F6RnByMThMR01KVUNZOGFiaE84b0c1bm55S0NxamE2STJNOWRrSlZNcTFneFN0U3NndG5iTGdYTWRRZDdJSjJUL3Z2NE1mZ0NkWlVNRFV5dWpGV2lWYXN4OE9lWGd5ODltbXFtQ2l6M0dwalVXR0ZpM0dYVEQ0dTlSdzRrQzlwUDdiK01jV2xzaCtaeXh4RlRiTGhVRDZTdlVDM2pPTEFTWThpOGlmdURBdVVqQnFkc1pqTkxFTC93RFNvZjNtSGJQZnhVQzRDUklGa0Z4ZHh6T1dpaWNqS1dBSkQzSEdVMVBYd0FEOFV0MUhqL0ZvM01XaEV1THFxbE1CcEpTL0JqKzVUT0lUamNjYWxFVG9uaVBIemVVRTVNUXVGUzJxOVFxVktoM0RHODBubDhaaDFLc21BM0g3WnNxQlBGbWhsaFJ2M04vUFQ4WEEzYzVYcVlsdEUyTlE5eXlxQ1Vtbzl4bHM1WDgzRFp1UGRFeEVZM0wzSFRBZ0hVcW93RzVlV1dub2lWOEJPcFZ6WlVwUm14aWJnV3lxZ0t4TlE2K2R3blc3andxMWVjMnpqOEJaOGVtWS9GL0Y2cVhUSHY1Q0FUaUxNOGF6cU5Fc0pkdWliV1lZM012OFpvcEVKeFRKR0dWWThjOTRrWGRuWHI0cUlWcUZ3Uzl5emVwaW40alRGTGh1ZHdLeGxZOXhMbFJMbkNjSnhneEg1cjV4M0tuR1lZeklqb3FGQk9POU00MFN0eEpUaGpwZzBUR1BjMkRDRE84VmdoajF1VXYvQUtCTU1iRkpWUzZhU0RkL0o4WlkwSHpVT29mSEd4bFdRajBWM0xOL21IWHd3MlFtTVduNU5UOStxbmxjZGNTQ3NMTXJHRGFyRDlFc2ZpcVp1N2k3bzZnQkRxNE5ueGN6THdHSGNZTEtnT1JaOEVKbENNV0JjZmg2bHVvNU9XUmMxeStQY3VzNTdoTDFaT2o0V29XUm5JU3BVeGFqU3pKQXFWWkErTW1YZUZTbzNWRTlVd0lFR2U0eXErTzJPSjFNRUhxUGF6dUV1WTdqaUh3TkxDRFVkWVFkVEN1K1ZNZHFyY29tS0dSTXE1eXBpRVBaK0psazVWY3FZQTViWm54NWZWZzd1TzVYd0N3Z2JoK0dGRE1GVGlicVpjbVpFNTVCbGlMVUtEVVlWZTRGdEVSRm1Oa2ZnbVdtREJlbjVwUGpLWFBFR1kyK29DUXlHeGhHQ3pjMmU1d0U1R1UxR3dsMkJuRVNBdTJKZlVNUWlzTERvbTVVSVRLQXpqdU9SZlV0OXl4Nmx5ck5ReFc3YWhUcG1pYWkvZ2lCUitaVkxwbEpqSDR1VitYVXVuWFVNcUVoR2ttRGNZMTJYOHQ0a0xtTnpQSDJ6YXhGWUNmK2hLYm5GblgrNFdURGVhek1qaFhGNVRIYXpJM0FxYnZYd2JMWUVDQWlzNURWZ1JybE9vaVQ3RGp4MHh1MjNkekVyKzN3dHo3QWNjZVRNOEhFTFpVZUJndnVJZ0pOM3FPTzIva2JnMFJENHVqNGNhbHBIS0hLT1ZsUUkvQVMyb0xVTzQ2aDFCZzdoMU1vZkFjaVhUVXFWRFVQekRiclVSbC9BMGZCUmNDR3ZnK09FTlRsRFBmVXplV2ZLSkNNeDF1WW9Vc3hjTWZGbFdiYkxRTnpEem1Qanl3NEN2dVplcmxNcG51aU0zVTlRWjNOTDhlb1FzN213dG1salk2aCs1aTZZTEZLZzdsMVpWeTQvTmExRHFGd29JcEdNRUhxWncvcXhhSVhISDhmK2xibW9LTUVKaTVGMHkrSXdTVU1vSmJWZFMyWDhKTVl6Y0NWT1VLU1ZNY3pwSnBFaERyNGVKZ0ozRUtjcWd0YUZtcFN3RWd5dzNNdHcrY0VHY3U0YWZpNFAxcVpjRURFZVI4Rjl6SEk5N0pXMkJaOFVrdWFKYWdFL0w4RTIzK0lYaVVmSFRENVlJWVVrRUNDTWZqYnNsd3BsVTFFcUNYOEh4ZC9CVjdtUGRzenA2aktodHFJMnpJMFFqb21NeTB5MGh0V2JHWEF2NUNkVHVCRW1HZkh2Y2Rxd2ZrYWg4TDhHcHFGeXAzMlRzQ0FSSWtNbVlzL1AvcDBhSlgwK0VyM0hTUVZoVk5zeExqaUV4eWNjaFFTWmVRejhpbUppVjhmeW85REYyL3VIeWEzT1hLUHg2SlZScTZZbE11R1Z0TTZZckwrRDNPZFlIQ0FvS3hQeENQVXhqOFk0a3FFVlV1ZVh5WVpBWTRWVXhUY0NwdHVCYjhFY1VlNHdKWHgxTC85RmNTWHk5eTAvSHlhWUt6SlY3bXVOYmppSkhVQy9oZFFJZmlZOS9IaXdNMXZJTlhOczZJTlRKbnE0UHFjYnNuV3FsSFQzREV1cmdSNmg4RjNISkg0Rzg1ZkY3amd1STJUTGIyekVDNG4wNVN6anVZdGV5RGJGdnFXSnFGelRidWV0c09vVGVWMU1Ha1puazVaTE1WZS9ueGViTHd0bE15eVhOZnpIa3d3YWpjd2ZjVlc1MUZPTUdwYzNFaFVzOUl5MlUwc3VMVWJKZXAwYm5mVU92bnFKcjRDRUFtZFpNektQZ0VqOG53Tk56TEp6Z1JucWVORHNpWG5aLzZQKzV0YWxUSEU5d3h4clhxZVB5YmRSVnZxRnNFUGt3OGVIZy9sQldaN2JDRXRadG5LS2hNWldTcFVOS1B4MFFmZ0ordmlsTFdPVHhxSmlvazNjV2VxaHJHRU1qS2hubk1CSEIrQ0RNcDJhaFhxZFFKK2crQll4aGxURkhLL1h4c0lyQzVjdVZNYldwbDlXbUUxTlN3eGh1TXdhdzRzZmhZb0VHSzN1RDhVTUNwV0wzOFhxTGh4S0dlb3RRYmx0VERMTENMdGZraG5SYVR5ZVRITEU0bGZKRm11TUttb3dtSlRjeVJtNmFsSENGKzRmSEhMTHFDVThvQng3Z296SDR3eDVDWERQNm1GVktNV29nTEd1RXh4c3VLakZqMURxTTJQdzZuT1hjNm5LNVZ0UndNTTBObGZBd2RmUHY0djQ4UWNtNWpqMm5xSzNML0wxQXZmeFRNbmNlbUVmZ3VWTnpBRzdZSzR1TlNvTVNVUStVZ1V6RmlCc2cyenRnTVdlby8xbUxHWXc3bVh3ZkJLbnFYUk9NS2RNUUpxb1FPVjY2ZzB4Ymd6SHVZOXM5eE4vRnk3bFhHRng2Z2tFcUc5QkVPcml3M08yYm1WUWdUdVZYeGZxRlRqS29tSmNvTlNrNmx5dml2aHhRMURGbnVkTVc1VVcycHhQZ2xneW4xQml6UC9BQjh2RjRNZk1DbVh0akdwNmpQOXcrRmdzNGlYQjdQZ3BFaGlBL0JyNERUYk44QWorSUJ4bENYQTlNdmlrN0xpVEsxbFNxaXdJRUcyT241QXowekZVNDMxTWp0bU1iNm5GenN4OVRwcFBnS1pxOVJkZk5TbDFNTUZ4UWFDR05rQ2xnRXM5ektrbFh1S2syd3M3WnA2WUNETzhaVVlWd2hVd3U1by93Qk16Y1hMNmxZc3k0WS8wN2grKzJVNDl6U3hTTXdySTNxcGsyMGJpVEdMT1V1RE9YS2M0UHoyc09ybHhneTQ5UzcvQVBVbE01SHdGSHhZNEdOZmFPTGk3ZmpjYm1BZ3l5NWRFR0MrcFlNTXN1RGk5UWRzZW9SYWpSdVpaYzVnOFplUmJIZS8vVWZrdnFWUGNQY3JVQ1haRW5FK0tvaC9XRUMyTWRmMW5yZmNDV3dNUTJQd3h6K1NWY0kvQ1dTNXkrMS9pTGJmNWdiajNLZ1UvRm56VW9qQWp1RU9wajhVSjg0LzBsNzFFYWcwVEUwdnFWUDlRSDV0cW1XT0JNdTRmR3JpRjZoRklmSE5xb296a2VweTFOYW5wWmhSM0E1RHhnQll5ajE4aFh3UWFpaVhVeWR3YkpkUjcxRWhyNDdmaTVwWURDZTduS1laMHN1NEc0TVg0eDdnWGJMZmkrTUg2cCtaU0c0a3dOVlBKNDNES21Zb1Iyd0JndS9oQ0VIRUdiWVMyL2gyMFJFZmcrQ0FUVUQ0WU81bGRhbFRFeDRQNW01ZW9Oa1BoZ1RaL3dDalppYWpSQUpWZGZHWFFFTElGcUdpWlBMRXhvMThFeG1KY2NaVzRyOGJxRmt2YkxmamkvR0dhV0VMR010aTg2ckdQc21KTWQzalc1eDBIdjNPRlRSSEluSFVxWTBkL0F3eWx4WUdvRVJScUJEL0FIUGZjQzlrL053TlNtNWtGeHd3TUw1N2hUcUc3dVZLZlVxWWhNdkptNEdEbThEb2hjLzJSWVB3SVRURTFCS3FGWTJURURMY3pwYXhoWkJHZFIyeXlHUHVNclREcUhqeVRVRlZIdVZ5MHBPQ0hjQTZKMHA4Y2hqdlV6d2NBdVhBdnVVVFNNSmRFRzJJdU1ORXVZNnVsR0RxMmFTL2d5S21JTHVOM3FFdWlwVEZjZ0ZxVWhEOXpwakJtejR4MzNOUzVpdXlEeGhsdU4yNmxFcUc1bmt0ZGFnR1JUNm1PSTJIYzRseTBsdVF6V09Pb040MUhSUk1aMnNyNG8rRFhVc2hTU3VUQnJVSGp0Nm5oY1J5Y3hwNmk3MUtpaENOUWR6cnFFOXovVVkvRlM2NmlzWmN0dWI5UzFpeW4rTlpSUWp1QmZjUU9vRTFLS2pUQWdNcWRRNm5aS3NsMFZMZ2YrbXJsYmg4TUlsa0pqaGkrTE5jcVRxWTVWaHJiRmh2NEdFdVY4QzdtNGxUdURSRkUrZHpHRmpES3Brd2RUOHpIQzQ2eW5lNWlMZTUzS1o2aC9XTXcxTzQvRkh4VU9tNFFtSmJVekt5b2gzT0JXMldWM1pQLzhRQUlCRUFBZ0VFQXdFQkFRQUFBQUFBQUFBQUFSRmdBRUJRY0JBd2dDQ1FvUC9hQUFnQkFnRUJQd0QrZlpYN3NYRjNUcDA2ZFBFTHgycVZLbFNwUUZlWkI1elA2TVB6U1BCaTVGS2xEQjFMdzZ2TkE5VWlHTGJiZ3c4UnJ6MnZKd3VSK09wOEZyek1OUEw4R0g1Vkg0c0RaSzArTkNxQmlhcWxpM1RwN0djMlA1b0QxcUp1S2RQRENqc2dSWndkek45RDVmTHA0VWVNaHdld2NqRFB4d1BNNW9VWW9OQWpRb2tLL0I1YjJYV3JSeEljSHNXZzNvUThDUERRUWxKdnhnaGxCZ0JFaHFBUllUSWJVR2tsdFlabGZ3Y21iSFk3cCtKVnlwNnZBaWtZOGxLL2VnaGxSSkJqekVUUXZ4dXNRMFc0OG9MZXk3SFBocFpjcnBXSlduUnBZWGlnQm9UVWFQR3poanhEaGVqWndub3A3cUdwMUUzc1IyTDRmaVpjRzJGSHlpYllVZE5uNk9yeFJ0aFIzb0lBTlNEY1M3WGdoWWlDcnVHT0dwaEFSUDNxbDVRZGc4TENERHNFT0dhSGk0WVFXdzh0aWpwUWFSZkxnVDdudGNUeDdsR2gzdUVVZk5CODBIekNPRnlPUktSOWpaaHdnbkEzZ0p3TmFpNE9oeEFUc0llYVg0bUdpWG5WMXExZll0RnJXSTZ4Z1R3T29TRTlhODhqelFOVER4d081eUVjSHdJY0lzKy9BZzgwQ2orYXc4dHZLdWFpak1sbm40cUV0VktsOWpZeTBjTkFpTkhIaUJDOEdnUjRFRkhTWmppOEZ2MSt1UlJpbzd4dDVZVVVZcUlvZExEQmpWSTg1clJReXIvQWQ5VGh6MUVLV1hHangyRFp4M3dQTkFnUTJtTktMZmI4cXY3ZlVPcDA2ZWkzczFmQXh3OGREZFpnQWdJL0FKMDZld1YzUFJMNUJoTHB6a2FrTkQ4Ung1b0dnaHRvV1l2UkdYWUtRcWxwMFJnOENhQ2pGeFJ2ejhDK0Y2TllpekVHTitjY05lRDZGbUlNY0dOcUNqY0RMQzlHL0JSemdzaGVpK1hhcWUwQmZxL2RpTHcwTDBkaXlUMHNNcW9VdnA5eSszZ3h5TFliR0VPRnNLUEEvRFVhK0htZ1RCNzRIb1VZOGVPUnRzYU5FMk1sSHlOK3VURGgwOUNHaHQ4ME9Wam5Uc2hCQmpGclpZbDNJNkJuQmt4dFVZUWFJR21SZ3pRdlRrQjNpSGpUSXdab2RJN2hsaEJ4OGlqMURVNHhhN3hoM0VIVDFzTU8rWFRzRTZYQ25yMWFNcVBvY254R1BOQWxZOFRDK0hZT0hsQnVvWHdoQStGWXZiTHAwN1ZXeitSOUx4Z3FWSzRkRExxbFN3NDNnSldPMGJ3R0RIalpaSVJRYTJPbEJmQ3hHODNsUmp4eTZmYU5MdnVOQ0dIckZtTVNMY2VVUmJqTkRjNDdUZ3hiak5EUndvNmZHeUJOaGloSkJHUkxGdzZka05IQ0FPaGZQRE9MalJnZ0l2eFBCcDRSTS9aN3hEQlJpZ2p3amE3VkNoeUxNWThkSTFvcVZMN1VDZnkrbFVxWFV2Z1dZeUtwZExzM3k4dzZkTzBXYkI2MThMbDA2Y0pWTDRWSzVka01rK29VYkladFVyUjVzZUxoNEtHbVROemRqRERxSGFJME04SVNNdXVrWkFkUTBBOFE0TTZjdkdVSDJMSVhwNVd6MTJqeXVNMkx3UWtlZ0RoeGNud2c3Wi9DMHVwSVBsOTdwNEFYNHdUNkhUcDNBby9ZK0JSb2IzRjhva2JweEV5OFh3MG9Od25IR3hIaFlSSWFQRTNkZ0tkUGgyRGhUdnhhakxqVGorMXNVWWRiUWZRSWVxVksyUEEraGJqc0dwaGdoS3gxcWZHSkRKaU5ETWlIaWpCaGlSMkNhbmdkUm9XSXR4TUhiT0tpU0hyVVpXV0ZQSnJsVXZsVXJCWGFzeGRQR2pyTkRFaktpbERsU3RCWUtsU3h6NlZESFR2bFlPQUMyRkhSb2c0c3haRHFIMGVCbzRhZFB5TVlOOXVBaWVpakpCQlZsWFRwMkwraE1CUjJjOUtuNEZISnV4ZE9uaEQzT24wRHJkNitrM292UnJ3WkFSTVlrYU5OOE5KbWhpUk1SZUdNREJEa1I0YU5lSGR5T0hUdW5rQkVIaUYwdU5LbFMrQmlsU3BjanBWTHVGSDRVREdDRndjcVBvZklqNGc0bzNoNzNpWEloOUNTREhtNEZIV3craDhqTENIRDRPR0dCRkh3NE1vUEZicDAvc1pRVTZkUENQSWlMUGdRUjRJMkwrRlN6Q3NIVDYxeTk5T0FyckZMaDJvNkQwRFN3MkVLUGlZUUVlSEJSeEkzOFlxdkNaME11RnFkOGpRNG84dmUzLy9FQUNNUkFBSUJBd1VCQVFFQkFRQUFBQUFBQUFFUmdBQlFjQ0F3UUdDUUVBS2dNU0wvMmdBSUFRTUJBVDhBeElQQlFlZjdpVXJBb0NxbGNYd0JCQVhvY0lheEU4Y2tlckNqY01KRzdPUEQ3RU12aU9ZMjF1RFNJNU9JUzNCc3VucGVoeElHNkkwQ0tJOHozR2tXNFlaR0dodHEwcUdnendPMkRnRG1pSEp2ZzhCamprYmFwZVh3alFQT3d4bVY0V3lzRW5CdzRSaThPMERQeCtDRzVvV2dRUlhablRnQU92TFdvQ09ZdzNCRlVlUVo2eVA1cFJHZ1NhR2NWYWg1aXJqQ0tJa2tMZTZjTm5HYy9CRlVhRlNpK0kwQ0tEM0JvRzg5azBQTUJ4ekhsOEkwQzNyNG9VS2x2Q0dhcFV1dnFLWWpHT1NJVEMvbnljZHZXeW9iRGdqeldHb1JpRWEzR3BVTTRPY0EvZ2NkcFVFbDFVUk9WTCtZMXhVVktsdm5hY2pSc0NNQW8vd0Z2NDQ3Q05BM0ZHd1J3RVd6UTB2ZGVWRlNwY1pVcVhiVmUzMWRkUWVBWExNd21IMFp3SGF4bjBkcU5EUG9zZzZNYUVhVi9KcU1qUHhOVktUZzZlSTBuQ2d6b3FVWjNUekdJMU9uR282aEdnUmlNYURHOTlyWFkxaGhVdkdjeHpIV0RoRitINDMxNXFpTkE4TGp6eDBzU2FHVERnbFVxVWVoRjhlZmJ4S01HaVE0allMc0laQzdDRjYraTdER2krcktDOGtoQ2tYOFFwRmtITEVTSFlCR2dSb0dNaGdkMDlZNEF5U0xRT2NPa2pnREpJdEE2cUxFTWtpYjRqT3JTdENndU9RTllqTVBNb2M0UTNWdWRQZUhXWGx4Vzg2MS9CcU5nUlhHeU5nY1Y0OVZMQUkrallYQVdTblRwNFdHeWFHb1plTkRyWXBST0hKSG1FSkJPbi9NNEl3T25mQmh4MDhITG9UK0h5RUhRQkdnUmtIbFErSTZjVTExd1JvRUlCRk1iNjFEaENJQzByVWRzYTFhWHRLbHNyNHNNTDR2RGdZSEhjUjB3NHJIY1J4Um1JWUdGbWRwRUdWWnhwRmpGSGhxbG5aZlZ0Q3YwUDhBbW5aVnFISEc0TVlqNHJnYlFOQjJSWCtpdjFRdFEramhtaENRVitUWDZ0WTR4b2M4WkFIUlJYNHI5YWhmQmFSbFVXWVYrUDhBYS9meGJLdVN6MitldmozUlg0S05mcXh1N2prUEpUcDhwN0QyQkdvY29ST0hCSEpFUEI1bGk5S0xLeDRNREMvRHloSE1FYUJEZDNFY1pRbkZyRU9CcEgzLzJRPT0nKSByZXBlYXQgdG9wIGNlbnRlcjtcXG4gIHotaW5kZXg6IC0yO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3JjL2xlc3MvaW5kZXgubGVzc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcL3xcXHMqJCkvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpXG52YXIgTm90ZSA9IHJlcXVpcmUoJy4vbm90ZS5qcycpLk5vdGU7XG52YXIgVG9hc3QgPSByZXF1aXJlKCcuL3RvYXN0LmpzJykuVG9hc3Q7XG52YXIgRXZlbnQgPSByZXF1aXJlKCdtb2QvZXZlbnQuanMnKTtcblxuXG5cbnZhciBOb3RlTWFuYWdlciA9IChmdW5jdGlvbigpe1xuICB2YXIgdW5hbWUgPSBudWxsLGNsayA9IG51bGxcbiAgZnVuY3Rpb24gc2V0TGF5b3V0KCkge1xuICAgICAgaWYoY2xrKXtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoY2xrKTtcbiAgICAgIH1cbiAgICAgIGNsayA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICBFdmVudC5maXJlKCd3YXRlcmZhbGwnKTtcbiAgICAgIH0sMTAwKTtcbiAgfVxuICBmdW5jdGlvbiBsb2FkKCkge1xuICAgICQuZ2V0KCcvYXBpL25vdGVzJylcbiAgICAgIC5kb25lKGZ1bmN0aW9uKHJldCl7XG4gICAgICAgIGlmKHJldC5zdGF0dXMgPT0gMCl7XG4gICAgICAgICAgdW5hbWUgPSByZXQuZGF0YS51bmFtZVxuICAgICAgICAgICQuZWFjaChyZXQuZGF0YS5ub3RlcywgZnVuY3Rpb24oaWR4LCBhcnRpY2xlKSB7XG4gICAgICAgICAgICAgIG5ldyBOb3RlKHtcbiAgICAgICAgICAgICAgICBpZDogYXJ0aWNsZS5pZCxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBhcnRpY2xlLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgdW5hbWU6IGFydGljbGUudW5hbWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBFdmVudC5maXJlKCd3YXRlcmZhbGwnKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgVG9hc3QocmV0LmVycm9yTXNnKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5mYWlsKGZ1bmN0aW9uKCl7XG4gICAgICAgIFRvYXN0KCfnvZHnu5zlvILluLgnKTtcbiAgICAgIH0pO1xuXG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZCgpe1xuICAgIG5ldyBOb3RlKHt1bmFtZTp1bmFtZX0pO1xuICAgIHNldExheW91dCgpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxvYWQ6IGxvYWQsXG4gICAgYWRkOiBhZGRcbiAgfVxuXG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cy5Ob3RlTWFuYWdlciA9IE5vdGVNYW5hZ2VyXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbW9kL25vdGUtbWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCdsZXNzL25vdGUubGVzcycpO1xuXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpXG52YXIgVG9hc3QgPSByZXF1aXJlKCcuL3RvYXN0LmpzJykuVG9hc3Q7XG52YXIgRXZlbnQgPSByZXF1aXJlKCdtb2QvZXZlbnQuanMnKTtcblxuZnVuY3Rpb24gTm90ZShvcHRzKXtcbiAgdGhpcy5pbml0T3B0cyhvcHRzKTtcbiAgdGhpcy5jcmVhdGVOb3RlKCk7XG4gIHRoaXMuc2V0U3R5bGUoKTtcbiAgdGhpcy5iaW5kRXZlbnQoKTtcbn1cbk5vdGUucHJvdG90eXBlID0ge1xuICBjb2xvcnM6IFtcbiAgICBbJyNlYTliMzUnLCcjZWZiMDRlJ10sIC8vIGhlYWRDb2xvciwgY29udGFpbmVyQ29sb3JcbiAgICBbJyNkZDU5OGInLCcjZTY3MmEyJ10sXG4gICAgWycjZWVlMzRiJywnI2YyZWI2NyddLFxuICAgIFsnI2MyNDIyNicsJyNkMTVhMzknXSxcbiAgICBbJyNjMWMzNDEnLCcjZDBkMjVjJ10sXG4gICAgWycjM2Y3OGMzJywnIzU1OTFkMiddXG4gIF0sXG5cbiAgZGVmYXVsdE9wdHM6IHtcbiAgICBpZDogJycsICAgLy9Ob3Rl55qEIGlkXG4gICAgJGN0OiAkKCcjY29udGVudCcpLmxlbmd0aD4wPyQoJyNjb250ZW50Jyk6JCgnYm9keScpLCAgLy/pu5jorqTlrZjmlL4gTm90ZSDnmoTlrrnlmahcbiAgICBjb250ZXh0OiAnaW5wdXQgaGVyZScgIC8vTm90ZSDnmoTlhoXlrrlcbiAgfSxcblxuICBpbml0T3B0czogZnVuY3Rpb24gKG9wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSAkLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0T3B0cywgb3B0c3x8e30pO1xuICAgIGlmKHRoaXMub3B0cy5pZCl7XG4gICAgICAgdGhpcy5pZCA9IHRoaXMub3B0cy5pZDtcbiAgICB9XG4gIH0sXG5cbiAgY3JlYXRlTm90ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0cGwgPSAgJzxkaXYgY2xhc3M9XCJub3RlXCI+J1xuICAgICAgICAgICAgICArICc8ZGl2IGNsYXNzPVwibm90ZS1oZWFkXCI+PHNwYW4gY2xhc3M9XCJ1c2VybmFtZVwiPjwvc3Bhbj48c3BhbiBjbGFzcz1cImRlbGV0ZVwiPiZ0aW1lczs8L3NwYW4+PC9kaXY+J1xuICAgICAgICAgICAgICArICc8ZGl2IGNsYXNzPVwibm90ZS1jdFwiIGNvbnRlbnRlZGl0YWJsZT1cInRydWVcIj48L2Rpdj4nXG4gICAgICAgICAgICAgICsnPC9kaXY+JztcbiAgICB0aGlzLiRub3RlID0gJCh0cGwpO1xuICAgIC8vY29uc29sZS5sb2codGhpcy5vcHRzLHRoaXMub3B0cy51bmFtZSlcbiAgICB0aGlzLiRub3RlLmZpbmQoJy5ub3RlLWhlYWQ+LnVzZXJuYW1lJykuaHRtbCh0aGlzLm9wdHMudW5hbWUrJzror7QnKVxuICAgIHRoaXMuJG5vdGUuZmluZCgnLm5vdGUtY3QnKS5odG1sKHRoaXMub3B0cy5jb250ZXh0KTtcbiAgICB0aGlzLm9wdHMuJGN0LmFwcGVuZCh0aGlzLiRub3RlKTtcbiAgICAvLyBpZighdGhpcy5pZCkgIHRoaXMuJG5vdGUuY3NzKCdib3R0b20nLCAnMTBweCcpOyAgLy/mlrDlop7mlL7liLDlj7PovrlcbiAgfSxcblxuICBzZXRTdHlsZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb2xvciA9IHRoaXMuY29sb3JzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSo2KV07XG4gICAgdGhpcy4kbm90ZS5maW5kKCcubm90ZS1oZWFkJykuY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJywgY29sb3JbMF0pO1xuICAgIHRoaXMuJG5vdGUuZmluZCgnLm5vdGUtY3QnKS5jc3MoJ2JhY2tncm91bmQtY29sb3InLCBjb2xvclsxXSk7XG4gIH0sXG5cbiAgc2V0TGF5b3V0OiBmdW5jdGlvbigpe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZihzZWxmLmNsayl7XG4gICAgICBjbGVhclRpbWVvdXQoc2VsZi5jbGspO1xuICAgIH1cbiAgICBzZWxmLmNsayA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIEV2ZW50LmZpcmUoJ3dhdGVyZmFsbCcpO1xuICAgIH0sMTAwKTtcbiAgfSxcblxuICBiaW5kRXZlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICRub3RlID0gdGhpcy4kbm90ZSxcbiAgICAgICAgJG5vdGVIZWFkID0gJG5vdGUuZmluZCgnLm5vdGUtaGVhZCcpLFxuICAgICAgICAkbm90ZUN0ID0gJG5vdGUuZmluZCgnLm5vdGUtY3QnKSxcbiAgICAgICAgJGRlbGV0ZSA9ICRub3RlLmZpbmQoJy5kZWxldGUnKTtcblxuICAgICRkZWxldGUub24oJ2NsaWNrJywgZnVuY3Rpb24oKXtcbiAgICAgIHNlbGYuZGVsZXRlKCk7XG4gICAgfSlcblxuICAgIC8vY29udGVudGVkaXRhYmxl5rKh5pyJIGNoYW5nZSDkuovku7bvvIzmiYDmnInov5nph4zlgZrkuobmqKHmi5/pgJrov4fliKTmlq3lhYPntKDlhoXlrrnlj5jliqjvvIzmiafooYwgc2F2ZVxuICAgICRub3RlQ3Qub24oJ2ZvY3VzJywgZnVuY3Rpb24oKSB7XG4gICAgICBpZigkbm90ZUN0Lmh0bWwoKT09J2lucHV0IGhlcmUnKSAkbm90ZUN0Lmh0bWwoJycpO1xuICAgICAgJG5vdGVDdC5kYXRhKCdiZWZvcmUnLCAkbm90ZUN0Lmh0bWwoKSk7XG4gICAgfSkub24oJ2JsdXIgcGFzdGUnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmKCAkbm90ZUN0LmRhdGEoJ2JlZm9yZScpICE9ICRub3RlQ3QuaHRtbCgpICkge1xuICAgICAgICAkbm90ZUN0LmRhdGEoJ2JlZm9yZScsJG5vdGVDdC5odG1sKCkpO1xuICAgICAgICBzZWxmLnNldExheW91dCgpO1xuICAgICAgICBpZihzZWxmLmlkKXtcbiAgICAgICAgICBzZWxmLmVkaXQoJG5vdGVDdC5odG1sKCkpXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIHNlbGYuYWRkKCRub3RlQ3QuaHRtbCgpKVxuICAgICAgICB9XG4gICAgICB9ZWxzZXtcbiAgICAgICAgICBzZWxmLnNldExheW91dCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy/orr7nva7nrJTorrDnmoTnp7vliqhcbiAgICAkbm90ZUhlYWQub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uKGUpe1xuICAgICAgdmFyIGV2dFggPSBlLnBhZ2VYIC0gJG5vdGUub2Zmc2V0KCkubGVmdCwgICAvL2V2dFgg6K6h566X5LqL5Lu255qE6Kem5Y+R54K55ZyoIGRpYWxvZ+WGhemDqOWIsCBkaWFsb2cg55qE5bem6L6557yY55qE6Led56a7XG4gICAgICAgICAgZXZ0WSA9IGUucGFnZVkgLSAkbm90ZS5vZmZzZXQoKS50b3A7XG4gICAgICAkbm90ZS5hZGRDbGFzcygnZHJhZ2dhYmxlJykuZGF0YSgnZXZ0UG9zJywge3g6ZXZ0WCwgeTpldnRZfSk7IC8v5oqK5LqL5Lu25YiwIGRpYWxvZyDovrnnvJjnmoTot53nprvkv53lrZjkuIvmnaVcbiAgICB9KS5vbignbW91c2V1cCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgJG5vdGUucmVtb3ZlQ2xhc3MoJ2RyYWdnYWJsZScpLnJlbW92ZURhdGEoJ3BvcycpO1xuICAgIH0pO1xuXG4gICAgJCgnYm9keScpLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbihlKXtcbiAgICAgICQoJy5kcmFnZ2FibGUnKS5sZW5ndGggJiYgJCgnLmRyYWdnYWJsZScpLm9mZnNldCh7XG4gICAgICAgIHRvcDogZS5wYWdlWS0kKCcuZHJhZ2dhYmxlJykuZGF0YSgnZXZ0UG9zJykueSwgICAgLy8g5b2T55So5oi36byg5qCH56e75Yqo5pe277yM5qC55o2u6byg5qCH55qE5L2N572u5ZKM5YmN6Z2i5L+d5a2Y55qE6Led56a777yM6K6h566XIGRpYWxvZyDnmoTnu53lr7nkvY3nva5cbiAgICAgICAgbGVmdDogZS5wYWdlWC0kKCcuZHJhZ2dhYmxlJykuZGF0YSgnZXZ0UG9zJykueFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgZWRpdDogZnVuY3Rpb24gKG1zZykge1xuICAgICQucG9zdCgnL2FwaS9ub3RlL2VkaXQnLHtcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIG5vdGU6IG1zZ1xuICAgICAgfSkuZG9uZShmdW5jdGlvbihyZXQpe1xuICAgICAgaWYocmV0LnN0YXR1cyA9PT0gMCl7XG4gICAgICAgIFRvYXN0KHJldC5kYXRhLm1zZyk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgVG9hc3QocmV0Lm1zZyk7XG4gICAgICB9XG4gICAgfSlcbiAgfSxcblxuICBhZGQ6IGZ1bmN0aW9uIChtc2cpe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAkLnBvc3QoJy9hcGkvbm90ZS9hZGQnLCB7bm90ZTogbXNnfSlcbiAgICAgIC5kb25lKGZ1bmN0aW9uKHJldCl7XG4gICAgICAgIGlmKHJldC5kYXRhLmNvZGUgPT0gLTIwMCkge1xuICAgICAgICAgICAgc2VsZi4kbm90ZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICAgIGlmKHJldC5kYXRhLmNvZGUgPT0gMjAwKSB7XG4gICAgICAgICAgICAgIHNlbGYuaWQgPSByZXQuZGF0YS5pbnNlcnRJZDtcbiAgICAgICAgICB9XG4gICAgICAgIFRvYXN0KHJldC5kYXRhLm1zZyk7XG4gICAgICAgIEV2ZW50LmZpcmUoJ3dhdGVyZmFsbCcpO1xuICAgICAgfSk7XG4gICAgLy90b2RvXG4gIH0sXG5cbiAgZGVsZXRlOiBmdW5jdGlvbigpe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIGlmKCF0aGlzLmlkKXtcbiAgICAgICAgICBUb2FzdCgnZGVsZXRlIHN1Y2Nlc3MnKTtcbiAgICAgICAgICBzZWxmLiRub3RlLnJlbW92ZSgpO1xuICAgICAgICAgIEV2ZW50LmZpcmUoJ3dhdGVyZmFsbCcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAkLnBvc3QoJy9hcGkvbm90ZS9kZWxldGUnLCB7aWQ6IHRoaXMuaWR9KVxuICAgICAgLmRvbmUoZnVuY3Rpb24ocmV0KXtcbiAgICAgICAgaWYocmV0LnN0YXR1cyA9PT0gMCl7XG4gICAgICAgICAgVG9hc3QocmV0LmRhdGEubXNnKTtcbiAgICAgICAgICBpZihyZXQuZGF0YS5jb2RlID09IDIwMCl7XG4gICAgICAgICAgICAgIHNlbGYuJG5vdGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIEV2ZW50LmZpcmUoJ3dhdGVyZmFsbCcpXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIFRvYXN0KHJldC5tc2cpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Ob3RlID0gTm90ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9tb2Qvbm90ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vdGUubGVzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm90ZS5sZXNzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm90ZS5sZXNzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGVzcy9ub3RlLmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLm5vdGUge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgY29sb3I6ICMzMzM7XFxuICB3aWR0aDogMTYwcHg7XFxuICBtYXJnaW46IDIwcHggMTBweDtcXG4gIHRyYW5zaXRpb246IGFsbCAwLjVzO1xcbn1cXG4ubm90ZSAubm90ZS1oZWFkIHtcXG4gIGhlaWdodDogMzBweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlYTliMzU7XFxuICBjdXJzb3I6IG1vdmU7XFxufVxcbi5ub3RlIC5ub3RlLWhlYWQgLnVzZXJuYW1lIHtcXG4gIGNvbG9yOiAjNzc3O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgcGFkZGluZy1sZWZ0OiAzcHg7XFxuICBsaW5lLWhlaWdodDogMzBweDtcXG59XFxuLm5vdGUgLm5vdGUtaGVhZDpob3ZlciAuZGVsZXRlIHtcXG4gIG9wYWNpdHk6IDE7XFxufVxcbi5ub3RlIC5ub3RlLWhlYWQ6YmVmb3JlIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDUwJTtcXG4gIHRvcDogLTExcHg7XFxuICBtYXJnaW4tbGVmdDogLTMycHg7XFxuICBjb250ZW50OiAnICc7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHdpZHRoOiA2NHB4O1xcbiAgaGVpZ2h0OiAxOHB4O1xcbiAgYmFja2dyb3VuZDogIzM1YmJhMztcXG59XFxuLm5vdGUgLm5vdGUtaGVhZDphZnRlciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBsZWZ0OiA1MCU7XFxuICBtYXJnaW4tbGVmdDogMzJweDtcXG4gIHRvcDogLTExcHg7XFxuICB6LWluZGV4OiAtMTtcXG4gIGNvbnRlbnQ6ICcnO1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICB3aWR0aDogMDtcXG4gIGhlaWdodDogMDtcXG4gIGJvcmRlci1sZWZ0OiA1cHggc29saWQgIzI5OTY4MztcXG4gIGJvcmRlci10b3A6IDE4cHggc29saWQgdHJhbnNwYXJlbnQ7XFxufVxcbi5ub3RlIC5ub3RlLWN0IHtcXG4gIHBhZGRpbmc6IDEwcHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWZiMDRlO1xcbiAgb3V0bGluZTogbm9uZTtcXG59XFxuLm5vdGUgLm5vdGUtY3QgZGl2IHtcXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCAjYTc3NjtcXG59XFxuLm5vdGUgLmRlbGV0ZSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDRweDtcXG4gIHJpZ2h0OiA0cHg7XFxuICBmb250LXNpemU6IDE2cHg7XFxuICBjb2xvcjogI2ZmZjtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIG9wYWNpdHk6IDA7XFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IC4zcztcXG59XFxuLmRyYWdnYWJsZSB7XFxuICBvcGFjaXR5OiAwLjg7XFxuICBjdXJzb3I6IG1vdmU7XFxuICB0cmFuc2l0aW9uOiBub25lO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3JjL2xlc3Mvbm90ZS5sZXNzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vdG9hc3QubGVzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vdG9hc3QubGVzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3RvYXN0Lmxlc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sZXNzL3RvYXN0Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnRvYXN0IHtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIGxlZnQ6IDUwJTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcXG4gIGJvdHRvbTogMjBweDtcXG4gIGNvbG9yOiAjRDE1QTM5O1xcbiAgYmFja2dyb3VuZDogI2ZmZjtcXG4gIHBhZGRpbmc6IDVweCAxMHB4O1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgYm94LXNoYWRvdzogMHB4IDBweCAzcHggMXB4IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC42KTtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIhLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zcmMvbGVzcy90b2FzdC5sZXNzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpXG52YXIgV2F0ZXJGYWxsID0gKGZ1bmN0aW9uKCl7XG4gIHZhciAkY3Q7XG4gIHZhciAkaXRlbXM7XG5cbiAgZnVuY3Rpb24gcmVuZGVyKCRjKXtcbiAgICBpZighJGMpcmV0dXJuO1xuICAgICRjdCA9ICRjO1xuICAgICRpdGVtcyA9ICRjdC5jaGlsZHJlbigpID8gJGN0LmNoaWxkcmVuKCkgOiBudWxsO1xuXG4gICAgaWYoISRpdGVtcylyZXR1cm47XG5cbiAgICB2YXIgbm9kZVdpZHRoID0gJGl0ZW1zLm91dGVyV2lkdGgodHJ1ZSksXG4gICAgICBjb2xOdW0gPSBwYXJzZUludCgkKHdpbmRvdykud2lkdGgoKS9ub2RlV2lkdGgpLFxuICAgICAgY29sU3VtSGVpZ2h0ID0gW107XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpPGNvbE51bTtpKyspe1xuICAgICAgY29sU3VtSGVpZ2h0LnB1c2goMCk7XG4gICAgfVxuXG4gICAgJGl0ZW1zLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgIHZhciAkY3VyID0gJCh0aGlzKTtcblxuICAgICAgLy9jb2xTdW1IZWlnaHQgPSBbMTAwLCAyNTAsIDgwLCAyMDBdXG5cbiAgICAgIHZhciBpZHggPSAwLFxuICAgICAgICAgIG1pblN1bUhlaWdodCA9IGNvbFN1bUhlaWdodFswXTtcbiAgICAgICAgICBtYXhTdW1IZWlnaHQgPSBjb2xTdW1IZWlnaHRbMF07XG5cbiAgICAgIGZvcih2YXIgaT0wO2k8Y29sU3VtSGVpZ2h0Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYoY29sU3VtSGVpZ2h0W2ldIDwgbWluU3VtSGVpZ2h0KXtcbiAgICAgICAgICBpZHggPSBpO1xuICAgICAgICAgIG1pblN1bUhlaWdodCA9IGNvbFN1bUhlaWdodFtpXTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBtYXhTdW1IZWlnaHQgPSBjb2xTdW1IZWlnaHRbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgJGN1ci5jc3Moe1xuICAgICAgICBsZWZ0OiBub2RlV2lkdGgqaWR4LFxuICAgICAgICB0b3A6IG1pblN1bUhlaWdodFxuICAgICAgfSk7XG4gICAgICAkY3QuY3NzKHtcbiAgICAgICAgICBoZWlnaHQ6IG1heFN1bUhlaWdodCArIDUwMFxuICAgICAgfSlcbiAgICAgIGNvbFN1bUhlaWdodFtpZHhdID0gJGN1ci5vdXRlckhlaWdodCh0cnVlKSArIGNvbFN1bUhlaWdodFtpZHhdO1xuICAgIH0pO1xuICB9XG5cblxuICAkKHdpbmRvdykub24oJ3Jlc2l6ZScsIGZ1bmN0aW9uKCl7XG4gICAgcmVuZGVyKCRjdCk7XG4gIH0pXG5cblxuICByZXR1cm4ge1xuICAgIGluaXQ6IHJlbmRlclxuICB9XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdhdGVyRmFsbFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL21vZC93YXRlcmZhbGwuanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=